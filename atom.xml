<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TsuiWade&#39;s blog</title>
  
  
  <link href="https://tsuiwade.github.io/atom.xml" rel="self"/>
  
  <link href="https://tsuiwade.github.io/"/>
  <updated>2022-02-28T11:04:22.000Z</updated>
  <id>https://tsuiwade.github.io/</id>
  
  <author>
    <name>tsuiwade</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>blog38-guideSel-2</title>
    <link href="https://tsuiwade.github.io/2022/02/28/blog38-guideSel-2/"/>
    <id>https://tsuiwade.github.io/2022/02/28/blog38-guideSel-2/</id>
    <published>2022-02-28T11:04:22.000Z</published>
    <updated>2022-02-28T11:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220228111816120.png" alt="image-20220228111816120"></p><h2 id="多尺度像面分割《CN201510107562-0-用于星敏感器的筛选导航星的方法》"><a href="#多尺度像面分割《CN201510107562-0-用于星敏感器的筛选导航星的方法》" class="headerlink" title="多尺度像面分割《CN201510107562.0-用于星敏感器的筛选导航星的方法》"></a>多尺度像面分割《CN201510107562.0-用于星敏感器的筛选导航星的方法》</h2><p>用到玻尔兹曼熵</p><h2 id="正交网格法《A-general-method-of-the-automatical-selection-of-guide-star》"><a href="#正交网格法《A-general-method-of-the-automatical-selection-of-guide-star》" class="headerlink" title="正交网格法《A general method of the automatical selection of guide star》"></a>正交网格法《A general method of the automatical selection of guide star》</h2><p>用到uniformity的计算</p><h3 id="均匀性计算《Star-trackers-star-catalogs-and-attitude-determination-Probabilistic-aspects-of-system-design》"><a href="#均匀性计算《Star-trackers-star-catalogs-and-attitude-determination-Probabilistic-aspects-of-system-design》" class="headerlink" title="均匀性计算《Star trackers, star catalogs, and attitude determination-Probabilistic aspects of system design》"></a>均匀性计算《Star trackers, star catalogs, and attitude determination-Probabilistic aspects of system design》</h3><h4 id="《基于螺旋基准点的导航星选取方法》"><a href="#《基于螺旋基准点的导航星选取方法》" class="headerlink" title="《基于螺旋基准点的导航星选取方法》"></a>《基于螺旋基准点的导航星选取方法》</h4><h4 id="《均匀快速的导航星选取方法》"><a href="#《均匀快速的导航星选取方法》" class="headerlink" title="《均匀快速的导航星选取方法》"></a>《均匀快速的导航星选取方法》</h4><h4 id="《16mv精细导星星库构建与评价》"><a href="#《16mv精细导星星库构建与评价》" class="headerlink" title="《16mv精细导星星库构建与评价》"></a>《16mv精细导星星库构建与评价》</h4><h4 id="《适用于小视场星敏感器的导航星表构建方法》"><a href="#《适用于小视场星敏感器的导航星表构建方法》" class="headerlink" title="《适用于小视场星敏感器的导航星表构建方法》"></a>《适用于小视场星敏感器的导航星表构建方法》</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://gitee.com/tsuiwade/images/raw/master/img/image-20220228111816120.png&quot; alt=&quot;image-20220228111816120&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;多尺度像面分</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>《基于星座聚类的星敏感器导航星优选算法研究》的复现</title>
    <link href="https://tsuiwade.github.io/2022/02/24/blog37-guideSel-1/"/>
    <id>https://tsuiwade.github.io/2022/02/24/blog37-guideSel-1/</id>
    <published>2022-02-24T17:20:11.000Z</published>
    <updated>2022-02-28T03:20:58.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一直对公司采用的指向模型修正过程中的选星过程很感兴趣，想知道是否有相关的文献。</p><p>的确有找到相关文献，想就此进行复现。先对下文进行复现。</p><p><code>吴峰, 朱锡芳, 相入喜, 等. 基于星座聚类的星敏感器导航星优选算法研究[J]. 微电子学与计算机, 2018, 35(3): 140-144.</code></p><p>主要涉及<code>Mean Shift</code>（均值漂移）算法</p><hr><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>一般对原始星表恒星数据做星等阈值处理， 即可得到导航星星库． <code>为提高星图识别稳定性， 增强星敏感器系统性能</code>， 通常要求导航星在天球上分布均匀． 为此， 国内外许多研究人员提出了进一步筛选导航星的算法．   </p><hr><h1 id="相关文献："><a href="#相关文献：" class="headerlink" title="相关文献："></a>相关文献：</h1><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220224211251099.png" alt="image-20220224211251099"></p><hr><h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>通常星座区域的恒星密度高， 星座和星座之间的区域星密度低． 为此， 本文首先借鉴Mean Shift（均值漂移）算法， 提出星座聚类算法， 将视场内的恒星划分到不同的星座． 然后， 提出基于星座聚类的导航星优选算法， 通过每次选择星数最多的一个星座， 并删除离该星座中心最近的一颗恒星， 最终实现导航星的均匀分布  </p><p>Mean Shift（均值漂移）是<strong>基于密度的非参数聚类算法</strong>，其算法思想是假设不同簇类的数据集符合不同的概率密度分布，找到任一样本点<strong>密度增大的最快方向</strong>（最快方向的含义就是Mean Shift），样本密度高的区域对应于该分布的最大值，这些样本点最终会在局部密度最大值收敛，且收敛到相同局部最大值的点被认为是同一簇类的成员。（<a href="https://cloud.tencent.com/developer/article/1459530）">https://cloud.tencent.com/developer/article/1459530）</a></p><p><strong>1.核密度估计</strong></p><p>Mean Shift算法用核函数估计样本的密度，最常用的核函数是高斯核。它的工作原理是在数据集上的<strong>每一个样本点</strong>都设置一个核函数，然后对所有的核函数相加，得到数据集的核密度估计（kernel density estimation）。</p><p>假设我们有大小为n的d维数据集</p><p>如下图，我们用高斯核估计一维数据集的密度，每个样本点都设置了以该样本点为中心的高斯分布，累加所有的高斯分布，得到该数据集的密度。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220224212833039.png" alt="image-20220224212833039"></p><p>其中虚线表示每个样本点的高斯核，实线表示累加所有样本高斯核后的数据集密度。因此，我们通过高斯核来得到数据集的密度。</p><p><strong>5.图像分割</strong>示例</p><p>mean shift通过对像素空间进行聚类，达到图像分割的目的。</p><p>我们对下图进行图像分割：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220224212938640.png" alt="image-20220224212938640"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220224212952595.png" alt="image-20220224212952595"></p><h2 id="Mean-Shift算法的优缺点"><a href="#Mean-Shift算法的优缺点" class="headerlink" title="Mean Shift算法的优缺点"></a><strong>Mean Shift算法的优缺点</strong></h2><p>优点：</p><p>不需要设置簇类的个数；</p><p>可以处理任意形状的簇类；</p><p>算法只需设置带宽这一个参数，带宽影响数据集的核密度估计</p><p>算法结果稳定，不需要进行类似K均值的样本初始化</p><p>缺点：</p><p>聚类结果取决于带宽的设置，带宽设置的太小，收敛太慢，簇类个数过多；带宽设置的太大，一些簇类可能会丢失。</p><p>对于较大的特征空间，计算量非常大。</p><h2 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h2><p><a href="https://blog.csdn.net/google19890102/article/details/51030884">https://blog.csdn.net/google19890102/article/details/51030884</a></p><h1 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h1><p><a href="https://blog.csdn.net/HJ199404182515/article/details/121694298">https://blog.csdn.net/HJ199404182515/article/details/121694298</a></p><p><strong><a href="https://www.cnblogs.com/kailugaji/p/11646167.html">https://www.cnblogs.com/kailugaji/p/11646167.html</a></strong></p><p>函数代码为MeanShiftCluster.m</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"> </span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line">    stInd           = initPtInds(tempInd);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">%*** plot stuff ****</span></span><br><span class="line">        <span class="keyword">if</span> plotFlag</span><br><span class="line">            <span class="built_in">figure</span>(<span class="number">1</span>),clf,<span class="built_in">hold</span> on</span><br><span class="line">            <span class="keyword">if</span> numDim == <span class="number">2</span></span><br><span class="line">                <span class="built_in">plot</span>(dataPts(<span class="number">1</span>,:),dataPts(<span class="number">2</span>,:),<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(dataPts(<span class="number">1</span>,myMembers),dataPts(<span class="number">2</span>,myMembers),<span class="string">&#x27;ys&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(myMean(<span class="number">1</span>),myMean(<span class="number">2</span>),<span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(myOldMean(<span class="number">1</span>),myOldMean(<span class="number">2</span>),<span class="string">&#x27;rd&#x27;</span>)</span><br><span class="line">                pause</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = numClust+<span class="number">1</span>;                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">[val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);                <span class="comment">%a point belongs to the cluster with the most votes</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="number">9.32</span>   <span class="number">8.16</span>  </span><br><span class="line"><span class="number">8.45</span>    <span class="number">-4.4</span></span><br><span class="line"><span class="number">7.67</span>    <span class="number">0.73</span></span><br><span class="line"><span class="number">7.3</span>    <span class="number">-3.38</span></span><br><span class="line"><span class="number">5.72</span>  <span class="number">2.38</span></span><br><span class="line"><span class="number">5.5</span>  <span class="number">-3.7</span></span><br><span class="line"><span class="number">5.31</span>  <span class="number">-9.36</span></span><br><span class="line"><span class="number">4.31</span>  <span class="number">-5.68</span></span><br><span class="line"><span class="number">4.08</span>  <span class="number">-6.6</span></span><br><span class="line"><span class="number">2.52</span>  <span class="number">3.26</span></span><br><span class="line"><span class="number">1.24</span> <span class="number">-3.63</span></span><br><span class="line"><span class="number">0.24</span> <span class="number">7.19</span></span><br><span class="line"><span class="number">-0.45</span>  <span class="number">4.09</span></span><br><span class="line"><span class="number">-0.76</span>  <span class="number">-2.59</span></span><br><span class="line"><span class="number">-3.54</span>  <span class="number">8.17</span></span><br><span class="line"><span class="number">-4.49</span>  <span class="number">0.34</span></span><br><span class="line"><span class="number">-4.61</span>  <span class="number">9.58</span></span><br><span class="line"><span class="number">-5.76</span>  <span class="number">-6.98</span></span><br><span class="line"><span class="number">-6.55</span>  <span class="number">7.11</span></span><br><span class="line"><span class="number">-7.79</span>  <span class="number">8.99</span></span><br><span class="line"><span class="number">-9.40</span>  <span class="number">-3.37</span></span><br></pre></td></tr></table></figure><p>测试代码testMeanShift.m为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line"> </span><br><span class="line">bandwidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data=data_load;</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line">[clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(x,bandwidth);</span><br><span class="line"><span class="comment">% clustCent：聚类中心 D*K, point2cluster：聚类结果 类标签, 1*N</span></span><br><span class="line">toc</span><br><span class="line"><span class="comment">%% 作图</span></span><br><span class="line">numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line"><span class="comment">%     plot(x(1,myMembers),x(2,myMembers),[cVec(k) &#x27;.&#x27;]);</span></span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%     plot(myClustCen(1),myClustCen(2),&#x27;o&#x27;,&#x27;MarkerEdgeColor&#x27;,&#x27;k&#x27;,&#x27;MarkerFaceColor&#x27;,cVec(k), &#x27;MarkerSize&#x27;,10)</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(data,<span class="number">1</span>)</span><br><span class="line">    text(data(<span class="built_in">j</span>,<span class="number">2</span>)+<span class="number">0.2</span>,data(<span class="built_in">j</span>,<span class="number">1</span>)<span class="number">-0.2</span>,num2str(<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220225104512976.png" alt="image-20220225104512976"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220225104550867.png" alt="image-20220225104550867"></p><p>结果不唯一，有时为18类。</p><p>clustCent 2*18 为中心坐标</p><p>point2cluster 1*21 为类别</p><p>clustMembsCell =</p><p>  18×1 cell 数组</p><p>{[   19]}<br>{[   11]}<br>{[15 17]}<br>{[    3]}<br>{[   21]}<br>{[   10]}<br>{[   13]}<br>{[    1]}<br>{[   16]}<br>{[   14]}<br>{[2 4 6]}<br>{[  8 9]}<br>{[    7]}<br>{[   18]}<br>{[   12]}<br>{[    5]}<br>{[   20]}</p><p>根据文章算法修改后MeanShiftCluster.m</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220226160621431.png" alt="image-20220226160621431"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line">nowNum = <span class="number">1</span>;</span><br><span class="line">outCom = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"></span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line"><span class="comment">%     stInd           = initPtInds(tempInd);                  %use this point as start of mean</span></span><br><span class="line">    stInd           = <span class="built_in">min</span>(initPtInds);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"><span class="comment">%     beyondMe=[];</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">length</span>(inInds)&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">min</span>(outCom(inInds))==<span class="number">0</span>)<span class="comment">% 2，6</span></span><br><span class="line">            beyondMe = inInds;</span><br><span class="line">            beyondMe(beyondMe == initPtInds(<span class="number">1</span>)) = [];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))</span><br><span class="line">                thisCluster = <span class="built_in">min</span>(outCom(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                outCom(stInd)=outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">% 4</span></span><br><span class="line">                outCom(stInd)=nowNum;</span><br><span class="line">                outCom(beyondMe)=nowNum;</span><br><span class="line">                nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> <span class="built_in">length</span>(inInds)==<span class="number">1</span> <span class="comment">% 1、3、5</span></span><br><span class="line">            outCom(stInd)=nowNum;</span><br><span class="line">            nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = outCom(stInd);                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line">    [val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data2cluster = outCom;</span><br><span class="line"></span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>outCom =</p><pre><code> 1     2     3     2     4     2     5     6     6     7     8     9    10    11    12    13    12    14    15    16    17</code></pre><p>clustCent 2*17 为中心坐标</p><p>point2cluster 1*21 为类别 1     1     3     2     4     2     5     6     6     7     8     9    10    11    12    13    12    14    15    16    17</p><p>根据文章算法修改后MeanShiftCluster.m</p><p>clustMembsCell =</p><p>  18×1 cell 数组</p><p>{[   19]}<br>{[   11]}<br>{[15 17]}<br>{[    3]}<br>{[   21]}<br>{[   10]}<br>{[   13]}<br>{[    1]}<br>{[   16]}<br>{[   14]}<br>{[2 4 6]}<br>{[  8 9]}<br>{[    7]}<br>{[   18]}<br>{[   12]}<br>{[    5]}<br>{[   20]}</p><p>经过第一轮循环，删除了第4/8/15个星。</p><p>再正式修改为MeanShiftCluster.m</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line">nowNum = <span class="number">1</span>;</span><br><span class="line">outCom = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"></span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line">    stInd           = initPtInds(tempInd);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"><span class="comment">%     beyondMe=[];</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">length</span>(inInds)&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">min</span>(outCom(inInds))==<span class="number">0</span>)<span class="comment">% 2，6</span></span><br><span class="line">            beyondMe = inInds;</span><br><span class="line">            beyondMe(beyondMe == stInd) = [];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))</span><br><span class="line">                thisCluster = <span class="built_in">min</span>(outCom(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                outCom(stInd)=<span class="built_in">min</span>(outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))));</span><br><span class="line">                outCom(beyondMe)=<span class="built_in">min</span>(outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))));</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">% 4</span></span><br><span class="line">                outCom(stInd)=nowNum;</span><br><span class="line">                outCom(beyondMe)=nowNum;</span><br><span class="line">                nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> <span class="built_in">length</span>(inInds)==<span class="number">1</span> <span class="comment">% 1、3、5</span></span><br><span class="line">            outCom(stInd)=nowNum;</span><br><span class="line">            nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = outCom(stInd);                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line">    [val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data2cluster = outCom;</span><br><span class="line"></span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>testMeanShift.m为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line"> </span><br><span class="line">bandwidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data=data_load;</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">6</span></span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bandwidth = bandwidth + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>得到不多于6个点的几个测试结果为：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220227002446282.png" alt="image-20220227002446282"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220227002502414.png" alt="image-20220227002502414"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220227002520760.png" alt="image-20220227002520760"></p><p>通常以玻尔兹曼熵评价导航星的全天球分布均匀性， 以视场内捕获恒星数的最大值、 最小值、 均值和标准差等评价局部天球分布均匀。</p><p>但我还不知道如何求解玻尔兹曼熵。</p><hr><p>带入星图数据</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">bandwidth = <span class="number">5</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data = star_data(<span class="number">2000</span>:<span class="number">4000</span>,<span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">50</span></span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bandwidth = bandwidth + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line"></span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220227104811094.png" alt="image-20220227104811094"></p><p>历时 126.527849 秒。</p>]]></content>
    
    
    <summary type="html">从本文起将开启研究导航星的筛选问题，本文首先研究 《基于星座聚类的星敏感器导航星优选算法研究》。</summary>
    
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/categories/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/tags/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>星图识别5-小结验证识别、求指向、求滚转角</title>
    <link href="https://tsuiwade.github.io/2022/02/18/blog36-starId-5/"/>
    <id>https://tsuiwade.github.io/2022/02/18/blog36-starId-5/</id>
    <published>2022-02-18T16:15:53.000Z</published>
    <updated>2022-02-18T16:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结前面几个博客，首先main4.m计算出是哪些星，再带入main10.m求出滚转角。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main10.m</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">518</span></span><br><span class="line"><span class="number">472</span></span><br><span class="line"><span class="number">537</span></span><br><span class="line"><span class="number">428</span></span><br><span class="line"><span class="number">491</span></span><br><span class="line"><span class="number">469</span></span><br><span class="line"><span class="number">482</span></span><br><span class="line"><span class="number">503</span></span><br><span class="line"><span class="number">478</span></span><br><span class="line"><span class="number">499</span></span><br><span class="line"><span class="number">547</span></span><br><span class="line"><span class="number">460</span></span><br><span class="line"><span class="number">507</span></span><br><span class="line"><span class="number">556</span></span><br><span class="line"><span class="number">447</span></span><br><span class="line"><span class="number">479</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu02.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    alpha=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    alpha = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">beta</span>=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syms a b fai;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [diff(x_ba,a) , diff(x_ba,b) , diff(x_ba,fai)];</span><br><span class="line">B = [diff(y_ba,a) , diff(y_ba,b) , diff(y_ba,fai)];</span><br><span class="line"></span><br><span class="line">iter=[alpha;<span class="built_in">beta</span>;<span class="number">0</span>];</span><br><span class="line">times = <span class="number">10</span>;</span><br><span class="line">iterRecord = <span class="built_in">zeros</span>(<span class="number">3</span>, times);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : times</span><br><span class="line">    </span><br><span class="line">    p = [double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))-xingtu1(:,<span class="number">1</span>); double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)) - xingtu1(:,<span class="number">2</span>)];</span><br><span class="line">    M = [double(subs(A , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)); double(subs(B , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))];</span><br><span class="line">    wow = inv((M.&#x27;) * M) * (M.&#x27;)*p;</span><br><span class="line">    iter = iter - wow</span><br><span class="line">    iterRecord(:,<span class="built_in">i</span>) = iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x=<span class="number">1</span>:<span class="number">1</span>:times;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,iterRecord(<span class="number">3</span>,:),<span class="string">&#x27;-or&#x27;</span> , x,iterRecord(<span class="number">1</span>,:),<span class="string">&#x27;-*b&#x27;</span> , x,iterRecord(<span class="number">2</span>,:),<span class="string">&#x27;-*b&#x27;</span> ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;maxp=&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line">RMS</span><br><span class="line"><span class="comment">%  最后看各点的差值p即可</span></span><br><span class="line"></span><br><span class="line">x_real = double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line">y_real = double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(x_real,y_real,<span class="number">140</span>,<span class="string">&#x27;dk&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(xingtu1(:,<span class="number">1</span>), xingtu1(:,<span class="number">2</span>), <span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>);</span><br></pre></td></tr></table></figure><p>发现星图4和星图6有所偏差。</p><hr><p>针对星图1的点</p><p>1670<br>1477<br>1502<br>1631<br>1603<br>1453<br>1432<br>1492<br>1488<br>1648<br>1646<br>1566<br>1688<br>1655<br>1505</p><p>iter =</p><p>  109.6000<br>   34.5000<br>  -89.9997</p><p>maxp=<br>    0.0048  表征最大的x、y值的变差绝对值。</p><p>RMS =</p><p>   1.1755e-07</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218183202596.png" alt="image-20220218183202596"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218170719748.png" alt="image-20220218170719748"></p><hr><p>星图2</p><p>518<br>472<br>537<br>428<br>491<br>469<br>482<br>503<br>478<br>499<br>547<br>460<br>507<br>556<br>447<br>479</p><p>iter =</p><p>   43.0000<br>   18.0000<br>  -29.9994</p><p>maxp=<br>    0.0054</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218181712233.png" alt="image-20220218170548186"></p><p>修改main6.m得到上图</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218183005140.png" alt="image-20220218183005140"></p><hr><p>星图3</p><p>1864<br>1942<br>1825<br>1941<br>1943<br>1900<br>1722</p><p>iter =</p><p>  124.9771<br>   43.9942<br>  -90.0708</p><p>maxp=<br>    2.3836</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218183333607.png" alt="image-20220218183333607"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218170255850.png" alt="image-20220218170255850"></p><hr><p>星图4（指向117，-28 (后查看应该为243，-28)</p><p>3249<br>3346<br>3364<br>3275<br>3421<br>3319<br>3283<br>3370<br>3265<br>3261<br>3321<br>3309</p><p>iter =</p><p>   61.7471<br>   28.6652<br>   28.7760</p><p>maxp=<br>  441.2296</p><p>由main6看上去是旋转270得到的结果。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218225852784.png" alt="image-20220218225852784"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218171253121.png" alt="image-20220218171253121"></p><p>main8得到</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220220221305644.png" alt="image-20220220221305644"></p><p>很奇怪，明明一致。</p><p>经过 360-赤经 修改后</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222193234089.png" alt="image-20220222193234089"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222193416059.png" alt="image-20220222193416059"></p><p>iter =</p><p>  243.0000<br>  -28.0000<br>  -90.0002</p><p>RMS =</p><p>   5.8798e-08</p><hr><p>星图5</p><p>1230<br>1150<br>1017<br>1033<br>1014<br>1223<br>1008<br>1208<br>1201</p><p>iter =</p><p>   86.5836<br>   44.4766<br>  270.0121</p><p>maxp=<br>    0.0058</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218223127789.png" alt="image-20220218223127789"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218171428172.png" alt="image-20220218171428172"></p><hr><p>星图6</p><p>1670<br>1675<br>1502<br>1631<br>1655<br>1692<br>1492<br>1576<br>1646<br>1566<br>1655<br>1505</p><p>iter =</p><p>  113.7861<br>   35.4645<br>  280.3664</p><p>maxp=<br>  258.0423</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218223440442.png" alt="image-20220218223440442"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218171627300.png" alt="image-20220218171627300"></p><p>查看问题</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220220212053946.png" alt="image-20220220212053946"></p><p>逆时针旋转90度，并且参考053.pdf的F02/F05/F08无解，则圈红，猜测大致是如此。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220220181726568.png" alt="image-20220220181726568"></p><p>main6中用到了错误的点，去除错误点得到赤经赤纬为112.6，34.5</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220220192757928.png" alt="image-20220220192757928"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main10.m</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1675</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1692</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1576</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu06.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"><span class="comment">% A  =  [  cosd(star_data(index,3)).*cosd(star_data(index,2))   ,   cosd(star_data(index,3)).*sind(star_data(index,2))  ,  sind(star_data(index,3))  ];</span></span><br><span class="line"><span class="comment">% Y = [   (f  ./  (sqrt(f^2 + newMatrix(1:size(index,1),1).^2 + newMatrix(1:size(index,1),2).^2))  )];</span></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">1</span>).^<span class="number">2</span> + newMatrix([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line"></span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    alpha=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    alpha = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">beta</span>=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"><span class="comment">% corWorld =  [  cosd(star_data(index,3)).*cosd(star_data(index,2))   ,   cosd(star_data(index,3)).*sind(star_data(index,2))  ,  sind(star_data(index,3))  ];</span></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syms a b fai;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AA = [diff(x_ba,a) , diff(x_ba,b) , diff(x_ba,fai)];</span><br><span class="line">B = [diff(y_ba,a) , diff(y_ba,b) , diff(y_ba,fai)];</span><br><span class="line"></span><br><span class="line">iter=[alpha;<span class="built_in">beta</span>;<span class="number">0</span>];</span><br><span class="line">times = <span class="number">10</span>;</span><br><span class="line">iterRecord = <span class="built_in">zeros</span>(<span class="number">3</span>, times);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : times</span><br><span class="line">    </span><br><span class="line">    p = [double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))-xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">1</span>); double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)) - xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">2</span>)];</span><br><span class="line">    <span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line">    M = [double(subs(AA , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)); double(subs(B , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))];</span><br><span class="line">    wow = inv((M.&#x27;) * M) * (M.&#x27;)*p;</span><br><span class="line">    iter = iter - wow</span><br><span class="line">    iterRecord(:,<span class="built_in">i</span>) = iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x=<span class="number">1</span>:<span class="number">1</span>:times;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,iterRecord(<span class="number">3</span>,:),<span class="string">&#x27;-or&#x27;</span> , x,iterRecord(<span class="number">1</span>,:),<span class="string">&#x27;-*b&#x27;</span> , x,iterRecord(<span class="number">2</span>,:),<span class="string">&#x27;-*b&#x27;</span> ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;maxp=&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line">RMS</span><br><span class="line"><span class="comment">%  最后看各点的差值p即可</span></span><br><span class="line"></span><br><span class="line">x_real = double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line">y_real = double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(x_real,y_real,<span class="number">140</span>,<span class="string">&#x27;dk&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">1</span>), xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">2</span>), <span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220220192830453.png" alt="image-20220220192830453"></p><p>iter =</p><p>  112.6000<br>   34.5000<br>  -89.9997</p><p>maxp=<br>    0.0048</p><p>RMS =</p><p>   4.6872e-08</p><hr><p>星图7</p><p>1525<br>1572<br>1443<br>1748<br>1780<br>1675<br>1720<br>1503<br>1634<br>1577<br>1757<br>1586<br>1536<br>1610<br>1681<br>1606<br>1670<br>1477<br>1790<br>1502<br>1631<br>1603<br>1415<br>1692<br>1453<br>1432<br>1492<br>1488<br>1648<br>1646<br>1566<br>1688<br>1655<br>1505<br>1373<br>1576<br>1545<br>1424<br>1375<br>1825<br>1401</p><p>iter =</p><p>  112.6000<br>   34.5000<br>  269.9999</p><p>maxp=<br>    0.0060</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218223545858.png" alt="image-20220218223545858"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218172202760.png" alt="image-20220218172202760"></p><hr><p>星图8</p><p>1572<br>1387<br>1675<br>1634<br>1586<br>1610<br>1354<br>1681<br>1606<br>1670<br>1390<br>1502<br>1631<br>1603<br>1692<br>1432<br>1488<br>1648<br>1646<br>1566<br>1688<br>1359<br>1505<br>1373<br>1576<br>1424<br>1375<br>1401<br>1385</p><p>iter =</p><p>  106.0000<br>   35.0000<br>  270.0000</p><p>maxp=<br>    0.0081</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218223640303.png" alt="image-20220218223640303"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218172345094.png" alt="image-20220218172345094"></p><hr><p>针对星图4，需要考察一下问题。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222185204497.png" alt="image-20220222185204497"></p><p>正向验证</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main11.m</span></span><br><span class="line"><span class="comment">%  正向求解指向区域内的星图和题图的对比。</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    alpha=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    alpha = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">beta</span>=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(:,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(:,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(:,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% syms a b fai;</span></span><br><span class="line">a = alpha;</span><br><span class="line">b = <span class="built_in">beta</span>;</span><br><span class="line">fai = <span class="number">270</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">indexIn = <span class="built_in">find</span>(x_ba(:,<span class="number">1</span>)&lt;<span class="number">256</span> &amp; x_ba(:,<span class="number">1</span>)&gt;<span class="number">-256</span> &amp; y_ba(:,<span class="number">1</span>)&lt;<span class="number">256</span> &amp; y_ba(:,<span class="number">1</span>)&gt;<span class="number">-256</span>);</span><br><span class="line">idx = kmeans(indexIn,<span class="number">2</span>);</span><br><span class="line">idx1 = <span class="built_in">find</span>(idx == <span class="number">1</span>);</span><br><span class="line">idx2 = <span class="built_in">find</span>(idx == <span class="number">2</span>);</span><br><span class="line">all(<span class="built_in">ismember</span>(index,indexIn))</span><br><span class="line"></span><br><span class="line">CorIn = [x_ba(indexIn(idx2)) , y_ba(indexIn(idx2))];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">plot</span>(CorIn(:,<span class="number">1</span>),CorIn(:,<span class="number">2</span>),<span class="string">&#x27;ok&#x27;</span>  ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"><span class="comment">% plot(x,iterRecord(3,:),&#x27;-or&#x27; , x,iterRecord(1,:),&#x27;-*b&#x27; , x,iterRecord(2,:),&#x27;-*b&#x27; ); %线性，颜色，标记</span></span><br><span class="line">text(CorIn(:,<span class="number">1</span>)<span class="number">-20</span>,CorIn(:,<span class="number">2</span>)<span class="number">-17</span>,string(indexIn(idx2)));</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter</span>(xingtu1(:,<span class="number">1</span>),xingtu1(:,<span class="number">2</span>),<span class="number">140</span>,<span class="string">&#x27;or&#x27;</span>  ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(star_data(:,<span class="number">2</span>),star_data(:,<span class="number">3</span>),<span class="string">&#x27;ok&#x27;</span>  ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"></span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-6</span>  <span class="number">109.6</span>+<span class="number">6</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-6</span>  <span class="number">34.5</span>+<span class="number">6</span>]);</span><br><span class="line">text(star_data(:,<span class="number">2</span>),star_data(:,<span class="number">3</span>),string(star_data(:,<span class="number">1</span>)) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">scatter3</span>(corWorld(indexIn,<span class="number">1</span>),corWorld(indexIn,<span class="number">2</span>),corWorld(indexIn,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>星图1：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222184550530.png" alt="image-20220222184550530"></p><p>星图2：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222184816184.png" alt="image-20220222184816184"></p><p>星图3</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222185427074.png" alt="image-20220222185427074"></p><p>星图4：</p><p>3249<br>3346<br>3364<br>3275<br>3421<br>3319<br>3283<br>3370<br>3265<br>3261<br>3321<br>3309</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222191924445.png" alt="image-20220222191924445"></p><p>对照003.pdf的答案才知道，指向并非117，-28，而是243，-28</p><p>星图5：</p><p>未被圈出的是缺失星：如1210为5.97等星，</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222185753031.png" alt="image-20220222185753031"></p><p>星图6：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222190321348.png" alt="image-20220222190321348"></p><p>1670<br>1675 无解 ：应该为1477<br>1502<br>1631<br>1655 ：应该为1603 位置偏移<br>1692<br>1492<br>1576 应该无解<br>1646<br>1566<br>1655<br>1505</p><p> 星图7</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222191043412.png" alt="image-20220222191043412"></p><p>星图8 缺失挺多星</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222191119023.png" alt="image-20220222191119023"></p>]]></content>
    
    
    <summary type="html">终于求出滚转角，之前的求解过程已忘了差不多，在此总结一下各星图的指向滚转角。并且验证各图的实际星图与数据星图的叠加对比和分析。</summary>
    
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>抽奖程序</title>
    <link href="https://tsuiwade.github.io/2022/01/24/blog35-luckydraw/"/>
    <id>https://tsuiwade.github.io/2022/01/24/blog35-luckydraw/</id>
    <published>2022-01-24T21:19:26.000Z</published>
    <updated>2022-01-24T21:19:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次给公司搞了抽奖程序，使用了js语言，vue框架，electron进行打包。</p><p>首先安装nodejs，最新版出现许多问题，因此推荐使用v14.16版本。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124212221950.png" alt="image-20220124212221950"></p><p>本项目fork自 <a href="https://github.com/vitozyf/lucky-draw">https://github.com/vitozyf/lucky-draw</a> </p><p>修改了背景图片。</p><p>发现了 <code>先抽三等奖就三等奖出现在抽奖结果上分</code>的bug，无奈只得写死特等、一等、二等、三等。</p><p>修改了抽奖结果显示号码，而显示<code>姓名</code>。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220124165803965.png" alt="image-20220124165803965"></p><p>再通过<a href="https://www.cxyzjd.com/article/qq_41579104/107340431">https://www.cxyzjd.com/article/qq_41579104/107340431</a> 用electron进行打包成exe文件。</p><p>第一步   将自己的vue项目进行打包，可以看到打包后的dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>第二步（选）安装electron</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron</span><br></pre></td></tr></table></figure><p>第三步  在dist文件夹中 创建主程序的入口文件main.js和相关配置package.json文件</p><p>其中，main程序为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; =<span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);<span class="comment">//引入electron</span></span><br><span class="line"><span class="keyword">let</span> win;</span><br><span class="line"><span class="keyword">let</span> windowConfig = &#123;</span><br><span class="line">  width:<span class="number">800</span>,</span><br><span class="line">  height:<span class="number">600</span></span><br><span class="line">&#125;;<span class="comment">//窗口配置程序运行窗口的大小，可自行设置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  win = <span class="keyword">new</span> BrowserWindow(windowConfig);<span class="comment">//创建一个窗口</span></span><br><span class="line">  win.loadURL(<span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span>);<span class="comment">//在窗口内要展示的内容index.html 就是打包生成的index.html</span></span><br><span class="line"><span class="comment">//   win.webContents.openDevTools();  //开启调试工具</span></span><br><span class="line">  win.on(<span class="string">&#x27;close&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//回收BrowserWindow对象</span></span><br><span class="line">    win = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  win.on(<span class="string">&#x27;resize&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    win.reload();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>,createWindow);</span><br><span class="line">app.on(<span class="string">&#x27;window-all-closed&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  app.quit();</span><br><span class="line">&#125;);</span><br><span class="line">app.on(<span class="string">&#x27;activate&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(win == <span class="literal">null</span>)&#123;</span><br><span class="line">    createWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> package.json为</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;productName&quot;</span>: <span class="string">&quot;天仪公司2022抽奖程序&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;天仪公司2022抽奖程序&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pack&quot;</span>: <span class="string">&quot;electron-builder --dir&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;dist&quot;</span>: <span class="string">&quot;electron-builder&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;postinstall&quot;</span>: <span class="string">&quot;electron-builder install-app-deps&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;electronVersion&quot;</span>: <span class="string">&quot;1.8.4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;win&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;requestedExecutionLevel&quot;</span>: <span class="string">&quot;highestAvailable&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;nsis&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;arch&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;x64&quot;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;appId&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;artifactName&quot;</span>: <span class="string">&quot;demo-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nsis&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;artifactName&quot;</span>: <span class="string">&quot;demo-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;extraResources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;./static/xxxx/&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;to&quot;</span>: <span class="string">&quot;app-server&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;**/*&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;publish&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;provider&quot;</span>: <span class="string">&quot;generic&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://xxxxx/download/&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;electron-packager&quot;</span>: <span class="string">&quot;^12.1.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;electron-updater&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>第四步 在dist文件夹中运行electron</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">elctron .</span><br></pre></td></tr></table></figure><p>最后一步 打包为exe程序了</p><p>先<strong>安装electron-builder</strong>，直接在dist目录下安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron-builder --save-dev</span><br></pre></td></tr></table></figure><p>执行<strong>npm run dist</strong> ,执行<strong>npm run dist</strong>进行打包，由于我们package.json中将打包命令electron-builder，定义为了dist，因此我们只需执行npm run dist即可打包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dist</span><br></pre></td></tr></table></figure><p>在我们原本vue项目打包后的dist文件夹下，又出现一个dist,进去之后，就发现了这个exe程序。</p><hr><h1 id="天仪公司2022年会抽奖软件说明"><a href="#天仪公司2022年会抽奖软件说明" class="headerlink" title="天仪公司2022年会抽奖软件说明"></a>天仪公司2022年会抽奖软件说明</h1><h3 id="一、-快速指南"><a href="#一、-快速指南" class="headerlink" title="一、 快速指南"></a>一、 快速指南</h3><p>进入软件后，如果您之前已经设置过该程序，请根据需要，点击右边<em>重置</em>进行记录重置。</p><p>接着需要点击右边<em>导入名单</em>，名单则从<em>附件中的名单</em>中复制带有序号和姓名的两列，呈现为下图的格式。（如果后续打开软件不修改名单，可省略该步）</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124182658614.png" alt="image-20220124182658614"></p><p>还需要点击右上角<em>抽奖配置</em>，检查总人数及奖项人数（如果后续打开软件不修改，可省略）。接着点击右边<em>开始</em>就可以开始抽奖、点击<em>停止</em>结束抽奖。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220124182928507.png" alt="image-20220124182928507"></p><p>​    最后点击右上角<em>抽奖结果</em>可以查看当前各项抽奖结果。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124185905221.png" alt="image-20220124185905221"></p><h3 id="二、安装说明"><a href="#二、安装说明" class="headerlink" title="二、安装说明"></a>二、安装说明</h3><p>​    软件需要安装，安装包为<em>天仪公司<strong>2022</strong>抽奖程序安装包**.exe</em>。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124190127040.png" alt="image-20220124190127040"></p><p>安装生成<em>天仪公司<strong>2022</strong>抽奖程序**.exe</em>。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124190147521.png" alt="image-20220124190147521"></p><p>打开<em>天仪公司<strong>2022</strong>抽奖程序**.exe</em>，出现以下界面。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124190218686.png" alt="image-20220124190218686"></p><p>​     若要删除该程序别忘了在<em>程序和功能</em>内删除。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220124190302295.png" alt="image-20220124190302295"></p><h3 id="三、功能介绍"><a href="#三、功能介绍" class="headerlink" title="三、功能介绍"></a>三、功能介绍</h3><p>​    总体上，该程序将呈现现代化的抽奖效果，采用炫酷的动效，喜庆的背景音乐；可以实现自定义奖项及人数、重置部分设置及结果、单独取消中奖人员；幕布滚动播放中奖结果；软件关闭后仍可保存当前设置情况和抽奖结果。</p><p>​    下面进行分功能介绍。</p><div class="table-container"><table><thead><tr><th>功能</th><th>介绍</th></tr></thead><tbody><tr><td>主界面中心展示</td><td>自动三维旋转抽奖人员姓名</td></tr><tr><td>鼠标滚轮名单球</td><td>名单球放大缩小</td></tr><tr><td>抽奖设置</td><td>设置抽奖标题、总人数、各奖项人数，可新增奖项</td></tr><tr><td>抽奖结果</td><td>显示各奖项中奖人员，可单独删除中奖人员</td></tr><tr><td>主界面上方幕布</td><td>展示标题、各奖项中奖人员</td></tr><tr><td>重置</td><td>重置设置或结果</td></tr><tr><td>导入名单</td><td>导入备选人员的序号和名单，注意格式</td></tr><tr><td>抽取方式</td><td>设置抽取奖项和抽取人数</td></tr><tr><td>背景音乐</td><td>可播放暂停背景音乐</td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">这次给公司搞了抽奖程序，使用了js语言，vue框架，electron进行打包。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>树莓派外接显示屏</title>
    <link href="https://tsuiwade.github.io/2022/01/16/blog34-raspScreen/"/>
    <id>https://tsuiwade.github.io/2022/01/16/blog34-raspScreen/</id>
    <published>2022-01-16T10:32:37.000Z</published>
    <updated>2022-01-16T10:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116112051112.png" alt="image-20220116112051112"></p><p>最近在研究树莓派的屏幕，当看到这样一个参数复杂的屏幕截图时，我有些难以理解。今天就来查一查里面的参数含义。</p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p><code>分辨率</code>又称解析度、解像度，可以从显示分辨率与图像分辨率两个方向来分类。 </p><p>通常，“分辨率”被表示成每一个方向上的像素数量，比如640X480等。某些情况下也可以同时表示成“每英寸像素”（ppi）以及图形的长度和宽度。比如72ppi，和8X6英寸。</p><p>15英寸LCD的最佳分辨率为1024×768，17～19英寸的最佳分辨率通常为1280×1024，更大尺寸拥有更大的最佳分辨率。</p><p><strong>屏幕分辨率</strong></p><p>屏幕分辨率（显示分辨率）是屏幕<a href="https://baike.baidu.com/item/图像/773234">图像</a>的<a href="https://baike.baidu.com/item/精密度/7902819">精密度</a>，是指<a href="https://baike.baidu.com/item/显示器/362722">显示器</a>所能显示的<a href="https://baike.baidu.com/item/像素/95084">像素</a>有多少。由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越<a href="https://baike.baidu.com/item/精细/1312083">精细</a>，同样的屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标。可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。</p><p><a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>是指实际显示图像时计算机所采用的分辨率，用户可在“控制面板”的“显示”属性的“设置”下根据需要设置“<a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>”，或右击桌面，在快捷菜单中选择“<a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>”命令，也可根据需要设置“屏幕分辨率”。 </p><p><a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>必须小于或等于显示器分辨率，而显示器分辨率描述的是显示器自身的像素点数量，是固有的、不可改变的。</p><p><strong>图像分辨率</strong></p><p><a href="https://baike.baidu.com/item/图像分辨率/872374">图像分辨率</a>是指在计算机中保存和显示一幅<a href="https://baike.baidu.com/item/数字图像/5199238">数字图像</a>所具有的分辨率，它和图像的像素有直接的关系。例如，一张分辨率为640×480像素的图片，其分辨率就达到了307200像素，也就是常说的30万像素；而一张分辨率为1600×1200的图片，它的像素就是200万这样，<a href="https://baike.baidu.com/item/图像分辨率/872374">图像分辨率</a>表示的是图片在长和宽上占的点数的单位。一张数码图片的长宽比通常是4:3。 </p><p><a href="https://baike.baidu.com/item/图像分辨率/872374">图像分辨率</a>决定图像的质量。对于同样尺寸的一幅图，如果图像分辨率越高，则组成该图的图像像素数目越多，像素点也越小，图像越清晰、逼真。如：72dpi分辨率的1英寸×1英寸图像包含5184像素，而300dpi分辨率的1英寸×1英寸图像包含90000像素。</p><p>图像分辨率与<a href="https://baike.baidu.com/item/显示器分辨率/8575053">显示器分辨率</a>是两个不同的概念：<a href="https://baike.baidu.com/item/显示器分辨率/8575053">显示器分辨率</a>用于确定显示图像的区域大小，而图像分辨率用于确定组成一幅图像的像素数目。如在显示器分辨率为1024×768的显示屏上，一幅图像分辨率为320×240的图像约占显示屏的1/12，而一幅图像分辨率为2400×3000的图像在这个显示屏上是不能完全显示的。</p><p>对于具有相同图像分辨率的图像，<a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>越低(如800×600)，则图像看起来较大，但屏幕上显示的项目少；屏幕分辨率越高(如1024×768)，则图像看起来就越小。 </p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116114123143.png" alt="image-20220116114123143"></p><p>亮度</p><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><p>色域其实也可以叫做色彩空间（Color Space），而域有是一个数学概念，可以更好的说明色彩是有一定的范围。色域是对一种颜色进行编码的方法，也指一个技术系统能够产生颜色的总和。在计算机图形处理中色域是颜色的某个完全的子集。颜色子集最常见的应用是用来精确地代表一种给定的情况，例如一个给定的空间或是某个输出装置的呈色范围。色域是显示器屏幕所能够表达的颜色数量所构成的范围区域，在现实世界中自然界中可见光谱的颜色组成了最大的色域空间，该色域空间中包含了人眼所能见到的所有颜色。</p><p>CIE国际照明协会为了更好的让用户轻易的理解色域，制定了一个用于描述色域的方法，那就是CIE-xy色度图。在这个坐标系中，各种显示设备能表现的色域范围用RGB（红、绿、蓝）三点连线组成的三角形区域来表示，三角形的面积越大，就表示这种显示设备的色域范围越大。 </p><p><strong>常见的屏幕色域三种标准：</strong></p><p>目前常见的屏幕色域标准有三种，分别是sRGB、NTSC、Adobe RGB。</p><p><strong>1、sRGB</strong></p><p>最早期的色域标准之一，至今仍有重要的影响力。</p><p>由微软和惠普在1996年制定，当时主流显示器为CRT显示器，这种显示器对颜色还原能力比较差。其中一个<strong>严重的问题</strong>就是对<strong>绿色部分</strong>色域覆盖非常少。</p><p>从它的特点可以得出结论，sRGB 属于一种比较宽松的标准，很多显示器都能达到100%。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116115727055.png" alt="image-20220116115727055"></p><p><strong>2、NTSC</strong></p><p>NTSC色域是NTSC电视标准下的色彩空间，NTSC是美国国家电视标准委员会，他们所推出的NTSC电视标准是一套广播电视传输协议，被运用在美国、日本等国家的广播电视系统中。当然这也就意味着，NTSC色彩空间更多被运用在电视行业。</p><p>由 Adobe Systems于1998年制定，为了解决 sRGB 色域不能覆盖印刷系统中的 CMYK 色域的问题而制定的新标准。</p><p>一般针对色彩专业的显示器都会以 Adobe sRGB 的色域进行标示。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116115757500.png" alt="image-20220116115757500"></p><p><strong>3、Adobe RGB</strong></p><p>Adobe RGB是专业软件生产商Adobe在1998年推出的色彩空间，初衷是为了同时囊括sRGB（电脑常用的色彩空间）和CMYK（印刷常用的色彩空间），这样拍出的数码照片不仅能在电脑上正常显示和编辑，也能印刷出颜色无损而正确的相片。Adobe RGB相比sRGB囊括的色彩范围更广，受到设计师的青睐，因此在专业的摄影和后期领域被广泛使用。</p><p>通过下图可以得知，Adobe RGB的色域几乎和NTSC1953年标准比较相近一些，而sRGB所能表示的色彩最少，sRGB色彩空间范围要小于前两者，近似相当于 sRGB ≈ 72% NTSC，Adobe RGB≈95% NTSC，不过sRGB是世界上最为广泛使用的色彩空间，大多数的显示器，都只支持sRGB的色域范围。AdobeRGB相比sRGB，能表示出更加细腻的青色和绿色，而NTSC的色域范围是最广的。 </p><p><strong>100%sRGB = 72%NTSC</strong></p><p><strong>100%AdobeRGB = 95%NTSC</strong>﻿</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/1-191024150551G3.jpg" alt="色域是什么？显示器屏幕色域sRGB、NTSC、Adobe RGB区别对比科普"></p><h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><p>对比度是屏幕上同一点最亮时(白色)与最暗时(黑色)的亮度的比值,高的对比度意味着相对较高的亮度和呈现颜色的艳丽程度;</p><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><p>液晶是一种介于液体和晶体之间的物质，本身并不能发光，因此背光的亮度决定了它的亮度。一般来说，液晶显示器的亮度越高，显示的色彩就越鲜艳，现实效果也就越好。液晶显示器中表示亮度的单位为cd/m2（流明），普通液晶显示器的亮度为250cd/m2。如果亮度过低，显示出来的颜色会偏暗，看久了就会觉得非常疲劳。对比度是亮度的比值，也就是在暗室中，白色画面下的亮度除以黑色画面下的亮度。因此白色越亮、黑色越暗，对比度就越高，显示的画面就越清晰亮丽，色彩的层次感就越强。一般液晶显示器的对比度为300:1，一些较好的可达到400:1，而传统的CRT显示器可达到500:1。如果对比度小于250:1，我们在看屏幕时就会产生模糊感。</p><h2 id="面板类型"><a href="#面板类型" class="headerlink" title="面板类型"></a>面板类型</h2><p>面板类型关系着液晶显示器的响应时间、色彩、可视角度、对比度这些重要因素。液晶显示器的常用面板有TN（Twisted Nematic扭曲向列型）、IPS（In-Plane-Switching平面转换型）、VA（Vertical Alignment多象限垂直配向型）三种类型，前两种相对常见。</p><p><strong>TN屏：响应时间快是优势</strong></p><p>TN屏就是较早前常见的软屏，用手能按出水波纹，这是最早使用的LCD面板之一，目前也在大量使用，因为它的技术最成熟，成本最低。TN屏响应速度快，最快可以达到1ms的响应时间，不会出现残影。使用这种材质的屏幕通常用来作为职业电竞屏，通过快速响应，TN屏可无损呈现高速变化的场景细节。</p><p>相对地，TN面板的缺陷也很明显，输出灰阶少，原生只有6bit色彩，画面色彩偏白、可视角度小，显示效果一般，通过不同角度观看会出现偏色和亮度差别。因此，如果你从事设计、影视后期相关工作或在观影娱乐时对屏幕色彩有较高要求，不建议使用这种屏幕。</p><p><strong>IPS屏：广视角、色彩好</strong></p><p>IPS屏面板较硬，用手指轻触屏幕，画面不会变形。IPS屏在色彩显示、可视角度等方面比TN面板好上不少，对于色彩的呈现范围与准确性也都有亮眼的表现，广视角是IPS面板的原生优势，不论哪个角度观看都不会产生色偏。目前跟影像处理有关的专业屏幕大多采用IPS面板。苹果也一直与IPS屏捆绑宣传，对于偏爱Mac的用户，IPS屏是一个不错的选择。</p><p>此外，尽管在响应时间上IPS屏比TN屏稍逊一筹，但得益于IPS屏出色的色彩表现，对于兼有办公娱乐多功能需求的普通游戏玩家，IPS屏仍然值得考虑。</p><p>受制于IPS屏需要更多背光灯来提高亮度，功耗偏高的局限性，控制不好就会漏光是IPS屏的通病。不过专业的屏幕生产厂商在应对这个问题时通常有更规范的把控机制，更值得信赖。</p><p><strong>VA屏：对比度高</strong></p><p>VA类面板也属于软屏，只要用手指轻触面板，显现梅花纹的是VA面板，出现水波纹的则是TN面板。VA面板是在中高端液晶显示器应用比较多的面板类型，富士通、三星、奇美电子、友达光电等面板企业均采用了这项面板技术。VA屏的特点是宽容度和对比度都更高，可达到3000:1的高对比度，画面中黑色和白色都更加纯净，且不会出现漏光等问题。</p><p>VA面板的缺陷主要体现在响应时间方面，好在现在VA面板的响应时间已经大幅改善，可以低至6ms内，足够正常使用。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/5d5f5c4c6718d4523.png_e1080.jpg" alt="一文讲解LCD显示器：TN/IPS/VA面板的好与坏，我究竟该选哪一种？"></p><h2 id="屏幕色彩"><a href="#屏幕色彩" class="headerlink" title="屏幕色彩"></a>屏幕色彩</h2><p>彩屏的色阶指数从低到高可分三个层次，最低单色，其次是256色、4096色、 65536色； 最高的为1677万色。</p><p>256=2的8次方，即8位彩色，依次律推，65536色=2的16次方，即通常所说 的16位真彩色，26万=2的18次方，也就是18位<a href="https://baike.baidu.com/item/真彩">真彩</a>。其实65536色已基本可满足我们肉眼的识别 需求。</p><h2 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h2><p>普通显示器采用的是标准动态范围（Standard Dynamic Range），简称 SDR，与之相比，HDR 显示器采用的是高动态范围（High Dynamic Range），简称 HDR。</p><p>HDR 显示器能明显改善屏幕明暗区域的对比度，提供更好的色彩，使画面更加细腻逼真，也更接近现实中的样子。其中最重要的是增加亮度，足够的亮度才能增强对比感，图像才能更接近现实中的样子。</p><p>所以，在挑选 HDR 显示器时，<strong>对比度</strong>和<strong>颜色</strong>是两个非常关键的因素，下文会详细阐述。</p><h3 id="HDR-显示器如何影响显示效果？"><a href="#HDR-显示器如何影响显示效果？" class="headerlink" title="HDR 显示器如何影响显示效果？"></a>HDR 显示器如何影响显示效果？</h3><p>1、亮度<br>亮度对 HDR 非常重要，一般显示器都能达到 300cd / m²，而 HDR 显示器的亮度为 600cd / m² – 1000cd / m² 之间，更高的亮度必然带来更好的显示效果。</p><p>2、位深<br>8位面板可以显示1678万种颜色，而10位面板则可以显示10.7亿种颜色。理论上来说，HDR 显示器要具有 10bit 的面板，但实际情况可能没有那么理想，比如华硕 ROG Swift PG27UQ 和 Acer Predator X27 虽然只是8位面板，通过2位抖动来模拟 10 位面板的质量，从显示上来说，要优于真 8位 面板。</p><p>3、色域<br>sRGB 色域大家比较熟悉，这种标准是人类肉眼可以感知到的颜色的33%，DCI-P3 标准则是人类肉眼可以感知到的颜色的 45% ，而 HDR 显示器至少要达到 90% 的 DCI-P3，才能保证良好的显示效果</p><h3 id="对硬件和软件有什么要求？"><a href="#对硬件和软件有什么要求？" class="headerlink" title="对硬件和软件有什么要求？"></a>对硬件和软件有什么要求？</h3><p>游戏需要更高性能的 GPU，而 HDR 并不需要非常强大的 GPU，Nvidia 的 GTX 950、AMD 的 R9 380 及以后的显卡均能支持；<br>接口方面，需要 HDMI 2.0 和 DisplayPort 1.4；<br>面板方面，TN 面板不支持 HDR；<br>Win10、PS4、Xbox one 都支持 HDR。</p><hr><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220116163159.png" alt=""></p><h3 id="白色的线："><a href="#白色的线：" class="headerlink" title="白色的线："></a>白色的线：</h3><p>FPC（Flexible printed circuit）排线，FPC排线就是可在一定程度内弯曲的连接线组。</p><h3 id="屏幕输出线："><a href="#屏幕输出线：" class="headerlink" title="屏幕输出线："></a>屏幕输出线：</h3><p><strong>EDP接口屏线</strong>常年技术领先VGA，HDMI是因为十几年前高清需求被电影电视垄断，PC显示器高清不是主流需求，由电视/DVD 厂商主推的HDMI才得以快速普及。<br>目前计算机公司 AMD/Intel/NVIDIA 的显示芯片都是原生输出<strong><a href="https://link.zhihu.com/?target=http%3A//www.kem-ffc.com/">高清EDP屏线</a></strong>信号，HDMI芯片也是由EDP-HDMI转换芯片转接出来的。<br>目前趋势上来讲，高规格显示器普遍都采用EDP接口。USB4 的内置显示协议也是EDP1.4。由于 HDMI 的市场惯性优势，低规格显示器 HDMI 会多一些。但是长远看HDMI被EDP接口排线取代是发展趋势。</p><p>而树莓派上有个dsi接口，</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116164007140.png" alt="image-20220116164007140"></p><p>树莓派的DSI显示器接口</p><p>可以将LCD显示器连接到树莓派上，一般用于嵌入式产品开发。通常情况下，HDMI接口已经能满足需求。<img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116164219580.png" alt="image-20220116164219580"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20160614171106516" alt="img"></p><h2 id="绿色板子："><a href="#绿色板子：" class="headerlink" title="绿色板子："></a>绿色板子：</h2><p>液晶屏驱动板，eDP转hdmi<a href="https://www.taobao.com/list/item/573596992161.htm?spm=a21wu.10013406.taglist-content.1.586310ffaQ3QGI">https://www.taobao.com/list/item/573596992161.htm?spm=a21wu.10013406.taglist-content.1.586310ffaQ3QGI</a></p><p>近年来随着电子产业的高速发展，智能显示设备也取得了辉煌的成就，高清显示得到了消费者的青睐。目前高清显示协议接口有RGB、LVDS、MIPI、eDP、HDMI、miniLVDS、V-by-One等</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220116165446262.png" alt="image-20220116165446262"></p><h2 id="蓝色板子"><a href="#蓝色板子" class="headerlink" title="蓝色板子"></a>蓝色板子</h2><p>触摸屏驱动，电容屏触摸 IIC转USB，免驱动。</p>]]></content>
    
    
    <summary type="html">重温曾在福晴做的这套树莓派外接显示器的解决方案。</summary>
    
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/categories/raspberrypi/"/>
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/tags/raspberrypi/"/>
    
  </entry>
  
  <entry>
    <title>星图识别4-共线方程与非线性最小二乘法求滚转角</title>
    <link href="https://tsuiwade.github.io/2022/01/10/blog33-starId-4/"/>
    <id>https://tsuiwade.github.io/2022/01/10/blog33-starId-4/</id>
    <published>2022-01-10T22:42:12.000Z</published>
    <updated>2022-02-18T22:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>大概拖了一个月都没有进度，今天才找到正确的切入点。</p><p>即是这篇 <code>CN100348460C - 一种基于星场的星敏感器校准方法</code> 专利，这篇专利因最开始的一张非右手坐标系的图，被我打入冷宫，但经过自己的琢磨发现自己原先的想法应该是错的，于是顺着该专利仔细研究，尤其对下述式子尤其好奇，于是想在此介绍一下<code>共线方程</code>和<code>高斯牛顿非线性最小二乘法</code>。</p><p><code>共线方程</code>参考 <a href="https://baike.baidu.com/item/%E5%85%B1%E7%BA%BF%E6%96%B9%E7%A8%8B/2055962">https://baike.baidu.com/item/%E5%85%B1%E7%BA%BF%E6%96%B9%E7%A8%8B/2055962</a> 和 <a href="https://zhuanlan.zhihu.com/p/101549821">https://zhuanlan.zhihu.com/p/101549821</a> 。</p><p>其实很好理解，其实我原本的计算过程也近似如此，只不过下式更为精简。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220210233834515.png" alt="image-20220210233834515"></p><hr><p>在专利中有此公式，053.pdf中也有此公式。我一直挂念于心，确实以自己的想法无法解出滚转角。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220210233649809.png" alt="image-20220210233649809"></p><p>本以为像线性最小二乘法能解决，但仔细看该专利，结合查资料，用的是<code>高斯牛顿非线性最小二乘法</code>。</p><p><a href="https://zhuanlan.zhihu.com/p/42383070">https://zhuanlan.zhihu.com/p/42383070</a></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220218003540.png" alt=""></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220218003619.png" alt=""></p><p>以星图1为例</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main9.m</span></span><br><span class="line"><span class="comment">%  采用共线公式正向验证星图1从世界坐标到星敏坐标到像素坐标并画图</span></span><br><span class="line"><span class="comment">%  高斯牛顿非线性最小二乘算法求解滚转角</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% newMatrix= [A1,repmat(f,size(A1,1),1)];</span></span><br><span class="line"><span class="comment">% A  =  [  cosd(star_data(index,3)).*cosd(star_data(index,2))   ,   cosd(star_data(index,3)).*sind(star_data(index,2))  ,  sind(star_data(index,3))  ];</span></span><br><span class="line"><span class="comment">% Y = [   (f  ./  (sqrt(f^2 + newMatrix(1:15,1).^2 + newMatrix(1:15,2).^2))  )];</span></span><br><span class="line"><span class="comment">% zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span></span><br><span class="line"><span class="comment">% E = (A*zhixiang - Y);</span></span><br><span class="line"><span class="comment">% RMS = sqrt(mse(E));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% if   zhixiang(2)/sqrt(1-zhixiang(3)^2) &gt; 0 </span></span><br><span class="line"><span class="comment">%   a=acosd( zhixiang(1)  /  sqrt(1-((zhixiang(3))^2) )   );</span></span><br><span class="line"><span class="comment">% else </span></span><br><span class="line"><span class="comment">%    a = 360-acosd( zhixiang(1)  /  sqrt(1-((zhixiang(3))^2) )   );</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% b=asind( zhixiang(3) );</span></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syms a b fai;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [diff(x_ba,a) , diff(x_ba,b) , diff(x_ba,fai)];</span><br><span class="line">B = [diff(y_ba,a) , diff(y_ba,b) , diff(y_ba,fai)];</span><br><span class="line"><span class="comment">% iter=[0;0;0];</span></span><br><span class="line">iter=[<span class="number">109</span>;<span class="number">34</span>;<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    p = [double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))-xingtu1(:,<span class="number">1</span>); double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)) - xingtu1(:,<span class="number">2</span>)];</span><br><span class="line">    M = [double(subs(A , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)); double(subs(B , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))];</span><br><span class="line">    wow = inv((M.&#x27;) * M) * (M.&#x27;)*p;</span><br><span class="line">    iter = iter - wow</span><br><span class="line"><span class="comment">%     plot(i,iter(1));</span></span><br><span class="line">    <span class="built_in">plot</span>(<span class="built_in">i</span>,iter(<span class="number">3</span>),<span class="string">&#x27;-or&#x27;</span>); <span class="comment">%线性，颜色，标记</span></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;maxp=&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line"><span class="comment">%  最后看各点的差值p即可</span></span><br></pre></td></tr></table></figure><p>iter =</p><p>  109.6000<br>   34.5000<br>  -89.9997</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220218003849367.png" alt="image-20220218003849367"></p><p>得出星图1的滚转角为270°。</p><p>若不用之前计算的指向的赤经赤纬，则可能出现不收敛的情况。出现错误的指向</p><p>iter =</p><p>  -69.9166<br>  -33.2403<br> -124.7489</p><hr><p>总结前面几个博客，首先main4.m计算出是哪些星，main6.m计算出赤经赤纬，再带入main.9求出滚转角。</p><p>验证星图2：iter =</p><p>   43.0000<br>   18.0000<br>  -29.9994</p><p>maxp=<br>    0.0054</p>]]></content>
    
    
    <summary type="html">求解滚转角花费很长时间。</summary>
    
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>星图识别3-旋转矩阵与坐标转换</title>
    <link href="https://tsuiwade.github.io/2022/01/10/blog32-starId-3/"/>
    <id>https://tsuiwade.github.io/2022/01/10/blog32-starId-3/</id>
    <published>2022-01-10T11:45:41.000Z</published>
    <updated>2022-01-10T11:45:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将介绍<code>世界坐标</code>转为<code>星敏坐标</code>的过程。</p><p>根据专利 <a href="https://patentimages.storage.googleapis.com/da/9a/a0/6568cfa38683e7/CN1923621A.pdf">https://patentimages.storage.googleapis.com/da/9a/a0/6568cfa38683e7/CN1923621A.pdf</a> 的矩阵转换描述，再结合003.pdf文中的图 来理解 矩阵变换的算法过程。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110114902059.png" alt="image-20220110114902059"></p><p>（请注意，这里的R已是可以直接乘的姿态变换矩阵，为旋转矩阵的逆。）</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110114639546.png" alt="image-20220110114639546"></p><p>搜索旋转矩阵的基本原理，</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110115328203.png" alt="image-20220110115328203"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110140128402.png" alt="image-20220110140128402"></p><p>对本文的旋转应是左乘还是右乘？上文是绕固定轴旋转，为左乘。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110145543708.png" alt="image-20220110145543708"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110145557178.png" alt="image-20220110145557178"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110145619011.png" alt="image-20220110145619011"></p><p>再看一个定理 <code>绕固定坐标轴旋转与绕自身坐标轴旋转一致性证明</code> <a href="https://blog.csdn.net/jiongjiongxia123/article/details/90236737">https://blog.csdn.net/jiongjiongxia123/article/details/90236737</a></p><p>绕固定轴 左乘的公式为</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110162648283.png" alt="image-20220110162648283"></p><p>而绕自身轴 右乘的公式为</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220110162858815.png" alt="image-20220110162858815"></p><p>和专利的对应，但差了个转置。</p><hr><p><strong>想了很久这个转置的问题，其实是旋转矩阵与坐标变换的关系问题。从原坐标系到新坐标系的旋转矩阵为M。原坐标系下的坐标a，新坐标系下的坐标b，若a为行向量，则aM=b，若a为列向量，则m’a=b，公式应为b=m’a，举例可知。</strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110201912015.png" alt="image-20220110201912015"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110191105431.png" alt="image-20220110191105431"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110191237196.png" alt="image-20220110191237196"></p><hr><p>在这需要重述一下坐标系的定义</p><p>  （1）天球坐标系。以天赤道为基圈，过春分点的时圈为主圈，春分点为主点。天球坐标系采用赤经、赤纬作为坐标量。参见附件1相关叙述。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110114639546.png" alt="image-20220110114639546"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/clip_image002.jpg" alt="img"></p><p><em>图1 星敏感器坐标系、图像坐标系及前视投影成像示意图</em></p><p> （2）星敏感器坐标系xyz。以投影中心O（光轴上与感光面距离为f的点，即光心，参见图1）为坐标原点，以光轴为z轴（后面的讨论中，光轴OO’与天球面的交点记为D点），过O点平行于感光面两边的直线作为x轴和y轴。图1为星敏感器坐标系、图像坐标系及前视投影成像示意图。</p><p> （3）图像坐标系XY。以感光面的中心O’（O点在该平面上的投影点）为坐标原点，平行于感光面两边的直线为X轴和Y轴的平面坐标系，参见图1。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    a=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    a = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% syms fai x;</span></span><br><span class="line"><span class="comment">% assume(fai&gt;=0 &amp; fai&lt;=2*pi);</span></span><br><span class="line"></span><br><span class="line">fai = <span class="number">0</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inn = <span class="number">1670</span>;</span><br><span class="line">star1 =  [  <span class="built_in">cosd</span>(star_data(inn,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(inn,<span class="number">2</span>))   ;   <span class="built_in">cosd</span>(star_data(inn,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(inn,<span class="number">2</span>))  ;  <span class="built_in">sind</span>(star_data(inn,<span class="number">3</span>))  ];</span><br><span class="line">R * star1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">title(<span class="string">&#x27;天球坐标系，从外向内看&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line">title(<span class="string">&#x27;星图1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，从内往外看&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line">view(<span class="number">-90</span>,<span class="number">90</span>);  <span class="comment">% view(az,el) 为当前坐标区设置相机视线的方位角(顺时针为正)和仰角。</span></span><br><span class="line">title(<span class="string">&#x27;星图1逆时针旋转90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>针对星图1的第一个点，即第1670个点，它的赤经赤纬为 115.828 , 28.8835，用旋转矩阵乘得到星敏坐标（0.0950，-0.0949， 0.9909）与左下图对应， 第二个点，即第1477个点，赤经赤纬为105.88,29.33 ， 星敏坐标为（-0.0566，-0.0889，0.9944）</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220118160235525.png" alt="image-20220118160235525"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220118161031114.png" alt="image-20220118161031114"></p><p><strong><code>这个感光面，究竟对于图像坐标系来说，是哪一面呢？不管哪一面，都不影响已经确定了的XY轴和点坐标。但我画星图1的意义就不大，不好直接比对。</code></strong></p><p><strong><code>但在这里，经过很长时间的考虑，如题所述的（图像坐标系与星敏坐标系的XY对应）经过验证后是错误的（倘若如上上上图的XY轴示意图和上图的文字描述，第二列和第三列没有负坐标）。</code></strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  星图1各个坐标</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">Attribute_Set = &#123;<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>&#125;; </span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">title(<span class="string">&#x27;天球坐标系，从外向内看&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，从内往外看&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;上图旋转&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line">view(<span class="number">180</span>,<span class="number">90</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，旋转90&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">-6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span><span class="number">-6</span>,<span class="number">34.5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（负负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负正）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]); </span><br><span class="line">view(<span class="number">-90</span>,<span class="number">90</span>); </span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，旋转180&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">-6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">-6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span><span class="number">-6</span>,<span class="number">34.5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span><span class="number">-6</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（正正）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line">view(<span class="number">180</span>,<span class="number">90</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，旋转270&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">-6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span><span class="number">-6</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正正）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（正负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line">view(<span class="number">90</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    a=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    a = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">% syms fai x;</span></span><br><span class="line"><span class="comment">% assume(fai&gt;=0 &amp; fai&lt;=2*pi);</span></span><br><span class="line"></span><br><span class="line">fai = <span class="number">90</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋90度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（负负）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（负正）&#x27;</span>);</span><br><span class="line"><span class="comment">% view(0,90);</span></span><br><span class="line"></span><br><span class="line">fai = <span class="number">180</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋180度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（正正）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fai = <span class="number">270</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>); </span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋270度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（正正）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（正负）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,[<span class="number">9</span>,<span class="number">10</span>]); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;YDir&#x27;,&#x27;reverse&#x27;)%对y方向反转</span></span><br><span class="line">title(<span class="string">&#x27;星图1&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">0</span>,<span class="number">512</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">512</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">text(<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">-233</span>,<span class="number">233</span>,<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(<span class="number">-217</span>,<span class="number">-138</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-260</span> <span class="number">260</span>]);</span><br><span class="line">ylim([<span class="number">-260</span> <span class="number">260</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,[<span class="number">11</span>,<span class="number">12</span>]); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;YDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对y方向反转</span></span><br><span class="line">title(<span class="string">&#x27;星图1&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">0</span>,<span class="number">512</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">512</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">text(<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">-233</span>,<span class="number">233</span>,<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(<span class="number">-217</span>,<span class="number">-138</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-260</span> <span class="number">260</span>]);</span><br><span class="line">ylim([<span class="number">-260</span> <span class="number">260</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220119112958202.png" alt="image-20220119112958202"></p><p>我又细细画了一幅图，图2是 <code>将</code> 图1的xyz轴 滚转角fai = 90（图为从外往内看，xy轴逆时针旋转90°，相当于图 顺时针旋转了90度），绕着朝向自己的拇指方向，右旋90°，相当于将图1顺时针旋转90°。依次画其他图。</p><p><strong>根据第一点、第二点的正负可见，没有一幅图上的星点坐标值是符合星图1的描述，而图8和星图1是一致的，可以猜测出结论。</strong></p><p><strong>因此正确的理解应该是将天球坐标转为星敏坐标，然后将x轴反向 x’ = -x </strong>。</p><p>星图1就是由星敏坐标经过滚转角270度旋转后得到图4，再将x轴反向 x’ = -x得到图像坐标。</p><p>如何得到图像坐标呢？</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/4c570ee2f679076f4d16e05c3eca29fa.png" alt="img"></p><p>（注意 ， 本题与上文所描述不同，连相机坐标系都不是右手坐标系）</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220119111033783.png" alt="image-20220119111033783"></p><p>（<a href="https://qiy.net/2020/06/09/IAP-Cam-calibration/）">https://qiy.net/2020/06/09/IAP-Cam-calibration/）</a></p><p>f = 256/(tand(6));  % f = 2435.677300280981像素</p><p>x = f * Xc / Zc ; </p><p>该公式一步到像素坐标。</p><p>下面进行验证。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  正向验证星图1从世界坐标到星敏坐标到像素坐标并画图</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    a=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    a = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fai = <span class="number">270</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋270度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（正正）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（正负）&#x27;</span>);</span><br><span class="line"></span><br><span class="line">corSensor1=[-corSensor(:,<span class="number">1</span>), corSensor(:,<span class="number">2</span>:<span class="number">3</span>) ];</span><br><span class="line">corPic = [f .* corSensor1(:,<span class="number">1</span>) ./corSensor1(:,<span class="number">3</span>)  ,  f .* corSensor1(:,<span class="number">2</span>) ./corSensor1(:,<span class="number">3</span>) ];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(corPic(:,<span class="number">1</span>),corPic(:,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220119114259344.png" alt="image-20220119114259344"></p><p>以我预测的正向过程结果Fig2与星图数据画出结果Fig3一致，终于结束。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220119114416118.png" alt="image-20220119114416118"></p>]]></content>
    
    
    <summary type="html">接续前文已求出指向中的赤经赤纬，至于滚转角的求法，需要深入旋转矩阵的理解。</summary>
    
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>星图识别2-指向计算</title>
    <link href="https://tsuiwade.github.io/2022/01/09/blog31-starId-2/"/>
    <id>https://tsuiwade.github.io/2022/01/09/blog31-starId-2/</id>
    <published>2022-01-09T21:41:56.000Z</published>
    <updated>2022-01-09T21:41:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据 文章 B19910360003.pdf 中 </p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109214931059.png" alt="image-20220109214931059"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109215007244.png" alt="image-20220109215007244"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109215025866.png" alt="image-20220109215025866"></p><p>焦距f，即为相机坐标系下的投影中心到感光面的距离，即f = 256/(tand(6)); 单位位像素，与a保持一致。</p><hr><p><strong>选前三点</strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110002256884.png" alt="image-20220110002256884"></p><p>赤经赤纬为：  109.6002   34.5005</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109232504457.png" alt="image-20220109232504457"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/img/image-20220222193014726.png" alt="image-20220222193014726"></p><p>注意这里可能有2个解，在星图4中想了好几天。<code>其中这里有错，赤经应该还可能等于360°-式。</code></p><p><code>经过研究，结合sin赤经的正负号表现，探究最终结论：</code></p><p>若tan赤经和cos赤经同号则为原式，否则为360°-式</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>   Res(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    [   <span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    [   <span class="number">360</span>-<span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110001730296.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% main5.m</span></span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line">syms m31 m32 m33;</span><br><span class="line"></span><br><span class="line">eqns = [</span><br><span class="line">    (f/(<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>,<span class="number">2</span>)^<span class="number">2</span> + newMatrix(<span class="number">1</span>,<span class="number">3</span>)^<span class="number">2</span>))) == <span class="built_in">cosd</span>(star_data(<span class="number">1670</span>,<span class="number">3</span>))*<span class="built_in">cosd</span>(star_data(<span class="number">1670</span>,<span class="number">2</span>))*m31 +   <span class="built_in">cosd</span>(star_data(<span class="number">1670</span>,<span class="number">3</span>))*<span class="built_in">sind</span>(star_data(<span class="number">1670</span>,<span class="number">2</span>))*m32  +  <span class="built_in">sind</span>(star_data(<span class="number">1670</span>,<span class="number">3</span>))*m33,</span><br><span class="line">    (f/(<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span> + newMatrix(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>))) == <span class="built_in">cosd</span>(star_data(<span class="number">1477</span>,<span class="number">3</span>))*<span class="built_in">cosd</span>(star_data(<span class="number">1477</span>,<span class="number">2</span>))*m31 +   <span class="built_in">cosd</span>(star_data(<span class="number">1477</span>,<span class="number">3</span>))*<span class="built_in">sind</span>(star_data(<span class="number">1477</span>,<span class="number">2</span>))*m32  +  <span class="built_in">sind</span>(star_data(<span class="number">1477</span>,<span class="number">3</span>))*m33,</span><br><span class="line">    (f/(<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">3</span>,<span class="number">2</span>)^<span class="number">2</span> + newMatrix(<span class="number">3</span>,<span class="number">3</span>)^<span class="number">2</span>))) == <span class="built_in">cosd</span>(star_data(<span class="number">1502</span>,<span class="number">3</span>))*<span class="built_in">cosd</span>(star_data(<span class="number">1502</span>,<span class="number">2</span>))*m31 +   <span class="built_in">cosd</span>(star_data(<span class="number">1502</span>,<span class="number">3</span>))*<span class="built_in">sind</span>(star_data(<span class="number">1502</span>,<span class="number">2</span>))*m32  +  <span class="built_in">sind</span>(star_data(<span class="number">1502</span>,<span class="number">3</span>))*m33</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">vars = [m31 m32 m33];</span><br><span class="line">[m31, m32 m33 ] = solve(eqns, vars);</span><br><span class="line">m31=double(m31);</span><br><span class="line">m32=double(m32);</span><br><span class="line">m33=double(m33);</span><br><span class="line"><span class="keyword">if</span>   Res(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    [   <span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    [   <span class="number">360</span>-<span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>选全点：</strong></p><p>方程组个数小于未知数个数，这种情形称为不定方程组，不定方程组一般有无穷个解。</p><p>方程个数大于未知数个数的方程组称为超定方程组，超定方程组一般无解。但是它存在最小二乘解。比较常见的情形是实际生活中，我们要测量某一组数据大小，为减小误差，必须重复测很多次，每测一次就是一组数据，这组数据就是一个超定方程组，它的最小二乘解就是误差最小的值。</p><p>算出最小二乘解是差不多的，赤经赤纬为：109.6000   34.5000</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 星图1 </span></span><br><span class="line"><span class="comment">% main5.m</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span>];</span><br><span class="line"></span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">3</span>).^<span class="number">2</span>))  )];</span><br><span class="line"></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*Res - Y);</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110084949071.png" alt="image-20220110084949071"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220110085851273.png" alt="image-20220110085851273"></p><p>对于星图3</p><p>全点：赤经赤纬 124.9740   43.9973</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220111143646339.png" alt="image-20220111143646339"></p><p>较为精准的3点：1825、1943、1722，赤经赤纬  125.0001   43.9999，和上对比，较为精准。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20220111100252007.png" alt="image-20220111100252007"></p><p>较为不精准的3点：1942、1941、1900，赤经赤纬 125.4325   44.2513，发现确实有较大偏差。</p>]]></content>
    
    
    <summary type="html">前一文用了简单的角距匹配算法进行星体的识别，本文将由识别的星体进行指向的计算。</summary>
    
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>星图识别1-角距矩阵匹配模型</title>
    <link href="https://tsuiwade.github.io/2022/01/07/blog30-starId-1/"/>
    <id>https://tsuiwade.github.io/2022/01/07/blog30-starId-1/</id>
    <published>2022-01-07T23:11:38.000Z</published>
    <updated>2022-01-07T23:11:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客主要是针对2019主要介绍的是<a href="https://www.shumo.com/wiki/doku.php?id=%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8A_2019_%E5%85%A8%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B_npmcm_%E8%AF%95%E9%A2%98">第十六届(2019)全国研究生数学建模竞赛(NPMCM)试题B题</a>：天文导航中的星图识别，这里我下载了<a href="https://github.com/tsuiwade/MathModel/tree/master/%E5%9B%BD%E8%B5%9B%E8%AE%BA%E6%96%87/2019%E5%B9%B4%E4%BC%98%E7%A7%80%E8%AE%BA%E6%96%87/B">5篇优秀论文</a>，以及优秀的<a href="https://www.bilibili.com/video/BV17J41117Ut?from=search&amp;seid=305839988149914531&amp;spm_id_from=333.337.0.0">答辩现场录像</a>，在这篇博客中，我将选取<code>B19102880053</code>提到的<code>基于角距传统算法</code>进行复现。</p><p>此赛题提供的4908个导航星表数据是.mat文件，因此将使用<code>MATLAB</code>进行代码编写。</p><ul><li><p>1、星表数据处理</p><p>首先将星表数据的<code>天球坐标系下的赤经、赤纬</code>转为<code>直角坐标系下的x/y/z轴的值</code>，利用公式</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220108103109.png" alt=""></p><p>得到</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220108103148.png" alt=""></p></li></ul><ul><li><p>2、准备库矩阵和星图矩阵</p><p> <img src="https://gitee.com/tsuiwade/images/raw/master/20220108094645.png" alt=""></p><ul><li><p>式6-1导航星角距库比较好理解，我将其化成度数，得到：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220108103624.png" alt=""></p></li><li><p>而式6-2某星图角距矩阵，文中作者提到选取导航星方式，但不妨以任意星，例如表中顺序来求。在此我选取第一个星<code>A01</code>作为基准星，求解与其他星的角距，但在此我去除了与本身星的角距（因其为0），得到如下角距：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220108103940.png" alt=""></p></li></ul></li></ul><ul><li><p>3、算法描述</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/20220108104116.png" alt=""></p><p>（其实在此我理解错了，怪不得我运行了这么长时间，先说一下我的理解的算法，是没有优化的算法，在于最后一步还进行遍历循环。）</p><p>取<code>星图角距矩阵</code>第i(i=1)个元素与<code>导航星角距矩阵</code>第j(j=1)列的元素依次匹配，若匹配到角距相等或近似的元素，判断矩阵第i(i=1)个元素数值加 1；  </p><p><strong>main3.m</strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>)) &lt; <span class="number">0.1</span>  ) <span class="comment">% 这里的0.1是匹配到角距的判定</span></span><br><span class="line">panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>取<code>星图角距矩阵</code>第i （ i= 2,3,…,n）个元素，重复上一步操作； （该步完成后，若导航星就是第j列，则判断矩阵会加很多个1；）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; <span class="number">0.1</span>  )</span><br><span class="line">panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>若星图矩阵所有元素均完成匹配，则取导航星矩阵第 j （ j = 2,3,…,4908）列元素重复上两步操作； </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; <span class="number">0.1</span>     )</span><br><span class="line">panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>取判断矩阵最大元素所在列（记为 x ）作为基准星编号 x ；  </p><p>（关于0.1的设置，假设其为a，我希望采用智能化判断，即当判断矩阵的最大的一个值不大于最大的值的2倍时，差距a减半，继续判断，直到第一个值大于第二个值，即能够明显判断出差异和保证准确性时，判断截止）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> delta=<span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">       panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">       <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">           <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line">               <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line">                   panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">5</span>)</span><br><span class="line">       <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt; <span class="built_in">max</span>(<span class="number">2</span>)*<span class="number">2</span> )</span><br><span class="line">           newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>继续匹配导航星矩阵第 x 列，确定星图其他恒星编号 。（其实我的理解的差别在这，作者由基准星的列直接判断其他星，而笨拙的方法是遍历其他基准星，<strong>若采用笨拙的方法，星图1将耗时60s，若不遍历，则耗时6s左右，若设定固定0.1差距，则耗时1s左右</strong>）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">    angle1(<span class="built_in">find</span>(angle1==<span class="number">0</span>))=[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> delta=<span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">        panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line">                <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line">                    panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt; <span class="built_in">max</span>(<span class="number">2</span>)*<span class="number">2</span> )</span><br><span class="line">            newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><p>  该方法在识别星图1和星图2的时候有较好的效果。但在识别星图3的时候，由于存在的星较少，星之间相距较近 的条件比较苛刻，判断条件需要优化，之前是判断最多的匹配个数大于次多的匹配个数的两倍，现在可能由于delta的缩放比例过大导致无法适应条件进行判断，因此需要修改delta的条件。</p><p>  对于星图3只能识别出C05</p><p>  <img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109105948234.png" alt="image-20220109105948234"></p><p>  通过对每一个星、每一种delta得出的<code>前几匹配数</code>可见，其实星图3是存在位置误差的，C02、C04、C06、C07存在较大误差。接着对星图4、5验证没问题，对于星图6部分有问题。</p><p>  <img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109105820180.png" alt="image-20220109105820180"></p><p>  接着识别星图7，总结当前代码为：</p>  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tic</span><br><span class="line">clc;clear;close all;</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">star_data_xyz(:,<span class="number">1</span>) = <span class="built_in">cos</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">2</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">3</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">angle</span> = <span class="built_in">real</span>(<span class="built_in">acosd</span>(star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>) * star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line"></span><br><span class="line">h2 = <span class="number">512</span>/(<span class="built_in">tand</span>(<span class="number">10</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu07.xls&#x27;</span>) - <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">    l(<span class="built_in">j</span>,<span class="number">1</span>) = norm(A(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(h2,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% ii = 7;</span></span><br><span class="line"></span><br><span class="line">    angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">    angle1(<span class="built_in">find</span>(angle1==<span class="number">0</span>))=[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> delta=<span class="number">1</span>:<span class="number">15</span> </span><br><span class="line">        panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line">                <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line"><span class="comment">%                 if (   length(find(abs(angle(:,j)-angle1(i))&lt; 0.0001       ))     )</span></span><br><span class="line">                    panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt; <span class="built_in">max</span>(<span class="number">2</span>)*<span class="number">2</span> )</span><br><span class="line">            newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">toc</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;运行时间: &#x27;</span>,num2str(toc)]);</span><br></pre></td></tr></table></figure><p>  对于星图7，识别41个星耗时573秒，判断结果全对。</p><p>  <img src="https://gitee.com/tsuiwade/images/raw/master/image-20220109111249906.png" alt="image-20220109111249906"></p><p>  对于星图8，识别29个星耗时319秒，判断结果全对。</p><p>到此为止，我描述了我的 遍历每个星作为基准星的方法，对于星图124578没问题，对于星图36存在找不全的情况。</p><hr><p>回到使用基准星的方法来看，使用基准星确实能加速识别过程，例如识别20个星，只需要识别出一个星，再找到对应的矩阵即可。并且使用基准星可以避免找不到星的情况。</p><p><code>如何挑选这个基准星呢？</code> 文中也没给出较好的计算方法。</p><p><code>对于一个基准星来说或许不可靠，能否有一个初步方法筛选出相对可靠的若干基准星？</code> 发现还是一个基准星来的快一些</p><p><code>得到若干基准星后，得到其他星之后是否有一个验证过程？</code> 当选择用一个基准星的时候其实已经进行了一轮验证。</p><p>总结上面的实验可得，后续的改进优化需要先快速算出基准星，再由基准星得到其他星，最后进行验证。</p><hr><p>基准星一定是相对最可靠的，遍历还是需要遍历，但遍历深度不可太深。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 来自B19102880053.pdf的角距矩阵匹配模型。</span></span><br><span class="line"><span class="comment">% 找到一个基准星，然后找到其他星</span></span><br><span class="line"><span class="comment">% main4.m</span></span><br><span class="line"></span><br><span class="line">tic</span><br><span class="line">clc;clear;close all;</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">star_data_xyz(:,<span class="number">1</span>) = <span class="built_in">cos</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">2</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">3</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">angle</span> = <span class="built_in">real</span>(<span class="built_in">acosd</span>(star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>) * star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line"></span><br><span class="line">h2 = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu03.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(h2,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> delta=<span class="number">5</span>:<span class="number">15</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)</span><br><span class="line">        panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">        angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">        angle1(<span class="built_in">find</span>(angle1==<span class="number">0</span>))=[];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line">                    panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>( (<span class="built_in">max</span>(<span class="number">1</span>) == <span class="number">1</span>) || (<span class="built_in">max</span>(<span class="number">1</span>) == <span class="number">0</span>) )<span class="comment">%将不讨论这个星</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt;= <span class="built_in">max</span>(<span class="number">2</span>)+<span class="number">2</span> )</span><br><span class="line">            newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (flag ==<span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">abs</span>(    <span class="built_in">angle</span>(:,newNewMatrix(ii,<span class="number">4</span>)) -angle1(<span class="built_in">i</span>)    );</span><br><span class="line">    [minvalue,I] = <span class="built_in">min</span>(A);</span><br><span class="line">    newNewMatrix(<span class="built_in">i</span>,<span class="number">5</span>) = I(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toc</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;运行时间: &#x27;</span>,num2str(toc)]);</span><br></pre></td></tr></table></figure><p>星图全遍历91s、找到一组基准星57s，找到一个基准星43s，最快设置delta 2.23s，</p><p>在此我将计算每个星图的指向参数。</p><hr><p>结果可以参考003.pdf，以下为main4.m的结果，左侧为基准星</p><p>星图1结果：2s多</p><p>0    1670<br>0    1477<br>1502    1502<br>0    1631<br>0    1603<br>0    1453<br>0    1432<br>0    1492<br>0    1488 与053.pdf不同<br>0    1648<br>0    1646<br>0    1566<br>0    1688<br>0    1655<br>0    1505</p><p>星图2结果：1s多</p><p>0    518<br>472    472<br>0    537<br>0    428<br>0    491<br>0    469<br>0    482<br>0    503<br>0    478<br>0    499<br>0    547<br>0    460<br>0    507<br>0    556<br>0    447<br>0    479</p><p>星图3结果：15s多</p><p>0    1864<br>0    1942<br>0    1825<br>0    1941<br>1943    1943 与053.pdf不同 可以确定不需要参考053答案。<br>0    1900<br>0    1722</p><p>星图4结果：4s 与003.pdf相同</p><p>0    3249<br>0    3346<br>0    3364<br>0    3275<br>0    3421<br>0    3319<br>3283    3283<br>0    3370<br>0    3265<br>0    3261<br>0    3321<br>0    3309</p><p>星图5：5.3s 与003.pdf相同</p><p>0    1230<br>0    1150<br>0    1017<br>1033    1033<br>0    1014<br>0    1223<br>0    1008<br>0    1208<br>0    1201</p><p>星图6： 11s</p><p>0    1670<br>0    1675 003.pdf为1477<br>0    1502<br>0    1631<br>0    1655  003.pdf为1603<br>0    1692<br>0    1492<br>0    1576  003.pdf为1488<br>1646    1646<br>0    1566<br>0    1655<br>0    1505</p><p>星图7:2.1s</p><p>1525    1525<br>0    1572<br>0    1443<br>0    1748<br>0    1780<br>0    1675<br>0    1720<br>0    1503<br>0    1634<br>0    1577<br>0    1757<br>0    1586<br>0    1536<br>0    1610<br>0    1681<br>0    1606<br>0    1670<br>0    1477<br>0    1790<br>0    1502<br>0    1631<br>0    1603<br>0    1415<br>0    1692<br>0    1453<br>0    1432<br>0    1492<br>0    1488<br>0    1648<br>0    1646<br>0    1566<br>0    1688<br>0    1655<br>0    1505<br>0    1373<br>0    1576<br>0    1545<br>0    1424<br>0    1375<br>0    1825<br>0    1401</p><p>星图8为1.6s：</p><p>1572    1572<br>0    1387<br>0    1675<br>0    1634<br>0    1586<br>0    1610<br>0    1354<br>0    1681<br>0    1606<br>0    1670<br>0    1390<br>0    1502<br>0    1631<br>0    1603<br>0    1692<br>0    1432<br>0    1488<br>0    1648<br>0    1646<br>0    1566<br>0    1688<br>0    1359<br>0    1505<br>0    1373<br>0    1576<br>0    1424<br>0    1375<br>0    1401<br>0    1385</p><hr><p>以main4.m的结果来看，仅星图6有差，后续再验证。</p>]]></content>
    
    
    <summary type="html">这是我研究生阶段的研究课题——星图识别的第一篇博客，过往的两个月，都幻想着高屋建瓴、一蹴而就，却步履维艰，决心潜心修行、脚踏实地，从最基础的传统方法做起。这篇博客主要是针对2019主要介绍的是第十六届(2019)全国研究生数学建模竞赛(NPMCM)试题B题：天文导航中的星图识别，其中最简单的角距矩阵匹配模型。</summary>
    
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
    
    <category term="星图识别" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E5%9B%BE%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>《QT项目》靶轮控制</title>
    <link href="https://tsuiwade.github.io/2021/10/10/blog28-qtTargetWheelConsole/"/>
    <id>https://tsuiwade.github.io/2021/10/10/blog28-qtTargetWheelConsole/</id>
    <published>2021-10-10T22:16:35.000Z</published>
    <updated>2021-10-10T22:16:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="targetWheelConsole"><a href="#targetWheelConsole" class="headerlink" title="targetWheelConsole"></a>targetWheelConsole</h1><p>源代码： <a href="https://github.com/tsuiwade/targetWheelConsole">https://github.com/tsuiwade/targetWheelConsole</a></p><p>这是一个简单的靶轮控制软件，主要用到的是串口功能。实现了一些现代化的按钮立体显示效果、动态交互激活按钮状态、菜单栏选择串口。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211010180956933.png" alt="image-20211010180956933"></p><ol><li><p>现代化的按钮立体显示效果，借鉴自<a href="https://www.jianshu.com/p/952637f9958f">https://www.jianshu.com/p/952637f9958f</a></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211010181447085.png" alt="image-20211010181447085"></p><p>1:可设置文本,居中显示</p><p>2:可设置文本颜色</p><p>3:可设置外边框渐变颜色</p><p>4:可设置里边框渐变颜色</p><p>5:可设置背景色</p><p>6:可直接调用内置的设置 绿色/红色/黄色/黑色/蓝色 等公有槽函数</p><p>7:可设置是否在容器中可移动,当成一个对象使用</p><p>8:可设置是否显示矩形</p><p>9:可设置报警颜色+非报警颜色</p><p>10:可控制启动报警和停止报警,报警时闪烁</p></li></ol><p>   这段配置了按键的样式。</p>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; btn_list.size(); i++) &#123;</span><br><span class="line">    connect(btn_list[i], &amp;QPushButton::clicked, <span class="keyword">this</span>, [ = ](<span class="keyword">bool</span> checked) &#123;</span><br><span class="line">        <span class="keyword">if</span>(checked)</span><br><span class="line">            btn_list[i]-&gt;setLightRed();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            btn_list[i]-&gt;setLightGreen();</span><br><span class="line">    &#125;);</span><br><span class="line">    connect(btn_list[i],  &amp;QPushButton::pressed, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">        btn_list[i]-&gt;setBgRadius(<span class="number">70</span>);</span><br><span class="line">        btn_list[i]-&gt;setOverlayRadius(<span class="number">70</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    connect(btn_list[i],  &amp;QPushButton::released, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">        btn_list[i]-&gt;setBgRadius(<span class="number">80</span>);</span><br><span class="line">        btn_list[i]-&gt;setOverlayRadius(<span class="number">80</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">   </span><br><span class="line">    QGraphicsDropShadowEffect *shadow_effect = <span class="keyword">new</span> QGraphicsDropShadowEffect(<span class="keyword">this</span>);</span><br><span class="line">    shadow_effect-&gt;setOffset(<span class="number">1</span>, <span class="number">1</span>);             <span class="comment">//阴影的偏移量</span></span><br><span class="line">    shadow_effect-&gt;setColor(QColor(<span class="number">43</span>, <span class="number">43</span>, <span class="number">43</span>, <span class="number">150</span>)); <span class="comment">//阴影的颜色</span></span><br><span class="line">    shadow_effect-&gt;setBlurRadius(<span class="number">8</span>);             <span class="comment">// 阴影圆角的大小</span></span><br><span class="line">   </span><br><span class="line">    btn_list[i]-&gt;setLightGreen();</span><br><span class="line">    btn_list[i]-&gt;resize(<span class="number">120</span>, <span class="number">120</span>);</span><br><span class="line">    btn_list[i]-&gt;setText(QString::number(i + <span class="number">1</span>));</span><br><span class="line">    btn_list[i]-&gt;setGraphicsEffect(shadow_effect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态交互激活按钮状态</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211010181553606.png" alt="image-20211010181553606"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(btn_list[i],  &amp;QPushButton::pressed, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">    btn_list[i]-&gt;setBgRadius(<span class="number">70</span>);</span><br><span class="line">    btn_list[i]-&gt;setOverlayRadius(<span class="number">70</span>);</span><br><span class="line">&#125;);</span><br><span class="line">connect(btn_list[i],  &amp;QPushButton::released, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">    btn_list[i]-&gt;setBgRadius(<span class="number">80</span>);</span><br><span class="line">    btn_list[i]-&gt;setOverlayRadius(<span class="number">80</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>这里我为了实现：点击主菜单，弹出可选串口，试过多个方案，最终发现挺简单的，由自己看着库函数实现了。在将要弹出子菜单之前，进行串口搜索，点击子菜单，进行配置打开串口。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    connect(ui-&gt;menuSerial, &amp;QMenu::aboutToShow, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ui-&gt;menuSerial-&gt;title() == QString(<span class="string">&quot;选择串口&quot;</span>)) &#123;</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">            foreach(<span class="keyword">const</span> QSerialPortInfo &amp;info, QSerialPortInfo::availablePorts()) &#123;</span><br><span class="line">                ui-&gt;menuSerial-&gt;addAction(QIcon(<span class="string">&quot;:/target.png&quot;</span>), info.portName() + <span class="string">&quot;: &quot;</span> + info.description());</span><br><span class="line"></span><br><span class="line">                ui-&gt;menuSerial-&gt;addSeparator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">            ui-&gt;menuSerial-&gt;addAction(QString(<span class="string">&quot;关闭串口&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    connect(ui-&gt;menuSerial, &amp;QMenu::triggered, <span class="keyword">this</span>, [ = ](QAction * _action) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ui-&gt;menuSerial-&gt;title() == QString(<span class="string">&quot;选择串口&quot;</span>)) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;点击 选择串口&quot;</span>;</span><br><span class="line">            qDebug() &lt;&lt; _action-&gt;text();</span><br><span class="line">            QString spTxt =  _action-&gt;text();</span><br><span class="line"><span class="comment">//            ui-&gt;menuSerial-&gt;setTitle(spTxt) ;</span></span><br><span class="line">            QString spTxt1 = spTxt.section(<span class="string">&#x27;:&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            serial.setPortName(spTxt1);</span><br><span class="line">            serial.setBaudRate(<span class="number">9600</span>);</span><br><span class="line">            serial.setDataBits(QSerialPort::Data8);</span><br><span class="line">            serial.setParity(QSerialPort::NoParity);</span><br><span class="line">            serial.setStopBits(QSerialPort::OneStop);</span><br><span class="line">            serial.setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">            <span class="keyword">if</span>(!serial.open(QIODevice::ReadWrite)) &#123;</span><br><span class="line">                QMessageBox::about(<span class="literal">NULL</span>, <span class="string">&quot;提示&quot;</span>, <span class="string">&quot;无法打开串口！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ui-&gt;menuSerial-&gt;setTitle(spTxt) ;</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;点击 else&quot;</span>;</span><br><span class="line">            serial.close();</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">            ui-&gt;menuSerial-&gt;setTitle(QString(<span class="string">&quot;选择串口&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">该平移台控制系统项目是我在nairc的第一个项目，2021.08.26接手，2021.10.10完成。主要涉及到一些现代化的按钮立体显示效果、动态交互激活按钮状态、菜单栏选择串口。</summary>
    
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>树莓派qt</title>
    <link href="https://tsuiwade.github.io/2021/10/07/blog29-raspberrypiQt/"/>
    <id>https://tsuiwade.github.io/2021/10/07/blog29-raspberrypiQt/</id>
    <published>2021-10-07T19:20:29.000Z</published>
    <updated>2021-10-07T19:20:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>第二次装树莓派系统。</p><p>google搜索raspberrypi os，下载imager和os系统，准备一个U盘或者sd卡，然后进行烧写。</p><p>默认安装完，由于我有买固态，想将U盘启动改为ssd启动，从而进行转移。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211007192857479.png" alt="image-20211007192857479"></p><p>接下来是换源：直接看官方文档，我的确实是debian10 buster版本系统。</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</a></p><p>接下来是准备远程环境。下载putty，开启ssh和vnc，最后远程桌面连接即可。<a href="https://tsuiwade.tk/2021/03/13/blog18_RaspberryPi/">https://tsuiwade.tk/2021/03/13/blog18_RaspberryPi/</a></p><p>再接下来是安装qt。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第二次装树莓派系统。&lt;/p&gt;
&lt;p&gt;google搜索raspberrypi os，下载imager和os系统，准备一个U盘或者sd卡，然后进行烧写。&lt;/p&gt;
&lt;p&gt;默认安装完，由于我有买固态，想将U盘启动改为ssd启动，从而进行转移。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht</summary>
      
    
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/categories/qt/"/>
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/categories/qt/raspberrypi/"/>
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/tags/raspberrypi/"/>
    
    <category term="qt" scheme="https://tsuiwade.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>《QT项目》平移台控制</title>
    <link href="https://tsuiwade.github.io/2021/10/06/blog27-qtSrialPort/"/>
    <id>https://tsuiwade.github.io/2021/10/06/blog27-qtSrialPort/</id>
    <published>2021-10-06T20:49:36.000Z</published>
    <updated>2021-10-06T20:49:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要涉及到上位机的布局、样式的调整、材质的阴影美化、完成标识的弹框动画、点击QLineEdit的虚拟键盘弹出。</p><p>源代码：<a href="https://github.com/tsuiwade/translationTableControlSystem210909">https://github.com/tsuiwade/translationTableControlSystem210909</a></p><p>这是一个简单的平移台控制软件，主要用到的是qt的串口功能。</p><ol><li><a href="https://blog.csdn.net/Mark_md/article/details/109048127">https://blog.csdn.net/Mark_md/article/details/109048127</a></li></ol><p>重写ComboBox下拉框的鼠标点击事件，实现点击下拉框扫描可用串口</p><ol><li><p>修改项目文件：</p><p>把新的 timeshow 文件夹重命名为 timeshowfixed，并把 timeshowfixed 里面 timeshow.pro.user 用户文件删掉。<br>进入 timeshowfixed 文件夹，把 timeshow.pro 重命名为 timeshowfixed.pro。<br>③用记事本打开 timeshowfixed.pro，修改里面的 TARGET 一行，变成下面这句：<br>TARGET = timeshowfixed<br>进行这样三步操作后，我们本章第一个例子的项目 timeshowfixed 就建立好了。</p></li><li><p>初始布局：</p><p><img src="https://user-images.githubusercontent.com/78476272/132862407-86f434ff-2748-4944-a236-213f7f98c96d.png" alt="image"></p></li></ol><p><img src="https://user-images.githubusercontent.com/78476272/132862466-c9d9b781-1851-478a-b0ec-54154e6004ab.png" alt="image"></p><ol><li>经过几天的优化。总体样式如下：</li></ol><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211006193232544.png" alt="image-20211006193232544"></p><p>项目结构如下：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211006193838493.png" alt="image-20211006193838493"></p><ul><li>先定分辨率1024<em>768，又布局了几天。布局采用Card的想法，分组放置，故研究阴影的放置，但出现groupBox<strong>与子组件的样式和阴影不兼容问题</strong>，查了好几天没找到是什么问题，最终偶然间下载qt5.14时，发现是<em>*5.9的bug</em></em>。</li></ul><ol><li><p>除了布局的设计，还有样式和阴影的设计。在qss文件和窗口文件中设置。</p><p>加阴影的代码已经经过优化，优化前写的较重复且乱，有个问题一个阴影对象只可以幅值给一个对象，因此…</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QList&lt;QWidget*&gt; qList = &#123;ui-&gt;horizontalSlider, ui-&gt;comboBox_portName,  ui-&gt;centralWidget&#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">   QList&lt;QPushButton*&gt; btnList = ui-&gt;centralWidget-&gt;findChildren&lt;QPushButton*&gt;();</span><br><span class="line">   QList&lt;QLineEdit*&gt; lineList = ui-&gt;centralWidget-&gt;findChildren&lt;QLineEdit*&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : btnList)  qList.append(i);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : lineList)  qList.append(i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : qList) &#123;</span><br><span class="line">       QGraphicsDropShadowEffect * shadow_effect = <span class="keyword">new</span> QGraphicsDropShadowEffect(<span class="keyword">this</span>);</span><br><span class="line">       shadow_effect-&gt;setOffset(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">       shadow_effect-&gt;setColor(QColor(<span class="number">55</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br><span class="line">       shadow_effect-&gt;setBlurRadius(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">       i-&gt;setGraphicsEffect(shadow_effect);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">QPushButton</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">253</span>,<span class="number">253</span>,<span class="number">253</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="attribute">border-style</span>:outset;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">1</span>,</span><br><span class="line">                                      stop: <span class="number">0</span> #f6f7fa, stop: <span class="number">1</span> #dadbde);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QPushButton</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">224</span>,<span class="number">238</span>,<span class="number">249</span>);</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="built_in">rgb</span>(<span class="number">11</span>,<span class="number">137</span>,<span class="number">234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QPushButton</span><span class="selector-pseudo">:pressed</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">1</span>,</span><br><span class="line">                                      stop: <span class="number">0</span> #dadbde, stop: <span class="number">1</span> #f6f7fa);</span><br><span class="line">    <span class="attribute">padding-left</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:inset;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::groove</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&quot;#EC7064&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::add-page</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&quot;#EC7064&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::sub-page</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&quot;#2EE1C1&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:-<span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">qradialgradient</span>(spread:pad,cx:<span class="number">0.5</span>,cy:<span class="number">0.5</span>,radius:<span class="number">0.5</span>,fx:<span class="number">0.5</span>,fy:<span class="number">0.5</span>,stop:<span class="number">0.6</span> <span class="string">&quot;#FFFFFF&quot;</span>,stop:<span class="number">0.8</span> <span class="string">&quot;#34495E&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QGroupBox</span><span class="selector-id">#groupBox_1</span>, <span class="selector-id">#groupBox_2</span>, <span class="selector-id">#groupBox_3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">qlineargradient</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">1</span>,</span><br><span class="line">    stop: <span class="number">0</span> #f6f7fa, stop: <span class="number">1</span> #dadbde);</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="attribute">border-style</span>:outset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式包括圆角、偏移、渐变及渐变的颠倒、滑动条的前后样式和滑块样式。</p><p>还有一个小tip是加上icon会生动许多。</p><ol><li>还有完成标志的动画。</li></ol><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211006194645681.png" alt="image-20211006194645681"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211006194751940.png" alt=""></p><p>截图看不出动画的效果，是有关位置和透明度的动画。</p><p>主要是设计了一个新对话框窗体，以非模态的方式出现3秒后自动消失。对话框淡入淡出的动画代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//获取主屏幕分辨率</span></span><br><span class="line">    QRect screenRect = QGuiApplication::primaryScreen()-&gt;geometry();</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation *appearPositionAnimation = <span class="keyword">new</span> QPropertyAnimation(<span class="keyword">this</span>, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line">    appearPositionAnimation-&gt;setDuration(<span class="number">1000</span>);</span><br><span class="line">    appearPositionAnimation-&gt;setStartValue(QRect((screenRect.width() / <span class="number">2</span>) - <span class="number">80</span>, screenRect.height() / <span class="number">2</span> - <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    appearPositionAnimation-&gt;setEndValue(QRect(screenRect.width() / <span class="number">2</span> - <span class="number">80</span>, screenRect.height() / <span class="number">2</span>, <span class="number">160</span>, <span class="number">80</span>));</span><br><span class="line">    appearPositionAnimation-&gt;setEasingCurve(QEasingCurve::InOutElastic);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    QPropertyAnimation *vanishPostionAnimation = new QPropertyAnimation(this, &quot;geometry&quot;);</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setDuration(1000);</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setStartValue(QRect(1024 / 2 - 80, 768 / 2, 160, 80));</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setEndValue(QRect(1024 / 2 - 80, 768 / 2 - 40, 0, 0));</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setEasingCurve(QEasingCurve::InBounce);</span></span><br><span class="line"></span><br><span class="line">    QSequentialAnimationGroup *positionAnimationGroup = <span class="keyword">new</span> QSequentialAnimationGroup(<span class="keyword">this</span>);</span><br><span class="line">    positionAnimationGroup-&gt;addAnimation(appearPositionAnimation);</span><br><span class="line">    positionAnimationGroup-&gt;addPause(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//    pScaleGroup-&gt;addAnimation(vanishPostionAnimation);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowOpacity(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation* appearOpacityAnimation = <span class="keyword">new</span> QPropertyAnimation(<span class="keyword">this</span>, <span class="string">&quot;windowOpacity&quot;</span>);</span><br><span class="line">    appearOpacityAnimation-&gt;setDuration(<span class="number">1000</span>); <span class="comment">// will take 5 seconds</span></span><br><span class="line">    appearOpacityAnimation-&gt;setEasingCurve(QEasingCurve::OutBack); <span class="comment">// just demonstration, there are a lot of curves to choose</span></span><br><span class="line">    appearOpacityAnimation-&gt;setStartValue(<span class="number">0.0</span>);</span><br><span class="line">    appearOpacityAnimation-&gt;setEndValue(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation* vanishOpacityAnimation = <span class="keyword">new</span> QPropertyAnimation(<span class="keyword">this</span>, <span class="string">&quot;windowOpacity&quot;</span>);</span><br><span class="line">    vanishOpacityAnimation-&gt;setDuration(<span class="number">1000</span>); <span class="comment">// will take 5 seconds</span></span><br><span class="line">    vanishOpacityAnimation-&gt;setEasingCurve(QEasingCurve::Linear); <span class="comment">// just demonstration, there are a lot of curves to choose</span></span><br><span class="line">    vanishOpacityAnimation-&gt;setStartValue(<span class="number">1.0</span>);</span><br><span class="line">    vanishOpacityAnimation-&gt;setEndValue(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    QSequentialAnimationGroup *opacityAnimationGroup = <span class="keyword">new</span> QSequentialAnimationGroup(<span class="keyword">this</span>);</span><br><span class="line">    opacityAnimationGroup-&gt;addAnimation(appearOpacityAnimation);</span><br><span class="line">    opacityAnimationGroup-&gt;addPause(<span class="number">2000</span>);</span><br><span class="line">    opacityAnimationGroup-&gt;addAnimation(vanishOpacityAnimation);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    anim-&gt;start(QAbstractAnimation::DeleteWhenStopped);</span></span><br><span class="line"></span><br><span class="line">    m_group = <span class="keyword">new</span> QParallelAnimationGroup(<span class="keyword">this</span>);</span><br><span class="line">    m_group-&gt;addAnimation(positionAnimationGroup);</span><br><span class="line">    m_group-&gt;addAnimation(opacityAnimationGroup);</span><br><span class="line">    m_group-&gt;setDirection(QAbstractAnimation::Forward);</span><br><span class="line">    m_group-&gt;setLoopCount(<span class="number">1</span>);</span><br><span class="line">    m_group-&gt;start();</span><br><span class="line">    connect(<span class="keyword">this</span>-&gt;m_group, SIGNAL(finished()), m_group, SLOT(deleteLater()), Qt::UniqueConnection);</span><br><span class="line">    connect(<span class="keyword">this</span>-&gt;m_group, SIGNAL(finished()), <span class="keyword">this</span>, SLOT(close()));</span><br></pre></td></tr></table></figure><p>其中最后几句槽函数是花了一些时间找来的，当动画消失后，对话框窗体关闭。</p><ol><li>点击QLineEdit，弹出虚拟数字键盘，代码也是网上找的修改了一下样式。</li></ol><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20211006195444106.png" alt="image-20211006195444106"></p><p>QT数字软键盘，包括QLineEdit弹出代码和键盘样式来自：<a href="https://download.csdn.net/download/zhuifengcong/8833143">https://download.csdn.net/download/zhuifengcong/8833143</a></p><p>最后采用遮罩蒙版，当某个窗体出现，背景变黑。代码来自：<a href="https://blog.csdn.net/tax10240809163com/article/details/108086890">https://blog.csdn.net/tax10240809163com/article/details/108086890</a></p>]]></content>
    
    
    <summary type="html">该平移台控制系统项目是我在nairc的第二个项目，2021.09.09接手，2021.10.07完成。主要涉及到上位机的布局、样式的调整、材质的阴影美化、完成标识的弹框动画、点击QLineEdit的虚拟键盘弹出。</summary>
    
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>《黑马程序员c++_STL》记录</title>
    <link href="https://tsuiwade.github.io/2021/08/11/blog26-cpp-stl/"/>
    <id>https://tsuiwade.github.io/2021/08/11/blog26-cpp-stl/</id>
    <published>2021-08-11T23:03:10.000Z</published>
    <updated>2021-08-11T23:03:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。 13542<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系 12345     </p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p><em>每个容器都有自己专属的迭代器</em></p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><div class="table-container"><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、—，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、—、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table></div><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><hr><h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pBegin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.begin(), v.end(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">v3.push_back(i + <span class="number">3</span>);</span><br><span class="line">v4.push_back(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>                          //创建一个空的字符串 例如: string str;</li><li><code>string(const char* s);</code>            //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象，拷贝构造函数</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li></ul><p><strong>示例：</strong> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str4;</span><br><span class="line">str4.assign(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str5;</span><br><span class="line">str5.assign(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str7;</span><br><span class="line">str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    string的赋值方式很多，<code>operator =</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator += (const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator += (const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator += (const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s);</code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.append(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.append(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找，查不到返回-1</li><li><code>int find(const char* s, int pos = 0) const;</code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.rfind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>> 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const;</code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);</code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.at(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);</code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.insert(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos = email.find(<span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li><p>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</p></li><li><p>vector容器的迭代器是支持<code>随机访问</code>的迭代器</p></li></ul><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210812153804882.png" alt="image-20210812153804882"></p><h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v;</code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code>       //将v[begin(), end())区间（前闭后开）中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator= (const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。（前闭后开）</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty();</code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.resize(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.resize(<span class="number">5</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  —- empty</li><li>返回元素个数  —- size</li><li>返回容器容量  —- capacity</li><li>重新指定大小  —-  resize</li></ul><h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.push_back(<span class="number">10</span>);</span><br><span class="line">v1.push_back(<span class="number">20</span>);</span><br><span class="line">v1.push_back(<span class="number">30</span>);</span><br><span class="line">v1.push_back(<span class="number">40</span>);</span><br><span class="line">v1.push_back(<span class="number">50</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.insert(v1.begin(), <span class="number">100</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">v1.clear();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  —- push_back</li><li>尾删  —- pop_back</li><li>插入  —- insert    (位置迭代器)</li><li>删除  —- erase  （位置迭代器）</li><li>清空  —-  clear  </li></ul><h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code>     //返回索引idx所指的数据</li><li><code>operator[];</code>       //返回索引idx所指的数据</li><li><code>front();</code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v.resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//不变</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p>double-ended queue </p><p><strong>功能：</strong></p><ul><li><strong><code>双端数组</code></strong>，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210812190612260.png" alt="image-20210812190612260"></p><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210812190711118.png" alt="image-20210812190711118"></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4 = d3;</span><br><span class="line">printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code>         //重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">d4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.resize(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">d1.resize(<span class="number">5</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   —- empty</li><li>返回元素个数   —- size</li><li>重新指定个数   —- resize</li></ul><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.pop_back();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.pop_front();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">1000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2.push_back(<span class="number">1</span>);</span><br><span class="line">d2.push_back(<span class="number">2</span>);</span><br><span class="line">d2.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin(), d.end());</span><br><span class="line">d.clear();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    test03();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —-  push_back</li><li>尾删   —-  pop_back</li><li>头插   —-  push_front</li><li>头删   —-  pop_front</li></ul><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code>     //返回索引idx所指的数据</li><li><code>operator[];</code>      //返回索引idx所指的数据</li><li><code>front();</code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line">sort(d.begin(), d.end()); <span class="comment">//默认从小到大</span></span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><hr><h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> create <span class="title">Person</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> score = rand() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">d.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除最高和最低分</span></span><br><span class="line">d.pop_back();</span><br><span class="line">d.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取平均分</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span><br><span class="line">&#123;</span><br><span class="line">sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> avg = sum / d.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">it-&gt;m_Score = avg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建5名选手</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">createPerson(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、给5名选手打分</span></span><br><span class="line">setScore(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最后得分</span></span><br><span class="line">showScore(v);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><hr><h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210812202123680.png" alt="image-20210812202123680"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  —- <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  —- <strong>出栈</strong>  <code>pop</code></p><h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p><strong>功能描述</strong>：栈容器常用的对外接口</p><p><strong>构造函数</strong>：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p><strong>赋值操作</strong>：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p><strong>数据存取</strong>：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top();</code>                //返回栈顶元素</li></ul><p><strong>大小操作</strong>：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size();</code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.push(<span class="number">10</span>);</span><br><span class="line">s.push(<span class="number">20</span>);</span><br><span class="line">s.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   —- push</li><li>出栈   —- pop</li><li>返回栈顶   —- top</li><li>判断栈是否为空   —- empty</li><li>返回栈大小   —- size</li></ul><hr><h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210812203149048.png" alt="image-20210812203149048"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 —- <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 —- <strong>出队</strong>    <code>pop</code></p><h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front();</code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size();</code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.push(p1);</span><br><span class="line">q.push(p2);</span><br><span class="line">q.push(p3);</span><br><span class="line">q.push(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.front().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.front().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.back().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.back().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   —- push</li><li>出队   —- pop</li><li>返回队头元素   —- front</li><li>返回队尾元素   —- back</li><li>判断队是否为空   —- empty</li><li>返回队列大小   —- size</li></ul><hr><h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210812230603286.png" alt="image-20210812230603286"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是<code>空间(指针域)</code> 和 <code>时间（遍历）</code>额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(L1.begin(),L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3(L2);</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">L3.assign(L2.begin(), L2.end());</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">L4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printList(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">L1.swap(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><hr><h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size();</code>                             //返回容器中元素的个数</p></li><li><p><code>empty();</code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem);</code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.resize(<span class="number">10</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line">L1.resize(<span class="number">2</span>);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   —- empty</li><li>返回元素个数   —- size</li><li>重新指定个数   —- resize</li></ul><h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中<code>所有</code>与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.push_back(<span class="number">10</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.push_front(<span class="number">100</span>);</span><br><span class="line">L.push_front(<span class="number">200</span>);</span><br><span class="line">L.push_front(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.pop_back();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.pop_front();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L.begin();</span><br><span class="line">L.insert(++it, <span class="number">1000</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.begin();</span><br><span class="line">L.erase(++it);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">L.remove(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.clear();</span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   —- push_back</li><li>尾删   —- pop_back</li><li>头插   —- push_front</li><li>头删   —- pop_front</li><li>插入   —- insert</li><li>删除   —- erase</li><li>移除   —- remove</li><li>清空   —- clear</li></ul><h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L1.begin();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访 问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   —- front</li><li>返回最后一个元素   —- back</li></ul><h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">L.push_back(<span class="number">90</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">70</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.reverse();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.sort(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">L.sort(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   —- reverse</li><li>排序   —- sort （成员函数）</li></ul><p>所有不支持随机访问迭代器的容器，不可以用标准算法。    </p><h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line">L.push_back(p5);</span><br><span class="line">L.push_back(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L.sort(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li></ul><ul><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><hr><h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset<code>允许容器中有重复的元素</code></li></ul><h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(<span class="number">100</span>);</span><br><span class="line">s2.insert(<span class="number">300</span>);</span><br><span class="line">s2.insert(<span class="number">200</span>);</span><br><span class="line">s2.insert(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s1.swap(s2);</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   —- size</li><li>判断是否为空   —- empty</li><li>交换容器   —- swap</li></ul><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">s1.erase(<span class="number">30</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   —- insert</li><li>删除   —- erase</li><li>清空   —- clear</li></ul><h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数，0或1.</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.find(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = s1.count(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —-  find    （返回的是迭代器）</li><li>统计   —-  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.insert(<span class="number">10</span>);</span><br><span class="line">s2.insert(<span class="number">40</span>);</span><br><span class="line">s2.insert(<span class="number">20</span>);</span><br><span class="line">s2.insert(<span class="number">30</span>);</span><br><span class="line">s2.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong>     set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><hr><h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li><code>map不允许容器中有重复key值元素</code></li><li><code>multimap允许容器中有重复key值元素</code></li></ul><h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2(m); <span class="comment">//拷贝构造</span></span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m.swap(m2);</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   —- size</li><li>判断是否为空   —- empty</li><li>交换容器   —- swap</li></ul><h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.erase(m.begin());</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line">m.erase(<span class="number">3</span>);</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.erase(m.begin(),m.end());</span><br><span class="line">m.clear();</span><br><span class="line">printMap(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   —- insert </li><li>删除   —- erase</li><li>清空   —- clear</li></ul><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.find(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = m.count(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —-  find    （返回的是迭代器）</li><li>统计   —-  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><hr><h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createWorker</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = rand() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.push_back(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGroup</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v,<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="keyword">int</span> deptId = rand() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showWorkerByGourp</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;::iterator pos = m.find(CEHUA);</span><br><span class="line"><span class="keyword">int</span> count = m.count(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(MEISHU);</span><br><span class="line">count = m.count(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(YANFA);</span><br><span class="line">count = m.count(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Worker&gt;vWorker;</span><br><span class="line">createWorker(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, Worker&gt;mWorker;</span><br><span class="line">setGroup(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line">showWorkerByGourp(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><hr><h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用<strong>重载的()</strong>时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , <span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">doPrint(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">sort(v.begin(), v.end(), MyCompare());<span class="comment">//此处有()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><hr><h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v.begin();it!= v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">v2.resize(v.size());</span><br><span class="line">transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p><hr><h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul><ul><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print02());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.resize(v.size()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">transform(v.begin(), v.end(), vTarget.begin(), TransForm());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), MyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());</span><br><span class="line"><span class="keyword">if</span> (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = adjacent_find(v.begin(), v.end());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), Greater4());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), AgeLess35());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge</code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);</code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line">random_shuffle(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.resize(v1.size() + v2.size());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());</span><br><span class="line">for_each(vtarget.begin(), vtarget.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);</code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">reverse(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.resize(v1.size());</span><br><span class="line">copy(v1.begin(), v1.end(), v2.begin());</span><br><span class="line"></span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace(v.begin(), v.end(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace_if(v.begin(), v.end(), ReplaceGreater30(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个同类容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);</code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(v1, v2);</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><hr><h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);</code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);</code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><hr><h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference</code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(min(v1.size(), v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(v1.size() + v2.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize( max(v1.size() , v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
    
    
    <summary type="html">本文是对b站黑马程序员C++的STL部分的学习记录</summary>
    
    
    
    <category term="cpp" scheme="https://tsuiwade.github.io/categories/cpp/"/>
    
    <category term="stl" scheme="https://tsuiwade.github.io/categories/cpp/stl/"/>
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>《小灰的算法之旅》记录</title>
    <link href="https://tsuiwade.github.io/2021/07/27/blog25-journeyOfAlgorithm/"/>
    <id>https://tsuiwade.github.io/2021/07/27/blog25-journeyOfAlgorithm/</id>
    <published>2021-07-27T14:52:44.000Z</published>
    <updated>2021-07-27T14:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法概述-空间复杂度"><a href="#算法概述-空间复杂度" class="headerlink" title="算法概述 - 空间复杂度"></a>算法概述 - 空间复杂度</h1><p>常见的空间复杂度有下面几种情形。</p><h3 id="1-常量空间"><a href="#1-常量空间" class="headerlink" title="1.常量空间"></a>1.常量空间</h3><p>当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作 O(1)。例如下面这段程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun1(int n)&#123;</span><br><span class="line">    int var &#x3D; 3;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-线性空间"><a href="#2-线性空间" class="headerlink" title="2.线性空间"></a>2.线性空间</h3><p>当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模 n 成正比时，空间复杂度记作 O(n)。</p><p>例如下面这段程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun2(int n)&#123;</span><br><span class="line">    int[] array &#x3D; new int[n];</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二维空间"><a href="#3-二维空间" class="headerlink" title="3.二维空间"></a>3.二维空间</h3><p>当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作 O(n^2)。</p><p>例如下面这段程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun3(int n)&#123;</span><br><span class="line">    int[][] matrix &#x3D; new int[n][n];</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-递归空间"><a href="#4-递归空间" class="headerlink" title="4.递归空间"></a>4.递归空间</h3><p>递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储「方法调用栈」。</p><p>「方法调用栈」包括进栈和出栈两个行为。</p><p>当进入一个新方法时，执行入栈操作，把调用的方法和参数信息压入栈中。</p><p>当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。</p><p>下面这段程序是一个标准的递归程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun4(int n)&#123;</span><br><span class="line">    if(n&lt;&#x3D;1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fun4(n-1);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>n = 1</code> 时，达到递归结束条件，执行 <code>return</code> 指令，方法出栈。</p><p>最终，「方法调用栈」的全部元素会一一出栈。</p><p>由上面「方法调用栈」的出入栈过程可以看出，执行递归操作所需要的内存空间和递归的深度成正比。纯粹的递归操作的空间复杂度也是线性，如果递归的深度是 n，那么空间复杂度就是 O(n)。</p><hr><h1 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组对应的英文是 array，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。</p><p>数组的另一个特点，是在内存中 <strong>顺序存储</strong>，因此可以很好地实现逻辑上的 <strong>顺序表</strong>。</p><p>内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。</p><p>数组中的每一个元素，都存储在小小的内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。</p><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><h4 id="1-读取元素"><a href="#1-读取元素" class="headerlink" title="1.读取元素"></a>1.读取元素</h4><p>对于数组来说，读取元素是最简单的操作。由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。</p><p>假设有一个名称为 array 的数组，我们要读取数组下标为 3 的元素，就写作 array[3]；读取数组下标为 5 的元素，就写作 array[5]。需要注意的是，输入的下标必须在数组的长度范围之内，否则会出现数组越界。</p><p>像这种根据下标读取元素的方式叫作随机读取。</p><p>简单的代码示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] array &#x3D; new int[]&#123;3,1,2,5,4,9,7,2&#125;;</span><br><span class="line">&#x2F;&#x2F;输出数组中下标为3的元素</span><br><span class="line">System.out.println(array[3]);</span><br></pre></td></tr></table></figure><h4 id="2-更新元素"><a href="#2-更新元素" class="headerlink" title="2.更新元素"></a>2.更新元素</h4><p>要把数组中某一个元素的值替换为一个新值，也是非常简单的操作。直接利用数组下标，就可以把新值赋给该元素。</p><p>简单的代码示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] array &#x3D; new int[]&#123;3,1,2,5,4,9,7,2&#125;;</span><br><span class="line">&#x2F;&#x2F;给数组下标为5的元素赋值</span><br><span class="line">array[5] &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;输出数组中下标为5的元素</span><br><span class="line">System.out.println(array[5]);</span><br></pre></td></tr></table></figure><h4 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h4><p>插入数组元素的操作存在 3 种情况。</p><ul><li>尾部插入</li><li>中间插入</li><li>超范围插入</li></ul><p><strong>1 尾部插入</strong>，是最简单的情况，直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/b084d760ebcb6bdc469b2e444aa192d7044a877e8735e6012f6747377acc3c9e-image.png" alt="img"></p><p><strong>2 中间插入</strong>，稍微复杂一些。由于数组的每一个元素都有其固定下标，所以不得不首先把插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/e5c8dcd40e043d1b627f9b62e33eb34527bad23155a35ebd93f7cecc4f588bc5-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/1eb68bb6d03400b4a84ce1a249e16c113f454030e38361c0e94a04147376384d-image.png" alt="img"></p><p>中间插入操作的完整实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int[] array;</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">public MyArray(int capacity)&#123;</span><br><span class="line">    this.array &#x3D; new int[capacity];</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 数组插入元素</span><br><span class="line"> * * @param index 插入的位置</span><br><span class="line"> * @param element 插入的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void insert(int index, int element) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;判断访问下标是否超出范围</span><br><span class="line">    if(index&lt;0 || index&gt;size)&#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从右向左循环，将元素逐个向右挪1位</span><br><span class="line">    for(int i&#x3D;size-1; i&gt;&#x3D;index; i--)&#123;</span><br><span class="line">        array[i+1] &#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;腾出的位置放入新元素</span><br><span class="line">    array[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输出数组</span><br><span class="line">*&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;size; i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyArray myArray &#x3D; new MyArray(10);</span><br><span class="line">    myArray.insert(0,3);</span><br><span class="line">    myArray.insert(1,7);</span><br><span class="line">    myArray.insert(2,9);</span><br><span class="line">    myArray.insert(3,5);</span><br><span class="line">    myArray.insert(1,6);</span><br><span class="line">    myArray.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的成员变量 size 是数组实际元素的数量。如果插入元素在数组尾部，传入的下标参数 index 等于 size；如果插入元素在数组中间或头部，则 index 小于 size。</p><p>如果传入的下标参数 index 大于 size 或小于 0，则认为是非法输入，会直接抛出异常。</p><p><strong>3 超范围输入</strong></p><p>假如现在有一个长度为 6 的数组，已经装满了元素，这时还想插入一个新元素。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/c620b217e9b32fd58f7334267b04fadcc5b86ee6e7b32b4332d724f54f370295-image.png" alt="img"></p><p>这就涉及数组的 扩容 了。可是数组的长度在创建时就已经确定了，无法像孙悟空的金箍棒那样随意变长或变短。这该如何是好呢？</p><p>此时可以创建一个新数组，长度是旧数组的 2 倍，再把旧数组中的元素统统复制过去，这样就实现了数组的扩容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int[] array;</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">public MyArray(int capacity)&#123;</span><br><span class="line">    this.array &#x3D; new int[capacity];</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 数组插入元素</span><br><span class="line">* @param index 插入的位置</span><br><span class="line">* @param element 插入的元素</span><br><span class="line">*&#x2F;</span><br><span class="line">public void insert(int index, int element) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;判断访问下标是否超出范围</span><br><span class="line">    if(index&lt;0 || index&gt;size)&#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果实际元素达到数组容量上限，则对数组进行扩容</span><br><span class="line">    if(size &gt;&#x3D; array.length)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从右向左循环，将元素逐个向右挪1位</span><br><span class="line">    for(int i&#x3D;size-1; i&gt;&#x3D;index; i--)&#123;</span><br><span class="line">        array[i+1] &#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;腾出的位置放入新元素</span><br><span class="line">    array[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 数组扩容</span><br><span class="line">*&#x2F;</span><br><span class="line">public void resize()&#123;</span><br><span class="line">    int[] arrayNew &#x3D; new int[array.length*2];</span><br><span class="line">    &#x2F;&#x2F;从旧数组复制到新数组</span><br><span class="line">    System.arraycopy(array, 0, arrayNew, 0, array.length);</span><br><span class="line">    array &#x3D; arrayNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输出数组</span><br><span class="line">*&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;size; i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyArray myArray &#x3D; new MyArray(4);</span><br><span class="line">    myArray.insert(0,3);</span><br><span class="line">    myArray.insert(1,7);</span><br><span class="line">    myArray.insert(2,9);</span><br><span class="line">    myArray.insert(3,5);</span><br><span class="line">    myArray.insert(1,6);</span><br><span class="line">    myArray.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><p>数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动 1 位。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/c58483d29aa1d381cc5b7ee9e6e1f4832141b07d5d21d04336b0eaf9484fa64b-image.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 数组删除元素</span><br><span class="line"> * @param index 删除的位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int delete(int index) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;判断访问下标是否超出范围</span><br><span class="line">    if(index&lt;0 || index&gt;&#x3D;size)&#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int deletedElement &#x3D; array[index];</span><br><span class="line">    &#x2F;&#x2F;从左向右循环，将元素逐个向左挪1位</span><br><span class="line">    for(int i&#x3D;index; i&lt;size-1; i++)&#123;</span><br><span class="line">        array[i] &#x3D; array[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    return deletedElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/99dbe210316c5f9e08deabe79f6207ca22a9172df1fe4cea268d8d375e462ac7-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/514206ab8eb6cffad3a6f2a6a701e41fa0870c90649ccbb3022dbff688f684d8-image.png" alt="img"></p><p>这样一来，无须进行大量的元素移动，时间复杂度降低为 O(1)。当然，这种方式只作参考，并不是删除元素时主流的操作方式。</p><h3 id="数组的优势和劣势"><a href="#数组的优势和劣势" class="headerlink" title="数组的优势和劣势"></a>数组的优势和劣势</h3><p><img src="https://gitee.com/tsuiwade/images/raw/master/135a196361d199ff34856893b77ea713d638b25fe8636d3f1ae97ba65084e86a-image.png" alt="img"></p><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>单向链表的结构。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/3eea67045ababc726d60ed11e23a0719ed6e795c2fe8062042f4e6d7594e76b0-image.png" alt="img"></p><p>链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。</p><p>单向链表的每一个节点又包含两部分，一部分是存放数据的变量 data，另一部分是指向下一个节点的指针 next。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表的第 1 个节点被称为头节点，最后 1 个节点被称为尾节点，尾节点的 next 指针指向空。</p><p>与数组按照下标来随机寻找元素不同，对于链表的其中一个节点 A，我们只能根据节点 A 的 next 指针来找到该节点的下一个节点 B，再根据节点 B 的 next 指针找到下一个节点 C……</p><p>双向链表比单向链表稍微复杂一些，它的每一个节点除了拥有 data 和 next 指针，还拥有指向前置节点的 prev 指针。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/56fc949c01057a4e6e23196a853bf750a77d3e50cc3b14400693786cdd560156-image.png" alt="img"></p><p>接下来我们看一看链表的存储方式。</p><p>如果说数组在内存中的存储方式是顺序存储，那么链表在内存中的存储方式则是 随机存储。</p><p>什么叫随机存储呢？</p><p>上一节我们讲解了数组的内存分配方式，数组在内存中占用了连续完整的存储空间。而链表则采用了见缝插针的方式，链表的每一个节点分布在内存的不同位置，依靠 next 指针关联起来。这样可以灵活有效地利用零散的碎片空间。</p><h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="1-查找节点"><a href="#1-查找节点" class="headerlink" title="1.查找节点"></a>1.查找节点</h4><p>在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从头节点开始向后一个一个节点逐一查找。</p><p>例如给出一个链表，需要查找从头节点开始的第 3 个节点。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/039ead8c0dd61e57aac46b3a34e09d00e15fc0cb67e552ab70fa1b3d09e697b9-image.png" alt="img"></p><h4 id="2-更新节点"><a href="#2-更新节点" class="headerlink" title="2.更新节点"></a>2.更新节点</h4><p>如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/b6a4e93a2eabd637fb8ec21bb148ff2d609d9817b2cf66fbd51ba2b34994d925-image.png" alt="img"></p><h4 id="3-插入节点"><a href="#3-插入节点" class="headerlink" title="3.插入节点"></a>3.插入节点</h4><p>与数组类似，链表插入节点时，同样分为 3 种情况。</p><ul><li>尾部插入</li><li>头部插入</li><li>中间插入</li></ul><p>尾部插入，是最简单的情况，把最后一个节点的 next 指针指向新插入的节点即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/7befe2351ef68342ce469d94ac19996df3da3be85e445bfff6b6373f68e845ef-image.png" alt="img"></p><p>头部插入，可以分成两个步骤。</p><p>第 1 步，把新节点的 next 指针指向原先的头节点。</p><p>第 2 步，把新节点变为链表的头节点。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/820aff3077399dc6fbd3c859341271a6c0ac41e0036eeae564a4f02dd2563308-image.png" alt="img"></p><p>中间插入，同样分为两个步骤。</p><p>第 1 步，新节点的 next 指针，指向插入位置的节点。</p><p>第 2 步，插入位置前置节点的 next 指针，指向新节点。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/9fda3b10e1d50512059b0ce9ca97f4b801a4a13d3130e4fd26c552f0be90cd51-image.png" alt="img"></p><p>只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要像数组那样考虑扩容的问题。</p><h4 id="4-删除元素-1"><a href="#4-删除元素-1" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><p>链表的删除操作同样分为 3 种情况。</p><ul><li>尾部删除</li><li>头部删除</li><li>中间删除</li></ul><p>尾部删除，是最简单的情况，把倒数第 2 个节点的 next 指针指向空即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/a02ef31340806c6fb15dd13a7564b30083fddf2108b48c34fb3f04f93e061054-image.png" alt="img"></p><p>头部删除，也很简单，把链表的头节点设为原先头节点的 next 指针即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/87f6c34725bb15ee04825e960583cff9e8bbe86f8ad5f912cac09cd37be183b3-image.png" alt="img"></p><p>中间删除，同样很简单，把要删除节点的前置节点的 next 指针，指向要删除元素的下一个节点即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/ac4c0f26d88d71beb9bf9aa2216f7d9925b39057f2bf7d4dd0bf296bf7525718-image.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;头节点指针</span><br><span class="line">private Node head;</span><br><span class="line">&#x2F;&#x2F;尾节点指针</span><br><span class="line">private Node last;</span><br><span class="line">&#x2F;&#x2F;链表实际长度</span><br><span class="line">private int size;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 链表插入元素</span><br><span class="line"> * @param data 插入元素</span><br><span class="line"> * @param index 插入位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void insert(int data, int index) throws Exception &#123;</span><br><span class="line">    if (index&lt;0 || index&gt;size) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出链表节点范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Node insertedNode &#x3D; new Node(data);</span><br><span class="line">    if(size &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;空链表</span><br><span class="line">        head &#x3D; insertedNode;</span><br><span class="line">        last &#x3D; insertedNode;</span><br><span class="line">    &#125; else if(index &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;插入头部</span><br><span class="line">        insertedNode.next &#x3D; head;</span><br><span class="line">        head &#x3D; insertedNode;</span><br><span class="line">    &#125;else if(size &#x3D;&#x3D; index)&#123;</span><br><span class="line">        &#x2F;&#x2F;插入尾部</span><br><span class="line">        last.next &#x3D; insertedNode;</span><br><span class="line">        last &#x3D; insertedNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;插入中间</span><br><span class="line">        Node prevNode &#x3D; get(index-1);</span><br><span class="line">        insertedNode.next &#x3D; prevNode.next;</span><br><span class="line">        prevNode.next &#x3D; insertedNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 链表删除元素</span><br><span class="line"> * @param index 删除的位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Node remove(int index) throws Exception &#123;</span><br><span class="line">    if (index&lt;0 || index&gt;&#x3D;size) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出链表节点范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Node removedNode &#x3D; null;</span><br><span class="line">    if(index &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;删除头节点</span><br><span class="line">        removedNode &#x3D; head;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;else if(index &#x3D;&#x3D; size-1)&#123;</span><br><span class="line">        &#x2F;&#x2F;删除尾节点</span><br><span class="line">        Node prevNode &#x3D; get(index-1);</span><br><span class="line">        removedNode &#x3D; prevNode.next;</span><br><span class="line">        prevNode.next &#x3D; null;</span><br><span class="line">        last &#x3D; prevNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;删除中间节点</span><br><span class="line">        Node prevNode &#x3D; get(index-1);</span><br><span class="line">        Node nextNode &#x3D; prevNode.next.next;</span><br><span class="line">        removedNode &#x3D; prevNode.next;</span><br><span class="line">        prevNode.next &#x3D; nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    return removedNode;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 链表查找元素</span><br><span class="line">* @param index 查找的位置</span><br><span class="line">*&#x2F;</span><br><span class="line">public Node get(int index) throws Exception &#123;</span><br><span class="line">    if (index&lt;0 || index&gt;&#x3D;size) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出链表节点范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp &#x3D; head;</span><br><span class="line">    for(int i&#x3D;0; i&lt;index; i++)&#123;</span><br><span class="line">        temp &#x3D; temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 输出链表</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    Node temp &#x3D; head;</span><br><span class="line">    while (temp!&#x3D;null) &#123;</span><br><span class="line">        System.out.println(temp.data);</span><br><span class="line">        temp &#x3D; temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 链表节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static class Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(int data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyLinkedList myLinkedList &#x3D; new MyLinkedList();</span><br><span class="line">    myLinkedList.insert(3,0);</span><br><span class="line">    myLinkedList.insert(7,1);</span><br><span class="line">    myLinkedList.insert(9,2);</span><br><span class="line">    myLinkedList.insert(5,3);</span><br><span class="line">    myLinkedList.insert(6,1);</span><br><span class="line">    myLinkedList.remove(0);</span><br><span class="line">    myLinkedList.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/f57ec4b3d5e2b7043953c04b5911091a67178d9017fcfd5e514ad6e485494a4f-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/5ec6a10f9d65a64422bc19da97620d86fb2486ac67a284cd02281f462289a808-image.png" alt="img"></p><hr><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="物理结构和逻辑结构"><a href="#物理结构和逻辑结构" class="headerlink" title="物理结构和逻辑结构"></a>物理结构和逻辑结构</h3><p><img src="https://gitee.com/tsuiwade/images/raw/master/88985dee51593997dd4a7d9296e28184c5ef47bc9b867cc6214b3ff35c8126a3-image.png" alt="img"></p><p>下面我们来讲解两个常用数据结构：栈和队列。这两者都属于逻辑结构，它们的物理实现既可以利用数组，也可以利用链表来完成。</p><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>假如有一个又细又长的圆筒，圆筒一端封闭，另一端开口。往圆筒里放入乒乓球，先放入的靠近圆筒底部，后放入的靠近圆筒入口。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/ff9dccb76fcdec6d2db3214c8dadaadd60858ce11a38fd1f3ece9c55e51eddcc-image.png" alt="img"></p><p>那么，要想取出这些乒乓球，则只能按照和放入顺序相反的顺序来取，先取出后放入的，再取出先放入的，而不可能把最里面最先放入的乒乓球优先取出。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/307099ac401e6b69e31b91ffe9c4f1f73f7e917f5cd8e18d25e19c9daef302b8-image.png" alt="img"></p><p><strong><code>栈</code></strong>（stack）是一种线性数据结构，它就像一个上图所示的放入乒乓球的圆筒容器，栈中的元素只能 先入后出（First In Last Out，简称 FILO）。最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作 栈顶（top）。</p><p>栈这种数据结构既可以用数组来实现，也可以用链表来实现。</p><p>栈的数组实现如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/6d4d1e54e6b04354c22104fdd3849074122e7a116f517e35acc2b3aeb8091a14-image.png" alt="img"></p><p>栈的链表实现如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/17a1ca94414d71874c3c28c376a94c4bae3fb969f3a23a0071310f26ebc2a1c3-image.png" alt="img"></p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><h4 id="1-入栈"><a href="#1-入栈" class="headerlink" title="1.入栈"></a>1.入栈</h4><p>入栈操作（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。</p><p>这里我们以数组实现为例。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/165fea0472143dce84bdccb1b5dceed8aa844c17afca5f34cbbec6d596bf16e8-image.png" alt="img"></p><h4 id="2-出栈"><a href="#2-出栈" class="headerlink" title="2.出栈"></a>2.出栈</h4><p><img src="https://gitee.com/tsuiwade/images/raw/master/21c46ad4ec11cb92963a640e8daaea82670019a22e956ce03e0315198224d8db-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/34b9e55307418e4809d0cb93d9e428f2605467815606bd5d07a58b0146e4de16-image.png" alt="img"></p><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>队列（queue）是一种线性数据结构，它的特征和行驶车辆的单行隧道很相似。不同于栈的先入后出，队列中的元素只能 先入先出（First In First Out，简称 FIFO）。队列的出口端叫作 队头（front），队列的入口端叫作 队尾（rear）。</p><p>用数组实现时，为了入队操作的方便，把队尾位置规定为最后入队元素的 <strong>下一个位置</strong>。</p><p>队列的数组实现如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/3b99c85efeafd71cba753fe6dc1bcddfac40cd1cb0ec9dd8405970f20e3a0309-image.png" alt="img"></p><p>队列的链表实现如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/6ca9fbf25a3f97629e02db4d66f28340d11c148f90266ac99b64180c3e3447e7-image.png" alt="img"></p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><p>对于链表实现方式，队列的入队、出队操作和栈是大同小异的。但对于数组实现方式来说，队列的入队和出队操作有了一些有趣的变化。怎么有趣呢？我们后面会看到。</p><h4 id="1-入队"><a href="#1-入队" class="headerlink" title="1.入队"></a>1.入队</h4><p>入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/9d75cd2557d351df63665964b9d4af556bca4d40b3bb44792d7c44693e8b7ccf-image.png" alt="img"></p><h4 id="2-出队"><a href="#2-出队" class="headerlink" title="2.出队"></a>2.出队</h4><p>出队操作（dequeue）是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/f0b3fa3f966854f375ff9f9a7c073812bb1b40e881dc22d85df79f034d7beba6-image.png" alt="img"></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>假设一个队列经过反复的入队和出队操作，还剩下 2 个元素，在「物理」上分布于数组的末尾位置。这时又有一个新元素将要入队。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/27bad911c70a460a24efdd07d001a6766899cb467965657d8606fa156ecc74b0-image.png" alt="img"></p><p>在数组不做扩容的前提下，如何让新元素入队并确定新的队尾位置呢？我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/60b109c45df53213d56999390e281ec0b9598e0394bb2df9092c95221be6d54f-image.png" alt="img"></p><p>这样一来，整个队列的元素就「循环」起来了。在物理存储上，队尾的位置也可以在队头之前。当再有元素入队时，将其放入数组的首位，队尾指针继续后移即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210728145044266.png" alt="image-20210728145044266"></p><p>一直到 (队尾下标 + 1) % 数组长度 = 队头下标 时，代表此队列真的已经满了。需要注意的是，队尾指针指向的位置永远空出 1 位，所以队列最大容量比数组长度小 1。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/db4ab58b927b2e6157d7867030be80177c5e0f23c3e6d7ee36f4b24cf6cca686-image.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int[] array;</span><br><span class="line">private int front;</span><br><span class="line">private int rear;</span><br><span class="line"></span><br><span class="line">public MyQueue(int capacity)&#123;</span><br><span class="line">    this.array &#x3D; new int[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 入队</span><br><span class="line"> * @param element 入队的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void enQueue(int element) throws Exception &#123;</span><br><span class="line">    if((rear+1)%array.length &#x3D;&#x3D; front)&#123;</span><br><span class="line">        throw new Exception(&quot;队列已满！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    array[rear] &#x3D; element;</span><br><span class="line">    rear &#x3D;(rear+1)%array.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 出队</span><br><span class="line">*&#x2F;</span><br><span class="line">public int deQueue() throws Exception &#123;</span><br><span class="line">    if(rear &#x3D;&#x3D; front)&#123;</span><br><span class="line">        throw new Exception(&quot;队列已空！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int deQueueElement &#x3D; array[front];</span><br><span class="line">    front &#x3D;(front+1)%array.length;</span><br><span class="line">    return deQueueElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输出队列</span><br><span class="line">*&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    for(int i&#x3D;front; i!&#x3D;rear; i&#x3D;(i+1)%array.length)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyQueue myQueue &#x3D; new MyQueue(6);</span><br><span class="line">    myQueue.enQueue(3);</span><br><span class="line">    myQueue.enQueue(5);</span><br><span class="line">    myQueue.enQueue(6);</span><br><span class="line">    myQueue.enQueue(8);</span><br><span class="line">    myQueue.enQueue(1);</span><br><span class="line">    myQueue.deQueue();</span><br><span class="line">    myQueue.deQueue();</span><br><span class="line">    myQueue.deQueue();</span><br><span class="line">    myQueue.enQueue(2);</span><br><span class="line">    myQueue.enQueue(4);</span><br><span class="line">    myQueue.enQueue(9);</span><br><span class="line">    myQueue.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/aca0e3d68ca2a1ebe9d155882034e97b0edab63900e0ae43c788cf7779e43ea5-image.png" alt="img"></p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>栈的输出顺序和输入顺序相反，所以栈通常用于对「历史」的回溯，也就是逆流而上追溯「历史」。</p><p>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。</p><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>队列的输出顺序和输入顺序相同，所以队列通常用于对「历史」的回放，也就是按照「历史」顺序，把「历史」重演一遍。</p><p>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。</p><p>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列这种数据结构，可以说综合了栈和队列的优点，对双端队列来说，从队头一端可以入队或出队，从队尾一端也可以入队或出队。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>还有一种队列，它遵循的不是先入先出，而是谁的优先级最高，谁先出队。</p><p>优先队列已经不属于线性数据结构的范畴了，它是基于二叉堆来实现的。关于优先队列的原理和使用情况，我们会在下一章进行详细介绍。</p><hr><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表也叫作 哈希表（hash table），这种数据结构提供了 键（Key）和 值（Value）的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于 O(1)。</p><p>通过哈希函数，把KEY和数组下标进行转换。</p><h3 id="散列表的读写操作"><a href="#散列表的读写操作" class="headerlink" title="散列表的读写操作"></a>散列表的读写操作</h3><h4 id="1-写操作"><a href="#1-写操作" class="headerlink" title="1.写操作"></a>1.写操作</h4><p>写操作就是在散列表中插入新的键值对（在 JDK 中叫作 Entry）。</p><p>如调用 hashMap.put(“002931”, “王五”) ，意思是插入一组 Key 为 002931、Value 为 王五 的键值对。</p><p>具体该怎么做呢？</p><p>第 1 步，通过哈希函数，把 Key 转化成数组下标 5。</p><p>第 2 步，如果数组下标5对应的位置没有元素，就把这个 Entry 填充到数组下标 5 的位置。</p><p>但是，由于数组的长度是有限的，当插入的 Entry 越来越多时，不同的 Key 通过哈希函数获得的下标有可能是相同的。例如 002936 这个 Key 对应的数组下标是 2；002947 这个 Key 对应的数组下标也是 2。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/179569e9240d28d3fd486b9fde35c4e01fde237f161ec2cd2214fabc6d3cd39c-image.png" alt="img"></p><p>这种情况，就叫作 <strong>哈希冲突</strong>。</p><p><strong>开放寻址法</strong></p><p>开放寻址法的原理很简单，当一个 Key 通过哈希函数获得对应的数组下标已被占用时，我们可以「另谋高就」，寻找下一个空档位置。</p><p>以上面的情况为例，Entry6 通过哈希函数得到下标 2，该下标在数组中已经有了其他元素，那么就向后移动 1 位，看看数组下标 3 的位置是否有空。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/e9a33f488461b4e40849263c40309328ab2bf4a3cf06d837d120a6d7b6093bce-image.png" alt="img"></p><p>很不巧，下标 3 也已经被占用，那么就再向后移动 1 位，看看数组下标 4 的位置是否有空。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/2d799d6d08fa9c31e113865e2e2234e2f402e908b6e2ff2702762cb5dea3cce3-image.png" alt="img"></p><p>幸运的是，数组下标 4 的位置还没有被占用，因此把 Entry6 存入数组下标 4 的位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/341f5b55f9d65a6b99b2980065eb423a97322daaeaa2714ff27afd7af0f4fa7f-image.png" alt=""></p><p>这就是开放寻址法的基本思路。当然，在遇到哈希冲突时，寻址方式有很多种，并不一定只是简单地寻找当前元素的后一个元素，这里只是举一个简单的示例而已。</p><p><strong>链表法</strong></p><p>这种方法被应用在了 Java 的集合类 HashMap 当中。</p><p>HashMap 数组的每一个元素不仅是一个 Entry 对象，还是一个链表的头节点。每一个 Entry 对象通过next指针指向它的下一个 Entry 节点。当新来的 Entry 映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/cdd31327f7b8840988f4aa6bae22211f4d151f92fbd3033e3952847700a8dc4d-image.png" alt="img"></p><h4 id="2-读操作"><a href="#2-读操作" class="headerlink" title="2.读操作"></a>2.读操作</h4><p>讲完了写操作，我们再来讲一讲读操作。读操作就是通过给定的 Key，在散列表中查找对应的 Value。</p><p>例如调用 hashMap.get(“002936”)，意思是查找 Key 为 002936 的 Entry 在散列表中所对应的值。</p><p>具体该怎么做呢？下面以链表法为例来讲一下。</p><p>第 1 步，通过哈希函数，把 Key 转化成数组下标 2。</p><p>第 2 步，找到数组下标 2 所对应的元素，如果这个元素的 Key 是 002936，那么就找到了；如果这个 Key 不是 002936 也没关系，由于数组的每个元素都与一个链表对应，我们可以顺着链表慢慢往下找，看看能否找到与 Key 相匹配的节点。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/28a5d1d6da1c4ec21911422d1773f5d92deb05955e89f2e003a8a74038a992cc-image.png" alt="img"></p><p>在上图中，首先查到的节点 Entry6 的 Key 是 002947，和待查找的 Key 002936 不符。接着定位到链表下一个节点 Entry1，发现 Entry1 的 Key 002936 正是我们要寻找的，所以返回 Entry1 的 Value 即可。</p><h4 id="3-扩容（resize）"><a href="#3-扩容（resize）" class="headerlink" title="3.扩容（resize）"></a>3.扩容（resize）</h4><p>在讲解数组时，曾经介绍过数组的扩容。既然散列表是基于数组实现的，那么散列表也要涉及扩容的问题。</p><p>首先，什么时候需要进行扩容呢？</p><p>当经过多次元素插入，散列表达到一定饱和度时，Key 映射位置发生冲突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。</p><ol><li>扩容，创建一个新的 Entry 空数组，长度是原数组的 2 倍。</li><li>重新 Hash，遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组中。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。</li></ol><p>经过扩容，原本拥挤的散列表重新变得稀疏，原有的 Entry 也重新得到了尽可能均匀的分配。</p><hr><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p>在数据结构中，树的定义如下。</p><p>树（tree）是 n(n≥0) 个节点的有限集。当 n=0 时，称为空树。在任意一个非空树中，有如下特点。</p><p>有且仅有一个特定的称为根的节点。</p><p>当 n&gt;1 时，其余节点可分为 m(m&gt;0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。</p><p>下面这张图，就是一个标准的树结构。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/a03fd322fa360e64fcd0cb63d1c54e0e2c7f1513ba50c7104ff76f2459e68f39-image.png" alt="img"></p><p>在上图中，节点 1 是 根节点（root）；节点 5、6、7、8 是树的末端，没有「孩子」，被称为叶子节点（leaf）。图中的虚线部分，是根节点 1 的其中一个子树。</p><p>同时，树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/954bb9227903d3be88f921bc76a5dac8a95bceb3dea9795184d3714cf7d5815b-image.png" alt="img"></p><p>在上图中，节点 4 的上一级节点，是节点 4 的父节点（parent）；从节点 4 衍生出来的节点，是节点 4 的孩子节点（child）；和节点 4 同级，由同一个父节点衍生出来的节点，是节点 4 的兄弟节点（sibling）。</p><p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是 4。</p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点 最多有 2 个孩子节点。注意，这里是最多有 2 个，也可能只有 1 个，或者没有孩子节点。</p><p>二叉树的结构如图所示。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/1d59b660750e8ff15f7c40d76461cedbbab01261eb9b2c562699f98882006d33-image.png" alt="img"></p><p>二叉树节点的两个孩子节点，一个被称为 左孩子（left child），一个被称为 右孩子（right child）。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p><p>此外，二叉树还有两种特殊形式，一个叫作 满二叉树，另一个叫作 完全二叉树。</p><p>什么是满二叉树呢？</p><p><strong>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/06369deec7bc21bf910da8c03b9f10f866b077adab18625c1e72db71eb1a7c98-image.png" alt="img"></p><p>简单点说，满二叉树的每一个分支都是满的。</p><p>什么又是完全二叉树呢？完全二叉树的定义很有意思。</p><p>对一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n。如果这个树所有节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为<code>完全二叉树</code>。</p><p>这个定义还真绕，看看下图就很容易理解了。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/2b7498a5b91e6765f1a654b7b16a4efb0214cb599be8e51fdea3cbc586174c74-image.png" alt="img"></p><p>在上图中，二叉树编号从 1 到 12 的 12 个节点，和前面满二叉树编号从 1 到 12 的节点位置完全对应。因此这个树是完全二叉树。</p><p>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/f28e307006deb99efb5c35ee5195dddac07da529d7ef8df77799c1cd6cbc0a02-image.png" alt="img"></p><p>二叉树可以用哪些物理存储结构来表达呢？</p><ol><li>链式存储结构。</li><li>数组。</li></ol><p><strong>链式存储结构</strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/c8341333e3a9453d0b84fe335b3911459a9894ade84592b5945205b746b855e6-image.png" alt="img"></p><p>链式存储是二叉树最直观的存储方式。</p><p>上一章讲过链表，链表是一对一的存储方式，每一个链表节点拥有 data 变量和一个指向下一节点的 next 指针。</p><p>而二叉树稍微复杂一些，一个节点最多可以指向左右两个孩子节点，所以二叉树的每一个节点包含 3 部分。</p><ul><li>存储数据的 data 变量</li><li>指向左孩子的 left 指针</li><li>指向右孩子的 right 指针</li></ul><p>再来看看用 数组 是如何存储的。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/257d8684f018221f33f86161a8434b2d09930035ddae9aaa2bf8722d577f6c70-image.png" alt="img"></p><p>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p><p>为什么这样设计呢？因为这样可以更方便地在数组中定位二叉树的孩子节点和父节点。</p><p>假设一个父节点的下标是 parent，那么它的左孩子节点下标就是 2×parent + 1；右孩子节点下标就是 2×parent + 2。</p><p>反过来，假设一个左孩子节点的下标是 leftChild，那么它的父节点下标就是 (leftChild-1) / 2。</p><p>假如节点 4 在数组中的下标是 3，节点 4 是节点 2 的左孩子，节点 2 的下标可以直接通过计算得出。</p><p>节点 2 的下标 = (3-1)/2 = 1</p><p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><p>什么样的二叉树最适合用数组表示呢？</p><p>我们后面即将学到的二叉堆，一种特殊的完全二叉树，就是用数组来存储的。</p><h3 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行 <strong>查找操作和维持相对顺序</strong> 这两个方面。</p><h4 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h4><p>二叉树的树形结构使它很适合扮演索引的角色。</p><p>这里我们介绍一种特殊的二叉树：二叉查找树（binary search tree）。光看名字就可以知道，这种二叉树的主要作用就是进行查找操作。</p><p>二叉查找树在二叉树的基础上增加了以下几个条件。</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</li><li>左、右子树也都是二叉查找树</li></ul><p>下图就是一个标准的二叉查找树。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/7ec930771a40155997e8055cf8542aeb989c2316253b1080d740c9f8fd90eafb-image.png" alt="img"></p><p>二叉查找树的这些条件有什么用呢？当然是为了查找方便。</p><p>对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是 n，那么搜索节点的时间复杂度就是 O(log n)，和树的深度是一样的。</p><p>这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。</p><h4 id="2-维持相对顺序"><a href="#2-维持相对顺序" class="headerlink" title="2. 维持相对顺序"></a>2. 维持相对顺序</h4><p>这一点仍然要从二叉查找树说起。二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。</p><p>因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。</p><p>新插入的节点，同样要遵循二叉排序树的原则。例如插入新元素 5，由于 5 &lt; 6，5 &gt; 3，5 &gt; 4，所以 5 最终会插入到节点 4 的右孩子位置。</p><p>这一切看起来很顺利，然而却隐藏着一个致命的问题。什么问题呢？下面请试着在二叉查找树中依次插入 9、8、7、6、5、4，看看会出现什么结果。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/678e3c1f5bb75ff5133f956151514e954d9bf07f5d8833f678a542f2c269eb81-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/90ec62910f0ea7efe02606c745d90412d3730418f07aa3c8247c2df9dd503ccb-image.png" alt="img"></p><p>怎么解决这个问题呢？这就涉及二叉树的自平衡了。二叉树自平衡的方式有多种，如红黑树、AVL 树、树堆等。由于篇幅有限，本书就不一一详细讲解了，感兴趣的读者可以查一查相关资料。</p><hr><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/c75787ee0fe6ecad30474b3454ba50ed1dd1e9c6bf36bdd984c81f5c3e48bbbb-image.png" alt="img"></p><p>从节点之间位置关系的角度来看，二叉树的遍历分为 4 种。</p><ol><li>前序遍历。</li><li>中序遍历。</li><li>后序遍历。</li><li>层序遍历。</li></ol><p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p><ul><li>深度优先遍历（前序遍历、中序遍历、后序遍历）。</li><li>广度优先遍历（层序遍历）。</li></ul><p>下面就来具体看一看这些不同的遍历方式。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。</p><p>所谓深度优先，顾名思义，就是偏向于纵深，「一头扎到底」的访问方式。可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍历、后序遍历，来看一看深度优先是怎么回事吧。</p><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h4><p>二叉树的前序遍历，输出顺序是根节点、左子树、右子树。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/f9753b165136f192c231d6b4c61852ee967de8e5cd949fc42ef372ec002d20db-image.png" alt="img"></p><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h4><p>二叉树的中序遍历，输出顺序是左子树、根节点、右子树。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/67021933c5aea3c7c6f54fc713d1967a965acbbf65ccab0bbdb44cbe8c3ebf7a-image.png" alt="img"></p><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><p>二叉树的后序遍历，输出顺序是左子树、右子树、根节点。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/e56788e04cffff8693c832ad0238d0ea3f2927da08723e1b2a0316802b45a7c0-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputList 输入序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(LinkedList&lt;Integer&gt;inputList)</span></span>&#123;</span><br><span class="line">    TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (inputList == <span class="keyword">null</span> || inputList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer data = inputList.removeFirst();</span><br><span class="line">    <span class="comment">// 这里的判空很关键：如果元素是空，则不在进一步递归</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">        node.leftChild = createBinaryTree(inputList);</span><br><span class="line">        node.rightChild = createBinaryTree(inputList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">    preOrderTraveral(node.leftChild);</span><br><span class="line">    preOrderTraveral(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraveral(node.leftChild);</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">    inOrderTraveral(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树后序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraveral(node.leftChild);</span><br><span class="line">    postOrderTraveral(node.rightChild);</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉树节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode leftChild;</span><br><span class="line">    TreeNode rightChild;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; inputList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(Arrays.</span><br><span class="line">              asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">10</span>,<span class="keyword">null</span>,</span><br><span class="line">              <span class="keyword">null</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createBinaryTree(inputList);</span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">    preOrderTraveral(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">    inOrderTraveral(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">    postOrderTraveral(treeNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树用递归方式来实现前序、中序、后序遍历，是最为自然的方式，因此代码也非常简单。</p><p>这 3 种遍历方式的区别，仅仅是输出的执行位置不同：前序遍历的输出在前，中序遍历的输出在中间，后序遍历的输出在最后。</p><p>代码中值得注意的一点是二叉树的构建。二叉树的构建方法有很多，这里把一个线性的链表转化成非线性的二叉树，链表节点的顺序恰恰是二叉树前序遍历的顺序。链表中的空值，代表二叉树节点的左孩子或右孩子为空的情况。</p><p>在代码的 main 函数中，通过 {3,2,9,null,null,10,null,null,8,null,4} 这样一个线性序列，构建成的二叉树如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/e4264241dd5b7f0dc81609b64c91aaf04f9933973e296827ae26a1c5e8d70b4b-image.png" alt="img"></p><p>绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈。因为递归和栈都有回溯的特性。</p><p>如何借助栈来实现二叉树的非递归遍历呢？下面以二叉树的前序遍历为例，看一看具体过程。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164313752.png" alt="image-20210727164313752"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164321565.png" alt="image-20210727164321565"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164334246.png" alt="image-20210727164334246"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164343866.png" alt="image-20210727164343866"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164350206.png" alt="image-20210727164350206"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164356767.png" alt="image-20210727164356767"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164405832.png" alt="image-20210727164405832"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树非递归前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveralWithStack</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    <span class="keyword">while</span>(treeNode!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//迭代访问节点的左孩子，并入栈</span></span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(treeNode.data);</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            treeNode = treeNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            treeNode = treeNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>如果说深度优先遍历是在一个方向上「一头扎到底」，那么广度优先遍历则恰恰相反：先在各个方向上各走出 1 步，再在各个方向上走出第 2 步、第 3 步……一直到各个方向全部走完。听起来有些抽象，下面让我们通过二叉树的层序遍历，来看一看广度优先是怎么回事。</p><p>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/a7b56e53db15682caade01d3006cbac57af7db32229a18048b1f46fe62cebd49-image.png" alt="img"></p><p>上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输出顺序。</p><p>可是，二叉树同一层次的节点之间是没有直接关联的，如何实现这种层序遍历呢？</p><p>这里同样需要借助一个数据结构来辅助工作，这个数据结构就是 <strong><code>队列</code></strong>。</p><p>详细遍历步骤如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164548134.png" alt="image-20210727164548134"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164554413.png" alt="image-20210727164554413"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164833894.png" alt="image-20210727164833894"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164843510.png" alt="image-20210727164843510"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164850404.png" alt="image-20210727164850404"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164856216.png" alt="image-20210727164856216"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210727164902536.png" alt="image-20210727164902536"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树层序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。</p><ol><li><strong>最大堆</strong>。</li><li><strong>最小堆</strong>。</li></ol><p>什么是最大堆呢？最大堆的任何一个父节点的值，都 <strong>大于或等于</strong> 它左、右孩子节点的值。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/09bac735648e52f9314bb098a29fa46f5ddf6306c9785f2c608ec86e4acc74dc-image.png" alt="img"></p><p>什么是最小堆呢？最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/d4f91b0691c64a085e0c960d03540938ee01a06856947fbbbf95ff7127642744-image.png" alt="img"></p><p>二叉堆的根节点叫作 <strong>堆顶</strong>。</p><p>最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的 <strong>最大元素</strong>；最小堆的堆顶是整个堆中的 <strong>最小元素</strong>。</p><h3 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h3><p>对于二叉堆，有如下几种操作。</p><ol><li><strong>插入节点</strong>。</li><li><strong>删除节点</strong>。</li><li><strong>构建二叉堆</strong></li></ol><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。下面让我们以最小堆为例，看一看二叉堆是如何进行自我调整的。</p><h4 id="1-插入节点"><a href="#1-插入节点" class="headerlink" title="1.插入节点"></a>1.插入节点</h4><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/50ef9b08afe7af3f7d88ce8482691e1a2c33486ab7517ca87eb38872827d620d-image.png" alt="img"></p><p>这时，新节点的父节点 5 比 0 大，显然不符合最小堆的性质。于是让新节点「上浮」，和父节点交换位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/dcc44ea987c79b3a0f8d7ecfac7e51fa3a42bff07778ab9f011491b18178b2d6-image.png" alt="img"></p><p>继续比较，最终新节点 0「上浮」到了堆顶位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/14fee45e056081a678354b60f30b710fe44f991d31cd27a959fc42d37440dcc2-image.png" alt="img"></p><h4 id="2-删除节点"><a href="#2-删除节点" class="headerlink" title="2. 删除节点"></a>2. 删除节点</h4><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点 1。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/63f392593a9bc353676e5ba49bc48649d0522ecb606318bedb47f279f3e42606-image.png" alt="img"></p><p>这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点 10 临时补到原本堆顶的位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/2e408f990508896b8bd8c62547751c6cb7b59d5d98789f1117e24b4ee64f7122-image.png" alt="img"></p><p>接下来，让暂处堆顶位置的节点 10 和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点 2）比节点 10 小，那么让节点 10「下沉」。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/e886fdfac8b08f8e93dc82b201eef0aeb3840d20790d07d84a8897587412edb1-image.png" alt="img"></p><h4 id="3-构建二叉堆"><a href="#3-构建二叉堆" class="headerlink" title="3. 构建二叉堆"></a>3. 构建二叉堆</h4><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次「下沉」。</p><p>下面举一个无序完全二叉树的例子，如下图所示。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/addf9731e7e6d555262d480207510be36835daebbcacfeffb3b5478ab1e8d701-image.png" alt="img"></p><p>首先，从最后一个非叶子节点开始，也就是从节点 10 开始。如果节点 10 大于它左、右孩子节点中最小的一个，则节点 10「下沉」。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/465057c49790ccc981a8f234b0212083d93f9e88634f1d520bea5855622f79b0-image.png" alt="img"></p><p>接下来轮到节点 3，如果节点 3 大于它左、右孩子节点中最小的一个，则节点 3「下沉」。</p><p>然后轮到节点 1，如果节点 1 大于它左、右孩子节点中最小的一个，则节点 1「下沉」。事实上节点 1 小于它的左、右孩子，所以不用改变。</p><p>接下来轮到节点 7，如果节点 7 大于它左、右孩子节点中最小的一个，则节点 7「下沉」。节点 7 继续比较，继续「下沉」。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/6e814125c69968b98f2369a3795dca226cdeace07787db9d42535606574cfbad-image.png" alt="img"></p><p>经过上述几轮比较和「下沉」操作，最终每一节点都小于它的左、右孩子节点，一个无序的完全二叉树就被构建成了一个最小堆。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/3c49e9cef1edcf064888a0ebbf761f4469998bde9f8ac90e3ec4bab2632b36aa-image.png" alt="img"></p><h3 id="二叉堆的代码实现"><a href="#二叉堆的代码实现" class="headerlink" title="二叉堆的代码实现"></a>二叉堆的代码实现</h3><p>在展示代码之前，我们还需要明确一点：二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组中。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/7a3431761cb8aa0be8d80d05936e394e5b09677a77c4eb07c5cae9c2089f479a-image.png" alt="img"></p><p>在数组中，在没有左、右指针的情况下，如何定位一个父节点的左孩子和右孩子呢？</p><p>像上图那样，可以依靠数组下标来计算。</p><p>假设父节点的下标是 parent，那么它的左孩子下标就是 2 <em> parent + 1；右孩子下标就是 2 </em> parent + 2。</p><p>例如上面的例子中，节点 6 包含 9 和 10 两个孩子节点，节点 6 在数组中的下标是 3，节点 9 在数组中的下标是 7，节点 10 在数组中的下标是 8。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “上浮”调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[parentIndex])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[childIndex] = array[parentIndex];</span><br><span class="line">        childIndex = parentIndex;</span><br><span class="line">        parentIndex = (parentIndex-<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">    <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &lt; array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构建堆</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    buildHeap(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中有一个优化的点，就是在父节点和孩子节点做连续交换时，并不一定要真的交换，只需要先把交换一方的值存入 temp 变量，做单向覆盖，循环结束后，再把 temp 的值存入交换后的最终位置即可。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/48a5e82dd75fb78290f3d0b60986f817c45d7f8e804648970bbbd7ee89557feb-image.png" alt="img"></p><hr><h2 id="优先队列-1"><a href="#优先队列-1" class="headerlink" title="优先队列"></a>优先队列</h2><p>队列的特点是什么？</p><p>在之前的章节中已经讲过，队列的特点是 <strong>先进先出（FIFO）</strong>。</p><p><strong>入队列，将新元素置于队尾</strong>。<strong>出队列，队头元素最先被移出：</strong>。</p><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p><p>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队<br>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</p><p>例如有一个最大优先队列，其中的最大元素是 8，那么虽然8并不是队头元素，但出队时仍然让元素8首先出队。</p><p><strong>最大堆的堆顶是整个堆中的最大元素。</strong></p><p>因此，可以用最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p><p><strong>入队操作</strong> 具体步骤如下</p><p>插入新节点 5。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/1cdd55a437f77a222effbd9cf4cd37a0e8f1911e0ec32766fd7d7810c9c92b40-image.png" alt="img"></p><p>新节点 5「上浮」到合适位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/192aa099efe7e0e1536fe5fbbfc2a825de1b2f6cbe4c4fcd1353260c589ef956-image.png" alt="img"></p><p><strong>出队操作</strong> 具体步骤如下。</p><p>让原堆顶节点 10 出队。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/3c2f229af70a78f2158387ea186bf0445f8df350a2a9b7978ddda41569e7a901-image.png" alt="img"></p><p>把最后一个节点 1 替换到堆顶位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/ea77504980fa8241c606ab06a20e6595e013a1fe1a7560557f10b0173a5a7972-image.png" alt="img"></p><p>节点 1「下沉」，节点 9 成为新堆顶。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/a12c8b8a7333c3dc2d46eb4f821b9ac0e9d48267bf7c6cfe5d9f4e3d149c7a93-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/eb7b3637b070212ec28ebd8d6176e26e8c8b0450428b573f9a0a5b91be0b7512-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为32</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span>(size &gt;= array.length)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “上浮”调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[childIndex] = array[parentIndex];</span><br><span class="line">        childIndex = parentIndex;</span><br><span class="line">        parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot;出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码采用数组来存储二叉堆的元素，因此当元素数量超过数组长度时，需要进行扩容来扩大数组长度。</p><hr><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>根据时间复杂度的不同，主流的排序算法可以分为 3 大类。</p><ol><li><p>时间复杂度为 O(n^2)的排序算法</p><ul><li><p>冒泡排序</p></li><li><p>选择排序</p></li><li><p>插入排序</p></li><li><p>希尔排序（希尔排序比较特殊，它的性能略优于 O(n^2)，但又比不上 O(nlog n)，姑且把它归入本类）</p></li></ul></li></ol><ol><li><p>时间复杂度为 O(nlog n) 的排序算法</p><ul><li><p>快速排序</p></li><li><p>归并排序</p></li><li><p>堆排序</p></li></ul></li><li><p>时间复杂度为线性的排序算法</p><ul><li><p>计数排序</p></li><li><p>桶排序</p></li><li><p>基数排序</p></li></ul></li></ol><p>当然，以上列举的只是最主流的排序算法，在算法界还存在着更多五花八门的排序，它们有些基于传统排序变形而来；有些则是脑洞大开，如鸡尾酒排序、猴子排序、睡眠排序等。</p><p>此外，排序算法还可以根据其稳定性，划分为稳定排序和不稳定排序。</p><p>即如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序之所以叫冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点地向着数组的一侧移动。</p><p>按照冒泡排序的思想，我们要 <strong>把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变</strong>。详细过程如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/40e8b3e132ed2482c4bc433bf6a72ffaa0ec386e94c91b0e188d508e6a5d39e0-image.png" alt="img"></p><p>这样一来，元素 9 作为数列中最大的元素，就像是汽水里的小气泡一样，「漂」到了最右侧。</p><p>这时，冒泡排序的第 1 轮就结束了。数列最右侧元素 9 的位置可以认为是一个有序区域，有序区域目前只有 1 个元素。</p><p>后续的交换细节，这里就不详细描述了，第 3 轮到第 7 轮的状态如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/c2e5a2a8d4399b4a38c7612b6a17b17abfdb88c6904094db6f9a1c7bdbeb822b-image.png" alt="img"></p><p>冒泡排序是一种稳定排序，值相等的元素并不会打乱原本的顺序。由于该排序算法的每一轮都要遍历所有元素，总共遍历（元素数量 - 1）轮，所以平均时间复杂度是 O(n^2)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显可以看出，经过第 6 轮排序后，整个数列已然是有序的了。可是排序算法仍然兢兢业业地继续执行了第 7 轮排序。</p><p>在这种情况下，如果能判断出数列已经有序，并做出标记，那么剩下的几轮排序就不必执行了，可以提前结束工作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与第 1 版代码相比，第 2 版代码做了小小的改动，利用布尔变量 isSorted 作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，则说明数列已然有序，然后直接跳出大循环。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/8103b28bab7794e0f225f01a52ea4591a6fddca77c1975763d15e714e12ebb9b-image.png" alt="img"></p><p>这个数列的特点是前半部分的元素（3、4、2、1）无序，后半部分的元素（5、6、7、8）按升序排列，并且后半部分元素中的最小值也大于前半部分元素的最大值。</p><p>这个问题的关键点在于对数列有序区的界定。</p><p>按照现有的逻辑，有序区的长度和排序的轮数是相等的。例如第1轮排序过后的有序区长度是 1，第 2 轮排序过后的有序区长度是 2 ……</p><p>实际上，数列真正的有序区可能会大于这个长度，如上述例子中在第 2 轮排序时，后面的 5 个元素实际上都已经属于有序区了。因此后面的多次元素比较是没有意义的。</p><p>那么，该如何避免这种情况呢？<strong>我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为无序数列的边界，再往后就是有序区了。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//更新为最后一次交换元素的位置</span></span><br><span class="line">                lastExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortBorder = lastExchangeIndex;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 3 版代码中，<code>sortBorder</code> 就是无序数列的边界。在每一轮排序过程中，处于 <code>sortBorder</code> 之后的元素就不需要再进行比较了，肯定是有序的。</p><p>还有一种排序算法叫作鸡尾酒排序，是基于冒泡排序的一种升级排序法。</p><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点地向着数组的一侧移动。算法的每一轮都是 从左到右来比较元素，进行单向的位置交换的。</p><p>那么鸡尾酒排序做了怎样的优化呢？</p><p>鸡尾酒排序的元素比较和交换过程是 双向 的。</p><p>下面举一个例子。</p><p>由 8 个数字组成一个无序数列 {2,3,4,5,6,7,8,1}，希望对其进行从小到大的排序。</p><p>如果按照冒泡排序的思想，排序过程如下。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/4cc400c0aecb6e3b81582a292b51faf6298184963c89a2cf708e8ade71190a06-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/95bb7836fb7989756714fa0c028ccd21657db20cea41294dc8ead144ec355150-image.png" alt="img"></p><p><strong>第 1 轮（和冒泡排序一样，8 和 1 交换）</strong></p><p><strong>第 2 轮</strong></p><p>此时开始不一样了，我们反过来 <strong>从右往左</strong> 比较并进行交换。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/b85cd9eb2b4d30eb006599ea4a6489bacc0dd649355452ab316a9fd4e21f691f-image.png" alt="img"></p><p><strong>第 3 轮（虽然实际上已经有序，但是流程并没有结束）</strong>在鸡尾酒排序的第3轮，需要重新从左向右比较并进行交换。</p><p><strong>这就是鸡尾酒排序的思路。排序过程就像钟摆一样，第1轮从左到右，第 2 轮从右到左，第 3 轮再从左到右……</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;array.length-i-<span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">        isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//偶数轮，从右向左比较和交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=array.length-i-<span class="number">1</span>; j&gt;i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是鸡尾酒排序的原始实现。代码外层的大循环控制着所有排序回合，大循环内包含 2 个小循环，第 1 个小循环从左向右比较并交换元素，第 2 个小循环从右向左比较并交换元素。</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>同冒泡排序一样，快速排序也属于 交换排序，通过元素之间的比较和交换位置来达到排序的目的。</p><p>不同的是，冒泡排序在每一轮中只把 1 个元素冒泡到数列的一端，而快速排序则 <strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/5736c868108b6e9d183759eb620905e71f289e745d50a6a7147ef0434c8effe4-image.png" alt="img"></p><p>这种思路就叫作分治法。</p><p>每次把数列分成两部分，究竟有什么好处呢？</p><p>假如给出一个 8 个元素的数列，一般情况下，使用冒泡排序需要比较 7 轮，每一轮把 1 个元素移动到数列的一端，时间复杂度是 O(n^2)。</p><p>而快速排序的流程是什么样子呢？</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/e422a4ef386acd9c816625ffef539ecdaaf56c31700e12fffb184515f79634f8-image.png" alt="img"></p><p>如图所示，在分治法的思想下，原数列在每一轮都被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</p><p>每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是 O(n)。这样的遍历一共需要多少轮呢？假如元素个数是 n，那么平均情况下需要 nlog n 轮，因此快速排序算法总体的平均时间复杂度是 O(n log n)。</p><p><strong>基准元素的选择</strong></p><p>基准元素，英文是 pivot，在分治过程中，以基准元素为中心，把其他元素移动到它的左右两边。</p><p>那么如何选择基准元素呢？</p><p>最简单的方式是选择数列的第 1 个元素。</p><p>这种选择在绝大多数情况下是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，那么会出现什么情况呢？</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/7b0909cf096fed67893c48c766adf99e386d41ee8adc9c7a08f749fd13ba6d47-image.png" alt="img"></p><p>那么，该怎么避免这种情况发生呢？</p><p>其实很简单，我们可以 <strong>随机选择一个元素作为基准元素</strong>，并且让基准元素和数列首元素交换位置。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/2def91a2981c50c627d63a0db237d033f9895f5e544572374bd83d4288be0d8f-image.png" alt="img"></p><p>这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。</p><p>当然，即使是随机选择基准元素，也会有极小的几率选到数列的最大值或最小值，同样会影响分治的效果。</p><p>所以，虽然快速排序的平均时间复杂度是 O(n\ \textit{log} \ n)O(n log n)，但最坏情况下的时间复杂度是 O(n^2)。</p><p><strong>元素的交换</strong></p><p>选定了基准元素以后，我们要做的就是把其他元素中小于基准元素的都交换到基准元素一边，大于基准元素的都交换到基准元素另一边。</p><p>具体如何实现呢？有两种方法。</p><p>双边循环法。<br>单边循环法。</p><p>何谓<code>双边循环法</code>？下面来看一看详细过程。</p><p>给出原始数列如下，要求对其从小到大进行排序。</p><p>首先，选定基准元素 pivot，并且设置两个指针 left 和 right，指向数列的最左和最右两个元素。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/38d88302ae7b345b733b6f67920a95fe62eb866336aa09eeacb8f59fc4935ed0-image.png" alt="img"></p><p>接下来进行 第 1 次循环，从 right 指针开始，让指针所指向的元素和基准元素做比较。如果 大于或等于 pivot，则指针向 左 移动；如果 小于pivot，则 right 指针停止移动，切换到 left 指针。</p><p>在当前数列中，1 &lt; 4，所以 right 直接停止移动，换到 left 指针，进行下一步行动。</p><p>轮到 left 指针行动，让指针所指向的元素和基准元素做比较。如果 小于或等于 pivot，则指针向 右 移动；如果 大于 pivot，则 left 指针停止移动。</p><p>由于 left 开始指向的是基准元素，判断肯定相等，所以 left 右移 1 位。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/0ba774f240df37a3cb972e63c4130c6a6de485293170f0fc884237851994e899-image.png" alt="img"></p><p>由于 <code>7 &gt; 4</code>，<code>left</code> 指针在元素 7 的位置停下。这时，让 <code>left</code> 和 <code>right</code> 指针所指向的元素进行交换。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/1b907951020ac200e7ba34647d47c8f12615b241cdf1b47cb59fa07dd2beb836-image.png" alt="img"></p><p>接下来，进入第 2 次循环，重新切换到 <code>right</code> 指针，向左移动。<code>right</code> 指针先移动到 <code>8</code>，<code>8 &gt; 4</code>，继续左移。由于 <code>2 &lt; 4</code>，停止在 <code>2</code> 的位置。</p><p>按照这个思路，后续步骤如图所示。<img src="https://gitee.com/tsuiwade/images/raw/master/845ef3e72b1bc5181aae35f5f0c965e4a49117f767a85c9fa2cbce84e8cc46dd-image.png" alt="img"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/f45c3b84ca308f42b34434d5ee57902b0a09c1adf9d6584f03e4df737da19bca-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分治（双边循环法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待交换的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex 结束下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( left != right) &#123;</span><br><span class="line">        <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right] &gt; pivot)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">        <span class="keyword">while</span>( left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换left和right指针所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">    arr[startIndex] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，quickSort 方法通过递归的方式，实现了分而治之的思想。</p><p>partition 方法则实现了元素的交换，让数列中的元素依据自身大小，分别交换到基准元素的左右两边。在这里，我们使用的交换方式是双边循环法。</p><p><strong>单边循环法</strong></p><p>双边循环法从数组的两边交替遍历元素，虽然更加直观，但是代码实现相对烦琐。而单边循环法则简单得多，只从数组的一边对元素进行遍历和交换。我们来看一看详细过程。</p><p>开始和双边循环法相似，首先选定基准元素 pivot。同时，设置一个 mmark 指针指向数列起始位置，这个 mark 指针代表小于基准元素的区域边界。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/244fe589cf1abbfc7f9ff4361ea21e460fd726d28e09fa0e62913847c1b6bb3e-image.png" alt="img"></p><p>接下来，从基准元素的下一个位置开始遍历数组。</p><p>如果遍历到的元素大于基准元素，就继续往后遍历。</p><p>如果遍历到的元素小于基准元素，则需要做两件事：第一，把 mark 指针右移 1 位，因为小于 pivot 的区域边界增大了 1；第二，让最新遍历到的元素和 mark 指针所在位置的元素交换位置，因为最新遍历的元素归属于小于 pivot 的区域。</p><p>首先遍历到元素 7，7 &gt; 4，所以继续遍历。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/f1e01cf864cfef5cb5f4259c0e19399d7e478f363f7a0896ccbe8726b1a62637-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治（单边循环法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待交换的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex 结束下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex+<span class="number">1</span>; i&lt;=endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">            mark ++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归实现</strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/8fb5a28d777c76225b546aaef67eb0d1ee996051ff61474f87aebdbcf4bfa5c1-image.png" alt="img"></p><p>在第 1 章介绍空间复杂度时我们曾经提到过，代码中一层一层的方法调用，本身就使用了一个方法调用栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。</p><p>所以，可以把原本的递归实现转化成一个栈的实现，在栈中存储每一次方法调用的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用一个集合栈来代替递归的函数栈</span></span><br><span class="line">    Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">// 整个数列的起止下标，以哈希的形式入栈</span></span><br><span class="line">    Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">    rootParam.put(<span class="string">&quot;startIndex&quot;</span>, startIndex);</span><br><span class="line">    rootParam.put(<span class="string">&quot;endIndex&quot;</span>, endIndex);</span><br><span class="line">    quickSortStack.push(rootParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环结束条件：栈为空时</span></span><br><span class="line">    <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 栈顶元素出栈，得到起止下标</span></span><br><span class="line">        Map&lt;String, Integer&gt; param = quickSortStack.pop();</span><br><span class="line">        <span class="comment">// 得到基准元素位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">&quot;startIndex&quot;</span>), param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">        <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈</span></span><br><span class="line">        <span class="keyword">if</span>(param.get(<span class="string">&quot;startIndex&quot;</span>) &lt; pivotIndex -<span class="number">1</span>)&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            leftParam.put(<span class="string">&quot;startIndex&quot;</span>, param.get(<span class="string">&quot;startIndex&quot;</span>));</span><br><span class="line">            leftParam.put(<span class="string">&quot;endIndex&quot;</span>, pivotIndex-<span class="number">1</span>);</span><br><span class="line">            quickSortStack.push(leftParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">&quot;endIndex&quot;</span>))&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            rightParam.put(<span class="string">&quot;startIndex&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">            rightParam.put(<span class="string">&quot;endIndex&quot;</span>, param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">            quickSortStack.push(rightParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治（单边循环法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待交换的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex 结束下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex+<span class="number">1</span>; i&lt;=endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">            mark ++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和刚才的递归实现相比，非递归方式代码的变动只发生在 quickSort 方法中。该方法引入了一个存储 Map 类型元素的栈，用于存储每一次交换时的起始下标和结束下标。</p><p>每一次循环，都会让栈顶元素出栈，通过 partition 方法进行分治，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。</p><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>以最大堆为例，如果删除一个最大堆的堆顶（并不是完全删除，而是跟末尾的节点交换位置），经过自我调整，第 2 大的元素就会被交换上来，成为最大堆的新堆顶。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/14acf856987e318b756b47d9432a96334a9581f668ec00e704ad52a61a511f43-image.png" alt="img"></p><p>正如上图所示，在删除值为 10 的堆顶节点后，经过调整，值为 9 的新节点就会顶替上来；在删除值为 9 的堆顶节点后，经过调整，值为 8 的新节点就会顶替上来……</p><p>由于二叉堆的这个特性，每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么只要反复删除堆顶，反复调整二叉堆，所得到的集合就会成为一个有序集合。</p><p>到此为止，原本的最大二叉堆已经变成了一个从小到大的有序集合。之前说过，二叉堆实际存储在数组中，数组中的元素排列如下。</p><p>由此，可以归纳出堆排序算法的步骤。</p><p><strong>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。</strong><br><strong>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序（升序）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.把无序数组构建成最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    <span class="comment">// 2.循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">        downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    heapSort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/e69e3c6d4a03488e9a6bdb0ad5a89d0ca7a265fd3691b5b43c9cb5e6c5c287ea-image.png" alt="img"></p><p>二叉堆的节点「下沉」调整（downAdjust 方法）是堆排序算法的基础，这个调节操作本身的时间复杂度在上一章讲过，是 O(log n)。</p><p>我们再来回顾一下堆排序算法的步骤。</p><p>把无序数组构建成二叉堆。<br>循环删除堆顶元素，并将该元素移到集合尾部，调整堆产生新的堆顶。<br>第 1 步，把无序数组构建成二叉堆，这一步的时间复杂度是 O(n)O(n)。<br>第 2 步，需要进行 n - 1 次循环。每次循环调用一次 downAdjust 方法，所以第 2 步的计算规模是 (n−1)×log n ，时间复杂度为 O(n log n)。</p><p>两个步骤是并列关系，所以整体的时间复杂度是 O(n log n)。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/c5aa2c35d580454d884e4f398b1446f4f1de9ce1aa9d6b08bff6ebef25b394b2-image.png" alt="img"></p><hr><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>不基于元素比较，而是利用数组下标来确定元素的正确位置。</p><p>假设数组中有 20 个随机整数，取值范围为 0 ～ 10，要求用最快的速度把这 20 个整数从小到大进行排序。</p><p>如何给这些无序的随机整数进行排序呢？</p><p>考虑到这些整数只能够在 0、1、2、3、4、5、6、7、8、9、10 这 11 个数中取值，取值范围有限。所以，可以根据这有限的范围，建立一个长度为 11 的数组。数组下标从 0 到 10，元素初始值全为 0。</p><p>假设 20 个随机整数的值如下所示。</p><p>9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9</p><p>下面就开始遍历这个无序的随机数列，每一个整数按照其值对号入座，同时，对应数组下标的元素进行加 1 操作。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/8d697731fbcdcaef14370f7a917e5814166ad7f99342d8b75dc61909cadd178b-image.png" alt="img"></p><p>有了这个统计结果，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。</p><p>0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10<br><img src="https://gitee.com/tsuiwade/images/raw/master/83d7c9f2a2d8078a39c3f516427eb822b53646f19a41a3c07709b09dec0a47fd-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">//1.得到数列的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max)&#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根据数列最大值确定统计数组的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//3.遍历数列，填充统计数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">        countArray[array[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.遍历统计数组，输出结果</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;countArray.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;countArray[i]; j++)&#123;</span><br><span class="line">            sortedArray[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/1d60e757d2b730ca10f98a119898cce818ff032d817fa0ee34273f9abc5dfe64-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">//1.得到数列的最大值和最小值，并算出差值d</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = max - min;</span><br><span class="line">    <span class="comment">//2.创建统计数组并统计对应元素的个数</span></span><br><span class="line">    <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[d+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">        countArray[array[i]-min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.统计数组做变形，后面的元素等于前面的元素之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;countArray.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">        countArray[i] += countArray[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组</span></span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        sortedArray[countArray[array[i]-min]-<span class="number">1</span>]=array[i];</span><br><span class="line">        countArray[array[i]-min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">95</span>,<span class="number">94</span>,<span class="number">91</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">90</span>,<span class="number">99</span>,<span class="number">93</span>,<span class="number">91</span>,<span class="number">92</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/tsuiwade/images/raw/master/a771193519b38732ac818d50dcbad94966fdf96f05974b19b9409e9920afde98-image.png" alt="img"></p><p>1．当数列最大和最小值差距过大时，并不适合用计数排序。</p><p>例如给出 20 个随机整数，范围在 0 到 1 亿之间，这时如果使用计数排序，需要创建长度为 1 亿的数组。不但严重浪费空间，而且时间复杂度也会随之升高。</p><p>2．当数列元素不是整数时，也不适合用计数排序。</p><p>如果数列中的元素都是小数，如 25.213，或 0.00 000 001 这样的数字，则无法创建对应的统计数组。这样显然无法进行计数排序。</p><hr><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><img src="https://gitee.com/tsuiwade/images/raw/master/86792b11a716df7aeee06b04c41311b4ffb7f067829eccfdbd2276001f6b87ba-image.png" alt="img"></p><p>那么，桶排序中所谓的「桶」，又是什么呢？</p><p>每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素。</p><p>假设有一个非整数数列如下：</p><p>4.5，0.84，3.25，2.18，0.5</p><p>让我们来看看桶排序的工作原理。</p><p>桶排序的第 1 步，就是创建这些桶，并确定每一个桶的区间范围。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/5450720558e4bd32f9b856826eed965ece3b570b0e60426af8fcccf2631f0626-image.png" alt="img"></p><p>具体需要建立多少个桶，如何确定桶的区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的元素数量，除最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定。</p><p>区间跨度 = （最大值-最小值）/ （桶的数量 - 1）</p><p>第 2 步，遍历原始数列，把元素对号入座放入各个桶中。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/a6abd25b80165df9664f0d53e09352af2f4282b7c03c86e85695344ee8fa583e-image.png" alt="img"></p><p>第 3 步，对每个桶内部的元素分别进行排序（显然，只有第 1 个桶需要排序）。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/007d88007ef69a9adb618c4e0974b762996c56ebef177c994bf21559b739801a-image.png" alt="img"></p><p>第 4 步，遍历所有的桶，输出所有元素。</p><p>0.5，0.84，2.18，3.25，4.5</p><p>到此为止，排序结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.得到数列的最大值和最小值，并算出差值d</span></span><br><span class="line">    <span class="keyword">double</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = array.length;</span><br><span class="line">    ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;LinkedList&lt;Double&gt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历原始数组，将每个元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>)((array[i] - min) * (bucketNum-<span class="number">1</span>) / d);</span><br><span class="line">        bucketList.get(num).add(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对每个桶内部进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//JDK底层采用了归并排序或归并的优化版本</span></span><br><span class="line">        Collections.sort(bucketList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.输出全部元素</span></span><br><span class="line">    <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LinkedList&lt;Double&gt; list : bucketList)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> element : list)&#123;</span><br><span class="line">            sortedArray[index] = element;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[] array = <span class="keyword">new</span> <span class="keyword">double</span>[] &#123;<span class="number">4.12</span>,<span class="number">6.421</span>,<span class="number">0.0023</span>,<span class="number">3.0</span>,<span class="number">2.123</span>,<span class="number">8.122</span>,<span class="number">4.12</span>, <span class="number">10.09</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span>[] sortedArray = bucketSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，所有的桶都保存在 ArrayList 集合中，每一个桶都被定义成一个链表（LinkedList<Double>），这样便于在尾部插入元素。</p><p>同时，上述代码使用了 JDK 的集合工具类 Collections.sort 来为桶内部的元素进行排序。Collections.sort 底层采用的是归并排序或 Timsort，各位读者可以简单地把它们当作一种时间复杂度为 O(n log n) 的排序。</p><p>假设原始数列有 n 个元素，分成 n 个桶。</p><p>下面逐步来分析一下算法复杂度。</p><p>第 1 步，求数列最大、最小值，运算量为 n。</p><p>第 2 步，创建空桶，运算量为 n。</p><p>第 3 步，把原始数列的元素分配到各个桶中，运算量为 n。</p><p>第 4 步，在每个桶内部做排序，在元素分布相对均匀的情况下，所有桶的运算量之和为 n。</p><p>第 5 步，输出排序数列，运算量为 n。</p><p>因此，桶排序的总体时间复杂度为 O(n)。</p><p>至于空间复杂度就很容易得到了，同样是 O(n)。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/18abb46becb47a9169e4281e3675ac92a39a9faab5e2ccf50f4b649d2e3cd406-image.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法概述-空间复杂度&quot;&gt;&lt;a href=&quot;#算法概述-空间复杂度&quot; class=&quot;headerlink&quot; title=&quot;算法概述 - 空间复杂度&quot;&gt;&lt;/a&gt;算法概述 - 空间复杂度&lt;/h1&gt;&lt;p&gt;常见的空间复杂度有下面几种情形。&lt;/p&gt;
&lt;h3 id=&quot;1-常量空</summary>
      
    
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://tsuiwade.github.io/2021/07/26/blog23-hashtable/"/>
    <id>https://tsuiwade.github.io/2021/07/26/blog23-hashtable/</id>
    <published>2021-07-26T16:11:25.000Z</published>
    <updated>2021-07-26T16:11:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>哈希表</code>是一种使用<code>哈希函数</code>组织数据，以支持快速插入和搜索的数据结构。</p><p>有两种不同类型的哈希表：哈希集合和哈希映射。</p><ul><li>哈希集合是集合数据结构的实现之一，用于存储非重复值。</li><li>哈希映射是映射 数据结构的实现之一，用于存储(key, value)键值对。</li></ul><p>在标准模板库的帮助下，哈希表是易于使用的。大多数常见语言（如Java，C ++ 和 Python）都支持哈希集合和哈希映射。</p><p>通过选择合适的哈希函数，哈希表可以在插入和搜索方面实现出色的性能。</p><p>在本 LeetBook 中，我们将回答以下问题：</p><p>哈希表的 <code>原理</code> 是什么？<br>如何 <code>设计</code> 哈希表？<br>如何使用 <code>哈希集</code> 来解决与重复相关的问题？<br>如何使用 <code>哈希映射</code> 按键聚合信息？<br>如何在使用哈希表时 <code>设计正确的键</code> ？</p><hr><h1 id="哈希表的原理"><a href="#哈希表的原理" class="headerlink" title="哈希表的原理"></a>哈希表的原理</h1><p>正如我们在介绍中提到的，<code>哈希表</code>是一种数据结构，它使用哈希函数组织数据，以支持<code>快速插入和搜索</code>。在本文中，我们将简要说明哈希表的原理。</p><p>哈希表的原理<br>哈希表的关键思想是使用哈希函数<code>将键映射到存储桶</code>。更确切地说，</p><ol><li>当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；</li><li>当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</li></ol><p>示例</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210726161917608.png" alt="image-20210726161917608"></p><p>在示例中，我们使用 <code>y = x ％ 5</code> 作为哈希函数。让我们使用这个例子来完成插入和搜索策略：</p><ol><li><p>插入：我们通过哈希函数解析键，将它们映射到相应的桶中。</p><ul><li>例如，1987 分配给桶 2，而 24 分配给桶 4。</li></ul></li><li><p>搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索。</p><ul><li><p>如果我们搜索 1987，我们将使用相同的哈希函数将1987 映射到 2。因此我们在桶 2 中搜索，我们在那个桶中成功找到了 1987。</p></li><li><p>例如，如果我们搜索 23，将映射 23 到 3，并在桶 3 中搜索。我们发现 23 不在桶 3 中，这意味着 23 不在哈希表中。</p></li></ul></li></ol><hr><h1 id="设计哈希表的关键"><a href="#设计哈希表的关键" class="headerlink" title="设计哈希表的关键"></a>设计哈希表的关键</h1><p>在设计哈希表时，你应该注意两个基本因素。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。在上一篇文章中的示例中，我们使用 y = x % 5 作为散列函数，其中 x 是键值，y 是分配的桶的索引。</p><p>散列函数将取决于<code>键值的范围</code>和桶的数量。</p><p>下面是一些哈希函数的示例：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/screen-shot-2018-05-04-at-145454.png" alt="img"></p><p>哈希函数的设计是一个开放的问题。其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射。然而，在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>理想情况下，如果我们的哈希函数是完美的一对一映射，我们将不需要处理冲突。不幸的是，在大多数情况下，冲突几乎是不可避免的。例如，在我们之前的哈希函数（y  =  x ％ 5）中，1987 和 2 都分配给了桶 2，这是一个冲突。</p><p>冲突解决算法应该解决以下几个问题：</p><ol><li>如何组织在同一个桶中的值？</li><li>如果为同一个桶分配了太多的值，该怎么办？</li><li>如何在特定的桶中搜索目标值？</li></ol><p>根据我们的哈希函数，这些问题与<code>桶的容量</code>和可能映射到<code>同一个桶</code>的<code>键的数目</code>有关。</p><p>让我们假设存储最大键数的桶有 N 个键。</p><p>通常，如果 N 是常数且很小，我们可以简单地使用一个数组将键存储在同一个桶中。如果 N 是可变的或很大，我们可能需要使用高度平衡的二叉树来代替.。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>到目前为止，您应该能够实现基本的哈希表。我们为您提供了实现哈希集和哈希映射的练习。阅读需求，确定哈希函数并在需要时解决冲突。</p><p>如果你不熟悉哈希集或是哈希映射的概念，可以返回介绍部分找出答案。</p><p>插入和搜索是哈希表中的两个基本操作。</p><p>此外，还有基于这两个操作的操作。例如，当我们删除元素时，我们将首先搜索元素，然后在元素存在的情况下从相应位置移除元素。</p><hr><h1 id="设计哈希集合"><a href="#设计哈希集合" class="headerlink" title="设计哈希集合"></a>设计哈希集合</h1><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 <code>MyHashSet</code> 类：</p><p><code>void add(key)</code> 向哈希集合中插入值 key 。<br><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 key 。<br><code>void remove(key)</code> 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]</span><br><span class="line">[[], [1], [2], [1], [3], [2], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, true, false, null, true, null, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashSet myHashSet &#x3D; new MyHashSet();</span><br><span class="line">myHashSet.add(1);      &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(1); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.remove(2);   &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除）</span><br></pre></td></tr></table></figure><p><strong>模板：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>题解：</strong></p><p><strong>链地址法:</strong></p><p>设哈希表的大小为base，则可以设计一个简单的哈希函数：hash(x)=x mod base。</p><p>我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将base 取为一个质数。在这里，我们取 base=769。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730182641745.png" alt="image-20210730182641745"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T705.设计哈希集合</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n/b)。其中 n 为哈希表中的元素数量，b 为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为n/b 。</p><p>空间复杂度：O(n+b)。</p><p>如果总共有 M 个键，那么在使用哈希表时，可以很容易地达到 O(M) 的空间复杂度。</p><p>但是，你可能已经注意到哈希表的时间复杂度与设计有很强的关系。</p><p>我们中的大多数人可能已经在每个桶中使用数组来将值存储在同一个桶中，理想情况下，桶的大小足够小时，可以看作是一个常数。插入和搜索的时间复杂度都是 O(1)。</p><p>但在最坏的情况下，桶大小的最大值将为 N。插入时时间复杂度为 O(1)，搜索时为 O(N)。</p><h3 id="内置哈希表的原理"><a href="#内置哈希表的原理" class="headerlink" title="内置哈希表的原理"></a>内置哈希表的原理</h3><p>内置哈希表的典型设计是：</p><ol><li>键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有哈希码。此哈希码将用于映射函数以获取存储区索引。</li><li>每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。</li><li>如果在同一个桶中有太多的值，这些值将被保留在一个高度平衡的二叉树搜索树中。</li></ol><p>插入和搜索的平均时间复杂度仍为 O(1)。最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。这是在插入和搜索之间的一种权衡。</p><hr><h1 id="设计哈希映射"><a href="#设计哈希映射" class="headerlink" title="设计哈希映射"></a>设计哈希映射</h1><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 MyHashMap 类：</p><ul><li>MyHashMap() 用空映射初始化对象</li><li>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。</li><li>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。</li><li>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T706.设计哈希映射</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashMap(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n/b)。其中 n 为哈希表中的元素数量，b 为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为n/b 。</p><p>空间复杂度：O(n+b)。</p><hr><h1 id="实际应用-哈希集-用法"><a href="#实际应用-哈希集-用法" class="headerlink" title="实际应用 - 哈希集 - 用法"></a>实际应用 - 哈希集 - 用法</h1><p><code>哈希集</code>是集合的实现之一，它是一种存储<code>不重复值</code>的数据结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;                // 0. include the library</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. initialize a hash set</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hashset;   </span><br><span class="line">    <span class="comment">// 2. insert a new key</span></span><br><span class="line">    hashset.insert(<span class="number">3</span>);</span><br><span class="line">    hashset.insert(<span class="number">2</span>);</span><br><span class="line">    hashset.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. delete a key</span></span><br><span class="line">    hashset.erase(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 4. check if the key is in the hash set</span></span><br><span class="line">    <span class="keyword">if</span> (hashset.count(<span class="number">2</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Key 2 is not in the hash set.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. get the size of the hash set</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The size of hash set is: &quot;</span> &lt;&lt; hashset.size() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 6. iterate the hash set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = hashset.begin(); it != hashset.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;are in the hash set.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 7. clear the hash set</span></span><br><span class="line">    hashset.clear();</span><br><span class="line">    <span class="comment">// 8. check if the hash set is empty</span></span><br><span class="line">    <span class="keyword">if</span> (hashset.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hash set is empty now!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用哈希集查重"><a href="#使用哈希集查重" class="headerlink" title="使用哈希集查重"></a>使用哈希集查重</h1><p>我们知道，插入新值并检查值是否在哈希集中是简单有效的。</p><p>因此，通常，使用哈希集来检查该值是否已经出现过。</p><p>让我们来看一个例子：</p><p>给定一个整数数组，查找数组是否包含任何重复项。</p><p>这是一个典型的问题，可以通过哈希集来解决。</p><p>你可以简单地迭代每个值并将值插入集合中。 如果值已经在哈希集中，则存在重复。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Template for using hash set to find duplicates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;Type&gt;&amp; keys)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Replace Type with actual type of your key</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;Type&gt; hashset;</span><br><span class="line">    <span class="keyword">for</span> (Type key : keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.count(key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashset.insert(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="实践-存在重复元素"><a href="#实践-存在重复元素" class="headerlink" title="实践 - 存在重复元素"></a>实践 - 存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><h3 id="方法1：排序"><a href="#方法1：排序" class="headerlink" title="方法1：排序"></a>方法1：排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T217.存在重复元素</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(NlogN)，其中 N 为数组的长度。需要对数组进行排序。</p></li><li><p>空间复杂度：O(logN)，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。</p></li></ul><h3 id="方法2：哈希表"><a href="#方法2：哈希表" class="headerlink" title="方法2：哈希表"></a>方法2：哈希表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T217.存在重复元素</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(x) != s.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O<em>(</em>N<em>)，其中 N</em> 为数组的长度。</li><li>空间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 为数组的长度。</li></ul><hr><h1 id="实践-只存在一次的数字"><a href="#实践-只存在一次的数字" class="headerlink" title="实践 - 只存在一次的数字"></a>实践 - 只存在一次的数字</h1><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210726192751515.png" alt="image-20210726192751515"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210726192846604.png" alt="image-20210726192846604"></p><p>时间空间复杂度都为O(n)。</p><p>其他方法：可使用异或运算⊕。异或运算有以下三个性质。</p><p>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。<br>任何数和其自身做异或运算，结果是 0，即 a⊕a=0。<br>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210726192944479.png" alt="image-20210726192944479"></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210726193035715.png" alt="image-20210726193035715"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T136.只出现一次的数字</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="实践-两个数组的交集"><a href="#实践-两个数组的交集" class="headerlink" title="实践 - 两个数组的交集"></a>实践 - 两个数组的交集</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>计算两个数组的交集，直观的方法是遍历数组 nums1，对于其中的每个元素，遍历数组 nums2 判断该元素是否在数组 nums2 中，如果存在，则将该元素添加到返回值。假设数组 nums1 和 nums2 的长度分别是 m 和 n，则遍历数组 nums1 需要 O(m) 的时间，判断 nums1 中的每个元素是否在数组 nums2 中需要 O(n) 的时间，因此总时间复杂度是 O(mn)。</p><p>如果使用<code>哈希集合</code>存储元素，则可以在 O(1) 的时间内判断一个元素是否在集合中，从而降低时间复杂度。</p><p>首先使用两个集合分别存储两个数组中的元素，然后遍历较小的集合，判断其中的每个元素是否在另一个集合中，如果元素也在另一个集合中，则将该元素添加到返回值。该方法的时间复杂度可以降低到 O(m+n)。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T349.两个数组的交集</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; set1, set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums1) &#123;</span><br><span class="line">            set1.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums2) &#123;</span><br><span class="line">            set2.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getIntersection</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set1, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.size() &gt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.count(num)) &#123;</span><br><span class="line">                intersection.push_back(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n)的时间，遍历较小的集合并判断元素是否在另一个集合中需要 O(\min(m,n))O(min(m,n)) 的时间，因此总时间复杂度是 O(m+n)。</p><p>空间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于两个集合。</p><hr><h1 id="实践-快乐数"><a href="#实践-快乐数" class="headerlink" title="实践 - 快乐数"></a>实践 - 快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li><li>如果 可以变为  1，那么这个数就是快乐数。</li></ul><p>如果 n 是快乐数就返回 true ；不是，则返回 false 。</p><p><strong>方法一：用哈希集合检测循环</strong><br>我们可以先举几个例子。我们从 77 开始。则下一个数字是 49，然后下一个数字是 97。我们可以不断重复该的过程，直到我们得到 11。因为我们得到了 1，我们知道 7 是一个快乐数，函数应该返回 true。</p><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 11。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 11 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><div class="table-container"><table><thead><tr><th>Digits</th><th style="text-align:center">Largest</th><th style="text-align:right">Next</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">9</td><td style="text-align:right">81</td></tr><tr><td>2</td><td style="text-align:center">99</td><td style="text-align:right">162</td></tr><tr><td>3</td><td style="text-align:center">999</td><td style="text-align:right">243</td></tr><tr><td>4</td><td style="text-align:center">9999</td><td style="text-align:right">324</td></tr><tr><td>13</td><td style="text-align:center">9999999999999</td><td style="text-align:right">1053</td></tr></tbody></table></div><p>对于 33 位数的数字，它不可能大于 243243。这意味着它要么被困在 243243 以下的循环内，要么跌到 11。44 位或 44 位以上的数字在每一步都会丢失一位，直到降到 33 位为止。所以我们知道，最坏的情况下，算法可能会在 243243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 11。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p><p><strong>算法</strong></p><p>算法分为两部分，我们需要设计和编写代码。</p><ol><li>给一个数字 nn，它的下一个数字是什么？</li><li>按照一系列的数字来判断我们是否进入了一个循环。</li></ol><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p><ul><li>如果它不在哈希集合中，我们应该添加它。</li><li>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</li></ul><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1)的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p><strong>复杂度分析</strong></p><p>确定这个问题的时间复杂度对于一个「简单」级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 getNext(n) 函数的时间复杂度。</p><p><code>时间复杂度</code>：.O(243⋅3+logn+loglogn+logloglogn)… = O(logn)。</p><ul><li>查找给定数字的下一个值的成本为 O(logn)，因为我们正在处理数字中的每位数字，而数字中的位数由 logn 给定。</li><li>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</li><li>我们在上面确定，一旦一个数字低于 243243，它就不可能回到 243 以上。因此，我们就可以用 243 以下最长循环的长度来代替 243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</li><li>对于高于 243 的 n，我们需要考虑循环中每个数高于 243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(logn)+O(loglogn)+O(logloglogn)…。幸运的是，O(logn) 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于logn），所以我们可以忽略它们。</li></ul><p><code>空间复杂度</code>：O(logn)。与时间复杂度密切相关的是衡量我们放入哈希集合中的数字以及它们有多大的指标。对于足够大的 n，大部分空间将由 n 本身占用。我们可以很容易地优化到 O(243⋅3)=O(1)，方法是只保存集合中小于 243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T202.快乐数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = getSum(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.find(sum) != <span class="built_in">set</span>.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="哈希映射-用法"><a href="#哈希映射-用法" class="headerlink" title="哈希映射 - 用法"></a>哈希映射 - 用法</h1><p><code>哈希映射</code>是用于存储 <code>(key, value)</code> 键值对的一种实现。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;                // 0. include the library</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. initialize a hash map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="comment">// 2. insert a new (key, value) pair</span></span><br><span class="line">    hashmap.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    hashmap.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 3. insert a new (key, value) pair or update the value of existed key</span></span><br><span class="line">    hashmap[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    hashmap[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 4. get the value of a specific key</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value of key 1 is: &quot;</span> &lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 5. delete a key</span></span><br><span class="line">    hashmap.erase(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 6. check if a key is in the hash map</span></span><br><span class="line">    <span class="keyword">if</span> (hashmap.count(<span class="number">2</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Key 2 is not in the hash map.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. get the size of the hash map</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the size of hash map is: &quot;</span> &lt;&lt; hashmap.size() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 8. iterate the hash map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = hashmap.begin(); it != hashmap.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;are in the hash map.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 9. clear the hash map</span></span><br><span class="line">    hashmap.clear();</span><br><span class="line">    <span class="comment">// 10. check if the hash map is empty</span></span><br><span class="line">    <span class="keyword">if</span> (hashmap.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hash map is empty now!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="实践-两数之和"><a href="#实践-两数之和" class="headerlink" title="实践 - 两数之和"></a>实践 - 两数之和</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T1.两数之和</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p><p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p><hr><h1 id="实践-同构字符串"><a href="#实践-同构字符串" class="headerlink" title="实践 - 同构字符串"></a>实践 - 同构字符串</h1><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T205.同构字符串</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; s2t;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; t2s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s[i], y = t[i];</span><br><span class="line">            <span class="keyword">if</span> ((s2t.count(x) &amp;&amp; s2t[x] != y) || (t2s.count(y) &amp;&amp; t2s[y] != x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2t[x] = y;</span><br><span class="line">            t2s[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：O(n)，其中 n 为字符串的长度。我们只需同时遍历一遍字符串 s 和 t 即可。<br>空间复杂度：O(∣Σ∣)，其中 Σ 是字符串的字符集。哈希表存储字符的空间取决于字符串的字符集大小，最坏情况下每个字符均不相同，需要 O(∣Σ∣) 的空间。</p><hr><h1 id="实践-两个列表的最小索引总和"><a href="#实践-两个列表的最小索引总和" class="headerlink" title="实践 - 两个列表的最小索引总和"></a>实践 - 两个列表的最小索引总和</h1><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p><p>示例 1:</p><p>输入:<br>[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]<br>[“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]<br>输出: [“Shogun”]<br>解释: 他们唯一共同喜爱的餐厅是“Shogun”。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T599.两个列表的最小索引总和</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRestaurant</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; str1ind;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            str1ind[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; sum2strs;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1ind.find(list2[i]) != str1ind.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curSum = i + str1ind[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (curSum &lt;= minSum)</span><br><span class="line">                &#123;</span><br><span class="line">                    minSum = curSum;</span><br><span class="line">                    sum2strs[minSum].push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum2strs[minSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p><code>时间复杂度</code>：O(l1 ∗l2 ∗x)。list1 中的每个字符串都与 list2 中的字符串进行了比较。l_1  和 l_2  是 list1 和 list2 列表的长度，x 是字符串的平均长度。</p><p><code>空间复杂度</code>：O(l1 ∗l2 ∗x) 。最坏情况下，list1 和 list2 中所有字符串都相同，那么哈希表最大会变成 l1 ∗l2 ∗x，其中 x 是字符串的平均长度。</p><hr><h1 id="哈希表与滑动窗口"><a href="#哈希表与滑动窗口" class="headerlink" title="哈希表与滑动窗口"></a>哈希表与滑动窗口</h1><p><strong>什么是滑动窗口</strong></p><p>顾名思义，滑动窗口就是将数组或字符串中的一个分段，形象地看作一个“窗口”，通过更改“窗口”的左右边界，实现窗口的移动、缩放等操作。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730183724897.png" alt="image-20210730183724897"></p><p>如图所示，窗口的左右边界使用 i, j 实现，当两个指针同时向右移动，则为窗口的“滑动”操作；而当其中一个指针不动，另一个指针向右移动时，窗口会扩大或缩小。</p><p>需要注意的是，一般情况下，在实际题目中指针只会沿 一个方向 移动。</p><p>对于基本情况，滑动窗口使用双指针即可实现，但是有时会出现一些问题，假如如窗口中的元素为 “(aaaaaabc)”，左右边界指针分别为 i 和 j，如果我们想要将窗口变为 “(abc)”，可以选择将左边界指针 i 向右移动 5 步。</p><p>以上情况会造成时间的浪费，假如建立元素 a 为键，下标为值的哈希表 {“a”:5}，那么元素 a 只需 1 步即可“跳跃”到下标 5 的位置。</p><p>优化运行时间，是滑动窗口问题中使用哈希表的一个目的。除此之外，哈希表还被用来统计窗口中的元素个数，以判断当前窗口的状态是否满足条件。以下是滑动窗口类题目的总结：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730183821382.png" alt="image-20210730183821382"></p><h3 id="例题1：存在重复元素-II（T219）"><a href="#例题1：存在重复元素-II（T219）" class="headerlink" title="例题1：存在重复元素 II（T219）"></a>例题1：存在重复元素 II（T219）</h3><h3 id="例题2：替换后的最长重复字符（T424）"><a href="#例题2：替换后的最长重复字符（T424）" class="headerlink" title="例题2：替换后的最长重复字符（T424）"></a>例题2：替换后的最长重复字符（T424）</h3><h3 id="例题3：最大连续-1-的个数-III（T1004）"><a href="#例题3：最大连续-1-的个数-III（T1004）" class="headerlink" title="例题3：最大连续 1 的个数 III（T1004）"></a>例题3：最大连续 1 的个数 III（T1004）</h3><h3 id="例题4：至多包含两个不同字符的最长子串（T159）"><a href="#例题4：至多包含两个不同字符的最长子串（T159）" class="headerlink" title="例题4：至多包含两个不同字符的最长子串（T159）"></a>例题4：至多包含两个不同字符的最长子串（T159）</h3><hr><h1 id="设计键"><a href="#设计键" class="headerlink" title="设计键"></a>设计键</h1><p>在前面的问题中，我们主要考虑了根据值的不同形式构造哈希表，而键的设计相对简单。然而在某些题目中，我们可能已经想到了哈希表的解法，但受限于 无法设计出合适的键，本章将对键的设计做出总结。</p><p>示例<br>我们来看一个例子：</p><p>给定一组字符串，将字母异位词组合在一起。</p><p>字母异位词指字母相同，但排列不同的字符串，比如 “ate” 与 “eat” 是一组字母异位词。如果单纯地把每个字符串作为键，显然没有起到任何作用。</p><p>解决方案<br>经过分析发现，同一组字母异位词中，如果按照字典序排列，得到的字符串相同，且长度相等。这时我们自然想到以 按照字典序排列后的字符串 作为键，这样就能合理区分出字母异位词了。例如对于 “ate” 和 “eat” 构造的哈希表为 {“aet”:[“ate”, “eat”]}。</p><p>设计键的策略可能是非常 棘手的，接下来我们将提供一些习题，并对键的设计技巧做出总结。</p><h3 id="例题1：字母异位词分组（T49）"><a href="#例题1：字母异位词分组（T49）" class="headerlink" title="例题1：字母异位词分组（T49）"></a>例题1：字母异位词分组（T49）</h3><h3 id="例题2：移位字符串分组（T249）"><a href="#例题2：移位字符串分组（T249）" class="headerlink" title="例题2：移位字符串分组（T249）"></a>例题2：移位字符串分组（T249）</h3><h3 id="例题3：有效的数独（T36）"><a href="#例题3：有效的数独（T36）" class="headerlink" title="例题3：有效的数独（T36）"></a>例题3：有效的数独（T36）</h3><h3 id="例题4：寻找重复的子树（T652）"><a href="#例题4：寻找重复的子树（T652）" class="headerlink" title="例题4：寻找重复的子树（T652）"></a>例题4：寻找重复的子树（T652）</h3><h3 id="例题5：稀疏矩阵的乘法（T311）"><a href="#例题5：稀疏矩阵的乘法（T311）" class="headerlink" title="例题5：稀疏矩阵的乘法（T311）"></a>例题5：稀疏矩阵的乘法（T311）</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是一些关于设计键的方法总结，我们鼓励你根据以下思路及做题经验，做出自己的总结。</p><ol><li><p>当字符串 / 数组中每个元素的顺序不重要时，可以使用 排序后的字符串 / 数组 作为键。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730185259148.png" alt="image-20210730185259148"></p></li><li><p>如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用偏移量作为键。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730185310947.png" alt="image-20210730185310947"></p></li><li><p>在树的题目中，可以直接使用 TreeNode 作为键。但在大多数情况下，可以将 子树的序列化结果 作为键。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730185331707.png" alt="image-20210730185331707"></p></li><li><p>在矩阵中，你可能会使用 行索引 或 列索引 作为键。</p></li><li><p>如果需要将矩阵分块，可以将行索引和列索引进行组合以标识该元素属于哪个 块。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730185353106.png" alt="image-20210730185353106"></p></li><li><p>有时，在矩阵中，你可能会希望将对角线的元素组合在一起。</p></li></ol><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730185402638.png" alt="image-20210730185402638"></p><hr><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210730185528833.png" alt="image-20210730185528833"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;哈希表&lt;/code&gt;是一种使用&lt;code&gt;哈希函数&lt;/code&gt;组织数据，以支持快速插入和搜索的数据结构。&lt;/p&gt;
&lt;p&gt;有两种</summary>
      
    
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="哈希表" scheme="https://tsuiwade.github.io/categories/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode刷题之路的一些记录</title>
    <link href="https://tsuiwade.github.io/2021/07/26/blog24-leetcode/"/>
    <id>https://tsuiwade.github.io/2021/07/26/blog24-leetcode/</id>
    <published>2021-07-26T14:35:47.000Z</published>
    <updated>2021-07-26T14:35:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-第-1-号问题：两数之和（暴力解、哈希表）"><a href="#LeetCode-第-1-号问题：两数之和（暴力解、哈希表）" class="headerlink" title="LeetCode 第 1 号问题：两数之和（暴力解、哈希表）"></a>LeetCode 第 1 号问题：两数之和（暴力解、哈希表）</h1><h2 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h2><ul><li><p>vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ STL的一个重要成员，使用它时需要包含头文件：</p><p><code>#include&lt;vector&gt;;</code></p></li><li><p>vector 的初始化：可以有五种方式,举例说明如下：</p><p>（1） vector<int> a(10); //定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。<br>（2）vector<int> a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1<br>（3）vector<int> a(b); //用b向量来创建a向量，整体复制性赋值<br>（4）vector<int> a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素<br>（5）int b[7]={1,2,3,4,5,9,8};<br>vector<int> a(b,b+7); //从数组中获得初值<br>（6）vector<int> vec1{ 1, 2, 3, 4, 5, 6 };             //vec1内容1,2,3,4,5,6</p></li></ul><h2 id="c-for循环"><a href="#c-for循环" class="headerlink" title="c++ for循环"></a>c++ for循环</h2><ul><li>可以在初始化部分中声明变量。如for (int i = 0; ;)</li></ul><h2 id="返回vector类型"><a href="#返回vector类型" class="headerlink" title="返回vector类型"></a>返回vector类型</h2><ul><li><p>可直接return {i,j}; 或 return {,};</p></li><li><p>capacity,如果不重新分配内存,当前已经分配的可以容纳的元素的个数.<br>max_size最大的可能的元素个数.<br>size是当前元素个数<br>sizeof是vector本身的大小（sizeof(vector<int>)）<br>int len=sizeof(arr)/size(arr[0])</p></li></ul><h2 id="引用作函数参数"><a href="#引用作函数参数" class="headerlink" title="引用作函数参数"></a>引用作函数参数</h2><ul><li>vector<int>&amp; nums 引用</li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p><p>最初的 C++ 标准库中没有类似 hash_map 的实现，但不同实现者自己提供了非标准的 hash_map。 因为这些实现不是遵循标准编写的，所以它们在功能和性能保证方面都有细微差别。从 C++ 11 开始，hash_map 实现已被添加到标准库中。但为了防止与已开发的代码存在冲突，决定使用替代名称 unordered_map。这个名字其实更具描述性，因为它暗示了该类元素的无序性。</p><p>C++ 11标准中加入了unordered系列的容器。unordered_map记录元素的hash值，根据hash值判断元素是否相同。map相当于java中的TreeMap，unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map；而空间复杂度方面，hash_map最低，unordered_map次之，map最大。</p><p><strong>unordered_map与map的对比：</strong></p><p>　　存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些。</p><p>　　总结：结构体用map重载&lt;运算符，结构体用unordered_map重载==运算符。</p><p><strong>unordered_map与hash_map对比：</strong></p><p>　　unordered_map原来属于boost分支和std::tr1中，而hash_map属于非标准容器。<br>　　unordered_map感觉速度和hash_map差不多，但是支持string做key，也可以使用复杂的对象作为key。<br>　　unordered_map编译时gxx需要添加编译选项：—std=c++11</p><p><strong>unordered_map模板：</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 template &lt; class Key,                                    &#x2F;&#x2F; unordered_map::key_type</span><br><span class="line">2            class T,                                      &#x2F;&#x2F; unordered_map::mapped_type</span><br><span class="line">3            class Hash &#x3D; hash&lt;Key&gt;,                       &#x2F;&#x2F; unordered_map::hasher</span><br><span class="line">4            class Pred &#x3D; equal_to&lt;Key&gt;,                   &#x2F;&#x2F; unordered_map::key_equal</span><br><span class="line">5            class Alloc &#x3D; allocator&lt; pair&lt;const Key,T&gt; &gt;  &#x2F;&#x2F; unordered_map::allocator_type</span><br><span class="line">6            &gt; class unordered_map;</span><br></pre></td></tr></table></figure><p> <strong>迭代器：</strong></p><p>unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 unordered_map&lt;Key,T&gt;::iterator it;</span><br><span class="line">2 (*it).first;             &#x2F;&#x2F; the key value (of type Key)</span><br><span class="line">3 (*it).second;            &#x2F;&#x2F; the mapped value (of type T)</span><br><span class="line">4 (*it);                   &#x2F;&#x2F; the &quot;element value&quot; (of type pair&lt;const Key,T&gt;) </span><br></pre></td></tr></table></figure><p>它的键值分别是迭代器的first和second属性。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 it-&gt;first;               &#x2F;&#x2F; same as (*it).first   (the key value)</span><br><span class="line">2 it-&gt;second;              &#x2F;&#x2F; same as (*it).second  (the mapped value) </span><br></pre></td></tr></table></figure><p><strong>成员函数：</strong></p><p>=================迭代器=========================<br>begin 　　返回指向容器起始位置的迭代器（iterator）<br>end 　　  返回指向容器末尾位置的迭代器<br>cbegin　  返回指向容器起始位置的常迭代器（const_iterator）<br>cend 　　 返回指向容器末尾位置的常迭代器<br>=================Capacity================<br>size  　 返回有效元素个数<br>max_size 返回 unordered_map 支持的最大元素个数<br>empty     判断是否为空<br>=================元素访问=================<br>operator[]  　  访问元素<br>at  　 　　　访问元素<br>=================元素修改=================<br>insert 　　插入元素<br>erase　　 删除元素<br>swap 　　 交换内容<br>clear　　  清空内容<br>emplace 　构造及插入一个元素<br>emplace_hint 按提示构造及插入一个元素<br>================操作=========================<br>find 　　　　　　通过给定主键查找元素,没找到：返回unordered_map::end<br>count 　　　　　返回匹配给定主键的元素的个数<br>equal_range 　　返回值匹配给定搜索值的元素组成的范围<br>================Buckets======================<br>bucket_count 　　　返回槽（Bucket）数<br>max_bucket_count  返回最大槽数<br>bucket_size 　　　  返回槽大小<br>bucket 　　　　　　返回元素所在槽的序号<br>load_factor　　　　 返回载入因子，即一个元素槽（Bucket）的最大元素数<br>max_load_factor 　 返回或设置最大载入因子<br>rehash　　　　　　 设置槽数<br>reserve 　　　　　 请求改变容器容量</p><p><a href="https://www.cnblogs.com/langyao/p/8823092.html">https://www.cnblogs.com/langyao/p/8823092.html</a></p><hr><p>LeetCode 第 15 号问题：三数之和（排序+双指针）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-第-1-号问题：两数之和（暴力解、哈希表）&quot;&gt;&lt;a href=&quot;#LeetCode-第-1-号问题：两数之和（暴力解、哈希表）&quot; class=&quot;headerlink&quot; title=&quot;LeetCode 第 1 号问题：两数之和（暴力解、哈希表）&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://tsuiwade.github.io/categories/leetcode/"/>
    
    <category term="cpp" scheme="https://tsuiwade.github.io/categories/leetcode/cpp/"/>
    
    
    <category term="leetcode" scheme="https://tsuiwade.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【第22篇博客】李航《统计学习方法·第一章》笔记、代码、习题</title>
    <link href="https://tsuiwade.github.io/2021/06/14/blog22-ML-Lihang-ch1/"/>
    <id>https://tsuiwade.github.io/2021/06/14/blog22-ML-Lihang-ch1/</id>
    <published>2021-06-14T20:44:11.000Z</published>
    <updated>2021-06-14T20:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CH01-统计学习及监督学习概论"><a href="#CH01-统计学习及监督学习概论" class="headerlink" title="CH01 统计学习及监督学习概论"></a>CH01 统计学习及监督学习概论</h1><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h3><ol><li>统计学习</li><li>统计学习的分类<ol><li>基本分类</li><li>按模型分类</li><li>按算法分类</li><li>按技巧分类</li></ol></li><li>统计学习三要素<ol><li>模型</li><li>策略</li><li>算法</li></ol></li><li>模型评估与模型选择<ol><li>训练误差与测试误差</li><li>过拟合与模型选择</li></ol></li><li>正则化与交叉验证<ol><li>正则化</li><li>交叉验证</li></ol></li><li>泛化能力<ol><li>泛化误差</li><li>泛化误差上界</li></ol></li><li>生成模型与判别模型</li><li>监督学习应用<ol><li>分类问题</li><li>标注问题</li><li>回归问题</li></ol></li></ol><h2 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h2><h4 id="实现统计学习方法的步骤"><a href="#实现统计学习方法的步骤" class="headerlink" title="实现统计学习方法的步骤"></a>实现统计学习方法的步骤</h4><p>统计学习方法三要素：模型，策略，算法</p><blockquote><ol><li>得到一个有限的训练数据集合</li><li>确定包含所有可能的模型的<strong>假设空间</strong>，即学习模型的集合</li><li>确定模型选择的准则，即学习的<strong>策略</strong></li><li>实现求解最优模型的算法，即学习的<strong>算法</strong></li><li>通过学习方法选择最优的模型</li><li>利用学习的最优模型对新数据进行预测或分析</li></ol></blockquote><h2 id="1-2-统计学习分类"><a href="#1-2-统计学习分类" class="headerlink" title="1.2 统计学习分类"></a>1.2 统计学习分类</h2><h3 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h3><p>这部分内容新增了无监督学习和强化学习。值得注意的一个点，之前因为只写了监督学习，样本表示(x, y)对，在无监督学习里面，样本就是x。</p><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><ul><li><p>监督学习指从标注数据中学习预测模型的机器学习问题，其本质是学习输入到输出的映射的统计规律。</p></li><li><p>输入变量<strong>X</strong>和输出变量<strong>Y</strong>有不同的类型，可以是连续或是离散的。根据输入输出变量的不同类型，对预测任务给予不同的名称：输入与输出均为连续变量的预测问题称为<strong>回归问题</strong>；输出变量为有限个离散变量的预测问题称为<strong>分类问题</strong>；输入与输出变量均为变量序列的预测问题称为<strong>标注问题</strong>。</p></li><li><p>条件概率分布 $\hat{P}(Y|X)$ 或决策函数 $Y=\hat{f}(X)$ 描述输入与输出随机变量之间的映射关系。</p><script type="math/tex; mode=display">\hat{f}</script></li></ul><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><ul><li>无监督学习模型，即函数 $z=\hat{g}(x)$, 条件概率分布 $\hat{P}(z|x)$ 或者条件概率分布 $\hat{P}(x|z)$ 可以实现对数据的聚类、降维或概率估计。在预测过程中，预测系统对于给定的输入 $x<em>{N+1}$ ，由模型 $z</em>{N+1}=\hat{g}(x<em>{N+1})$ 或 $z</em>{N+1}=\arg\max\limits<em>{z}\hat{P}(z|x</em>{N+1})$ 给出相应的输出 $z<em>{N+1}$ 进行聚类或降维，或者由模型 $\hat{P}(x|z)$ 给出输出的概率 $\hat{P}(x</em>{N+1}|z_{N+1})$ 进行概率估计。</li></ul><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><h3 id="按模型分类"><a href="#按模型分类" class="headerlink" title="按模型分类"></a>按模型分类</h3><ol><li><h4 id="概率模型与非概率模型（确定性模型）"><a href="#概率模型与非概率模型（确定性模型）" class="headerlink" title="概率模型与非概率模型（确定性模型）"></a>概率模型与非概率模型（确定性模型）</h4><ul><li>在监督学习中，概率模型 ${P}(y|x)$ 是生成模型，非概率模型 $y=f(x)$ 是判别模型。本书介绍的决策树、朴素贝叶斯、隐马尔科夫模型、条件随机场、概率潜在语义分析、潜在狄利克雷分配、高斯混合模型是概率模型。</li><li>在无监督学习中，概率模型取条件概率分布形式 ${P}(x|z)$ 或${P}(z|x)$ ，非概率模型取函数形式 $z=g(x)$ 。本书介绍的感知机、支持向量机、k近邻、AdaBoost、k均值、潜在语义分析、神经网络是非概率模型。Logistic回归两者都可算是。</li><li>条件概率分布和函数可以相互转化：条件概率分布最大化后得到函数，函数归一化得到条件概率分布。</li></ul></li><li><p>线性模型和非线性模型</p></li><li><p>参数化模型与非参数化模型</p></li></ol><h3 id="按算法分类"><a href="#按算法分类" class="headerlink" title="按算法分类"></a>按算法分类</h3><p>在线学习和批量学习，在线学习通常比批量学习更难。</p><h3 id="按技巧分类"><a href="#按技巧分类" class="headerlink" title="按技巧分类"></a>按技巧分类</h3><ul><li><p>贝叶斯学习</p></li><li><p>核方法（SVM、PCA、K-means）</p></li></ul><h2 id="1-3-统计学习方法三要素"><a href="#1-3-统计学习方法三要素" class="headerlink" title="1.3  统计学习方法三要素"></a>1.3  统计学习方法三要素</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a><u>模型</u></h3><h4 id="模型是什么"><a href="#模型是什么" class="headerlink" title="模型是什么?"></a>模型是什么?</h4><p>在监督学习过程中，模型就是所要学习的<strong>条件概率分布</strong>或者<strong>决策函数</strong>，模型的假设空间包含所有可能的条件概率分布或者决策函数。</p><p>注意书中的这部分描述，整理了一下到表格里：</p><div class="table-container"><table><thead><tr><th></th><th>假设空间$\cal F$</th><th>输入空间$\cal X$</th><th>输出空间$\cal Y$</th><th>参数空间</th></tr></thead><tbody><tr><td>决策函数</td><td>$\cal F\it ={f_{\theta}</td><td>Y=f_{\theta}(x), \theta \in \bf R \it ^n}$</td><td>变量</td><td>变量</td><td>$\bf R\it ^n$</td></tr><tr><td>条件概率分布</td><td>$\cal F\it ={P</td><td>P_{\theta}(Y</td><td>X),\theta\in \bf R \it ^n}$</td><td>随机变量</td><td>随机变量</td><td>$\bf R\it ^n$</td></tr></tbody></table></div><p>书中描述的时候，有提到<strong>条件概率分布族</strong>，这个留一下，后面<a href="../CH06/README.md">CH06</a>有提到确认逻辑斯谛分布属于指数分布族。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a><u>策略</u></h3><h4 id="损失函数与风险函数"><a href="#损失函数与风险函数" class="headerlink" title="损失函数与风险函数"></a>损失函数与风险函数</h4><blockquote><p><strong>损失函数</strong>度量模型<strong>一次预测</strong>的好坏，<strong>风险函数</strong>度量<strong>平均意义</strong>下模型预测的好坏。</p></blockquote><ol><li><p>损失函数(loss function)或代价函数(cost function)<br>损失函数定义为给定输入$X$的<strong>预测值$f(X)$</strong>和<strong>真实值$Y$</strong>之间的<strong>非负实值</strong>函数，记作<strong>$L(Y,f(X))$</strong></p></li><li><p>风险函数(risk function)或期望损失(expected loss)<br>这个和模型的泛化误差的形式是一样的<br>$R<em>{exp}(f)=E_p[L(Y, f(X))]=\int</em>{\mathcal X\times\mathcal Y}L(y,f(x))P(x,y)\, {\rm d}x{\rm d}y$<br>模型$f(X)$关于联合分布$P(X,Y)$的<strong>平均意义下的</strong>损失(<strong>期望</strong>损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是<strong>期望</strong>，以及<strong>平均意义下的</strong>。</p><p>这个表示其实就是损失的均值，反映了对整个数据的预测效果的好坏，P(x,y)$转换成$\frac {\nu(X=x, Y=y)}{N}$更容易直观理解, 可以参考<a href="../CH09/README.md">CH09</a>，6.2.2节的部分描述来理解，但是真实的数据N是无穷的。</p></li><li><p><strong>经验风险</strong>(empirical risk)或<strong>经验损失</strong>(empirical loss)<br>$R<em>{emp}(f)=\frac{1}{N}\sum^{N}</em>{i=1}L(y_i,f(x_i))$<br>模型$f$关于<strong>训练样本集</strong>的平均损失<br>根据大数定律，当样本容量N趋于无穷大时，经验风险趋于期望风险</p></li><li><p><strong>结构风险</strong>(structural risk)<br>$R<em>{srm}(f)=\frac{1}{N}\sum</em>{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$<br>$J(f)$为模型复杂度, $\lambda \geqslant 0$是系数，用以权衡经验风险和模型复杂度。</p></li></ol><h4 id="常用损失函数"><a href="#常用损失函数" class="headerlink" title="常用损失函数"></a>常用损失函数</h4><p>损失函数数值越小，模型就越好</p><ol><li>0-1损失<br>$L(Y,f(X))=\begin{cases}1, Y \neq f(X) \0, Y=f(X) \end{cases}$</li><li>平方损失<br>$L(Y,f(X))=(Y-f(X))^2$</li><li><p>绝对损失<br>$L(Y,f(X))=|Y-f(X)|$</p></li><li><p>对数损失<br>这里$P(Y|X)\leqslant 1$，对应的对数是负值，所以对数损失中包含一个负号，为什么不是绝对值？因为肯定是负的。<br>$L(Y,P(Y|X))=-\log P(Y|X)$</p></li></ol><h4 id="ERM与SRM"><a href="#ERM与SRM" class="headerlink" title="ERM与SRM"></a>ERM与SRM</h4><p>经验风险最小化(ERM)与结构风险最小化(SRM)</p><ol><li><strong>极大似然估计</strong>是<strong>经验风险最小化</strong>的一个例子<br>当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计</li><li><strong>贝叶斯估计</strong>中的<strong>最大后验概率估计</strong>是<strong>结构风险最小化</strong>的一个例子<br>当模型是条件概率分布，损失函数是对数损失函数，<strong>模型复杂度由模型的先验概率表示</strong>时，结构风险最小化等价于最大后验概率估计</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a><u>算法</u></h3><p>这章里面简单提了一下，具体可以参考<a href="../CH12/README.md">CH12</a>表格中关于学习算法的描述。</p><h2 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h2><p><strong>训练误差和测试误差</strong>是模型关于数据集的平均损失。</p><p>提到一句， <code>统计学习方法具体采用的损失函数未必是评估时使用的损失函数</code>，这句理解下。参考下在数据科学比赛中给出的评分标准，与实际学习采用的损失函数之间的关系。</p><h3 id="过拟合与模型选择"><a href="#过拟合与模型选择" class="headerlink" title="过拟合与模型选择"></a>过拟合与模型选择</h3><p>这部分讲到了最小二乘法，给了PRML中的一个例子。</p><p>这个问题中<strong>训练数据</strong>为$T={(x_1, y_1),(x_2,y_2),\cdots,(x_N,y_N)}$</p><p><strong>模型</strong>为</p><p>$f<em>M(x,w)=w_0+w_1x+w_2x^2+\cdots+w_Mx^M=\sum\limits</em>{j=0}^Mw_jx^j$</p><p>经验风险最小化策略下</p><p>$L(w)=\frac{1}{2}\sum\limits_{i=1}^N(f(x_i,w)-y_i)^2$</p><p>将模型和训练数据带入到上式得到</p><p>$L(w)=\frac{1}{2}\sum\limits<em>{i=1}^N\left(\sum\limits</em>{j=0}^Mw<em>jx_i^j-y_i\right)^2=\frac{1}{2}\sum\limits</em>{i=1}^N(w\cdot x_i-y_i)^2$</p><p>这个问题要求$w=(w_0^<em>,w_1^</em>,\cdots,w_M^*)$</p><p>对$w$求偏导令其为零，得到一系列方程，求解可以用梯度下降或者矩阵分解。</p><p>求解线性方程组$Ax=b$，可以表示为$x=A/b$，问题展开之后可以涉及到<strong>矩阵分解</strong>。</p><h3 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h3><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>模型选择的典型方法是正则化。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。可以假设复杂的模型有较小的先验概率，简单的模型有较大的先验概率。</p><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><p>另一种常用的模型选择方法是交叉验证</p><ul><li>简单</li><li>S折(K折, K-Fold)</li><li>留一法</li></ul><p>关于交叉验证，这里补充一点。</p><p>数据集的划分这个问题，书中有提到数据充足的情况下，将数据划分为三个部分，训练集，验证集和测试集。看到这里，不知道大家会不会有一样的问题：<strong>验证集和测试集有什么区别？</strong></p><p>注意这里，在算法学习的过程中，测试集可能是固定的，但是验证集和训练集可能是变化的。比如K折交叉验证的情况下，分成K折之后，其中的K-1折作为训练集，1折作为验证集，这样针对每一个模型操作K次，计算平均测试误差，最后选择平均测试误差最小的模型。这个过程中用来验证模型效果的那一折数据就是<strong>验证集</strong>。交叉<strong>验证</strong>，就是这样一个使用<strong>验证</strong>集测试模型好坏的过程。他允许我们在模型选择的过程中，使用一部分数据（验证集）“偷窥”一下模型的效果。</p><h2 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h2><ul><li><p>现实中采用最多的方法是通过测试误差来评价学习方法的泛化能力</p></li><li><p>统计学习理论试图从理论上对学习方法的泛化能力进行分析</p></li><li><p>学习方法的泛化能力往往是通过研究泛化误差的<strong>概率上界</strong>进行的, 简称为泛化误差上界(generalization error bound)</p><p>这本书里面讨论的不多，在<a href="../CH08/README.md">CH08</a>里面有讨论提升方法的误差分析, 提到$AdaBoost$不需要知道下界$\gamma$。在<a href="../CH02/README.md">CH02</a>中讨论算法的收敛性的时候有提到误分类次数的上界.</p></li></ul><p>注意泛化误差的定义，书中有说<strong>事实上，泛化误差就是所学习到的模型的期望风险</strong></p><h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><p><strong>监督学习方法</strong>可分为<strong>生成方法</strong>(generative approach)与<strong>判别方法</strong>(discriminative approach)</p><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>generative approach</p><ul><li>可以还原出<strong>联合概率分布</strong>$P(X,Y)$</li><li>收敛速度快, 当样本容量增加时, 学到的模型可以更快收敛到真实模型</li><li>当存在隐变量时仍可以用</li></ul><h3 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h3><p>discriminative approach</p><ul><li>直接学习<strong>条件概率</strong>$P(Y|X)$或者<strong>决策函数</strong>$f(X)$</li><li>直接面对预测, 往往学习准确率更高</li><li>可以对数据进行各种程度的抽象,  定义特征并使用特征, 可以简化学习问题</li></ul><h1 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h1><ul><li><p><strong>1.1</strong>   说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学方法三要素</p><ul><li><p>伯努利模型是定义在取值为0与1的随机变量上的概率分布。统计学分为两派：<strong>经典统计学派</strong>和<strong>贝叶斯统计学派</strong>。两者的不同主要是，<u>经典统计学派认为模型已定，参数未知，参数是固定的，只是还不知道</u>；<u>贝叶斯统计学派是通过观察到的现象对概率分布中的主观认定不断进行修正</u>。</p><ul><li><p><strong>极大似然估计</strong>用的是<u>经典统计学派的策略</u>，<strong>贝叶斯估计</strong>用的是<u>贝叶斯统计学派的策略</u>；为了得到使经验风险最小的参数值，使用的算法都是对经验风险求导，使导数为0。</p></li><li><p>定义随机变量$A$为一次伯努利试验的结果，$A$的取值为${0,1}$，概率分布为$P(A)$：</p><pre><code>                $P(A=1)=θ，P(A=0)=1-θ$</code></pre></li><li><p>极大似然估计<br>$L(θ)=\prod_{i=1}^nP(A_i)=θ^k(1-θ)^{n-k}$</p><script type="math/tex; mode=display">θ=\arg\max_{θ}L(θ)=\frac{k}{n}</script><p>上述估计通过取对数求导得到，$A_i$为第$i$次随机试验</p></li><li><p>贝叶斯估计<br>$P(θ|A_1,A_2,…，A_n)=\frac{P(A_1,A_2,…，A_n|θ)P(θ)}{P(A_1,A_2,…，A_n)}$</p></li></ul></li></ul></li></ul><pre><code>   根据观察到的结果修正$θ$，也就是假设$θ$是随机变量，$θ$服从β分布，有很多个可能的取值，我们要取的值是在已知观察结果的条件下使$θ$出现概率最大的值。上式分母是不变的，求分子最大就可以。   $\begin&#123;aligned&#125;  \theta   &amp;=arg\max \limits_\theta &#123;P(A_1,A_2,...,A_n|\theta)P(\theta)&#125; \\   &amp;= arg\max \limits_\theta &#123;\prod_&#123;i=1&#125;^&#123;n&#125;P(A_i|\theta)P(\theta)&#125;  \\  &amp;=arg \max \limits_\theta &#123;\theta^k(1-\theta)^&#123;n-k&#125;\theta^&#123;a-1&#125;(1-\theta)^&#123;b-1&#125;&#125; \\  &amp;=\frac&#123;k+(a-1)&#125;&#123;n+(a-1)+(b-1)&#125;  \end&#123;aligned&#125;$  β分布是一个作为伯努利分布和二项式分布的共轭先验分布的密度函数，是指一组定义在$(0,1)$区间的连续概率分布，有两个参数α，β&gt;0。选定参数后就可以确定$\theta$。* 统计学习方法的三要素为模型，策略，算法。</code></pre><p><img src="https://img-blog.csdnimg.cn/20190524102938764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YzQ0ODEzNDE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>1.2</strong> 通过经验风险最小化推导极大似然估计。证明模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。<ul><li>模型是条件概率分布：$P<em>θ(Y|X)$，<br>损失函数是对数损失函数：$L(Y,P</em>θ(Y|X))=−logP<em>θ(Y|X)$<br>经验风险为：$$ \begin{aligned}<br>R</em>{emp}(f)&amp;=\frac{1}{N}\sum<em>{i=1}^{N}L(y_i,f(x_i)) \<br>&amp;=\frac{1}{N}\sum</em>{i=1}^{N}-logP(y<em>i|x_i) \<br>&amp;=-\frac{1}{N}\sum</em>{i=1}^{N}logP(y_i|x_i)<br>\end{aligned}$$</li></ul></li></ul><ul><li><p>极大似然估计的似然函数为： </p><script type="math/tex; mode=display">L(\theta)=\prod_DP_{\theta}(Y|X)</script><ul><li>取对数<script type="math/tex; mode=display">log(L(\theta))=\sum_DlogP_{\theta}(Y|X)</script><script type="math/tex; mode=display">arg\max_\theta\sum_DlogP_{\theta}(Y|X)=arg\min_{\theta}\sum_D-logP_{\theta}(Y|X)</script></li></ul><ul><li>因此，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本博客记录如何将 树莓派作服务器端，使用nodejs 和 主机作客户端使用flutter 进行socket.io通信。在此过程中遇到了许多坑点，例如nodejs中的socket.io版本问题、运行环境使用chrome的web程序和windows的desktop程序等。</summary>
    
    
    
    <category term="ML" scheme="https://tsuiwade.github.io/categories/ML/"/>
    
    
    <category term="ML" scheme="https://tsuiwade.github.io/tags/ML/"/>
    
    <category term="统计学习" scheme="https://tsuiwade.github.io/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【第21篇博客】树莓派-服务器端-nodejs 和 主机-客户端-flutter 进行socket.io通信</title>
    <link href="https://tsuiwade.github.io/2021/06/02/blog21-RaspberryPi-SocketIo/"/>
    <id>https://tsuiwade.github.io/2021/06/02/blog21-RaspberryPi-SocketIo/</id>
    <published>2021-06-02T20:44:11.000Z</published>
    <updated>2021-06-02T20:44:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何创建一个nodejs项目"><a href="#如何创建一个nodejs项目" class="headerlink" title="如何创建一个nodejs项目"></a>如何创建一个nodejs项目</h2><p><a href="https://www.pianshen.com/article/27061493784/">https://www.pianshen.com/article/27061493784/</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令&#96;</span><br><span class="line">&#96;npm install -g express</span><br></pre></td></tr></table></figure><h2 id="树莓派上使用nodejs进行socket-io收发信息"><a href="#树莓派上使用nodejs进行socket-io收发信息" class="headerlink" title="树莓派上使用nodejs进行socket.io收发信息"></a>树莓派上使用nodejs进行socket.io收发信息</h2><p>服务器端socketServerTest.js文件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>)(<span class="number">3003</span>);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Connected&#x27;</span>)</span><br><span class="line">    <span class="comment">// either with send()</span></span><br><span class="line">    socket.send(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or with emit() and custom event names</span></span><br><span class="line">    socket.emit(<span class="string">&quot;greetings&quot;</span>, <span class="string">&quot;Hey!&quot;</span>, &#123; <span class="string">&quot;ms&quot;</span>: <span class="string">&quot;jane&quot;</span> &#125;, Buffer.from([<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle the event sent with socket.send()</span></span><br><span class="line">    socket.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle the event sent with socket.emit()</span></span><br><span class="line">    socket.on(<span class="string">&quot;salutations&quot;</span>, <span class="function">(<span class="params">elem1, elem2, elem3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(elem1, elem2, elem3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端socketClientTest.js文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&quot;socket.io-client&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> io(<span class="string">&quot;http://10.0.1.83:3003&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&quot;connect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// either with send()</span></span><br><span class="line">    socket.send(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or with emit() and custom event names</span></span><br><span class="line">    socket.emit(<span class="string">&quot;salutations&quot;</span>, <span class="string">&quot;Hello!&quot;</span>, &#123; <span class="string">&quot;mr&quot;</span>: <span class="string">&quot;john&quot;</span> &#125;, <span class="built_in">Uint8Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hhhhh&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the event sent with socket.send()</span></span><br><span class="line">socket.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the event sent with socket.emit()</span></span><br><span class="line">socket.on(<span class="string">&quot;greetings&quot;</span>, <span class="function">(<span class="params">elem1, elem2, elem3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem1, elem2, elem3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在可以使用flutter做客户端连接</p><h2 id="flutter做客户端使用socket-io"><a href="#flutter做客户端使用socket-io" class="headerlink" title="flutter做客户端使用socket.io"></a>flutter做客户端使用socket.io</h2><p><a href="https://pub.dev/packages/socket_io_client">https://pub.dev/packages/socket_io_client</a></p><p>该网页有几个简单的示例程序，如dart和flutter下的server端和client端。</p><h4 id="这里遇到了几个坑点："><a href="#这里遇到了几个坑点：" class="headerlink" title="这里遇到了几个坑点："></a>这里遇到了几个坑点：</h4><p>坑是说自己坑…，其实文档上都写了…，刚开始自己没注意。</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210602212038706.png" alt="image-20210602212038706"></p><p><strong><code>意思是对应于flutter下的版本v1的socket.io-client对应的Socket.io Sever的版本为v2，而npm package下的socket.io的版本已经到了v4了，一味追求最新版会导致客户端不能正常连上。</code></strong></p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210602212349943.png" alt="image-20210602212349943"></p><p>因此在树莓派下的nodejs服务器端，得使用较低版本的v2.4.1的socket.io package.</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210602212536110.png" alt="image-20210602212536110"></p><p>以上是第一个坑点，版本问题。</p><p>第二个问题是flutter客户端的程序。</p><p>以前用chrome的web程序运行没有问题，</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Socket socket = io(<span class="string">&#x27;http://10.0.1.83:3002&#x27;</span>);</span><br></pre></td></tr></table></figure><p>但在windows下的desktop程序运行连不上，文档中如此说道：</p><p><img src="https://gitee.com/tsuiwade/images/raw/master/image-20210602213002606.png" alt="image-20210602213002606"></p><p>需要改成</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Socket socket = io(</span><br><span class="line">     <span class="string">&#x27;http://10.0.1.83:3002&#x27;</span>,</span><br><span class="line">     OptionBuilder().setTransports([<span class="string">&#x27;websocket&#x27;</span>]) <span class="comment">// for Flutter or Dart VM</span></span><br><span class="line">         .build());</span><br></pre></td></tr></table></figure><p>就可以连接服务器端了</p><p>flutter客户端代码为：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherCard</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _WeatherCardState createState() =&gt; _WeatherCardState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_WeatherCardState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">WeatherCard</span>&gt; </span>&#123;</span><br><span class="line">  Socket socket = io(</span><br><span class="line">      <span class="string">&#x27;http://10.0.1.83:3002&#x27;</span>,</span><br><span class="line">      OptionBuilder().setTransports([<span class="string">&#x27;websocket&#x27;</span>]) <span class="comment">// for Flutter or Dart VM</span></span><br><span class="line">          .build());</span><br><span class="line">  <span class="keyword">void</span> closeDialogHandler(_, Socket socket, openDialogHandler) &#123;</span><br><span class="line">    Navigator.of(context).pop();</span><br><span class="line">    socket.off(<span class="string">&#x27;closeDialog&#x27;</span>);</span><br><span class="line">    socket.<span class="keyword">on</span>(</span><br><span class="line">        <span class="string">&#x27;openDialog&#x27;</span>, (_) =&gt; openDialogHandler(_, socket, closeDialogHandler));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> openDialogHandler(_, Socket socket, closeDialogHandler) &#123;</span><br><span class="line">    _showMyMaterialDialog();</span><br><span class="line">    socket.off(<span class="string">&#x27;openDialog&#x27;</span>);</span><br><span class="line">    socket.<span class="keyword">on</span>(</span><br><span class="line">        <span class="string">&#x27;closeDialog&#x27;</span>, (_) =&gt; closeDialogHandler(_, socket, openDialogHandler));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    loadJson();</span><br><span class="line"></span><br><span class="line">    socket.onConnect((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;socket.io connect&#x27;</span>);</span><br><span class="line">      <span class="comment">// socket.emit(&#x27;msg&#x27;, &#x27;test&#x27;); //客户端发</span></span><br><span class="line">    &#125;);</span><br><span class="line">    socket.onConnectError((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onConnectError&#x27;</span> + _);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.onConnectTimeout((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onConnectTimeout&#x27;</span> + _);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.onError((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onError&#x27;</span> + _);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.<span class="keyword">on</span>(</span><br><span class="line">        <span class="string">&#x27;openDialog&#x27;</span>, (_) =&gt; openDialogHandler(_, socket, closeDialogHandler));</span><br><span class="line">    socket.onDisconnect((_) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;disconnect&#x27;</span>));</span><br><span class="line">    socket.<span class="keyword">on</span>(<span class="string">&#x27;fromServer&#x27;</span>, (_) =&gt; <span class="built_in">print</span>(_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本博客记录如何将 树莓派作服务器端，使用nodejs 和 主机作客户端使用flutter 进行socket.io通信。在此过程中遇到了许多坑点，例如nodejs中的socket.io版本问题、运行环境使用chrome的web程序和windows的desktop程序等。</summary>
    
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/categories/raspberrypi/"/>
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/tags/raspberrypi/"/>
    
    <category term="NodeJs" scheme="https://tsuiwade.github.io/tags/NodeJs/"/>
    
    <category term="flutter" scheme="https://tsuiwade.github.io/tags/flutter/"/>
    
    <category term="socket.io" scheme="https://tsuiwade.github.io/tags/socket-io/"/>
    
  </entry>
  
  <entry>
    <title>【第20篇博客】使用NodeJs进行树莓派串口使用</title>
    <link href="https://tsuiwade.github.io/2021/06/01/blog20-RaspberryPi-SerialPort/"/>
    <id>https://tsuiwade.github.io/2021/06/01/blog20-RaspberryPi-SerialPort/</id>
    <published>2021-06-01T23:39:50.000Z</published>
    <updated>2021-06-01T23:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前搜到的大多数描述树莓派 4 串口的文章，大多数开头都是禁用下蓝牙，这个做法针对树莓派0-3 是必须的，因为本身串口不够用，但对树莓派 4 来说并不需要，因为有额外 4 个串口可以利用，默认配置好的两串口一个用于蓝牙（UART0）另一个是 miniUART 可以保留设置。此方面的文章大多都是一个流程，原因是参考的最初版本是树莓派 3 的设置；树莓派 4 的额外串口设置在树莓派论坛中可以看到相关的介绍，外面的文章不太多。除此之外，还有USB的4个口可以使用，也就是说，<strong>树莓派4将有10个串口可以使用。</strong></p><h2 id="树莓派正确识别CH340"><a href="#树莓派正确识别CH340" class="headerlink" title="树莓派正确识别CH340"></a>树莓派正确识别CH340</h2><p><a href="https://lightningleader.github.io/posts/4.html">https://lightningleader.github.io/posts/4.html</a></p><p>首先正常开启树莓派，不要插入CH340，然后进入树莓派桌面，打开命令行，输入命令lsusb，可以查看本机的USB设备列表，以及USB设备的详细信息。</p><p>然后插入CH340，再次运行lsusb命令，这个时候再看界面。可以明显看出多了一个设备，后面的设备详情也明确表示这个是CH340，这就表明树莓派正确识别到了插入的CH340。</p><p>接着在命令行输入命令 ls -l /dev/tty*</p><p>不出意外的话最后一个就是你插入的ch340，然后就记住这个黄色字体即/dev/ttyUSB0。这里的USB0也可能是USB1，这个是不确定的。</p><p>到了这里就代表你的树莓派可以正常识别CH34，下面就是写代码来验证效果了。</p><h2 id="树莓派4B如何使用串口与外部进行通信"><a href="#树莓派4B如何使用串口与外部进行通信" class="headerlink" title="树莓派4B如何使用串口与外部进行通信"></a>树莓派4B如何使用串口与外部进行通信</h2><p><a href="https://blog.csdn.net/weixin_42108484/article/details/104039992">https://blog.csdn.net/weixin_42108484/article/details/104039992</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">硬件串口 （PL011）</th><th style="text-align:center">mini串口</th></tr></thead><tbody><tr><td style="text-align:center">/dev/ttyAMA0</td><td style="text-align:center">/dev/ttyS0</td></tr><tr><td style="text-align:center">硬件串口有单独的波特率时钟源，性能好，稳定性强</td><td style="text-align:center">mini串口功能简单，稳定性较差，波特率由CPU内核时钟提供，受内核时钟影响</td></tr><tr><td style="text-align:center">分配给蓝牙模块使用的</td><td style="text-align:center">性能较差的mini串口是分配给GPIO串口 TXD0（GPIO14）、RXD0（GPIO15）</td></tr></tbody></table></div><p>相比树莓派零、1、2 以及 3 的双串口 UART0（PL011）和 UART1（mini UART），树莓派 4 中新增了 4 个 PL011 串口共计有 6 个 UART，整理此笔记用作记录和配置参考。</p><h2 id="树莓派-4-UART-多串口配置通信"><a href="#树莓派-4-UART-多串口配置通信" class="headerlink" title="树莓派 4 UART 多串口配置通信"></a>树莓派 4 UART 多串口配置通信</h2><p><a href="https://blog.csdn.net/weixin_40796925/article/details/107907991">https://blog.csdn.net/weixin_40796925/article/details/107907991</a></p><p>展示所有串口命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dtoverlay -a | grep uart</span><br><span class="line">pi@raspberrypi:~ $ dtoverlay -a | grep uart</span><br><span class="line">  midi-uart0</span><br><span class="line">  midi-uart1</span><br><span class="line">  miniuart-bt</span><br><span class="line">  uart0</span><br><span class="line">  uart1</span><br><span class="line">  uart2</span><br><span class="line">  uart3</span><br><span class="line">  uart4</span><br><span class="line">  uart5</span><br></pre></td></tr></table></figure><p>GPIO14 = TXD0 -&gt; ttyAMA0<br>GPIO0  = TXD2 -&gt; ttyAMA1<br>GPIO4  = TXD3 -&gt; ttyAMA2<br>GPIO8  = TXD4 -&gt; ttyAMA3<br>GPIO12 = TXD5 -&gt; ttyAMA4</p><p>GPIO15 = RXD0 -&gt; ttyAMA0<br>GPIO1  = RXD2 -&gt; ttyAMA1<br>GPIO5  = RXD3 -&gt; ttyAMA2<br>GPIO9  = RXD4 -&gt; ttyAMA3<br>GPIO13 = RXD5 -&gt; ttyAMA4</p><h2 id="NodeJs示例程序"><a href="#NodeJs示例程序" class="headerlink" title="NodeJs示例程序"></a>NodeJs示例程序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SerialPort = <span class="built_in">require</span>(<span class="string">&#x27;serialport&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> port = <span class="keyword">new</span> SerialPort(<span class="string">&#x27;/dev/ttyUSB0&#x27;</span>, &#123;</span><br><span class="line">    baudRate: <span class="number">9600</span>, <span class="comment">//波特率</span></span><br><span class="line">    dataBits: <span class="number">8</span>, <span class="comment">//数据位</span></span><br><span class="line">    parity: <span class="string">&#x27;none&#x27;</span>, <span class="comment">//奇偶校验</span></span><br><span class="line">    stopBits: <span class="number">1</span>, <span class="comment">//停止位</span></span><br><span class="line">    flowControl: <span class="literal">false</span></span><br><span class="line">&#125;, <span class="literal">false</span>); <span class="comment">// this is the openImmediately flag [default is true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指令监听</span></span><br><span class="line">port.on(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    port.write(<span class="string">&#x27;main screen turn on &#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Error on write: &#x27;</span>, err.message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;send success&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    port.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data received: &#x27;</span> + data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开错误将会发出一个错误事件</span></span><br><span class="line">port.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span>, err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的<code>/dev/ttyUSB0</code>还可以替换成<code>/dev/ttyAMA1</code>。</p>]]></content>
    
    
    <summary type="html">该博客记录树莓派做下位机时，使用Nodejs进行串口的收发实验。包括开启额外4个串口、使用USB串口。</summary>
    
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/categories/raspberrypi/"/>
    
    
    <category term="raspberrypi" scheme="https://tsuiwade.github.io/tags/raspberrypi/"/>
    
    <category term="NodeJs" scheme="https://tsuiwade.github.io/tags/NodeJs/"/>
    
    <category term="串口" scheme="https://tsuiwade.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>blog17-GithubActions</title>
    <link href="https://tsuiwade.github.io/2021/03/15/blog17-GithubActions/"/>
    <id>https://tsuiwade.github.io/2021/03/15/blog17-GithubActions/</id>
    <published>2021-03-15T16:11:50.000Z</published>
    <updated>2021-03-15T16:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>DevOps</p><p>CI/CD（持续集成、持续部署）</p><p>GitHub Actions 部署爬虫并定时发送邮件</p><p><a href="https://blog.csdn.net/a12355556/article/details/112099143">https://blog.csdn.net/a12355556/article/details/112099143</a></p><p>newsexpress—利用github_actions建立自动运行爬取学校官网通知并自动发送邮件的小玩意</p><p><a href="https://www.cnblogs.com/roccoshi/p/13144078.html">https://www.cnblogs.com/roccoshi/p/13144078.html</a></p><p>github:epc ustc</p>]]></content>
    
    
    <summary type="html">挖坑、爬虫、deploy.yml</summary>
    
    
    
    
  </entry>
  
</feed>
