<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TsuiWade&#39;s blog</title>
  
  
  <link href="https://tsuiwade.github.io/atom.xml" rel="self"/>
  
  <link href="https://tsuiwade.github.io/"/>
  <updated>2022-07-17T23:26:16.000Z</updated>
  <id>https://tsuiwade.github.io/</id>
  
  <author>
    <name>tsuiwade</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客网项目记录-第五章项目实战与总结</title>
    <link href="https://tsuiwade.github.io/2022/07/17/blog56-nowcoderProject5/"/>
    <id>https://tsuiwade.github.io/2022/07/17/blog56-nowcoderProject5/</id>
    <published>2022-07-17T23:26:16.000Z</published>
    <updated>2022-07-17T23:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-阻塞-非阻塞、同步-异步-网络IO"><a href="#1-阻塞-非阻塞、同步-异步-网络IO" class="headerlink" title="1.阻塞/非阻塞、同步/异步(网络IO)"></a>1.阻塞/非阻塞、同步/异步(网络IO)</h1><blockquote><p>阻塞/非阻塞、同步/异步(网络IO)  </p></blockquote><p>数据就绪：根据系统IO操作的就绪状态</p><ul><li><p>阻塞</p></li><li><p>非阻塞</p></li></ul><p>数据读写：根据应用程序和内核的交互方式</p><ul><li><p>同步</p></li><li><p>异步</p></li></ul><p>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717233456139.png" alt="image-20220717233456139"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717234840065.png" alt="image-20220717234840065"></p><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><p>同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。  </p><h1 id="5-2-Unix-Linux上的5种IO模型"><a href="#5-2-Unix-Linux上的5种IO模型" class="headerlink" title="5.2 Unix/Linux上的5种IO模型"></a>5.2 Unix/Linux上的5种IO模型</h1><h3 id="a-阻塞-blocking-（BIO"><a href="#a-阻塞-blocking-（BIO" class="headerlink" title="a.阻塞 blocking  （BIO)"></a>a.阻塞 blocking  （BIO)</h3><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717235855889.png" alt="image-20220717235855889"></p><h3 id="b-非阻塞-non-blocking（NIO）"><a href="#b-非阻塞-non-blocking（NIO）" class="headerlink" title="b.非阻塞 non-blocking（NIO）"></a>b.非阻塞 non-blocking（NIO）</h3><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718000028084.png" alt="image-20220718000028084"></p><h3 id="c-IO复用（IO-multiplexing）"><a href="#c-IO复用（IO-multiplexing）" class="headerlink" title="c.IO复用（IO multiplexing）"></a>c.IO复用（IO multiplexing）</h3><p>Linux 用 select/poll/epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数    据可读或可写时，才真正调用IO操作函数  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718000243045.png" alt="image-20220718000243045"></p><h3 id="d-信号驱动（signal-driven）"><a href="#d-信号驱动（signal-driven）" class="headerlink" title="d.信号驱动（signal-driven）"></a>d.信号驱动（signal-driven）</h3><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718000404751.png" alt="image-20220718000404751"></p><p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。  </p><h3 id="e-异步（asynchronous）"><a href="#e-异步（asynchronous）" class="headerlink" title="e.异步（asynchronous）"></a>e.异步（asynchronous）</h3><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718000534332.png" alt="image-20220718000534332"></p><h1 id="5-3-Web服务器简介及Http协议"><a href="#5-3-Web服务器简介及Http协议" class="headerlink" title="5.3 Web服务器简介及Http协议"></a>5.3 Web服务器简介及Http协议</h1><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718001127832.png" alt="image-20220718001127832"></p><p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。  </p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的CS的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p><p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering TaskForce，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。  </p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管 TCP/IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP/IP 协议族使用 TCP 作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。  </p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。  </p><p>以下是 HTTP 请求/响应的步骤：</p><ol><li><p>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，<a href="http://www.baidu.com。（URL）">http://www.baidu.com。（URL）</a></p></li><li><p>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个<strong>请求报文</strong>由<strong>请求行、请求头部、空行和请求数据 4 部分</strong>组成。</p></li><li><p>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个<strong>响应</strong>由<strong>状态行、响应头部、空行和响应数据 4 部分</strong>组成。</p></li><li><p>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应<br>头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据<br>HTML 的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><p>例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</li><li>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</li><li>释放 TCP 连接;</li><li>浏览器将该 HTML 文本并显示内容。</li></ol><p>HTTP 协议是基于 TCP/IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718095202692.png" alt="image-20220718095202692"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718095153165.png" alt="image-20220718095153165"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718095213622.png" alt="image-20220718095213622"></p><h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><p>HTTP/1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：  </p><ol><li>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</li><li>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li><li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li><li>PUT：向指定资源位置上传其最新内容。</li><li>DELETE：请求服务器删除 Request-URI 所标识的资源。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</li><li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的 HTTP 代理服务器）。  </li></ol><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误  </li></ul><p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718102726568.png" alt="image-20220718102726568"></p><hr><h1 id="5-4-服务器编程基本框架"><a href="#5-4-服务器编程基本框架" class="headerlink" title="5.4 服务器编程基本框架"></a>5.4 服务器编程基本框架</h1><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718103155738.png" alt="image-20220718103155738"></p><div class="table-container"><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>IO处理单元</td><td>处理客户连接，读写网络数据</td></tr><tr><td>逻辑单元</td><td>业务进程或线程</td></tr><tr><td>网络存储单元</td><td>数据库、文件或缓存</td></tr><tr><td>请求队列</td><td>各单元之间的通信方式</td></tr></tbody></table></div><p><strong>I/O 处理单元</strong>是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I/O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。</p><p>一个<strong>逻辑单元</strong>通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。</p><p>网络存储单元可以是数据库、缓存和文件，但不是必须的。</p><p><strong>请求队列</strong>是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。  </p><h3 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h3><p>服务器程序通常需要处理三类事件：<strong>I/O 事件、信号及定时事件</strong>。有两种高效的事件处理模式：Reactor和 Proactor，<strong>同步 I/O 模型</strong>通常用于实现 Reactor 模式，<strong>异步 I/O 模型</strong>通常用于实现 Proactor 模式。  </p><h4 id="Reactor模式-（反应堆）"><a href="#Reactor模式-（反应堆）" class="headerlink" title="Reactor模式  （反应堆）"></a>Reactor模式  （反应堆）</h4><p>要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步 I/O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll内核事件表中注册该 socket 上的写就绪事件。</li><li>当主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。  </li></ol><p>Reactor 模式的工作流程：  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718104011617.png" alt="image-20220718104011617"></p><h4 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h4><p>Proactor 模式将所有 I/O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。使用<strong>异步</strong> I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p><ol><li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><p>Proactor 模式的工作流程：  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718110332425.png" alt="image-20220718110332425"></p><h2 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h2><p>使用同步 I/O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步 I/O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><p>同步 I/O 模拟 Proactor 模式的工作流程：  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718110517234.png" alt="image-20220718110517234"></p><hr><h1 id="5-5线程池"><a href="#5-5线程池" class="headerlink" title="5.5线程池"></a>5.5线程池</h1><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式：  </p><ul><li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</li><li>主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。  </li></ul><p>线程池的一般模型为：  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220718110732722.png" alt="image-20220718110732722"></p><blockquote><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。  </p></blockquote><ul><li>空间换时间，浪费服务器的硬件资源，换取运行效率。</li><li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li><li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。</li><li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。  </li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// locker.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程同步机制封装类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    locker() &#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~locker() &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cond()&#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_cond_init(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~cond() &#123;</span><br><span class="line">        pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = pthread_cond_wait(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">timewait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex, struct timespec t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = pthread_cond_timedwait(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_signal(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_broadcast(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sem() &#123;</span><br><span class="line">        <span class="keyword">if</span>( sem_init( &amp;m_sem, <span class="number">0</span>, <span class="number">0</span> ) != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sem(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span>( sem_init( &amp;m_sem, <span class="number">0</span>, num ) != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~sem() &#123;</span><br><span class="line">        sem_destroy( &amp;m_sem );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sem_wait( &amp;m_sem ) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sem_post( &amp;m_sem ) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    threadpool(<span class="keyword">int</span> thread_number = <span class="number">8</span>, <span class="keyword">int</span> max_requests = <span class="number">10000</span>);</span><br><span class="line">    ~threadpool();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程的数量</span></span><br><span class="line">    <span class="keyword">int</span> m_thread_number;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述线程池的数组，大小为m_thread_number    </span></span><br><span class="line">    <span class="keyword">pthread_t</span> * m_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求队列中最多允许的、等待处理的请求的数量  </span></span><br><span class="line">    <span class="keyword">int</span> m_max_requests; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求队列</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt; T* &gt; m_workqueue;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line">    locker m_queuelocker;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有任务需要处理</span></span><br><span class="line">    sem m_queuestat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否结束线程          </span></span><br><span class="line">    <span class="keyword">bool</span> m_stop;                    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::threadpool(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests) : </span><br><span class="line">        m_thread_number(thread_number), m_max_requests(max_requests), </span><br><span class="line">        m_stop(<span class="literal">false</span>), m_threads(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建thread_number 个线程，并将他们设置为脱离线程。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( pthread_detach( m_threads[i] ) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~threadpool() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt; T &gt;::append( T* request )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 操作工作队列时一定要加锁，因为它被所有线程共享。</span></span><br><span class="line">    m_queuelocker.lock();</span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.size() &gt; m_max_requests ) &#123;</span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.push_back(request);</span><br><span class="line">    m_queuelocker.unlock();</span><br><span class="line">    m_queuestat.post();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">void</span>* threadpool&lt; T &gt;::worker( <span class="keyword">void</span>* arg )</span><br><span class="line">&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;run();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt; T &gt;::run() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.wait();</span><br><span class="line">        m_queuelocker.lock();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.empty() ) &#123;</span><br><span class="line">            m_queuelocker.unlock();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.front();</span><br><span class="line">        m_workqueue.pop_front();</span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line">        <span class="keyword">if</span> ( !request ) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FD 65536   <span class="comment">// 最大的文件描述符个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 10000  <span class="comment">// 监听的最大的事件数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">removefd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>( handler )(<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>( &amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>( sa ) );</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sigfillset( &amp;sa.sa_mask );</span><br><span class="line">    assert( sigaction( sig, &amp;sa, <span class="literal">NULL</span> ) != <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取端口号</span></span><br><span class="line">    <span class="keyword">int</span> port = atoi( argv[<span class="number">1</span>] );</span><br><span class="line">    <span class="comment">// 对SIGPIE信号进行处理</span></span><br><span class="line">    addsig( SIGPIPE, SIG_IGN );</span><br><span class="line"></span><br><span class="line">    threadpool&lt; http_conn &gt;* pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;;</span><br><span class="line">    &#125; <span class="keyword">catch</span>( ... ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    http_conn* users = <span class="keyword">new</span> http_conn[ MAX_FD ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>( reuse ) );</span><br><span class="line">    ret = bind( listenfd, ( struct sockaddr* )&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    ret = listen( listenfd, <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll对象，和事件数组，添加</span></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create( <span class="number">5</span> );</span><br><span class="line">    <span class="comment">// 添加到epoll对象中</span></span><br><span class="line">    addfd( epollfd, listenfd, <span class="literal">false</span> );</span><br><span class="line">    http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( ( number &lt; <span class="number">0</span> ) &amp;&amp; ( errno != EINTR ) ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++ ) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( sockfd == listenfd ) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>( client_address );</span><br><span class="line">                <span class="keyword">int</span> connfd = accept( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( http_conn::m_user_count &gt;= MAX_FD ) &#123;</span><br><span class="line">                    <span class="comment">// 目前 连接数满了， 给客户端写一个服务器正忙的信息</span></span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将新的客户的数据初始化，放到数组里</span></span><br><span class="line">                users[connfd].init( connfd, client_address);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events &amp; ( EPOLLRDHUP | EPOLLHUP | EPOLLERR ) ) &#123;</span><br><span class="line">                <span class="comment">// 对方异常断开</span></span><br><span class="line">                users[sockfd].close_conn();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">               <span class="comment">// 一次性把所有数据都读完</span></span><br><span class="line">                <span class="keyword">if</span>(users[sockfd].read()) &#123;</span><br><span class="line">                    pool-&gt;append(users + sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    users[sockfd].close_conn();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;  <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events &amp; EPOLLOUT ) &#123;</span><br><span class="line">                <span class="comment">// 一次性写完所有数据</span></span><br><span class="line">                <span class="keyword">if</span>( !users[sockfd].write() ) &#123;</span><br><span class="line">                    users[sockfd].close_conn();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( epollfd );</span><br><span class="line">    close( listenfd );</span><br><span class="line">    <span class="keyword">delete</span> [] users;</span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http_conn.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTPCONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http_conn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> FILENAME_LEN = <span class="number">200</span>;        <span class="comment">// 文件名的最大长度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;   <span class="comment">// 读缓冲区的大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;  <span class="comment">// 写缓冲区的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// HTTP请求方法，这里只支持GET</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">METHOD</span> &#123;</span>GET = <span class="number">0</span>, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        解析客户端请求时，主状态机的状态</span></span><br><span class="line"><span class="comment">        CHECK_STATE_REQUESTLINE:当前正在分析请求行</span></span><br><span class="line"><span class="comment">        CHECK_STATE_HEADER:当前正在分析头部字段</span></span><br><span class="line"><span class="comment">        CHECK_STATE_CONTENT:当前正在解析请求体</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        服务器处理HTTP请求的可能结果，报文解析的结果</span></span><br><span class="line"><span class="comment">        NO_REQUEST          :   请求不完整，需要继续读取客户数据</span></span><br><span class="line"><span class="comment">        GET_REQUEST         :   表示获得了一个完成的客户请求</span></span><br><span class="line"><span class="comment">        BAD_REQUEST         :   表示客户请求语法错误</span></span><br><span class="line"><span class="comment">        NO_RESOURCE         :   表示服务器没有资源</span></span><br><span class="line"><span class="comment">        FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限</span></span><br><span class="line"><span class="comment">        FILE_REQUEST        :   文件请求,获取文件成功</span></span><br><span class="line"><span class="comment">        INTERNAL_ERROR      :   表示服务器内部错误</span></span><br><span class="line"><span class="comment">        CLOSED_CONNECTION   :   表示客户端已经关闭连接了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从状态机的三种可能状态，即行的读取状态，分别表示</span></span><br><span class="line">    <span class="comment">// 1.读取到一个完整的行 2.行出错 3.行数据尚且不完整</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_OPEN &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    http_conn()&#123;&#125;</span><br><span class="line">    ~http_conn()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>; <span class="comment">// 初始化新接受的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">()</span></span>;  <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>; <span class="comment">// 处理客户端请求</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">// 非阻塞读</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">()</span></span>;<span class="comment">// 非阻塞写</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;    <span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">process_read</span><span class="params">()</span></span>;    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">process_write</span><span class="params">( HTTP_CODE ret )</span></span>;    <span class="comment">// 填充HTTP应答</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这一组函数被process_read调用以分析HTTP请求</span></span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">parse_request_line</span><span class="params">( <span class="keyword">char</span>* text )</span></span>;</span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">( <span class="keyword">char</span>* text )</span></span>;</span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">( <span class="keyword">char</span>* text )</span></span>;</span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">do_request</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_line</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_read_buf + m_start_line; &#125;</span><br><span class="line">    <span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一组函数被process_write调用以填充HTTP应答。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unmap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_response</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_content</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* content )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_content_type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_status_line</span><span class="params">( <span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span>* title )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_headers</span><span class="params">( <span class="keyword">int</span> content_length )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_content_length</span><span class="params">( <span class="keyword">int</span> content_length )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_linger</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_blank_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;       <span class="comment">// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_user_count;    <span class="comment">// 统计用户的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_sockfd;           <span class="comment">// 该HTTP连接的socket和对方的socket地址</span></span><br><span class="line">    sockaddr_in m_address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> m_read_buf[ READ_BUFFER_SIZE ];    <span class="comment">// 读缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> m_read_idx;                         <span class="comment">// 标识读缓冲区中已经读入的客户端数据的最后一个字节的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span> m_checked_idx;                      <span class="comment">// 当前正在分析的字符在读缓冲区中的位置</span></span><br><span class="line">    <span class="keyword">int</span> m_start_line;                       <span class="comment">// 当前正在解析的行的起始位置</span></span><br><span class="line"></span><br><span class="line">    CHECK_STATE m_check_state;              <span class="comment">// 主状态机当前所处的状态</span></span><br><span class="line">    METHOD m_method;                        <span class="comment">// 请求方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> m_real_file[ FILENAME_LEN ];       <span class="comment">// 客户请求的目标文件的完整路径，其内容等于 doc_root + m_url, doc_root是网站根目录</span></span><br><span class="line">    <span class="keyword">char</span>* m_url;                            <span class="comment">// 客户请求的目标文件的文件名</span></span><br><span class="line">    <span class="keyword">char</span>* m_version;                        <span class="comment">// HTTP协议版本号，我们仅支持HTTP1.1</span></span><br><span class="line">    <span class="keyword">char</span>* m_host;                           <span class="comment">// 主机名</span></span><br><span class="line">    <span class="keyword">int</span> m_content_length;                   <span class="comment">// HTTP请求的消息总长度</span></span><br><span class="line">    <span class="keyword">bool</span> m_linger;                          <span class="comment">// HTTP请求是否要求保持连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> m_write_buf[ WRITE_BUFFER_SIZE ];  <span class="comment">// 写缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> m_write_idx;                        <span class="comment">// 写缓冲区中待发送的字节数</span></span><br><span class="line">    <span class="keyword">char</span>* m_file_address;                   <span class="comment">// 客户请求的目标文件被mmap到内存中的起始位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">m_file_stat</span>;</span>                <span class="comment">// 目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获取文件大小等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">m_iv</span>[2];</span>                   <span class="comment">// 我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示被写内存块的数量。</span></span><br><span class="line">    <span class="keyword">int</span> m_iv_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytes_to_send;              <span class="comment">// 将要发送的数据的字节数</span></span><br><span class="line">    <span class="keyword">int</span> bytes_have_send;            <span class="comment">// 已经发送的字节数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http_conn.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HTTP响应的一些状态信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_403_form = <span class="string">&quot;You do not have permission to get file from this server.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_500_form = <span class="string">&quot;There was an unusual problem serving the requested file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站的根目录</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* doc_root = <span class="string">&quot;/home/nowcoder/webserver/resources&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向epoll中添加需要监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot )</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 防止同一个通信被不同的线程处理</span></span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="comment">// 设置文件描述符非阻塞</span></span><br><span class="line">    setnonblocking(fd);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从epoll中移除监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removefd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span> </span>&#123;</span><br><span class="line">    epoll_ctl( epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span> );</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> ev)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    epoll_ctl( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的客户数</span></span><br><span class="line"><span class="keyword">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的</span></span><br><span class="line"><span class="keyword">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_sockfd != <span class="number">-1</span>) &#123;</span><br><span class="line">        removefd(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--; <span class="comment">// 关闭一个连接，将客户总数量-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化连接,外部调用初始化套接字地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt( m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>( reuse ) );</span><br><span class="line">    addfd( m_epollfd, sockfd, <span class="literal">true</span> );</span><br><span class="line">    m_user_count++;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;    <span class="comment">// 初始状态为检查请求行</span></span><br><span class="line">    m_linger = <span class="literal">false</span>;       <span class="comment">// 默认不保持链接  Connection : keep-alive保持连接</span></span><br><span class="line"></span><br><span class="line">    m_method = GET;         <span class="comment">// 默认请求方式为GET</span></span><br><span class="line">    m_url = <span class="number">0</span>;              </span><br><span class="line">    m_version = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_checked_idx = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bzero(m_read_buf, READ_BUFFER_SIZE);</span><br><span class="line">    bzero(m_write_buf, READ_BUFFER_SIZE);</span><br><span class="line">    bzero(m_real_file, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取客户数据，直到无数据可读或者对方关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_read_idx &gt;= READ_BUFFER_SIZE ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 从m_read_buf + m_read_idx索引出开始保存数据，大小是READ_BUFFER_SIZE - m_read_idx</span></span><br><span class="line">        bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, </span><br><span class="line">        READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( errno == EAGAIN || errno == EWOULDBLOCK ) &#123;</span><br><span class="line">                <span class="comment">// 没有数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;   <span class="comment">// 对方关闭连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_read_idx += bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析一行，判断依据\r\n</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> ( ; m_checked_idx &lt; m_read_idx; ++m_checked_idx ) &#123;</span><br><span class="line">        temp = m_read_buf[ m_checked_idx ];</span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="string">&#x27;\r&#x27;</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ( m_checked_idx + <span class="number">1</span> ) == m_read_idx ) &#123;</span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( m_read_buf[ m_checked_idx + <span class="number">1</span> ] == <span class="string">&#x27;\n&#x27;</span> ) &#123;</span><br><span class="line">                m_read_buf[ m_checked_idx++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[ m_checked_idx++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( temp == <span class="string">&#x27;\n&#x27;</span> )  &#123;</span><br><span class="line">            <span class="keyword">if</span>( ( m_checked_idx &gt; <span class="number">1</span>) &amp;&amp; ( m_read_buf[ m_checked_idx - <span class="number">1</span> ] == <span class="string">&#x27;\r&#x27;</span> ) ) &#123;</span><br><span class="line">                m_read_buf[ m_checked_idx<span class="number">-1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[ m_checked_idx++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span>* text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GET /index.html HTTP/1.1</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>); <span class="comment">// 判断第二个参数中的字符哪个在text中最先出现</span></span><br><span class="line">    <span class="keyword">if</span> (! m_url) &#123; </span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GET\0/index.html HTTP/1.1</span></span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">// 置位空字符，字符串结束符</span></span><br><span class="line">    <span class="keyword">char</span>* method = text;</span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span> ) &#123; <span class="comment">// 忽略大小写比较</span></span><br><span class="line">        m_method = GET;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment">// 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>( m_url, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> (!m_version) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp( m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http://192.168.110.129:10000/index.html</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (strncasecmp(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span> ) &#123;   </span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line">        m_url = <span class="built_in">strchr</span>( m_url, <span class="string">&#x27;/&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    m_check_state = CHECK_STATE_HEADER; <span class="comment">// 检查状态变成检查头</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析HTTP请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span>* text)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 遇到空行，表示头部字段解析完毕</span></span><br><span class="line">    <span class="keyword">if</span>( text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="comment">// 如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，</span></span><br><span class="line">        <span class="comment">// 状态机转移到CHECK_STATE_CONTENT状态</span></span><br><span class="line">        <span class="keyword">if</span> ( m_content_length != <span class="number">0</span> ) &#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则说明我们已经得到了一个完整的HTTP请求</span></span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Connection 头部字段  Connection: keep-alive</span></span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        <span class="keyword">if</span> ( strcasecmp( text, <span class="string">&quot;keep-alive&quot;</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Content-Length头部字段</span></span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        m_content_length = atol(text);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Host头部字段</span></span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;oop! unknow header %s\n&quot;</span>, text );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">( <span class="keyword">char</span>* text )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( m_read_idx &gt;= ( m_content_length + m_checked_idx ) )</span><br><span class="line">    &#123;</span><br><span class="line">        text[ m_content_length ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主状态机，解析请求</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;</span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="keyword">char</span>* text = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))</span><br><span class="line">                || ((line_status = parse_line()) == LINE_OK)) &#123;</span><br><span class="line">        <span class="comment">// 获取一行数据</span></span><br><span class="line">        text = get_line();</span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got 1 http line: %s\n&quot;</span>, text );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ( m_check_state ) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123;</span><br><span class="line">                ret = parse_request_line( text );</span><br><span class="line">                <span class="keyword">if</span> ( ret == BAD_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_HEADER: &#123;</span><br><span class="line">                ret = parse_headers( text );</span><br><span class="line">                <span class="keyword">if</span> ( ret == BAD_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ret == GET_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> do_request();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_CONTENT: &#123;</span><br><span class="line">                ret = parse_content( text );</span><br><span class="line">                <span class="keyword">if</span> ( ret == GET_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> do_request();</span><br><span class="line">                &#125;</span><br><span class="line">                line_status = LINE_OPEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，</span></span><br><span class="line"><span class="comment">// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其</span></span><br><span class="line"><span class="comment">// 映射到内存地址m_file_address处，并告诉调用者获取文件成功</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;/home/nowcoder/webserver/resources&quot;</span></span><br><span class="line">    <span class="built_in">strcpy</span>( m_real_file, doc_root );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>( doc_root );</span><br><span class="line">    <span class="built_in">strncpy</span>( m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span> );</span><br><span class="line">    <span class="comment">// 获取m_real_file文件的相关的状态信息，-1失败，0成功</span></span><br><span class="line">    <span class="keyword">if</span> ( stat( m_real_file, &amp;m_file_stat ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断访问权限</span></span><br><span class="line">    <span class="keyword">if</span> ( ! ( m_file_stat.st_mode &amp; S_IROTH ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是目录</span></span><br><span class="line">    <span class="keyword">if</span> ( S_ISDIR( m_file_stat.st_mode ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读方式打开文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open( m_real_file, O_RDONLY );</span><br><span class="line">    <span class="comment">// 创建内存映射</span></span><br><span class="line">    m_file_address = ( <span class="keyword">char</span>* )mmap( <span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span> );</span><br><span class="line">    close( fd );</span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内存映射区执行munmap操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_file_address )</span><br><span class="line">    &#123;</span><br><span class="line">        munmap( m_file_address, m_file_stat.st_size );</span><br><span class="line">        m_file_address = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写HTTP响应</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( bytes_to_send == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 将要发送的字节为0，这一次响应结束。</span></span><br><span class="line">        modfd( m_epollfd, m_sockfd, EPOLLIN ); </span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 分散写</span></span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span> ( temp &lt;= <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="comment">// 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，</span></span><br><span class="line">            <span class="comment">// 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。</span></span><br><span class="line">            <span class="keyword">if</span>( errno == EAGAIN ) &#123;</span><br><span class="line">                modfd( m_epollfd, m_sockfd, EPOLLOUT );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有数据要发送了</span></span><br><span class="line">            unmap();</span><br><span class="line">            modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_linger)</span><br><span class="line">            &#123;</span><br><span class="line">                init();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往写缓冲中写入待发送的数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_response</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_write_idx &gt;= WRITE_BUFFER_SIZE ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_list arg_list;</span><br><span class="line">    va_start( arg_list, format );</span><br><span class="line">    <span class="keyword">int</span> len = vsnprintf( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list );</span><br><span class="line">    <span class="keyword">if</span>( len &gt;= ( WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_write_idx += len;</span><br><span class="line">    va_end( arg_list );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">( <span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span>* title )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">    add_content_length(content_len);</span><br><span class="line">    add_content_type();</span><br><span class="line">    add_linger();</span><br><span class="line">    add_blank_line();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, content_len );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;Connection: %s\r\n&quot;</span>, ( m_linger == <span class="literal">true</span> ) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* content )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s&quot;</span>, content );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERNAL_ERROR:</span><br><span class="line">            add_status_line( <span class="number">500</span>, error_500_title );</span><br><span class="line">            add_headers( <span class="built_in">strlen</span>( error_500_form ) );</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_500_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BAD_REQUEST:</span><br><span class="line">            add_status_line( <span class="number">400</span>, error_400_title );</span><br><span class="line">            add_headers( <span class="built_in">strlen</span>( error_400_form ) );</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_400_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NO_RESOURCE:</span><br><span class="line">            add_status_line( <span class="number">404</span>, error_404_title );</span><br><span class="line">            add_headers( <span class="built_in">strlen</span>( error_404_form ) );</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_404_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FORBIDDEN_REQUEST:</span><br><span class="line">            add_status_line( <span class="number">403</span>, error_403_title );</span><br><span class="line">            add_headers(<span class="built_in">strlen</span>( error_403_form));</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_403_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FILE_REQUEST:</span><br><span class="line">            add_status_line(<span class="number">200</span>, ok_200_title );</span><br><span class="line">            add_headers(m_file_stat.st_size);</span><br><span class="line">            m_iv[ <span class="number">0</span> ].iov_base = m_write_buf;</span><br><span class="line">            m_iv[ <span class="number">0</span> ].iov_len = m_write_idx;</span><br><span class="line">            m_iv[ <span class="number">1</span> ].iov_base = m_file_address;</span><br><span class="line">            m_iv[ <span class="number">1</span> ].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_iv[ <span class="number">0</span> ].iov_base = m_write_buf;</span><br><span class="line">    m_iv[ <span class="number">0</span> ].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = process_read();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        modfd( m_epollfd, m_sockfd, EPOLLIN );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="keyword">bool</span> write_ret = process_write( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) &#123;</span><br><span class="line">        close_conn();</span><br><span class="line">    &#125;</span><br><span class="line">    modfd( m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。</p><p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATE_MACHINE( Package _pack )</span><br><span class="line">&#123;</span><br><span class="line">    PackageType _type = _pack.GetType();</span><br><span class="line">    <span class="keyword">switch</span>( _type )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">        process_package_A( _pack );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">        process_package_B( _pack );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动，如下代码：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATE_MACHINE()</span><br><span class="line">&#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line">    <span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">    &#123;</span><br><span class="line">        Package _pack = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span>( cur_State )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_package_state_A( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_package_state_B( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。  </p><h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</p><p>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。  </p>]]></content>
    
    
    <summary type="html">Linux高并发服务器开发第五章</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>牛客网项目记录-第四章linux网络编程</title>
    <link href="https://tsuiwade.github.io/2022/07/16/blog55-nowcoderProject4/"/>
    <id>https://tsuiwade.github.io/2022/07/16/blog55-nowcoderProject4/</id>
    <published>2022-07-16T10:04:52.000Z</published>
    <updated>2022-07-16T10:04:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-状态转换"><a href="#TCP-状态转换" class="headerlink" title="TCP 状态转换"></a>TCP 状态转换</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716231619986.png" alt="image-20220716231619986"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716231822128.png" alt="image-20220716231822128"></p><p> <strong>2MSL（Maximum Segment Lifetime）</strong><br>主动断开连接的一方, 最后进入一个 TIME_WAIT状态, 这个状态会持续: 2msl<br>msl: 官方建议: 2分钟, 实际是30s<br>当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方必须处于TIME_WAIT 状态并持续 2MSL 时间。</p><p>这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。</p><p>主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。  </p><hr><h2 id="4-24-半关闭-端口复用"><a href="#4-24-半关闭-端口复用" class="headerlink" title="4.24 半关闭 端口复用"></a>4.24 半关闭 端口复用</h2><h3 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h3><p>当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 A 已经不能再向 B 发送数据。  </p><p>从程序的角度，可以使用 API <strong>shutdown</strong> 来控制实现半连接状态：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li><li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。  </li></ol><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>tcp_server.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//int optval = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> optval = <span class="number">1</span>;</span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accpet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client&#x27;s ip is %s, and port is %d\n&quot;</span>, cliIp, cliPort );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = recv(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小写转大写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            recvBuf[i] = <span class="built_in">toupper</span>(recvBuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大写字符串发给客户端</span></span><br><span class="line">        ret = send(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tcp_client.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行服务器端、运行客户端之后</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716235324113.png" alt="image-20220716235324113"></p><p>如果断开服务器，</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716235422484.png" alt="image-20220716235422484"></p><p>如果也断开客户端</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716235754918.png" alt="image-20220716235754918"></p><p>端口复用最常用的用途是:<br>1 防止服务器重启时之前绑定的端口还未释放<br>2 程序突然退出而系统没有释放 端口</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, socklen_toptlen)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    - sockfd : 要操作的文件描述符</span><br><span class="line">    - level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">    - optname : 选项的名称</span><br><span class="line">        - SO_REUSEADDR</span><br><span class="line">        - SO_REUSEPORT</span><br><span class="line">    - optval : 端口复用的值（整型）</span><br><span class="line">        - <span class="number">1</span> : 可以复用</span><br><span class="line">        - <span class="number">0</span> : 不可以复用</span><br><span class="line">    - optlen : optval参数的大小</span><br><span class="line">端口复用，设置的时机是在服务器绑定端口之前。</span><br><span class="line">setsockopt();</span><br><span class="line">bind();</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717001941962.png" alt="image-20220717001941962"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717002011322.png" alt="image-20220717002011322"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717002209461.png" alt="image-20220717002209461"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717002221751.png" alt="image-20220717002221751"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717002449530.png" alt="image-20220717002449530"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717002508544.png" alt="image-20220717002508544"></p><h2 id="4-25-IO多路复用"><a href="#4-25-IO多路复用" class="headerlink" title="4.25 IO多路复用"></a>4.25 IO多路复用</h2><p><strong><em>I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，</em></strong>Linux 下实现 I/O 多路复用的 系统调用主要有 select、poll 和 epoll。  </p><p>文件和内存！！！的IO。</p><h2 id="4-26-select"><a href="#4-26-select" class="headerlink" title="4.26 select"></a>4.26 select</h2><blockquote><p>主旨思想：</p><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li><li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。<ol><li>这个函数是阻塞</li><li>函数对文件描述符的检测的操作是由内核完成的</li></ol></li><li>在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">    - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">    - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">    - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">    - 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">    - exceptfds : 检测发生异常的文件描述符的集合</span><br><span class="line">    - timeout : 设置的超时时间</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">            <span class="keyword">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">            <span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        - <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">        - tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">        - tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">- 返回值 :</span><br><span class="line">    - <span class="number">-1</span> : 失败</span><br><span class="line">    - &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="keyword">void</span> FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717091112284.png" alt="image-20220717091112284"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="keyword">int</span> ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717091222305.png" alt="image-20220717091222305"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717091231707.png" alt="image-20220717091231707"></p><h2 id="4-28、poll"><a href="#4-28、poll" class="headerlink" title="4.28、poll"></a>4.28、poll</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT; <span class="comment">// 检测可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">    - <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">    - timeout : 阻塞时长</span><br><span class="line">        <span class="number">0</span> : 不阻塞</span><br><span class="line">        <span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">        &gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">- 返回值：</span><br><span class="line">    <span class="number">-1</span> : 失败</span><br><span class="line">    &gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717001356597.png" alt="image-20220717001356597"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// poll.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>; <span class="comment">// </span></span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">// 检测读事件  </span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="keyword">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pull 解决select 的第三个和第四个缺点。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717100834306.png" alt="image-20220717100834306"></p><h2 id="4-29-epoll"><a href="#4-29-epoll" class="headerlink" title="4.29 epoll"></a>4.29 epoll</h2><p>没有用户态到内核态的切换，之前是线性数据结构，现在是红黑树数据结构。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717100946633.png" alt="image-20220717100946633"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">    size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">-1</span> : 失败</span><br><span class="line">        &gt; <span class="number">0</span> : 文件描述符，操作epoll实例的</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">    常见的Epoll检测事件events：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - op : 要进行什么操作</span><br><span class="line">            EPOLL_CTL_ADD: 添加</span><br><span class="line">            EPOLL_CTL_MOD: 修改</span><br><span class="line">            EPOLL_CTL_DEL: 删除</span><br><span class="line">        - fd : 要检测的文件描述符</span><br><span class="line">        - event : 检测文件描述符什么事情</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">timeout)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - events : 传出参数，保存了发送了变化的文件描述符的信息</span><br><span class="line">        - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">        - timeout : 阻塞时间</span><br><span class="line">            - <span class="number">0</span> : 不阻塞</span><br><span class="line">            - <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">            - &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">        - 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717104350319.png" alt="image-20220717104350319"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717104402343.png" alt="image-20220717104402343"></p><h2 id="4-31-epoll-的两种工作模式"><a href="#4-31-epoll-的两种工作模式" class="headerlink" title="4.31 epoll 的两种工作模式"></a>4.31 epoll 的两种工作模式</h2><ul><li><p>LT 模式 （水平触发）</p><blockquote><p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的</p></blockquote><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p><ul><li><p>a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</p></li><li><p>b.用户只读了一部分数据，epoll会通知</p></li><li><p>c.缓冲区的数据读完了，不通知  </p></li></ul></li><li><p>ET 模式（边沿触发）</p><blockquote><p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄（文件描述符）的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。  </p></blockquote><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p><ul><li><p>a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了</p></li><li><p>b.用户只读了一部分数据，epoll不通知</p></li><li><p>c.缓冲区的数据读完了，不通知  </p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">- EPOLLIN</span><br><span class="line">- EPOLLOUT</span><br><span class="line">- EPOLLERR</span><br><span class="line">- EPOLLET</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_lt.c LT 模式 （水平触发）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_et.c ET 模式（边沿触发）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="keyword">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag | O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-32-UDP通信"><a href="#4-32-UDP通信" class="headerlink" title="4.32 UDP通信"></a>4.32 UDP通信</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717112034101.png" alt="image-20220717112034101"></p><p>而tcp</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716155939527.png" alt="image-20220716155939527"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - sockfd : 通信的fd</span><br><span class="line">        - buf : 要发送的数据</span><br><span class="line">        - len : 发送数据的长度</span><br><span class="line">        - flags : <span class="number">0</span></span><br><span class="line">        - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">        - addrlen : 地址的内存大小</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - sockfd : 通信的fd</span><br><span class="line">        - buf : 接收数据的数组</span><br><span class="line">        - len : 数组的大小</span><br><span class="line">        - flags : <span class="number">0</span></span><br><span class="line">        - src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">        - addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, Port : %d\n&quot;</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , i am client %d \n&quot;</span>, num++);</span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现多个客户端。</p><h2 id="4-33-UDP广播"><a href="#4-33-UDP广播" class="headerlink" title="4.33 UDP广播"></a>4.33 UDP广播</h2><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内<strong>主机标志部分的二进制全部为1(255)。</strong><br>a.只能在局域网中使用。<br>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,<span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">    - sockfd : 文件描述符</span><br><span class="line">    - level : SOL_SOCKET</span><br><span class="line">    - optname : SO_BROADCAST</span><br><span class="line">    - optval : <span class="keyword">int</span>类型的值，为<span class="number">1</span>表示允许广播</span><br><span class="line">    - optlen : optval的大小</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bro_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置广播属性</span></span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.创建一个广播的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bro_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-33-组播（多播）"><a href="#4-33-组播（多播）" class="headerlink" title="4.33 组播（多播）"></a>4.33 组播（多播）</h2><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。<br>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717165626932.png" alt="image-20220717165626932"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,<span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">    <span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">    - level : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">    // 客户端加入到多播组：</span></span><br><span class="line"><span class="class">    - <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">    - optname : IP_ADD_MEMBERSHIP</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* IP multicast address of group. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址</span></span><br><span class="line">    <span class="comment">/* Local IP address of interface. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 初始化多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-35-本地套接字通信"><a href="#4-35-本地套接字通信" class="headerlink" title="4.35 本地套接字通信"></a>4.35 本地套接字通信</h2><blockquote><p>本地套接字的作用：本地的进程间通信<br>有关系的进程间的通信，父子进程<br>没有关系的进程间的通信<br>本地套接字实现流程和网络套接字类似，一般采用TCP的通信流程。  </p></blockquote><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220717171230447.png" alt="image-20220717171230447"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地套接字通信的流程 - tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="number">1.</span> 创建监听的套接字</span><br><span class="line"><span class="keyword">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 </span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 监听</span><br><span class="line">    listen(lfd, <span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span> 等待并接受连接请求</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">6.</span> 关闭连接</span><br><span class="line">close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的流程</span></span><br><span class="line"><span class="number">1.</span> 创建通信的套接字</span><br><span class="line"><span class="keyword">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的IP 端口</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 连接服务器</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">5.</span> 关闭连接</span><br><span class="line">    close();</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ipc_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);     </span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ipc_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(cfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux高并发服务器开发第四章</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>牛客网项目记录-第三章linux多线程开发</title>
    <link href="https://tsuiwade.github.io/2022/07/14/blog54-nowcoderProject3/"/>
    <id>https://tsuiwade.github.io/2022/07/14/blog54-nowcoderProject3/</id>
    <published>2022-07-14T15:53:03.000Z</published>
    <updated>2022-07-14T15:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714155743501.png" alt="image-20220714155743501"></p><p>火狐浏览器开启的线程。PID进程号 LWP线程号</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220722163714455.png" alt="image-20220722163714455"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714155957795.png" alt="image-20220714155957795"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714160152562.png" alt="image-20220714160152562"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714160305621.png" alt="image-20220714160305621"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714162300308.png" alt="image-20220714162300308"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span></span><br><span class="line"><span class="comment">    称之为子线程。</span></span><br><span class="line"><span class="comment">    程序中默认只有一个进程，fork()函数调用，2进行</span></span><br><span class="line"><span class="comment">    程序中默认只有一个线程，pthread_create()函数调用，2个线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, </span></span><br><span class="line"><span class="comment">    void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 功能：创建一个子线程</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span></span><br><span class="line"><span class="comment">            - attr : 设置线程的属性，一般使用默认值，NULL</span></span><br><span class="line"><span class="comment">            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">            - arg : 给第三个参数使用，传参</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功：0</span></span><br><span class="line"><span class="comment">            失败：返回错误号。这个错误号和之前errno不太一样。</span></span><br><span class="line"><span class="comment">            获取错误号的信息：  char * strerror(int errnum);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span> *)&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不是标准系统库 ，而是第三方</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715000852721.png" alt="image-20220715000852721"></p><p>因为主线程return 0 退出了，没执行子线程里的。只执行主线程。加了sleep就可以</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220722170427094.png" alt="image-20220722170427094"></p><hr><p>3.3 终止进程 pthread_exit   </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">        功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pthread_t pthread_self(void);</span></span><br><span class="line"><span class="comment">        功能：获取当前的线程的线程ID</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_equal(pthread_t t1, pthread_t t2);</span></span><br><span class="line"><span class="comment">        功能：比较两个线程ID是否相等</span></span><br><span class="line"><span class="comment">        不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的</span></span><br><span class="line"><span class="comment">        是使用结构体去实现的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// pthread_exit(NULL);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714234028445.png" alt="image-20220714234028445"></p><hr><h2 id="3-4-连接已终止的现场-pthread-join"><a href="#3-4-连接已终止的现场-pthread-join" class="headerlink" title="3.4 连接已终止的现场 pthread_join"></a>3.4 连接已终止的现场 pthread_join</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">        - 功能：和一个已经终止的线程进行连接</span></span><br><span class="line"><span class="comment">                回收子线程的资源</span></span><br><span class="line"><span class="comment">                这个函数是阻塞函数，调用一次只能回收一个子线程</span></span><br><span class="line"><span class="comment">                一般在主线程中使用</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - thread：需要回收的子线程的ID</span></span><br><span class="line"><span class="comment">            - retval: 接收子线程退出时的返回值</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            0 : 成功</span></span><br><span class="line"><span class="comment">            非0 : 失败，返回的错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 不能局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    <span class="comment">// return NULL; </span></span><br><span class="line">    <span class="comment">// int value = 10; // 局部变量</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)&amp;value);   <span class="comment">// return (void *)&amp;value;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join()回收子线程的资源</span></span><br><span class="line">    <span class="keyword">int</span> * thread_retval;</span><br><span class="line">    ret = pthread_join(tid, (<span class="keyword">void</span> **)&amp;thread_retval); <span class="comment">// 子线程不结束，join不执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data : %d\n&quot;</span>, *thread_retval);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程资源成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715093336175.png" alt="image-20220715093336175"></p><hr><h2 id="3-5-线程的分离-pthread-detach"><a href="#3-5-线程的分离-pthread-detach" class="headerlink" title="3.5 线程的分离 pthread_detach"></a>3.5 线程的分离 pthread_detach</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_detach(pthread_t thread);</span></span><br><span class="line"><span class="comment">        - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span></span><br><span class="line"><span class="comment">          1.不能多次分离，会产生不可预料的行为。</span></span><br><span class="line"><span class="comment">          2.不能去连接一个已经分离的线程，会报错。</span></span><br><span class="line"><span class="comment">        - 参数：需要分离的线程的ID</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功：0</span></span><br><span class="line"><span class="comment">            失败：返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分离后，对分离的子线程进行连接 pthread_join() 是错误的</span></span><br><span class="line">    <span class="comment">// ret = pthread_join(tid, NULL);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) &#123;</span></span><br><span class="line">    <span class="comment">//     char * errstr = strerror(ret);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;error3 : %s\n&quot;, errstr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715094417683.png" alt="image-20220715094417683"></p><p>试试设置分离后，对分离的子线程进行join</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715094516540.png" alt="image-20220715094516540"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715094635605.png" alt="image-20220715094635605"></p><hr><h2 id="3-6-线程取消-pthread-cancel"><a href="#3-6-线程取消-pthread-cancel" class="headerlink" title="3.6 线程取消 pthread_cancel"></a>3.6 线程取消 pthread_cancel</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_cancel(pthread_t thread);</span></span><br><span class="line"><span class="comment">        - 功能：取消线程（让线程终止）</span></span><br><span class="line"><span class="comment">            取消某个线程，可以终止某个线程的运行，</span></span><br><span class="line"><span class="comment">            但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</span></span><br><span class="line"><span class="comment">            取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i); <span class="comment">//这个是一个取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715095844927.png" alt="image-20220715095844927"></p><p>子线程并没有打印完5个，而是在printf时到达取消点，就终止。</p><hr><h2 id="3-7线程属性"><a href="#3-7线程属性" class="headerlink" title="3.7线程属性"></a>3.7线程属性</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715100202031.png" alt="image-20220715100202031"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715100922322.png" alt="image-20220715100922322"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int pthread_attr_init(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">        - 初始化线程属性变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_destroy(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">        - 释放线程属性的资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span></span><br><span class="line"><span class="comment">        - 获取线程分离的状态属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span></span><br><span class="line"><span class="comment">        - 设置线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span>     </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程属性变量</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">// 初始化属性变量</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程的栈的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread stack size : %ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放线程属性资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715101755534.png" alt="image-20220715101755534"></p><hr><h2 id="3-8-线程同步"><a href="#3-8-线程同步" class="headerlink" title="3.8 线程同步"></a>3.8 线程同步</h2><p>设计 有3个窗口 一共100个窗口。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用多线程实现买票的案例。</span></span><br><span class="line"><span class="comment">    有3个窗口，一共是100张票。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，所有的线程都共享这一份资源。</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">100</span>; <span class="comment">// 不能局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        usleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);</span><br><span class="line">        tickets--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程的资源,阻塞</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离。</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid1);</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid2);</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid3);</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 退出主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715102933418.png" alt="image-20220715102933418"></p><p> <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715103248904.png" alt="image-20220715103248904"></p><p>临界区指tickets</p><hr><h2 id="3-9-互斥锁、互斥量-mutex"><a href="#3-9-互斥锁、互斥量-mutex" class="headerlink" title="3.9 互斥锁、互斥量 mutex"></a>3.9 互斥锁、互斥量 mutex</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715103532431.png" alt="image-20220715103532431"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715114012298.png" alt="image-20220715114012298"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715114054656.png" alt="image-20220715114054656"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    互斥量的类型 pthread_mutex_t</span></span><br><span class="line"><span class="comment">    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">        - 初始化互斥量</span></span><br><span class="line"><span class="comment">        - 参数 ：</span></span><br><span class="line"><span class="comment">            - mutex ： 需要初始化的互斥量变量</span></span><br><span class="line"><span class="comment">            - attr ： 互斥量相关的属性，NULL</span></span><br><span class="line"><span class="comment">        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。</span></span><br><span class="line"><span class="comment">            pthread_mutex_t *restrict mutex = xxx;</span></span><br><span class="line"><span class="comment">            pthread_mutex_t * mutex1 = mutex; 不行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 释放互斥量的资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，所有的线程都共享这一份资源。</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程的资源,阻塞</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 退出主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有可能还是一个线程，如果票数增加就正确。</p><hr><h2 id="3-10-死锁"><a href="#3-10-死锁" class="headerlink" title="3.10 死锁"></a>3.10 死锁</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715142644522.png" alt="image-20220715142644522"></p><p>场景1：忘记释放锁，结果阻塞</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715144054097.png" alt="image-20220715144054097"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715144006208.png" alt="image-20220715144006208"></p><p>场景2：重复加相同锁</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715144247466.png" alt="image-20220715144247466"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715144309560.png" alt="image-20220715144309560"></p><p>场景3：多线程 多锁 抢占锁资源</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715144806566.png" alt="image-20220715144806566"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220722212536063.png" alt="image-20220722212536063"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715144553043.png" alt="image-20220715144553043"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715145044194.png" alt="image-20220715145044194"></p><hr><h2 id="3-11-读写锁"><a href="#3-11-读写锁" class="headerlink" title="3.11 读写锁"></a>3.11 读写锁</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715145139509.png" alt="image-20220715145139509"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715181242740.png" alt="image-20220715181242740"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    案例：8个线程操作同一个全局变量。</span></span><br><span class="line"><span class="comment">    3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个共享数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// pthread_mutex_t mutex;</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">writeNum</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">readNum</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个写线程，5个读线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">       pthread_detach(wtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         pthread_detach(rtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用锁之前效果</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715182857154.png" alt="image-20220715182857154"></p><p> 利用互斥锁试试，但是互斥锁，当有一个线程读的时候，其他线程不能读，效率太低。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715183025599.png" alt="image-20220715183025599"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715183039703.png" alt="image-20220715183039703"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715183110137.png" alt="image-20220715183110137"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715183154178.png" alt="image-20220715183154178"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715183338882.png" alt="image-20220715183338882"></p><p>结果虽然正确。读写锁才能保证其他线程也能读，且效率更高。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715191430731.png" alt="image-20220715191430731"></p><hr><h2 id="3-12-生产者消费者模型"><a href="#3-12-生产者消费者模型" class="headerlink" title="3.12 生产者消费者模型"></a>3.12 生产者消费者模型</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715194155420.png" alt="image-20220715194155420"></p><p>生产者 将东西 生产到容器中，消费者从容器中消费。当容器满了，生产者通知消费者取走东西，当容器为空，消费者通知生产者生产。</p><p>条件变量，信号量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者消费者模型（粗略的版本）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程, 容器是列表</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715220400658.png" alt="image-20220715220400658"></p><p>出现问题，互斥量来确保同步，还需要 条件变量或信号量来解决生产者和消费者 同步问题。</p><p><em>以上代码是粗略代码造成的结果</em></p><hr><h2 id="3-13-条件变量"><a href="#3-13-条件变量" class="headerlink" title="3.13 条件变量"></a>3.13 条件变量</h2><p>加上互斥锁之后结果：</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715221736873.png" alt="image-20220715221736873"></p><p>没问题，这么做但不好。需要生产者和消费者各自判断，最好需要通知方式。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715221857709.png" alt="image-20220715221857709"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    条件变量的类型 pthread_cond_t</span></span><br><span class="line"><span class="comment">    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">    int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</span></span><br><span class="line"><span class="comment">        - 等待，调用了该函数，线程会阻塞。</span></span><br><span class="line"><span class="comment">    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</span></span><br><span class="line"><span class="comment">        - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span></span><br><span class="line"><span class="comment">    int pthread_cond_signal(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="comment">    int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 唤醒所有的等待的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只要生产了一个，就通知消费者消费</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);<span class="comment">////</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据，需要等待</span></span><br><span class="line">            <span class="comment">// 当这个函数调用阻塞wait的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。从而生产者可以继续执行</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">////</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715233223049.png" alt="image-20220715233223049"></p><hr><h2 id="3-14-信号量-semaphore"><a href="#3-14-信号量-semaphore" class="headerlink" title="3.14 信号量 semaphore"></a>3.14 信号量 semaphore</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220715233434744.png" alt="image-20220715233434744"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    信号量的类型 sem_t</span></span><br><span class="line"><span class="comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);</span></span><br><span class="line"><span class="comment">        - 初始化信号量</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - sem : 信号量变量的地址</span></span><br><span class="line"><span class="comment">            - pshared : 0 用在线程间 ，非0 用在进程间</span></span><br><span class="line"><span class="comment">            - value : 信号量中的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_destroy(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 释放资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_wait(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_trywait(sem_t *sem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span></span><br><span class="line"><span class="comment">    int sem_post(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 对信号量解锁，调用一次对信号量的值+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_getvalue(sem_t *sem, int *sval);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    sem_t psem;</span></span><br><span class="line"><span class="comment">    sem_t csem;</span></span><br><span class="line"><span class="comment">    init(psem, 0, 8);</span></span><br><span class="line"><span class="comment">    init(csem, 0, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    producer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;psem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;csem)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    customer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;csem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;psem)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> psem;</span><br><span class="line"><span class="keyword">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716000312137.png" alt="image-20220716000312137"></p>]]></content>
    
    
    <summary type="html">Linux高并发服务器开发第三章</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>socket.io模块学习记录</title>
    <link href="https://tsuiwade.github.io/2022/07/10/blog53-socketio/"/>
    <id>https://tsuiwade.github.io/2022/07/10/blog53-socketio/</id>
    <published>2022-07-10T15:38:49.000Z</published>
    <updated>2022-07-10T15:38:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>Socket.IO 是一个库，可以在客户端和服务器之间实现<strong>低延迟</strong>、<strong>双向</strong>和<strong>基于事件的</strong>通信</p><p><strong>Socket.IO</strong> 是一个面向实时 <a href="https://zh.m.wikipedia.org/w/index.php?title=Web_应用&amp;action=edit&amp;redlink=1">web 应用</a>的 <a href="https://zh.m.wikipedia.org/wiki/JavaScript">JavaScript</a> 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在<a href="https://zh.m.wikipedia.org/wiki/浏览器">浏览器</a>中运行的<a href="https://zh.m.wikipedia.org/wiki/客户端">客户端</a>库，和一个面向<a href="https://zh.m.wikipedia.org/wiki/Node.js">Node.js</a>的服务端库。两者有着几乎一样的<a href="https://zh.m.wikipedia.org/wiki/API">API</a>。像Node.js一样，它也是<a href="https://zh.m.wikipedia.org/w/index.php?title=事件驱动程序设计&amp;action=edit&amp;redlink=1">事件驱动</a>的.</p><p>Socket.IO 主要使用<a href="https://zh.m.wikipedia.org/wiki/WebSocket">WebSocket</a>协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如<a href="https://zh.m.wikipedia.org/wiki/Adobe_Flash">Adobe Flash</a> Sockets，<a href="https://zh.m.wikipedia.org/wiki/JSONP">JSONP</a>拉取，或是<a href="https://zh.m.wikipedia.org/wiki/Comet_(web技术">传统的AJAX拉取</a>)，并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的<a href="https://zh.m.wikipedia.org/w/index.php?title=Wrapper_library&amp;action=edit&amp;redlink=1">包装库</a>，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和<a href="https://zh.m.wikipedia.org/w/index.php?title=Asynchronous_I/O&amp;action=edit&amp;redlink=1">异步IO操作</a>。</p><p>可以使用<a href="https://zh.m.wikipedia.org/wiki/Node包管理器">npm</a>（node 软件包）工具来安装。</p><p> Socket 为客户端和服务器提供了双向通信机制。</p><p>这意味着服务器可以 <em>推送</em> 消息给客户端。无论何时你发布一条消息，服务器都可以接收到消息并推送给其他连接到服务器的客户端。</p><p>Socket.IO 的核心理念就是允许发送、接收任意事件和任意数据。任意能被编码为 JSON 的对象都可以用于传输。二进制数据也是支持的。</p><p>这里的实现方案是，当用户输入消息时，服务器接收一个 <code>chat message</code> 事件。<code>index.html</code> 文件中的 <code>script</code> 部分现在应该内容如下：</p><p>接下来的目标就是让服务器将消息发送给其他用户。</p><p>要将事件发送给每个用户，Socket.IO 提供了 <code>io.emit</code> 方法：</p><hr><hr><h1 id="socket（套接字？插槽）"><a href="#socket（套接字？插槽）" class="headerlink" title="socket（套接字？插槽）"></a>socket（套接字？插槽）</h1><p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。“Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，提供一套调用TCP/IP协议的API。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220711204509818.png" alt="image-20220711204509818" style="zoom:67%;" /></p><p>所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字<strong>上联应用进程，下联网络协议栈</strong>，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。</strong></p><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。  </p><p>// 套接字通信分两部分：<br>- 服务器端：被动接受连接，一般不会主动发起连接<br>- 客户端：主动向服务器发起连接<br>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别  </p><h1 id="websocket和http的关系"><a href="#websocket和http的关系" class="headerlink" title="websocket和http的关系"></a>websocket和http的关系</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1、都是基于TCP的，都是可靠传输协议。</p><p>2、都是应用层协议。</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220711203604868.png" alt="image-20220711203604868" style="zoom: 80%;" /></p><h1 id="Http、Socket、WebSocket之间联系与区别"><a href="#Http、Socket、WebSocket之间联系与区别" class="headerlink" title="Http、Socket、WebSocket之间联系与区别"></a><a href="https://www.cnblogs.com/aspirant/p/11334957.html">Http、Socket、WebSocket之间联系与区别</a></h1><p><strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</strong></p><p>可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。</p><p>HTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。</p><p><strong>WebSocket 协议 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</strong></p><hr><p>socket和http的区别：<br>Http协议：简单的对象访问协议，对应于应用层。Http协议是基于TCP链接的。<br>tcp协议：对应于传输层<br>ip协议：对应于网络层<br>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而Http是应用层协议，主要解决如何包装数据。</p><p><strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</strong></p><hr><p>Http连接：http连接就是所谓的短连接，及客户端向服务器发送一次请求，服务器端相应后连接即会断掉。</p><p>socket连接：socket连接及时所谓的长连接，理论上客户端和服务端一旦建立连接，则不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该链接已释放网络资源。所以当一个socket连接中没有数据的传输，那么为了位置连续的连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。</p><hr><p>1.HTTP的长连接一般就只能坚持一分钟而已，而且是浏览器决定的，你的页面很难控制这个行为。<br>Socket连接就可以维持很久，几天、数月都有可能，只要网络不断、程序不结束，而且是可以编程灵活控制的。<br>2.HTTP连接是建立在Socket连接之上。在实际的网络栈中，Socket连接的确是HTTP连接的一部分。但是从HTTP协议看，它的连接一般是指它本身的那部分。</p><hr><p>TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,</p><p>每层都有相应的协议，如下图（TCP/IP四层模型）</p><p>应用层包括http（万维网）、ftp（文件传输）、smtp（电子邮件）、dns、telnet</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/9dbde0322cc1482fa17b38a4e3bfe664.jpeg" alt="img"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716100956055.png" alt="image-20220716100956055"></p><p>之前不太懂为什么有OSI七层模型、四层模型，其实他们的区分标准在于OSI七层模型是理论上的分层方式，而四层模型是实践过程中的分层模型。</p><p>OSI七层模型ISO（国际标准化组织）提出的一套理论性的网络标准化协议，可以把它看成一本教科书，它在指定之前是没有经过实践的，而为什么我们实践的过程中又没有遵循OSI的标准来分层呢，是因为我们在实践的过程中发现有些功能不必要分得那么细，而TCP四层模型就是我们实践过程中发现比较合理的分层，虽然我们实际过程中都没有按OSI分为七层，但是OSI对我们实践过程分层有着指导性的意义。</p><p>五层协议将四层协议中的网络接口层分为数据链路层和物理层</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/v2-9120fb10ff256120099cd152799fe309_720w.jpg" alt="img"></p><p><strong>TPC/IP协议栈，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</strong></p><p>把<strong>IP想像两个站点</strong>，<strong>TCP和UDP是高速公路，HTTP 、FTP 就是货车</strong>，而 Socket 就是两个站点的检票口。<strong>货车(http)在一端站点(ip)先通过检票口(socket)，检票后行驶在高速公路(tcp)上，到达另一站点(ip)卸载货物(http)。</strong></p><hr><p><a href="https://www.jianshu.com/p/4e80b931cdea">https://www.jianshu.com/p/4e80b931cdea</a></p><h3 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h3><p>Socket.io提供了基于事件的实时双向通讯</p><p>Browser和WebServer间的实时数据传输是一个很重要的需求，但最早只能通过AJAX轮询方式实现。在WebSocket标准没有推出之前，AJAX轮询是一种可行的方案。</p><p>AJAX轮询原理是设置定时器，定时通过AJAX同步服务端数据。这种方式存在延时且对服务端造成很大负载。直至2011年，IETF才标准化WebSocket - 一种基于TCP套接字进行收发数据的协议。</p><h3 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h3><p>WebSocket是HTML5新增的一种<strong>通信协议</strong>，其特点是服务端可以主动向客户端推送信息，客户端也可以主动向服务端发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后浏览器和服务端之间就形成了一条快速通道，两者之间就直接可以数据相互传送，带来的好处是</p><ol><li>相互沟通的<code>Header</code>很小，大概只有2Bytes。</li><li>服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。</li></ol><p>为了建立一个WebSocket连接，浏览器首先要向服务器发起一个HTTP请求，这个请求和通常的HTTP请求不同，包含了一些附加头信息，其中附加头信息<code>Upgrade: WebSocket</code>表明这是一个申请协议升级的HTTP请求。服务端解析这些头信息，然后产生应答信息返回给客户端，客户端和服务端的WebSocket连接就建立起来了。双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续直到客户端或者服务端的某一方主动关闭连接。</p><h3 id="为什么要使用WebSocket呢？"><a href="#为什么要使用WebSocket呢？" class="headerlink" title="为什么要使用WebSocket呢？"></a>为什么要使用WebSocket呢？</h3><p>Browser已经支持HTTP协议，为什么还要开发一种新的WebSocket协议呢？</p><p><strong>我们知道HTTP协议是一种单向的网络协议，在建立连接后，仅允许Browser/UserAgent向WebServer发出请求资源后，WebServer才能返回对应的数据，而WebServer不能主动的推送数据给Browser/UserAgent。</strong></p><p>最初这么设计HTTP协议的原因是，假设WebServer能主动的推送数据给Browser/UserAgent，那么Browser/UserAgent就太容易受到攻击了，一些广告商也会主动把广告在不经意间强行的传输给客户端，这不能不说是一个灾难。那么单向的HTTP协议给Web应用开发带哪些问题呢？</p><p>现在假设我们要开发一个基于Web的应用去获取当前WebServer的实时数据。例如股票实时行情、火车票剩余票数等。这就需要Browser/UserAgent与WebServer之间反复进行HTTP通信，Browser/UserAgent不断的发送请求去获取当前的实时数据。</p><p>常见的方式</p><ul><li>Polling</li></ul><p><strong>Polling轮询是通过Browser/UserAgent定时向WebServer发送HTTP请求</strong>，WebServer收到请求后把最新的数据发回给Browser/UserAgent，Browser/UserAgent得到数据后将其显示，然后再定期重复此过程。</p><p>虽然这样可以满足需求，但仍存在问题，例如某段时间内WebServer没有更新的数据，但Browser/UserAgent仍然会定时发送请求过来询问，WebServer可以把以前的老数据再传送过去，Browser/UserAgent把这些没有变化的数据再显示出来。这样既浪费网络带宽，有浪费CPU利用率。</p><p>如果说把Browser/UserAgent发送请求的周期调大一些，就可以缓解这个问题，但如果WebServer的数据更新很快时，这样又不能保证Web应用获取数据的实时性。</p><ul><li>LongPolling</li></ul><p>LongPolling是对Polling的一种改进。</p><p>Browser/UserAgent发送HTTP请求到WebServer，此时WebServer可以做2件事情：</p><ol><li>如果WebServer有新的数据需要传送，就立即把数据发回给Browser/UserAgent，Browser/UserAgent收到数据后，立即再发送HTTP请求给WebServer。</li><li>如果WebServer没有新数据需要传送，这里与Polling的方式不同的是，WebServer不是立即发送回应给Browser/UserAgent，而是将这个请求保持住，等待有新的数据来到，再去响应这个请求。当然，如果WebServer的数据长期没有更新，一段时间后，这个HTTP请求就会超时，Browser/UserAgent收到超时信息后，在立即发送一个新的HTTP请求给服务器，然后依次循环这个过程。</li></ol><p>LongPolling的方式虽然在某种程度上减少了网络带宽和CPU利用率等问题，但仍存在缺陷。</p><p>例如WebServer的数据更新速度较快，WebServer在传送一个数据包给Browser/UserAgent后必须等待Browser的下一个HTTP请求到来，才能传递第二个更新的数据包给Browser。这样的话，Browser显示实时数据最快的时间为2 xRTT（往返时间）。另外在网络拥堵的情况下，这个应该是不能让用户接受的。另外，由于HTTP数据包的头部数据量很大（通常有400多个字节），但真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性传输，难免对网络带宽是一种浪费。</p><p>综上所述，要是在Browser有一种新的网路一些，能支持客户端和服务端的双向通信，而且协议的头部又不那么庞大就very nice了。WebSocket正是肩负这样的使命登上了Web的舞台。</p><h3 id="WebSocket-原理"><a href="#WebSocket-原理" class="headerlink" title="WebSocket 原理"></a>WebSocket 原理</h3><p>WebSocket是一种<strong>双向通信协议</strong>，它建立在TCP之上，同HTTP一样通过TCP来传输数据，但与HTTP最大不同的是：</p><ol><li>WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/UserAgent都能主动的向对象发送或接收数据，就像Socket一样，不同的是WebSocket是一种建立在Web基础上的简单模拟Socket的协议。</li><li>WebSocket需要通过握手连接，类似TCP也需要客户端和服务端进行握手连接，连接成功后才能相互通信。</li></ol><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/4933701-2e68a6248c39caa9.gif" alt="img"></p><p>简单说明下WebSocket握手的过程</p><p>当Web应用端调用<code>new WebSocket(url)</code>接口时，Browser就开始了与地址为URL的WebServer建立握手连接的过程。</p><ol><li>Browser与WebSocket服务器通过TCP三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用将收到错误消息通知。</li><li>在TCP建立连接成功后，Browser/UserAgent通过HTTP协议传送WebSocket支持的版本号、协议的字版本号、原始地址、主机地址等一系列字段给服务端。</li><li>WebSocket服务器收到Browser/UserAgent发送来的握手请求后，如果数据包数据和格式正确，客户端和服务端的协议版本匹配等，就接受本次握手连接，并给出对应的数据回复，同样回复的数据包也是采用HTTP协议传输。</li><li>Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发<code>onopen</code>消息，此时Web开发者就可以在此时通过<code>send</code>接口向服务器发送数据。否则，握手连接失败，Web应用会收到<code>onerror</code>消息，并且能知道连接失败的原因。</li></ol><h3 id="WebSocket与TCP、HTTP的关系"><a href="#WebSocket与TCP、HTTP的关系" class="headerlink" title="WebSocket与TCP、HTTP的关系"></a>WebSocket与TCP、HTTP的关系</h3><h1 id="“三次握手，四次挥手”你真的懂吗？"><a href="#“三次握手，四次挥手”你真的懂吗？" class="headerlink" title="“三次握手，四次挥手”你真的懂吗？"></a>“三次握手，四次挥手”你真的懂吗？</h1><p>客户端：是服务器吗？我要跟你通信，听得到我说话吗？<br>服务器：可以通信，你听得到我说话吗？<br>客户端：我也听得到。</p><p>是双工</p><p>三次握手和四次挥手TCP一定是客户端发起 （谁发请求谁就是客户端） （http是基于tcp连接的）</p><p>TCP滑动窗口<a href="https://www.bilibili.com/video/BV1PZ4y1P7zp">https://www.bilibili.com/video/BV1PZ4y1P7zp</a></p><p>UDP报文格式：源端口+目标端口+报文长度+内容</p><p>TCP报文格式，一行4字节，1字节8位</p><p>16位源端口号 | 16位目的端口号</p><p>32位序号（seq 每个报文的序号，随机生成</p><p>32位确认序号 ack （服务器的ack=客户端发起请求的seq+1， 客户端的ack=服务器的seq+1</p><p>4位首部长度 | 保留6位 | URG | ACK(1位标志位) | PSH | RST | SYN(1位， 为1则为新) | FIN(我要结束，我要断开) | 16位窗口大小 </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710220737099.png" alt="image-20220710220737099"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716200913805.png" alt="image-20220716200913805"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716201845317.png" alt="image-20220716201845317"></p><p>全文背诵：</p><p>面试官你好，这个问题我是知道的。TCP/IP协议是传输层的一个面向连接的安全可靠的传输协议。</p><p>三次握手的机制是为了保证能建立一个安全可靠的连接；第一次握手是由客户端发起，客户端会向服务端发送一个报文，报文里面SYN标志位是置1的，当服务端收到这个报文的时候就知道客户端要和我发起一个新的连接，于是服务端就向客户端发送一个确认消息包ACK位置1，以上两次握手之后，对于客户端而言，其实是已经知道了所有信息，就是我既能给服务端发送消息，我还能收到服务端的消息；对于服务端而言，两次握手是不够的，因为到目前为止，服务端只知道一件事情，就是客户端给我发送的消息我收的到，但是我发给客户端的消息，客户端能不能收到我还不知道。</p><p>所以还要进行第三次握手。第三次握手就是当客户端收到服务端发过来的确认消息的报文之后，还要继续给服务端进行一个回应，也是一个ACK位置1的一个确认消息。</p><p>通过以上三次连接，不管是服务端还是客户端都彼此知道了，我既能给对方发送消息也能收到对方的消息，那么这个连接就能被安全的建立了。</p><p>四次握手机制，也是由客户端（服务器也可以）首先发起的，客户端会发起一个报文，在报文里面FIN标志位置1；当服务端收到这报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的时候，对于服务端而言它极有可能有未发送完的的消息，它还要继续发送；所以此时对于服务端而言他只能进行一个消息确认，我先告诉对方，我知道你要和我断开连接了，但是我这还可能没有做好准备，你还需要等我一下，等会我会告诉你；于是，发完这个消息确认包后，可能稍作片刻，它可能会继续发送一个断开连接的报文，一个FIN位置1的报文，是由服务端发给客户端的，这个报文表示了服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文。一共有四次，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开了。</p><p>这是我对三次握手和四次挥手的理解。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710221248490.png" alt="image-20220710221248490"></p><p>为什么服务器要分两次挥手，因为有可能正在发送一个数据给客户端，不能立刻断开。</p><p>server的第二步说：我知道你要和我断开，你先等我一下，我还没传输完。</p><p>server的第三步说：我终于传输完了，客户端你断开吧。</p><p>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。  </p><h1 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h1><p>开放系统互连参考模型 (Open System Interconnect 简称OSI）</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220711171534690.png" alt="image-20220711171534690"></p><p>7、应用层：用户app里的数据，图片、声音、文字</p><p>6、表示层： 用bmp或jpeg编码表示图片数据，WAV或mp3编码表示声音数据，wmv或avi编码表示视频数据。</p><p>5、会话层：会话连接，建立两个应用软件之间的会话关系和连接。</p><p>4、传输层（数据段）：简历TCP或UDP连接，建立端到端的连接。 给报文打上端口号，例如80是网页数据，4000是qq数据</p><p>3、网络层（数据包）：给数据表打上ip地址，并且使用路由转发。使用的协议统一，网络层基于IP地址进行<strong>路由</strong>转发。进行数据传输：路由数据包，选择传递数据的最佳路径，支持逻辑<strong>寻址</strong>和路径选择。</p><p>2、数据链路层（数据帧）：以太网协议，mac地址，访问介质：定义如何格式化数据以便传输以及访问网络，支持错误检测。</p><p>1、物理层（数据位）：网线，二进制传输，定义了各种规范。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716100310633.png" alt="image-20220716100310633"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224132044.png" alt="image-20220710224132044"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224203925.png" alt="image-20220710224203925"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224218692.png" alt="image-20220710224218692"></p><h1 id="网络模型图"><a href="#网络模型图" class="headerlink" title="网络模型图"></a>网络模型图</h1><p>socket就是这里的TCP或UDP</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710230633852.png" alt="image-20220710230633852"></p><h1 id="基于TCP-UDP协议的应用层协议有哪些？"><a href="#基于TCP-UDP协议的应用层协议有哪些？" class="headerlink" title="基于TCP/UDP协议的应用层协议有哪些？"></a>基于TCP/UDP协议的应用层协议有哪些？</h1><p>1、基于TCP的<strong>应用层</strong>协议有：HTTP、FTP、SMTP、TELNET、SSH<br>协议    全称    默认端口<br>HTTP （ 浏览网页 ）    HyperText Transfer Protocol（超文本传输协议）    80<br>FTP    File Transfer Protocol (文件传输协议)    20用于传输数据，21用于传输控制信息<br>SMTP    Simple Mail Transfer Protocol (简单邮件传输协议)    25<br>TELNET    Teletype over the Network (远程登录，明码传输)    23<br>SSH    Secure Shell（远程，加密传输）    22<br>WebSocket 80或443端口</p><p>2、基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、SNMP：简单网络管理协议<br>协议    全称    默认端口<br>DNS    Domain Name Service (域名服务)    53<br>TFTP    Trivial File Transfer Protocol (简单文件传输协议)    69<br>SNMP    Simple Network Management Protocol (简单网络管理协议)    通过UDP端口161接收，只有Trap信息采用UDP端口162。<br>NTP    Network Time Protocol (网络时间协议)    123</p><hr><p>网络层有ip协议、IGMP、ICMP协议</p><p>数据链路层有ethernet以太网、ppp、PPPoE协议。</p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p><strong>传输控制协议TCP(Transmission Control Protocol)</strong></p><p> <strong>用户数据包协议UDP(User Datagram Protocol)</strong></p><p>TCP是面向连接的，通过三次握手建立客户端和服务端之间的可靠连接，而UDP是面向无连接的，可以直接给多台机器发送数据。<br>TCP是面向字节流的协议，字节流没有头尾，但是流通过报文段发送出去，UDP是面向报文的协议，通过数据报发送数据。<br>TCP有流量控制，拥塞控制等机制，而UDP只受数据生成的速率等影响，跟网络状况无关。<br>TCP保证可靠传输，超时重传。UDP使用尽最大努力交付。</p><p>UDP适合：直播，实时游戏，http3.0等场景。<br>不需要建立连接，一对一沟通，可以广播，对于丢包不敏感，网络较好的内网，即使网络不畅也不能降低数据发送的速度。</p><p>TCP适合发送文件 发送邮件 浏览网页</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224707044.png" alt="image-20220710224707044"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224734156.png" alt="image-20220710224734156"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224248909.png" alt="image-20220710224248909"></p><p>TCP面向字节流与UDP面向报文<br>之前对于tcp和udp只是记住了一个面向字节流，一个是面向报文的，但是并没有真正的理解，经过中间找工作的压力中间不停的面试和笔试，现在终于对于这两个概念有了一个全新的认识。<br>通俗的解释：</p><p>可以将tcp和upd看成不同公司的出租车，tcp这个公司的出租车司机（tcp头）在拉客的时候，一看来了一个乘客，可是自己车上还有三个位置，司机就会继续等，直到自己车上去同一个目的地的乘客坐满了才开车，因为tcp公司认为遵循Nagle算法可以提高效率，节省能源，从socket学校走出来三个团体的学生，每一个团体只有一个人，可能只要消耗一个tcp出租车。如果从socket学校出来了一个团队的学生，但是这个团队有6个学生，一号tcp出租车看看自己车上还有两个个空位置，就让这个团队的两个学生上车了，剩下的学生只能做下一辆车了。这也就造成了一个问题，一号出租车开到了城市中的一个小餐馆，餐馆老板并不知道他们四个学生是不是一个团队的，这也就是粘包粘包的问题。</p><p>udp公司的出租车与tcp公司的出租车不一样，udp公司有最新的科技，自己的车可以变大可以变小。只要有一个团队的人走过来，不管是一个人还是7个人，udp出租车都可以一次性给你送走（因为udp有核心科技，当然下层的ip层还是可能会分包的，这些我们不用管），不需要等待。到餐馆后，餐馆老板一看是udp公司的出租车，就知道这是一个团队的（也就是不会出现粘包粘包的问题）。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224302823.png" alt="image-20220710224302823"></p><h1 id="浏览器输入URL返回页面的过程——dns"><a href="#浏览器输入URL返回页面的过程——dns" class="headerlink" title="浏览器输入URL返回页面的过程——dns"></a>浏览器输入URL返回页面的过程——dns</h1><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224335246.png" alt="image-20220710224335246"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224354676.png" alt="image-20220710224354676"></p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224430637.png" alt="image-20220710224430637"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224459231.png" alt="image-20220710224459231"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220710224528356.png" alt="image-20220710224528356"></p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。</p><p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），<strong>它最终体现为在网络上传输的数据包的格式。</strong></p><p>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议 。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716101810317.png" alt="image-20220716101810317"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716101526161.png" alt="image-20220716101526161"></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716101848093.png" alt="image-20220716101848093"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102012808.png" alt="image-20220716102012808"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716101939094.png" alt="image-20220716101939094"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102105919.png" alt="image-20220716102105919"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102210270.png" alt="image-20220716102210270"></p><h2 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102501564.png" alt="image-20220716102501564"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102517324.png" alt="image-20220716102517324"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102601333.png" alt="image-20220716102601333"></p><h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102856437.png" alt="image-20220716102856437"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102903822.png" alt="image-20220716102903822"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102914332.png" alt="image-20220716102914332"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716103540290.png" alt="image-20220716103540290"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716103451453.png" alt="image-20220716103451453"></p><p>如何得到目标端的mac地址，arp请求会发给所有局域网内</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716103647487.png" alt="image-20220716103647487"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716102501564.png" alt="image-20220716102501564"></p><h2 id="字节序（同序为大端）"><a href="#字节序（同序为大端）" class="headerlink" title="字节序（同序为大端）"></a>字节序（同序为大端）</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716112033084.png" alt="image-20220716112033084"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716111515515.png" alt="image-20220716111515515"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716111945752.png" alt="image-20220716111945752"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716112003404.png" alt="image-20220716112003404"></p><p>网络字节序一定是大端，主机字节序不一定。</p><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。  </p><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。</p><p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序  </span></span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716114523015.png" alt="image-20220716114523015"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716115324918.png" alt="image-20220716115324918"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716115609326.png" alt="image-20220716115609326"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716115408917.png" alt="image-20220716115408917"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716115654574.png" alt="image-20220716115654574"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716115705028.png" alt="image-20220716115705028"></p><h2 id="Socket地址"><a href="#Socket地址" class="headerlink" title="Socket地址"></a>Socket地址</h2><p>// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。<br>// 客户端 -&gt; 服务器（IP, Port）  </p><h3 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a>通用 socket 地址</h3><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;<span class="comment">//sa_family 成员是地址族类型（sa_family_t）的变量</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br></pre></td></tr></table></figure><p>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：  </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716120025410.png" alt="image-20220716120025410"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716120117276.png" alt="image-20220716120117276"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716152431277.png" alt="image-20220716152431277"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span></span><br><span class="line"><span class="keyword">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) - <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr  </p><h2 id="IP地址转换（字符串ip-整数-，主机、网络字节序的转换）"><a href="#IP地址转换（字符串ip-整数-，主机、网络字节序的转换）" class="headerlink" title="IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）"></a>IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）</h2><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716155600862.png" alt="image-20220716155600862"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716155541442.png" alt="image-20220716155541442"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716155835353.png" alt="image-20220716155835353"></p><h2 id="用socket实现网络通信"><a href="#用socket实现网络通信" class="headerlink" title="用socket实现网络通信"></a>用socket实现网络通信</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716155939527.png" alt="image-20220716155939527"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">- 监听：监听有客户端的连接</span><br><span class="line">- 套接字：这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">- 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">- 接收数据</span><br><span class="line">- 发送数据</span><br><span class="line"><span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于通信的套接字（fd）</span><br><span class="line"><span class="number">2.</span> 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line"><span class="number">3.</span> 连接成功了，客户端可以直接和服务器通信</span><br><span class="line">- 接收数据</span><br><span class="line">- 发送数据</span><br><span class="line"><span class="number">4.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><h2 id="套接字Socket函数"><a href="#套接字Socket函数" class="headerlink" title="套接字Socket函数"></a>套接字Socket函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">    - domain: 协议族</span><br><span class="line">        AF_INET : ipv4</span><br><span class="line">        AF_INET6 : ipv6</span><br><span class="line">        AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">        SOCK_STREAM : 流式协议</span><br><span class="line">        SOCK_DGRAM : 报式协议</span><br><span class="line">    - protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">        - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">        - SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">        - 失败：<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">// socket命名</span></span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">    - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">    - addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">    - backlog : 未连接的和已经连接的和的最大值， <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 用于监听的文件描述符</span><br><span class="line">    - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">    - addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">    - 成功 ：用于通信的文件描述符</span><br><span class="line">    - <span class="number">-1</span> ： 失败</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 用于通信的文件描述符</span><br><span class="line">    - addr : 客户端要连接的服务器的地址信息</span><br><span class="line">    - addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket(用于监听的套接字)</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.193.128&quot;, saddr.sin_addr.s_addr);</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;clientaddr, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="keyword">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端的数据</span></span><br><span class="line">        <span class="keyword">int</span> num = read(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        write(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        write(fd, data , <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>滑动窗口（Sliding window）是一种<strong>流量控制技术</strong>。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即<strong>容许发送方在接收任何应答之前传送附加的包。</strong>接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。</p><p>TCP 中采用滑动窗口来进行传输控制，<strong>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0时，发送方一般不能再发送数据报。</p><p>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。  </p><p><strong>窗口理解为缓冲器的大小</strong>，会随着发送数据和接收数据而变化。通信双方都有发送和接收数据的缓冲区。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716202339331.png" alt="image-20220716202339331"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span></span><br><span class="line"><span class="meta"># win: 滑动窗口，相当于空闲的大小</span></span><br><span class="line"><span class="number">1.</span> 客户端向服务器发起连接，客户端的滑动窗口是<span class="number">4096</span>，一次发送的最大数据量是<span class="number">1460</span></span><br><span class="line"><span class="number">2.</span> 服务器接收连接情况，告诉客户端服务器的窗口大小是<span class="number">6144</span>，一次发送的最大数据量是<span class="number">1024</span></span><br><span class="line"><span class="number">3.</span> 第三次握手</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span><span class="number">-9</span> 客户端连续给服务器发送了<span class="number">6</span>k的数据，每次发送<span class="number">1</span>k</span><br><span class="line"><span class="number">5.</span> 第<span class="number">10</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">2</span>k,窗</span><br><span class="line">口大小是<span class="number">2</span>k = 剩余<span class="number">2</span>k空间</span><br><span class="line"><span class="number">6.</span> 第<span class="number">11</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">4</span>k,窗</span><br><span class="line">口大小是<span class="number">4</span>k，又处理<span class="number">2</span>k，还剩<span class="number">4</span>k空间</span><br><span class="line"><span class="number">7.</span> 第<span class="number">12</span>次，客户端给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">8.</span> 第<span class="number">13</span>次，客户端主动请求和服务器断开连接，并且给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">9.</span> 第<span class="number">14</span>次，服务器回复ACK <span class="number">8194</span>, a:同意断开连接的请求 b:告诉客户端已经接受到方才发的<span class="number">2</span>k的数据</span><br><span class="line">c:滑动窗口<span class="number">2</span>k</span><br><span class="line"><span class="number">10.</span>第<span class="number">15</span>、<span class="number">16</span>次，通知客户端滑动窗口的大小</span><br><span class="line"><span class="number">11.</span>第<span class="number">17</span>次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</span><br><span class="line"><span class="number">12.</span>第<span class="number">18</span>次，第四次挥手，客户端同意了服务器端的断开请求</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220716202752580.png" alt="image-20220716202752580"></p><p>发送方的缓冲区：<br>    白色格子：空闲的空间<br>    灰色格子：数据已经被发送出去了，但是还没有被接收<br>    紫色格子：还没有发送出去的数据<br>接收方的缓冲区：<br>    白色格子：空闲的空间<br>    紫色格子：已经接收到的数据  </p><hr><h2 id="TCP通信并发-多进程实现并发服务器"><a href="#TCP通信并发-多进程实现并发服务器" class="headerlink" title="TCP通信并发 - 多进程实现并发服务器"></a>TCP通信并发 - 多进程实现并发服务器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。</span><br><span class="line">思路：</span><br><span class="line"><span class="number">1.</span> 一个父进程，多个子进程</span><br><span class="line"><span class="number">2.</span>父进程负责等待并接受客户端的连接</span><br><span class="line"><span class="number">3.</span>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信。</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多进程 服务器端   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recyleChild</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h2 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">working</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span> =</span> (struct sockInfo *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Socket.io学习记录</summary>
    
    
    
    <category term="flutter" scheme="https://tsuiwade.github.io/categories/flutter/"/>
    
    
    <category term="flutter" scheme="https://tsuiwade.github.io/tags/flutter/"/>
    
    <category term="nodejs" scheme="https://tsuiwade.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>牛客网项目记录-第二章linux多进程开发</title>
    <link href="https://tsuiwade.github.io/2022/07/09/blog52-nowcoderProject2/"/>
    <id>https://tsuiwade.github.io/2022/07/09/blog52-nowcoderProject2/</id>
    <published>2022-07-09T11:14:33.000Z</published>
    <updated>2022-07-09T11:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709151547833.png" alt="image-20220709151547833"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709151741790.png" alt="image-20220709151741790"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152001679.png" alt="image-20220709152001679"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152137918.png" alt="image-20220709152137918"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152409441.png" alt="image-20220709152409441"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152513447.png" alt="image-20220709152513447" style="zoom: 67%;" /></p><p>进程的控制结构为PCB</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152551801.png" alt="image-20220709152551801"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152730589.png" alt="image-20220709152730589" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152820578.png" alt="image-20220709152820578" style="zoom:80%;" /></p><hr><h2 id="2-1-进程的状态"><a href="#2-1-进程的状态" class="headerlink" title="2.1 进程的状态"></a>2.1 进程的状态</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709152922274.png" alt="image-20220709152922274"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709153613473.png" alt="image-20220709153613473"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709153917036.png" alt="image-20220709153917036" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709154108593.png" alt="image-20220709154108593"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709155121586.png" alt="image-20220709155121586"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709154222057.png" alt="image-20220709154222057" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709154501219.png" alt="image-20220709154501219" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709155630565.png" alt="image-20220709155630565"></p><hr><h2 id="2-3-进程创建"><a href="#2-3-进程创建" class="headerlink" title="2.3 进程创建"></a>2.3 进程创建</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709155809181.png" alt="image-20220709155809181"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pid_t fork(void);</span></span><br><span class="line"><span class="comment">        函数的作用：用于创建子进程。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span></span><br><span class="line"><span class="comment">            在父进程中返回创建的子进程的ID,</span></span><br><span class="line"><span class="comment">            在子进程中返回0</span></span><br><span class="line"><span class="comment">            如何区分父进程和子进程：通过fork的返回值。</span></span><br><span class="line"><span class="comment">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        父子进程之间的关系：</span></span><br><span class="line"><span class="comment">        区别：</span></span><br><span class="line"><span class="comment">            1.fork()函数的返回值不同</span></span><br><span class="line"><span class="comment">                父进程中: &gt;0 返回的子进程的ID</span></span><br><span class="line"><span class="comment">                子进程中: =0</span></span><br><span class="line"><span class="comment">            2.pcb中的一些数据</span></span><br><span class="line"><span class="comment">                当前的进程的id pid</span></span><br><span class="line"><span class="comment">                当前的进程的父进程的id ppid</span></span><br><span class="line"><span class="comment">                信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        共同点：</span></span><br><span class="line"><span class="comment">            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span></span><br><span class="line"><span class="comment">                - 用户区的数据</span></span><br><span class="line"><span class="comment">                - 文件描述符表</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        父子进程对变量是不是共享的？</span></span><br><span class="line"><span class="comment">            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span></span><br><span class="line"><span class="comment">            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pid : %d\n&quot;, pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当前终端pid87186创建fork子进程87631（ 在父进程中 返回子进程的pid），一个父进程为87630，一个子进程87631。CPU时间片交替运行。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709161530157.png" alt="image-20220709161530157" style="zoom:50%;" /></p><hr><h2 id="2-4-父子进程关系及GDB多进程调试"><a href="#2-4-父子进程关系及GDB多进程调试" class="headerlink" title="2.4 父子进程关系及GDB多进程调试"></a>2.4 父子进程关系及GDB多进程调试</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709162506370.png" alt="image-20220709162506370"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709162743575.png" alt="image-20220709162743575" style="zoom:50%;" /></p><p>初始值一样，后续操作不一样。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709162845593.png" alt="image-20220709162845593" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712095224502.png" alt="image-20220712095224502"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709164650569.png" alt="image-20220709164650569"></p><p>父子进程间遵循<strong>读时共享写时复制</strong>的原则。只有进程空间的各段的内容要发生变化时（子进程或父进程进行写操作时，都会引起复制），才会将父进程的内容复制一份给子进程。<strong>父子进程在逻辑上仍然是严格相互独立的两个进程，各自维护各自的参数，只是在物理上实现了读时共享，写时复制。</strong> </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709173503178.png" alt="image-20220709173503178" style="zoom:50%;" /></p><hr><h2 id="2-5-父子进程关系"><a href="#2-5-父子进程关系" class="headerlink" title="2.5 父子进程关系"></a>2.5 父子进程关系</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709174528241.png" alt="image-20220709174528241" style="zoom:67%;" /></p><p>默认调试父进程，子进程自己跑自己的。   </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709174556763.png" alt="image-20220709174556763"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712170609358.png" alt="image-20220712170609358"></p><hr><h2 id="2-6-函数族"><a href="#2-6-函数族" class="headerlink" title="2.6 函数族"></a>2.6 函数族</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709191216787.png" alt="image-20220709191216787"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709192101771.png" alt="image-20220709192101771"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execl(const char *path, const char *arg, ...);</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - path:需要指定的执行的文件的路径或者名称</span></span><br><span class="line"><span class="comment">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span></span><br><span class="line"><span class="comment">                ./a.out hello world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// execl(&quot;hello&quot;,&quot;hello&quot;,NULL);</span></span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712193814626.png" alt="image-20220712193814626" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712193751377.png" alt="image-20220712193751377" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712184916552.png" alt="image-20220712184916552" style="zoom:67%;" /></p><p>hello world不在一起的原因是因为产生了孤儿进程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execlp(const char *file, const char *arg, ... );</span></span><br><span class="line"><span class="comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - file:需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">                a.out</span></span><br><span class="line"><span class="comment">                ps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execv(const char *path, char *const argv[]);</span></span><br><span class="line"><span class="comment">        argv是需要的参数的一个字符串数组</span></span><br><span class="line"><span class="comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">        execv(&quot;/bin/ps&quot;, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execve(const char *filename, char *const argv[], char *const envp[]);</span></span><br><span class="line"><span class="comment">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-进程退出"><a href="#2-7-进程退出" class="headerlink" title="2.7 进程退出"></a>2.7 进程退出</h2><p>上是标准C库，下是linux系统函数</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709200757166.png" alt="image-20220709200757166"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709200943834.png" alt="image-20220709200943834" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709201041144.png" alt="image-20220709201041144" style="zoom:50%;" /></p><p>在程序中</p><p>孤儿进程：子进程先睡一秒，父进程运行玩死了，子进程还活着，子进程成为孤儿进程。</p><p>僵尸进程：父进程一直运行不死，子进程死了，残留内核区资源，成为僵尸进程。然后只能Ctrl+C杀死，子进程被进程号为1回收。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709201148099.png" alt="image-20220709201148099"></p><p>正常的情况下</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712195746801.png" alt="image-20220712195746801" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712195707422.png" alt="image-20220712195707422"></p><p>想让父进程死，就让子进程睡一秒钟</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712195924079.png" alt="image-20220712195924079"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709201834519.png" alt="image-20220709201834519"></p><p>​    孤儿进程的父进程号为1，父进程结束后会显示终端，由进程号为1的进程来回收子进程的资源。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709202519128.png" alt="image-20220709202519128"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712200503016.png" alt="image-20220712200503016"></p><p>子进程死了父进程还在进行。父进程14859处于休眠状态，子进程14860是僵尸进程。，kill -9杀不死。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712200624838.png" alt="image-20220712200624838"></p><hr><h2 id="2-8-wait函数"><a href="#2-8-wait函数" class="headerlink" title="2.8 wait函数"></a>2.8 wait函数</h2><p>主要针对僵尸进程。学习如何在父进程中回收子进程的资源。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712201345734.png" alt="image-20220712201345734"></p><p>wait 能够<strong>等待子进程状态改变</strong>，包含子进程结束、被信号停止、被信号暂停。调用wait会去释放子进程的资源。父进程默认wait阻塞了，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">        参数：int *wstatus</span></span><br><span class="line"><span class="comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            - 成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// int ret = wait(NULL);</span></span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="keyword">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220721161212220.png" alt="image-20220721161212220" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712204152216.png" alt="image-20220712204152216" style="zoom:67%;" /></p><p>此时子进程已经死掉，成为僵尸进程。当被ctrl+c结束了父进程，僵尸进程就被进程号为1的进程回收了，因为父进程一死，子进程就变成孤儿进程。但并不能每次都结束父进程，应该在父进程中做一些操作。</p><p>wait(NULL) 表示不需要子进程退出的状态</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712204332100.png" alt="image-20220712204332100" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712210245314.png" alt="image-20220712210245314" style="zoom:67%;" /></p><p>子进程一直在打印，父进程没有动，说明父进程阻塞了。通过kill -9 13478 ，父进程不阻塞了，就打印。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712210434033.png" alt="image-20220712210434033" style="zoom:67%;" /></p><p>然后全kill掉，此时没有子进程了。<strong>所有子进程都结束，则返回-1。</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712204628113.png" alt="image-20220712204628113" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712204642539.png" alt="image-20220712204642539" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712204712745.png" alt="image-20220712204712745" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712211021844.png" alt="image-20220712211021844" style="zoom:80%;" /></p><p>通过信号kill -9杀死</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712205059554.png" alt="image-20220712205059554" style="zoom:80%;" /></p><hr><h2 id="2-9-waitpid函数"><a href="#2-9-waitpid函数" class="headerlink" title="2.9 waitpid函数"></a>2.9 waitpid函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pid:</span></span><br><span class="line"><span class="comment">                pid &gt; 0 : 某个子进程的pid</span></span><br><span class="line"><span class="comment">                pid = 0 : 回收当前进程组的所有子进程    </span></span><br><span class="line"><span class="comment">                pid = -1 : 回收所有的子进程，相当于 wait()  （最常用）</span></span><br><span class="line"><span class="comment">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">            - options：设置阻塞或者非阻塞</span></span><br><span class="line"><span class="comment">                0 : 阻塞</span></span><br><span class="line"><span class="comment">                WNOHANG : 非阻塞</span></span><br><span class="line"><span class="comment">            - 返回值：</span></span><br><span class="line"><span class="comment">                &gt; 0 : 返回子进程的id</span></span><br><span class="line"><span class="comment">                = 0 : options=WNOHANG, 表示还有子进程或者</span></span><br><span class="line"><span class="comment">                = -1 ：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="comment">// int ret = waitpid(-1, &amp;st, 0);</span></span><br><span class="line">            <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, &amp;st, WNOHANG);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明还有子进程存在</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是正常退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是异常终止</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int ret = waitpid(-1, &amp;st, 0);<strong>阻塞情况</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712215332656.png" alt="image-20220712215332656"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712215357568.png" alt="image-20220712215357568"></p><p>父进程非阻塞。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712215625353.png" alt="image-20220712215625353" style="zoom:80%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712214240848.png" alt="image-20220712214240848"></p><p>所有子进程都结束之后，再回过来 ret返回了-1值。</p><hr><h2 id="2-10-进程间通信-IPC"><a href="#2-10-进程间通信-IPC" class="headerlink" title="2.10 进程间通信 IPC"></a>2.10 进程间通信 IPC</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712221317444.png" alt="image-20220712221317444"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712222017940.png" alt="image-20220712222017940"></p><hr><h2 id="2-11-匿名管道（PIPE）"><a href="#2-11-匿名管道（PIPE）" class="headerlink" title="2.11 匿名管道（PIPE）"></a>2.11 匿名管道（PIPE）</h2><p><strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/6-%E7%AE%A1%E9%81%93-pipe-fork.jpg" alt="img" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220712222710566.png" alt="image-20220712222710566"></p><p>竖线为管道符，前后各为一个指令，ls为获取当前文件列表，wc -l统计个数。写入端就是向管道注入，管道读取端就是从管道输出。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713093759069.png" alt="image-20220713093759069"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713094021279.png" alt="image-20220713094021279"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713094503815.png" alt="image-20220713094503815"></p><p>父进程通过文件描述符5向管道写数据，子进程通过6从管道读数据，通过其管道5写数据，父进程通过6从管道读数据，父子进程共享文件描述符。 </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713094835797.png" alt="image-20220713094835797" style="zoom:50%;" /></p><p>管道数据结构为环形队列。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713095024204.png" alt="image-20220713095024204" style="zoom:67%;" /></p><h2 id="2-12-父子进程通过匿名管道通信"><a href="#2-12-父子进程通过匿名管道通信" class="headerlink" title="2.12 父子进程通过匿名管道通信"></a>2.12 父子进程通过匿名管道通信</h2><p>数据被写到管道的写端，（应该是入端）</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713095309303.png" alt="image-20220713095309303" style="zoom:50%;" /></p><p>子进程发送数据给父进程，父进程读取到数据 后 输出</p><p><code>在fork之前创建管道</code></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713095708508.png" alt="image-20220713095708508" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713095916244.png" alt="image-20220713095916244" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713095929370.png" alt="image-20220713095929370"></p><p>如果子进程写之前休眠10秒，父进程仍然是阻塞等待。read是阻塞，管道默认是阻塞，当管道没有数据时，read阻塞，管道满了，write阻塞。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713100236399.png" alt="image-20220713100236399" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713100301798.png" alt="image-20220713100301798"></p><p>父进程先读后写，子进程先写后读。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713100626622.png" alt="image-20220713100626622" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713100739557.png" alt="image-20220713100739557" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713100758213.png" alt="image-20220713100758213" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220722105708703.png" alt="image-20220722105708703"></p><p>管道大小为4k</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713101030871.png" alt="image-20220713101030871" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713101045461.png" alt="image-20220713101045461"></p><h2 id="2-13-匿名管道通信案例"><a href="#2-13-匿名管道通信案例" class="headerlink" title="2.13 匿名管道通信案例"></a>2.13 匿名管道通信案例</h2><p>注释掉sleep</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713101531493.png" alt="image-20220713101531493" style="zoom:67%;" /></p><p>输出有错误，乱码 且 收到自己发的数据，不对。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713102307570.png" alt="image-20220713102307570" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713102327586.png" alt="image-20220713102327586" style="zoom:50%;" /></p><p>现在情况变成了</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713102353491.png" alt="image-20220713102353491" style="zoom:50%;" /></p><p>所以在读的时候 父进程要关闭写端，子进程要关闭读端</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713102934517.png" alt="image-20220713102934517" style="zoom: 50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713102959385.png" alt="image-20220713102959385" style="zoom:50%;" /></p><p>案例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现 ps aux | grep xxx 父子进程间通信</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    子进程： ps aux, 子进程结束后，将数据发送给父进程</span></span><br><span class="line"><span class="comment">    父进程：获取到数据，过滤</span></span><br><span class="line"><span class="comment">    pipe()</span></span><br><span class="line"><span class="comment">    execlp()</span></span><br><span class="line"><span class="comment">    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 过滤数据输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 回收子进程资源</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 管道就4k</span></span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-14-管道读写特点和管道设置非阻塞"><a href="#2-14-管道读写特点和管道设置非阻塞" class="headerlink" title="2.14 管道读写特点和管道设置非阻塞"></a>2.14 管道读写特点和管道设置非阻塞</h2><p>管道的读写特点：<br>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，<strong>再次read会返回0</strong>，就像读到文件末尾一样。</p><p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次<strong>read会阻塞</strong>，直到管道中有数据可以读了才读取数据并返回。</p><p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p><p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。</p><p>总结：<br>    读管道：<br>        管道中有数据，read返回实际读到的字节数。<br>        管道中无数据：<br>            写端被全部关闭，read返回0（相当于读到文件的末尾）<br>            写端没有完全关闭，read阻塞等待</p><p>写管道：<br>    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）<br>    管道读端没有全部关闭：<br>        管道已满，write阻塞<br>        管道没有满，write将数据写入，并返回实际写入的字节数</p><p>父进程read阻塞</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713110555043.png" alt="image-20220713110555043" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713110514941.png" alt="image-20220713110514941" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713110755428.png" alt="image-20220713110755428" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="keyword">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709110426450.png" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713111545212.png" alt="image-20220713111545212" style="zoom:50%;" /></p><p>没有数据就-1， 没有阻塞。</p><hr><h2 id="2-15有名管道（FIFO）"><a href="#2-15有名管道（FIFO）" class="headerlink" title="2.15有名管道（FIFO）"></a>2.15有名管道（FIFO）</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713112030962.png" alt="image-20220713112030962"></p><p> <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713112131822.png" alt="image-20220713112131822"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713112720107.png" alt="image-20220713112720107"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713112734113.png" alt="image-20220713112734113"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713112936238.png" alt="image-20220713112936238"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建fifo文件</span></span><br><span class="line"><span class="comment">    1.通过命令： mkfifo 名字</span></span><br><span class="line"><span class="comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 管道名称的路径</span></span><br><span class="line"><span class="comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span></span><br><span class="line"><span class="comment">                    是一个八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1，并设置错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   写数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    有名管道的注意事项：</span></span><br><span class="line"><span class="comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span></span><br><span class="line"><span class="comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读管道：</span></span><br><span class="line"><span class="comment">        管道中有数据，read返回实际读到的字节数</span></span><br><span class="line"><span class="comment">        管道中无数据：</span></span><br><span class="line"><span class="comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span></span><br><span class="line"><span class="comment">            写端没有全部被关闭，read阻塞等待</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    写管道：</span></span><br><span class="line"><span class="comment">        管道读端被全部关闭，进程异常终止（收到一个SIGPIPE信号）</span></span><br><span class="line"><span class="comment">        管道读端没有全部关闭：</span></span><br><span class="line"><span class="comment">            管道已经满了，write会阻塞</span></span><br><span class="line"><span class="comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建管道文件</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写端停了，读端显示“写端断开连接”，程序结束。</p><p>运行读端，读端在open管道文件时阻塞了。运行写端，读端就运行了。</p><p>把读端停了，写端程序立马结束。</p><hr><h2 id="2-16-有名管道实现简单聊天功能"><a href="#2-16-有名管道实现简单聊天功能" class="headerlink" title="2.16 有名管道实现简单聊天功能"></a>2.16 有名管道实现简单聊天功能</h2><p>  <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713115229732.png" alt="image-20220713115229732"></p><p>chatA</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.以只写的方式打开管道fifo1</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.以只读的方式打开管道fifo2</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.循环的写读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 获取标准输入的数据</span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只能收一句 发一句，不能把读和写都放入同一个进程中，必定有一个阻塞。所以要把读写分别放到不同进程里。A父进程写，子进程读。B父进程读，子进程写。</p><hr><h2 id="2-17内存映射"><a href="#2-17内存映射" class="headerlink" title="2.17内存映射"></a>2.17内存映射</h2><p>类似于动态库、共享库的位置。</p><p>可以指定映射 从文件的偏移量开始的len大小的文件。</p><p>内存映射之后，当修改了内存数据，也会同步到文件当中。 </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713141211276.png" alt="image-20220713141211276"></p><p>左右为进程中的内存数据。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713143305010.png" alt="image-20220713143305010" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713141859759.png" alt="image-20220713141859759"></p><p>映射文件到内存当中。</p><p>mmap()在调用进程的虚拟地址空间里，创建了一个映射</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713142227869.png" alt="image-20220713142227869"></p><ul><li>flags:<ul><li>map_shared 映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项。</li><li>map_private 不同步，内存映射区的数据修改了，对原来的文件不会修改，会重新出一个新的文件（copy on write）</li></ul></li></ul><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713142715528.png" alt="image-20220713142715528"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713142742847.png" alt="image-20220713142742847"></p><p>案例需求</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713142855197.png" alt="image-20220713142855197"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713150351372.png" alt="image-20220713150351372"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713150656773.png" alt="image-20220713150656773"></p><p>父进程读数据，子进程写数据。以文件为桥梁。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713150921776.png" alt="image-20220713150921776"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713150940667.png" alt="image-20220713150940667"></p><p>1、如果对mmap的返回值ptr做++操作，可以，但是munmap错误。</p><p>2、如果open时O_RDONLY，mmap时prot参数指定PROT_READ | PROT_WRITE 会产生错误，返回MAP_FAILED；两者权限应该一致，mmap权限小于等于open才对。</p><p>3、如果文件偏移量为1000，offset必须是4k的整数倍，所以会报错返回map_failed。</p><p>4、mmap什么情况下回调用失败？第二个参数length = 0， 第三个参数prot只指定了写权限。或者和open不一致会报错。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713151649555.png" alt="image-20220713151649555"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713151752961.png" alt="image-20220713151752961"></p><h3 id="使用内存映射实现文件拷贝的功能"><a href="#使用内存映射实现文件拷贝的功能" class="headerlink" title="使用内存映射实现文件拷贝的功能"></a>使用内存映射实现文件拷贝的功能</h3><p>把english.txt复制为cpy.txt</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713151957260.png" alt="image-20220713151957260"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713152315628.png" alt="image-20220713152315628"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713152434989.png" alt="image-20220713152434989"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713152512439.png" alt="image-20220713152512439"></p><p>之前为文件映射，下面为<strong>匿名映射 MAP_ANONYMOUS</strong> 。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713152941820.png" alt="image-20220713152941820"></p><p>内存映射为非阻塞的。 子进程读取，父进程写。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713153100366.png" alt="image-20220713153100366"></p><hr><h2 id="2-19-信号概述"><a href="#2-19-信号概述" class="headerlink" title="2.19 信号概述"></a>2.19 信号概述</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713153253383.png" alt="image-20220713153253383"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713153613482.png" alt="image-20220713153613482"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713153821911.png" alt="image-20220713153821911"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713153901814.png" alt="image-20220713153901814"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713153946392.png" alt="image-20220713153946392"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154013335.png" alt="image-20220713154013335"></p><p> <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154048465.png" alt="image-20220713154048465"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154055618.png" alt="image-20220713154055618"></p><p>针对core文件</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154842933.png" alt="image-20220713154842933"></p><p>用了buf野内存。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154912388.png" alt="image-20220713154912388"></p><p>要设置core文件</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154625742.png" alt="image-20220713154625742"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713155039196.png" alt="image-20220713155039196"></p><p>gdb a.out来调试，产生信号11。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713155148421.png" alt="image-20220713155148421"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713154413309.png" alt="image-20220713154413309"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713160018537.png" alt="image-20220713160018537"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713160111686.png" alt="image-20220713160111686"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713160135830.png" alt="image-20220713160135830"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713160419641.png" alt="image-20220713160419641"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713160442910.png" alt="image-20220713160442910"></p><hr><h2 id="2-21-alarm函数"><a href="#2-21-alarm函数" class="headerlink" title="2.21 alarm函数"></a>2.21 alarm函数</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713160937737.png" alt="image-20220713160937737"></p><p>alarm（100）是不阻塞的。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713161131386.png" alt="image-20220713161131386"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713161145062.png" alt="image-20220713161145062"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713162237088.png" alt="image-20220713162237088"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713162352329.png" alt="image-20220713162352329"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713162644561.png" alt="image-20220713162644561"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713164815325.png" alt="image-20220713164815325"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713171214771.png" alt="image-20220713171214771"></p><p>过3s吼，每隔2秒定时一次。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713165638806.png" alt="image-20220713165638806"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713170125850.png" alt="image-20220713170125850"></p><p>立马调用“定时器开始了， 因为setitimer是非阻塞的。应该是每隔两秒钟发送一个信号，把进程杀死了，因为没有信号捕捉，所以没有定时的效果。</p><hr><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713172022840.png" alt="image-20220713172022840"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713172712393.png" alt="image-20220713172712393"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713182100095.png" alt="image-20220713182100095"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713183123518.png" alt="image-20220713183123518"></p><hr><h2 id="2-24信号集"><a href="#2-24信号集" class="headerlink" title="2.24信号集"></a>2.24信号集</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713184355053.png" alt="image-20220713184355053"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713184959698.png" alt="image-20220713184959698"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713185257423.png" alt="image-20220713185257423"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713185450518.png" alt="image-20220713185450518"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713185441191.png" alt="image-20220713185441191"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713185727380.png" alt="image-20220713185727380"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713185630069.png" alt="image-20220713185630069"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713185706086.png" alt="image-20220713185706086"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713190200384.png" alt="image-20220713190200384"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713190225161.png" alt="image-20220713190225161"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713190258103.png" alt="image-20220713190258103"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220713190611343.png" alt="image-20220713190611343"></p><hr><p>之前都是对用户自定义的信号集进行操作。如果想对内核的信号集进行操作。只能sigprocmask，对系统中的阻塞信号集进行操作，想获取阻塞信号集或者设置阻塞信号集。通过sigprocmask把自定义的系统信号集设置到内核中，</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714005733605.png" alt="image-20220714005733605"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714005809132.png" alt="image-20220714005809132"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714005919493.png" alt="image-20220714005919493"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714012506081.png" alt="image-20220714012506081"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714010119582.png" alt="image-20220714010119582"></p><p>按了ctrl+c和ctrl+\ </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714010413244.png" alt="image-20220714010413244"></p><p>然后只能新建会话kill -9杀死。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714010508133.png" alt="image-20220714010508133"></p><p>或者可以输入&amp; 以后台方式运行，还可响应其他指令。 此时再ctrl+c，或\</p><p>输入fg转为前台。 </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714010845622.png" alt="image-20220714010845622"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714010911746.png" alt="image-20220714010911746"></p><hr><h2 id="2-26-信号捕捉函数sigaction"><a href="#2-26-信号捕捉函数sigaction" class="headerlink" title="2.26 信号捕捉函数sigaction"></a>2.26 信号捕捉函数sigaction</h2><p>signum 可以是任何有效信号，除了SIGKILL和SIGSTOP（不能被捕捉）。</p><p> <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714101044645.png" alt="image-20220714101044645"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714101256982.png" alt="image-20220714101256982"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714102818217.png" alt="image-20220714102818217"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714103146248.png" alt="image-20220714103146248"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714103308334.png" alt="image-20220714103308334"></p><hr><h2 id="2-27-SIGCHLD信号"><a href="#2-27-SIGCHLD信号" class="headerlink" title="2.27 SIGCHLD信号"></a>2.27 SIGCHLD信号</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714104140287.png" alt="image-20220714104140287"></p><p>使用SIGCHLD信号解决僵尸进程问题。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714105452323.png" alt="image-20220714105452323"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714105421067.png" alt="image-20220714105421067"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714105145067.png" alt="image-20220714105145067"></p><p> <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714105512496.png" alt="image-20220714105512496"></p><p>同时有3个子进程死亡，在未决信号集处理信号的回调函数时，无法响应其他信号。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714105747442.png" alt="image-20220714105747442"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714105956236.png" alt="image-20220714105956236"></p><p>会出现段错误。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714110408486.png" alt="image-20220714110408486" style="zoom: 50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714110451684.png" alt="image-20220714110451684" style="zoom:67%;" /></p><hr><h2 id="2-28-共享内存"><a href="#2-28-共享内存" class="headerlink" title="2.28 共享内存"></a>2.28 共享内存</h2><p>比内存映射效率高，内存映射需要关联一个文件，</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714112130286.png" alt="image-20220714112130286"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714113340274.png" alt="image-20220714113340274"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714113656491.png" alt="image-20220714113656491"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="keyword">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="keyword">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="keyword">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="keyword">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>shmctl ：创建共享内存的进程被销毁了，对共享内存是没有任何影响的。</p><p>在write_shm.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在read_shm.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714140417147.png" alt="image-20220714140417147"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714140428610.png" alt="image-20220714140428610"></p><p>之前的实验是通过随便取的100内存，应该用ftok：根据指定的路径名，和int值，生成一个共享内存的key</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714140904302.png" alt="image-20220714140904302"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题1：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714141051334.png" alt="image-20220714141051334"></p><p>键100转为0x64,如果有一个读一个写，那么状态数就为2了</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714141129189.png" alt="image-20220714141129189"></p><p>如果将其中一个读进程结束了，键变成0，共享内存被标记删除。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714141403061.png" alt="image-20220714141403061"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714141742551.png" alt="image-20220714141742551"></p><p>ipcrm -m 4只是标记了删除，连接数没有删，当其他进程ctrl + c，状态数才变0.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">问题<span class="number">2</span>：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为<span class="number">0</span>的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为<span class="number">0</span>的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">共享内存和内存映射的区别</span><br><span class="line"><span class="number">1.</span>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="line"><span class="number">2.</span>共享内存效果更高</span><br><span class="line"><span class="number">3.</span>内存</span><br><span class="line">    所有的进程操作的是同一块共享内存。</span><br><span class="line">    内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="line"><span class="number">4.</span>数据安全</span><br><span class="line">    - 进程突然退出</span><br><span class="line">        共享内存还存在</span><br><span class="line">        内存映射区消失</span><br><span class="line">    - 运行进程的电脑死机，宕机了</span><br><span class="line">        数据存在在共享内存中，没有了</span><br><span class="line">        内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="line"><span class="number">5.</span>生命周期</span><br><span class="line">    - 内存映射区：进程退出，内存映射区销毁</span><br><span class="line">    - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为<span class="number">0</span>），或者关机</span><br><span class="line">        如果一个进程退出，会自动和共享内存进行取消关联。</span><br></pre></td></tr></table></figure><hr><h2 id="2-30-守护进程"><a href="#2-30-守护进程" class="headerlink" title="2.30 守护进程"></a>2.30 守护进程</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714145944446.png" alt="image-20220714145944446"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714150116296.png" alt="image-20220714150116296"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714150131600.png" alt="image-20220714150131600"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714150140913.png" alt="image-20220714150140913"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714150309918.png" alt="image-20220714150309918"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714150600775.png" alt="image-20220714150600775"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714150850261.png" alt="image-20220714150850261"></p><p>1、在终端上 输入指令 find查找2，重定向到/dev/null 设备上，管道符会创建子进程，&amp;在后台运行。是后台进程。</p><p>2、在shell中，默认没有会话 没有组，pid为400，创建ppid，然后创建出一个组 ，创建出的会话pid也是400，默认是后台程序。</p><p>3、运行find，创建新的进程组，首进程是658，父进程是bash 的400，组PGID是658，会话进程是400。 </p><p>4、sort是前台运行，是前台运行组，而bash和find是后台进程组。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714151125316.png" alt="image-20220714151125316" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714151211201.png" alt="image-20220714151211201"></p><p>后台服务进程，生命周期长，不拥有控制终端。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714152110355.png" alt="image-20220714152110355"></p><p>1、为什么 父进程退出</p><p>命令行启动进程，如果不退出父进程，父进程死了之后，shell会提供shell提示符。</p><p>使用fork可以确保子进程不会成为进程组的首进程。</p><p>2、子进程开启新会话，组id和进程id一样，又成为会话的id。要脱离控制终端。 </p><h3 id="写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。"><a href="#写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。" class="headerlink" title="写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。"></a>写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。</h3><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714153957356.png" alt="image-20220714153957356" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714154206911.png" alt="image-20220714154206911" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714155024113.png" alt="image-20220714155024113" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220714154723472.png" alt="image-20220714154723472"></p>]]></content>
    
    
    <summary type="html">Linux高并发服务器开发第二章</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>牛客网项目记录-第一章linux系统编程入门</title>
    <link href="https://tsuiwade.github.io/2022/07/07/blog51-nowcoderProject1/"/>
    <id>https://tsuiwade.github.io/2022/07/07/blog51-nowcoderProject1/</id>
    <published>2022-07-07T10:37:42.000Z</published>
    <updated>2022-07-07T10:37:42.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="1-2GCC"><a href="#1-2GCC" class="headerlink" title="1.2GCC"></a>1.2GCC</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707104035969.png" alt="image-20220707104035969"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707103826857.png" alt="image-20220707103826857"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707234008969.png" alt="image-20220707234008969"></p><p>gcc test.c -E -o test.i 将源代码 经过预处理器 转换为预处理后源代码</p><p>gcc test.i -S -o test.s 将预处理后源代码 经过编译器 编译成汇编语言</p><p>gcc test.s -s -o test.o 将汇编语言 经过汇编器 汇编成目标代码（二进制文件）</p><p>./test.o 可以执行</p><p>gcc test.c -S 直接生成test.s</p><p>gcc test.c 直接生成a.out</p><p>gcc test.c -o test 生成可执行文件test</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707104106542.png" alt="image-20220707104106542"></p><hr><p>1.4 静态库的制作和使用</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707162622123.png" alt="image-20220707162622123"></p><p>lesson04下面有calc和library</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707211708002.png" alt="image-20220707211708002"></p><p>calc目录下</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707163507506.png" alt="image-20220707163507506"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707163558574.png" alt="image-20220707163558574"></p><p>library目录下，文件基本同calc中文件</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707212819186.png" alt="image-20220707212819186"></p><p>将静态库文件拷贝到library/lib下</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707213127527.png" alt="image-20220707213127527"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707213245664.png" alt="image-20220707213245664"></p><p> 在main中使用库文件 </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707213410642.png" alt="image-20220707213410642"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707213541008.png" alt="image-20220707213541008"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707164322392.png" alt="image-20220707164322392"></p><p>或者在library/src文件夹下</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707214201467.png" alt="image-20220707214201467"></p><hr><h2 id="1-6-动态库的制作和使用"><a href="#1-6-动态库的制作和使用" class="headerlink" title="1.6 动态库的制作和使用"></a>1.6 动态库的制作和使用</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707164605558.png" alt="image-20220707164605558"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707164918390.png" alt="image-20220707164918390"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707223732478.png" alt="image-20220707223732478"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707223928765.png" alt="image-20220707223928765"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707165332730.png" alt="image-20220707165332730"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707165444349.png" alt="image-20220707165444349"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707224945116.png" alt="image-20220707224945116"></p><p>有问题， 需要动态库加载到内存当中</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707230434407.png" alt="image-20220707230434407"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707230643122.png" alt="image-20220707230643122"></p><p>输入env输出环境变量</p><p>解决方法1</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707231740047.png" alt="image-20220707231740047"></p><p>$ 原有变量 ：增加新变量</p><p>此时仅在会话级别可行，新开会话不可行。</p><p>解决方法2，用户级别配置，根目录~下</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707232016476.png" alt="image-20220707232016476"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707232102006.png" alt="image-20220707232102006"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707232156867.png" alt="image-20220707232156867"></p><p>使其生效</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707232436634.png" alt="image-20220707232436634"></p><p>最后一样</p><p>方法4：修改/etc/ld.so.cache文件列表 里面是二进制数据，需要间接修改</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707233158730.png" alt="image-20220707233158730"></p><p>sudo vim /etc/ld.so.conf</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707233111497.png" alt="image-20220707233111497"></p><hr><p>动态库和静态库的优缺点</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707234615271.png" alt="image-20220707234615271"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220707234752872.png" alt="image-20220707234752872"></p><hr><h2 id="1-10-makefile"><a href="#1-10-makefile" class="headerlink" title="1.10 makefile"></a>1.10 makefile</h2><p>在项目src文件夹下make指令</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708095030870.png" alt="image-20220708095030870"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708094453324.png" alt="image-20220708094453324"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708094309244.png" alt="image-20220708094309244"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708094938348.png" alt="image-20220708094938348"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708095911920.png" alt="image-20220708095911920"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708100317745.png" alt="image-20220708100317745"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708100203735.png" alt="image-20220708100203735"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708101408184.png" alt="image-20220708101408184"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708100416196.png" alt="image-20220708100416196"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708100606699.png" alt="image-20220708100606699"></p><p>删除依赖 make clean</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708100930274.png" alt="image-20220708100930274"></p><hr><h2 id="1-13-GDB调试"><a href="#1-13-GDB调试" class="headerlink" title="1.13 GDB调试"></a>1.13 GDB调试</h2><p> <img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708104655779.png" alt="image-20220708104655779"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708103904874.png" alt="image-20220708103904874"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708104440816.png" alt="image-20220708104440816"></p><p>没加调试信息就小点。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708105455704.png" alt="image-20220708105455704"></p><p>输入list，显示10行</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708114141209.png" alt="image-20220708114141209"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708114550493.png" alt="image-20220708114550493"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708114637397.png" alt="image-20220708114637397"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708115114472.png" alt="image-20220708115114472"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708134856843.png" alt="image-20220708134856843"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708135029955.png" alt="image-20220708135029955"></p><hr><h2 id="1-17-文件IO"><a href="#1-17-文件IO" class="headerlink" title="1.17 文件IO"></a>1.17 文件IO</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708142349617.png" alt="image-20220708142349617"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708160455300.png" alt="image-20220708160455300"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708160948453.png" alt="image-20220708160948453"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708162755823.png" alt="image-20220708162755823"></p><h2 id="1-20-open-打开文件"><a href="#1-20-open-打开文件" class="headerlink" title="1.20 open 打开文件"></a>1.20 open 打开文件</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709002625234.png" alt="image-20220709002625234"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708213355579.png" alt="image-20220708213355579" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708213611066.png" alt="image-20220708213611066"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708213910568.png" alt="image-20220708213910568" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708213825026.png" alt="image-20220708213825026" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708214013338.png" alt="image-20220708214013338"></p><p>三参数的open函数</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708215043338.png" alt="image-20220708215043338"></p><p>rwx read/write/执行权限</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708215002576.png" alt="image-20220708215002576"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708215246114.png" alt="image-20220708215246114" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708215329505.png" alt="image-20220708215329505"></p><hr><h2 id="1-22-read-write函数"><a href="#1-22-read-write函数" class="headerlink" title="1.22 read write函数"></a>1.22 read write函数</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708220033643.png" alt="image-20220708220033643"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220708220158280.png" alt="image-20220708220158280"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709002426032.png" alt="image-20220709002426032" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709002259381.png" alt="image-20220709002259381" style="zoom:50%;" /></p><hr><h2 id="1-23-lseek函数"><a href="#1-23-lseek函数" class="headerlink" title="1.23 lseek函数"></a>1.23 lseek函数</h2><p>用来重新定位文件读写的位移</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件大小 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="keyword">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="1-24-stat-lstat"><a href="#1-24-stat-lstat" class="headerlink" title="1.24 stat lstat"></a>1.24 stat lstat</h2><p>获取一个文件相关的一些信息</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709085617664.png" alt="image-20220709085617664"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span>, &amp;statbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709085805573.png" alt="image-20220709085805573"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709085854663.png" alt="image-20220709085854663"></p><p><strong>lstat 获取软连接信息，而stat会获取指向文件的信息</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709090638561.png" alt="image-20220709090638561"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709090650423.png" alt="image-20220709090650423"></p><hr><h2 id="1-25-模拟实现ls-l-命令"><a href="#1-25-模拟实现ls-l-命令" class="headerlink" title="1.25 模拟实现ls -l 命令"></a>1.25 模拟实现ls -l 命令</h2><p>想实现下图功能</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709090928800.png" alt="image-20220709090928800"></p><p>获取文件类型和文件权限</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709092833342.png" alt="image-20220709092833342"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现 ls -l 指令</span></span><br><span class="line"><span class="comment">// -rw-rw-r-- 1 nowcoder nowcoder 12 12月  3 15:48 a.txt</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断输入的参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过stat函数获取用户传入的文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件类型和文件权限</span></span><br><span class="line">    <span class="keyword">char</span> perms[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 用于保存文件类型和文件权限的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(st.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬连接数</span></span><br><span class="line">    <span class="keyword">int</span> linkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="keyword">char</span> * fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    <span class="keyword">char</span> * fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> fileSize = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改的时间</span></span><br><span class="line">    <span class="keyword">char</span> * time = ctime(&amp;st.st_mtime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> mtime[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime, time, <span class="built_in">strlen</span>(time) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709093234697.png" alt="image-20220709093234697"></p><hr><h2 id="1-26-文件属性操作函数access-chmod-chown-truncate"><a href="#1-26-文件属性操作函数access-chmod-chown-truncate" class="headerlink" title="1.26 文件属性操作函数access/chmod/chown/truncate"></a>1.26 文件属性操作函数access/chmod/chown/truncate</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709093328241.png" alt="image-20220709093328241"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 判断的文件路径</span></span><br><span class="line"><span class="comment">            - mode:</span></span><br><span class="line"><span class="comment">                R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">                W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">                X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">                F_OK: 判断文件是否存在</span></span><br><span class="line"><span class="comment">        返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在！！!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - mode:需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vim /etc/passwd</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709095934609.png" alt="image-20220709095934609"></p><p>vim /etc/group</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709100008469.png" alt="image-20220709100008469" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709100042295.png" alt="image-20220709100042295" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用：缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-27-目录操作函数-mkdir等"><a href="#1-27-目录操作函数-mkdir等" class="headerlink" title="1.27 目录操作函数 mkdir等"></a>1.27 目录操作函数 mkdir等</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709100717934.png" alt="image-20220709100717934"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            返回的指向的一块内存，这个数据就是第一个参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int rename(const char *oldpath, const char *newpath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = rename(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;rename&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709101242804.png" alt="image-20220709101242804" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709101657349.png" alt="image-20220709101657349" style="zoom:50%;" /></p><hr><h2 id="1-28-目录遍历函数opendir-readdir-closedir"><a href="#1-28-目录遍历函数opendir-readdir-closedir" class="headerlink" title="1.28 目录遍历函数opendir/readdir/closedir"></a>1.28 目录遍历函数opendir/readdir/closedir</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709101735515.png" alt="image-20220709101735515" style="zoom:67%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709101945277.png" alt="image-20220709101945277" style="zoom:50%;" /></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709102100519.png" alt="image-20220709102100519"></p><p>例子 读取某目录下所有的普通文件个数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取某个目录下所有的普通文件的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数为：%d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于获取目录下所有普通文件的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开目录</span></span><br><span class="line">    DIR * dir = opendir(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录普通文件的个数</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取名称</span></span><br><span class="line">        <span class="keyword">char</span> * dname = ptr-&gt;d_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略掉. 和..</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是普通文件还是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 目录,需要继续读取这个目录</span></span><br><span class="line">            <span class="keyword">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s/%s&quot;</span>, path, dname);</span><br><span class="line">            total += getFileNum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220721110809106.png" alt="image-20220721110809106"></p><hr><h2 id="1-29-dup函数"><a href="#1-29-dup函数" class="headerlink" title="1.29 dup函数"></a>1.29 dup函数</h2><p>复制文件描述符</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709104010554.png" alt="image-20220709104010554" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">        作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">        fd=3, int fd1 = dup(fd),</span></span><br><span class="line"><span class="comment">        fd指向的是a.txt, fd1也是指向a.txt</span></span><br><span class="line"><span class="comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">int</span> fd1 = dup(fd);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709104522066.png" alt="image-20220709104522066"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup2(int oldfd, int newfd);</span></span><br><span class="line"><span class="comment">        作用：重定向文件描述符</span></span><br><span class="line"><span class="comment">        oldfd 指向 a.txt, newfd 指向 b.txt</span></span><br><span class="line"><span class="comment">        调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span></span><br><span class="line"><span class="comment">        oldfd 必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment">        oldfd和newfd值相同，相当于什么都没有做</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709105521984.png" alt="image-20220709105521984"></p><hr><h2 id="1-30-fcntl函数"><a href="#1-30-fcntl函数" class="headerlink" title="1.30 fcntl函数"></a>1.30 fcntl函数</h2><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220709105622552.png" alt="image-20220709105622552" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        fd : 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">        cmd: 表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">                int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_SETFL : 设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment">              可选性：O_APPEND, O)NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                NONBLOK 设置成非阻塞</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        阻塞和非阻塞：描述的是函数调用的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件描述符状态flag</span></span><br><span class="line">    <span class="keyword">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_APPEND;   <span class="comment">// flag = flag | O_APPEND</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux高并发服务器开发第一章</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 并发</title>
    <link href="https://tsuiwade.github.io/2022/07/06/blog50-CPP-Concurrency-In-Action/"/>
    <id>https://tsuiwade.github.io/2022/07/06/blog50-CPP-Concurrency-In-Action/</id>
    <published>2022-07-06T14:45:05.000Z</published>
    <updated>2022-07-06T14:45:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>力扣1114 <a href="https://leetcode.cn/problems/print-in-order/solution/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi/">https://leetcode.cn/problems/print-in-order/solution/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi/</a></p><p>1、互斥量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证俩代码不会同时执行</span></span><br><span class="line"><span class="comment">// c++11并发与多线程视频课程_2_5</span></span><br><span class="line">mutex myMutex1;</span><br><span class="line"></span><br><span class="line">    myMutex1.lock();</span><br><span class="line">    <span class="comment">// code 1 </span></span><br><span class="line">    myMutex1.unlock();</span><br><span class="line"></span><br><span class="line">    myMutex1.lock();</span><br><span class="line">    <span class="comment">// code 2</span></span><br><span class="line">    myMutex1.unlock();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误代码  </span></span><br><span class="line"><span class="comment">// 根据 c++ 标准，在一个线程尝试对一个 mutex 对象进行 unlock 操作时，mutex 对象的所有权必须在这个线程上；也就是说，应该由同一个线程来对一个 mutex 对象进行 lock 和 unlock 操作，否则会产生未定义行为。题目中提到了 first, second, third 三个函数分别是由三个不同的线程来调用的，但我们是在 Foo 对象构造时（可以是在 create 这几个线程的主线程中，也可以是在三个线程中的任意一个）对两个 mutex 对象进行 lock 操作的，因此，调用 first 和 second 函数的两个线程中至少有一个在尝试获取其他线程所拥有的 mutex 对象的所有权。</span></span><br><span class="line"><span class="comment">// 一把锁的上锁与解锁在不同线程中进行，在windows上会报错，在Linux上不会报错，可能力扣用的跑代码的机器是Linux所以这样不会出现问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    mutex mtx1, mtx2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        mtx1.lock(), mtx2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        printFirst();</span><br><span class="line">        mtx1.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        mtx1.lock();</span><br><span class="line">        printSecond();</span><br><span class="line">        mtx1.unlock();</span><br><span class="line">        mtx2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        mtx2.lock();</span><br><span class="line">        printThird();</span><br><span class="line">        mtx2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们只是通过 mutex 的机制来保护数据被同时访问，所以最好使用 lock_guard 或者 unique_lock 提供的 RAII 机制来管理 mutex 对象，而不是直接操作 mutex 对象；其中 lock_guard 只拥有构造和析构函数，用来实现 RAII 机制，而 unique_lock 是一个完整的 mutex 所有权包装器，封装了所有 mutex 的函数：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    mutex mtx_1, mtx_2;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock_1, lock_2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() : lock_1(mtx_1, try_to_lock), lock_2(mtx_2, try_to_lock) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        printFirst();</span><br><span class="line">        lock_1.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx_1)</span></span>;</span><br><span class="line">        printSecond();</span><br><span class="line">        lock_2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx_2)</span></span>;</span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><p>2、条件变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        printFirst();</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        cv.notify_all();    <span class="comment">// 通知其他所有在等待唤醒队列中的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;   <span class="comment">// lock mtx</span></span><br><span class="line">        cv.wait(lock, [<span class="keyword">this</span>]()&#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);  <span class="comment">// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 1 才能继续运行</span></span><br><span class="line">        printSecond();</span><br><span class="line">        k = <span class="number">2</span>;</span><br><span class="line">        cv.notify_one();    <span class="comment">// 随机通知一个（unspecified）在等待唤醒队列中的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;   <span class="comment">// lock mtx</span></span><br><span class="line">        cv.wait(lock, [<span class="keyword">this</span>]()&#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);  <span class="comment">// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 2 才能继续运行</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><a href="https://yelinji.gitbooks.io/cpp_concurrency_in_action/content/">https://yelinji.gitbooks.io/cpp_concurrency_in_action/content/</a>  作为对《C++ Concurrency in Action》的中文翻译。</p><hr><p>1.4</p><p>清单 1.1 一个简单的Hello, Concurrent World程序：</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  //①</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  <span class="comment">//②</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">//③</span></span><br><span class="line">  t.join();  <span class="comment">//④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>2.1线程管理的基础</p><p><code>std::thread</code>可以用可调用类型构造，将带有函数调用符类型的实例传入<code>std::thread</code>类中，替换默认的构造函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    do_something();</span><br><span class="line">    do_something_else();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">作为对《C++ Concurrency in Action》的中文翻译。</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://tsuiwade.github.io/2022/07/06/blog49-segmentTree/"/>
    <id>https://tsuiwade.github.io/2022/07/06/blog49-segmentTree/</id>
    <published>2022-07-06T11:18:59.000Z</published>
    <updated>2022-07-06T11:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>针对力扣307题，找到题解 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/">https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/</a></p><p><strong>线段树解决的是「区间和」的问题，且该「区间」会被修改</strong></p><p>所以<strong>线段树</strong>主要实现两个方法：「求区间和」&amp;&amp;「修改区间」，且时间复杂度均为 <code>O(logn)</code></p><p>始终记住一句话：<strong>线段树的每个节点代表一个区间</strong></p><p>从图中可以看到，每个节点代表一个区间，而节点的值就是该区间的和 (其实还可以根据题目问题，改变表示的含义！！)</p><p>数字之和「总数字之和 = 左区间数字之和 + 右区间数字之和」<br>最大公因数 (GCD)「总 GCD = gcd(左区间 GCD, 右区间 GCD)」<br>最大值「总最大值 = max(左区间最大值，右区间最大值)」</p><p>不符合区间加法的例子：</p><ul><li>众数「只知道左右区间的众数，没法求总区间的众数」</li><li>01 序列的最长连续零「只知道左右区间的最长连续零，没法知道总的最长连续零」</li></ul><hr><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; segmentTree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            segmentTree[node] = nums[start];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        build(node * <span class="number">2</span> + <span class="number">1</span>, start, mid, nums);</span><br><span class="line">        build(node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end, nums);</span><br><span class="line">        segmentTree[node] = segmentTree[node * <span class="number">2</span> + <span class="number">1</span>] + segmentTree[node * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            segmentTree[node] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">            change(index, val, node * <span class="number">2</span> + <span class="number">1</span>, start, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            change(index, val, node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">        segmentTree[node] = segmentTree[node * <span class="number">2</span> + <span class="number">1</span>] + segmentTree[node * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == start &amp;&amp; right == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> segmentTree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> range(left, right, node * <span class="number">2</span> + <span class="number">1</span>, start, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> range(left, right, node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> range(left, mid, node * <span class="number">2</span> + <span class="number">1</span>, start, mid) + range(mid + <span class="number">1</span>, right, node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : n(nums.size()), segmentTree(nums.size() * <span class="number">4</span>) &#123;</span><br><span class="line">        build(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        change(index, val, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> range(left, right, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></h2><p>针对力扣307题的题解 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/">https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/</a></p><ul><li>对于表示为「区间和」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！) 如题目 最近的请求次数</li><li>对于表示为「区间和」且对区间进行「覆盖」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『不需要累加』！！(因为是覆盖操作！！) 如题目 区域和检索 - 数组可修改</li><li>对于表示为「区间最值」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『不需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！ 如题目 我的日程安排表 I、我的日程安排表 III</li></ul><p>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;针对力扣307题，找到题解 &lt;a href=&quot;https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/&quot;&gt;https://leetcode.cn/problems/range-s</summary>
      
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>不同文件共享函数的使用问题</title>
    <link href="https://tsuiwade.github.io/2022/07/01/blog48-extern/"/>
    <id>https://tsuiwade.github.io/2022/07/01/blog48-extern/</id>
    <published>2022-07-01T16:18:41.000Z</published>
    <updated>2022-07-01T16:18:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="情景描述："><a href="#情景描述：" class="headerlink" title="情景描述："></a>情景描述：</h4><p>在qt的mainwindow.cpp下想使用udpthread.cpp下的函数，遇到定义的错误。</p><p>初始代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">直接使用BLEndianUint32</span><br><span class="line"><span class="comment">// udpthread.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现</p><p>error: use of undeclared identifier ‘BLEndianUint32’问题</p><hr><p>解决方法1：类的定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpThread</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// udpthread.cpp</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span>  <span class="title">udpThread::BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line">    udpThread *MyUdp;</span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line">    MyUdp = <span class="keyword">new</span> udpThread;</span><br><span class="line">    value = MyUdp-&gt;BLEndianUint32(value);</span><br></pre></td></tr></table></figure><p>BLEndianUint32函数写成udpthread类的公有成员</p><p>而在mainwindow中实例化一个对象MyUdp，再调用函数BLEndianUint32。</p><p>或者在类中直接定义也可以。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpThread</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br></pre></td></tr></table></figure><p>或者把成员函数声明成静态函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpThread</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line">    value = MyUdp-&gt;BLEndianUint32(value);  <span class="comment">// 1</span></span><br><span class="line">    value = udpThread::BLEndianUint32(value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>来源于 <a href="https://blog.csdn.net/weixin_43222324/article/details/99707095">https://blog.csdn.net/weixin_43222324/article/details/99707095</a></p><p>下面我们来分析一下为什么可以这样改       </p><p>（1）为什么要实例化</p><pre><code>   仍然以上面的类Student为例。类Student表示学生，这是一个抽象的概念，表示的是所有学生。实例化一个对象Student XiaoWang;，这个对象表示的是具体的学生小王，你还可以实例化别的对象比如小张、小刘、小李、小周、小赵等等，这些对象都是具体的某个学生。   类的成员函数getAge()的意思是得到学生的年龄，我们最直观的理解就是，学生的年龄那肯定是某一个具体的学生的年龄，如果你用Student.getAge()的方法调用年龄函数，那究竟得到的是哪个学生的年龄呢？所以对于这种非静态成员函数，我们要实例化一个对象比如学生小王，我们调用XiaoWang.getAge()得到的就是小王的年龄。</code></pre><p>（2）为什么调用静态函数不需要实例化</p><pre><code>   仍然以上面的类Student为例。如果现在我们要得到所有学生的平均年龄该怎么办呢？假如现在类Student里增加了一个函数getAverageAge()，我们想得到所有学生的平均年龄，难道还要先实例化一个对象表示具体的学生，再通过这个对象得到平均年龄吗？   所有学生的平均年龄，是学生类Student的一个共同特点，我们可以把得到平均年龄函数声明成静态函数，static int getAverageAge();，然后无需实例化对象，直接通过Student::getAverageAge();的方式调用。   类的静态函数表示的是这个类的一个共同特点，静态函数是类的所有对象所共享的，不是某一个对象特有的，就像平均年龄是所有学生所共有的而不是某个学生所特有的，因此，静态函数不需要实例化对象，直接通过类名::函数名的方式就能调用。</code></pre><p>因此，在选择用上面两种方法中的哪一种方法的时候，需要根据你写的函数的意义。</p><p>（1）如果你写的函数表示的是对象特有的特性，比如学生的年龄函数，用第一种方法，实例化对象再调用函数，更好。<br>（2）如果你写的函数表示的是这个类的所有对象共享的特性，比如所有学生的平均年龄函数，用第二种方法，将该函数声明成静态函数，更好。<br>       当然用哪种方法都可以，只是说用对场景更好。</p><hr><p>解决方法2：内联函数</p><p>内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。所以C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个cpp中只出现一次就行。</p><p>来源于：<a href="https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/">https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在外就可以随意用BLEndianUint32了。</p><hr><p>解决方法3：extern基础函数？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint16</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>;</span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint16</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) | ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BLEndianUint16</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一次项目遇到的不同文件共享函数的使用问题，算是一个较为基础的问题，在此记录一下。</summary>
    
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/categories/c/"/>
    
    
    <category term="c++" scheme="https://tsuiwade.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>算法总结-图</title>
    <link href="https://tsuiwade.github.io/2022/06/30/blog47-algorithms/"/>
    <id>https://tsuiwade.github.io/2022/06/30/blog47-algorithms/</id>
    <published>2022-06-30T14:58:53.000Z</published>
    <updated>2022-06-30T14:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h4><p>「Kruskal 算法」是求解「加权无向图」的「最小生成树」的一种算法。</p><ol><li>所有边从小到大排序</li><li>依次加入最小生成树中，形成环则跳过</li><li>知道选择N-1条边为止</li></ol><p>LC. 1584</p><p>三元组：stl的对类，用户定义结构</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x != fa[x] ) </span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">                edges.push_back(<span class="built_in">make_pair</span>(dist(i,j), <span class="built_in">make_pair</span>(i, j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// sort(edges.begin(), edges.end()); 也可以</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [len, <span class="built_in">pair</span>] : edges ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(<span class="built_in">pair</span>.first) != find(<span class="built_in">pair</span>.second)) &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                unify(<span class="built_in">pair</span>.first, <span class="built_in">pair</span>.second);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>三元组写成用户定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x != fa[x] ) </span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="comment">// 注意此处</span></span><br><span class="line">        <span class="keyword">int</span> len, x, y;</span><br><span class="line">        Edge(<span class="keyword">int</span> len, <span class="keyword">int</span> x, <span class="keyword">int</span> y) : len(len), x(x), y(y) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">                <span class="comment">// edges.push_back(make_pair(dist(i,j), make_pair(i, j)));</span></span><br><span class="line">                edges.emplace_back(dist(i, j), i, j);  <span class="comment">// 注意此处</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123; </span><br><span class="line">            <span class="keyword">return</span> a.len &lt; b.len;  <span class="comment">// 注意此处</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [len, x, y] : edges ) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; len &lt;&lt; &quot; &quot; &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (find(x) != find(y)) &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> ( num == n ) <span class="keyword">break</span>;</span><br><span class="line">                unify(x, y);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并查集写成一个类</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    UnionFind (<span class="keyword">int</span> n) &#123;</span><br><span class="line">        fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x != fa[x] ) </span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">                edges.push_back(<span class="built_in">make_pair</span>(dist(i,j), <span class="built_in">make_pair</span>(i, j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [len, <span class="built_in">pair</span>] : edges ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.find(<span class="built_in">pair</span>.first) != uf.find(<span class="built_in">pair</span>.second)) &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                <span class="keyword">if</span> ( ++num == n ) <span class="keyword">break</span>;</span><br><span class="line">                uf.unify(<span class="built_in">pair</span>.first, <span class="built_in">pair</span>.second);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n2 log(n))，其中 n 是节点数。一般Kruskal 是O(mlogm) 的算法，但本题中m=n2</p><p>空间复杂度：O(n^2)，其中 n是节点数。并查集使用 O(n)的空间，边集数组需要使用 O(n^2) 的空间。</p><hr><h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p>在「Kruskal 算法」中，我们通过增加边数来扩大「最小生成树」；适用于稀疏图</p><p>在「Prim 算法」中，我们通过增加顶点来扩大「最小生成树」。适用于稠密图</p><p>「切分定理」指的是：在一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 生成树 到 各点的最短距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mindist[i] = dist(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        mindist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n<span class="number">-1</span>; k++) <span class="comment">// n-1次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i] &amp;&amp; minn &gt; mindist[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    minn = mindist[i]; <span class="comment">// 找最小值</span></span><br><span class="line">                    pos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cost += minn;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line">            mindist[pos] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i] &amp;&amp; dist(pos, i) &lt; mindist[i])</span><br><span class="line">                    mindist[i] = dist(pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Dijkstra-算法-ˈdeɪkstra"><a href="#Dijkstra-算法-ˈdeɪkstra" class="headerlink" title="Dijkstra 算法/ˈdɛɪkstra/."></a>Dijkstra 算法/ˈdɛɪkstra/.</h4><p>「Dijkstra 算法」解决的是加权有向图「单源最短路径」问题，其中该图的所有权重必须为非负数。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220629155416728.png" alt="image-20220629155416728"></p><p>LC 743 网络延迟时间</p><p>将所有节点分成两类：已确定从起点到当前点的最短路长度的节点，以及未确定从起点到当前点的最短路长度的节点（下面简称「未确定节点」和「已确定节点」）。</p><p>每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。</p><p>用节点 AA「更新」节点 BB 的意思是，用起点到节点 AA 的最短路长度加上从节点 AA 到节点 BB 的边的长度，去比较起点到节点 BB 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。</p><p>这里暗含的信息是：每次选择「未确定节点」时，起点到它的最短路径的长度可以被确定。</p><p>可以这样理解，因为我们已经用了每一个「已确定节点」更新过了当前节点，无需再次更新（因为一个点不能多次到达）。而当前节点已经是所有「未确定节点」中与起点距离最短的点，不可能被其它「未确定节点」更新。所以当前节点可以被归类为「已确定节点」。</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(n , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n , inf));</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; t : times ) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            dist[x][y] = t[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, inf)</span></span>;</span><br><span class="line">        mindist[k - <span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num = <span class="number">0</span>; num &lt; n; num++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( !visited[i] &amp;&amp; ( minn &gt; mindist[i] ) ) &#123;  <span class="comment">// 找最小值</span></span><br><span class="line">                    minn = mindist[i];</span><br><span class="line">                    pos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">                mindist[i] = min(mindist[i], mindist[pos] + dist[pos][i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = *max_element(mindist.begin(), mindist.end());</span><br><span class="line">        <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><h4 id="FLOYD"><a href="#FLOYD" class="headerlink" title="FLOYD"></a>FLOYD</h4><p>复杂度为O(n3 ) 的「多源汇最短路」算法 Floyd 算法进行求解，同时使用「邻接矩阵」来进行存图，可以得到「从任意起点出发，到达任意点。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220630140435434.png" alt="image-20220630140435434"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220630141653680.png" alt="image-20220630141653680"></p><p>A1,0 = 6，path 1,0 = 3; path 3,0 = 2; path 2,0 = -1 直接相连 </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">printPath</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> path[][max])</span> </span>&#123; <span class="comment">// i = 1, j = 0 </span></span><br><span class="line">    <span class="keyword">if</span> ( path[i][j] == <span class="number">-1</span> ) &#123; <span class="comment">/*直接输出*/</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> v = path[i][j]; <span class="comment">// path[1][0] = 3</span></span><br><span class="line">        printPath(i, mid, path);  <span class="comment">// path[1][3]</span></span><br><span class="line">        printPath(mid, j, path);  <span class="comment">// path[3][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外循环v为中间变量，Av，Pathv修改为v;内循环i，j ≠ v</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++ ) </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) </span><br><span class="line">            <span class="keyword">if</span> ( A[i][j] &gt; A[i][v] + A[v][j] ) &#123;</span><br><span class="line">                A[i][j] = A[i][v] + A[v][j];</span><br><span class="line">                path[i][j] = v;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></h2><h4 id="Bellman-Ford-算法（单源最短路径）"><a href="#Bellman-Ford-算法（单源最短路径）" class="headerlink" title="Bellman-Ford 算法（单源最短路径）"></a>Bellman-Ford 算法（单源最短路径）</h4><p>「Bellman-Ford 算法」虽然不能检测到「负权环图」的最短路径，但是它能检测到「图」中是否存在「负权环」。</p><p><strong>定理一：在一个有 N 个顶点的「非负权环图」中，两点之间的最短路径最多经过 N-1 条边。</strong></p><p><strong>定理二：「负权环」没有最短路径。</strong>环上 边权 为正为负，正权环图有最短距离。</p><p>DJ算法关注的是点，B-F算法关注的是边，动态规划</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220630175905930.png" alt="image-20220630175905930"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220630151237279.png" alt="image-20220630151237279"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220630151906670.png" alt="image-20220630151906670"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LC 743</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; dist(n); <span class="comment">// 存图方式</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; t : times ) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            dist[x].push_back( <span class="built_in">make_pair</span>(y, t[<span class="number">2</span>]) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// |V| - 1 次</span></span><br><span class="line">        mindist[k - <span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">bool</span> finished;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">1</span>; k++ ) &#123;<span class="comment">// n - 1 次</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++ ) &#123; <span class="comment">// 前一节点</span></span><br><span class="line">                <span class="keyword">if</span> ( mindist[u] == INT_MAX ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [ v, weight ] : dist[u] ) &#123;</span><br><span class="line">                    <span class="keyword">long</span> newV = mindist[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span> ( newV &lt; mindist[v] ) &#123;</span><br><span class="line">                        mindist[v] = newV;</span><br><span class="line">                        finished = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( finished ) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = *max_element(mindist.begin(), mindist.end());</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; dist(n); <span class="comment">// 存图方式</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; t : flights ) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = t[<span class="number">1</span>];</span><br><span class="line">            dist[x].push_back( <span class="built_in">make_pair</span>(y, t[<span class="number">2</span>]) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// |V| - 1 次</span></span><br><span class="line">        mindist[src] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; k + <span class="number">1</span>; kk++ ) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">newdist</span><span class="params">(mindist)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++ ) &#123; <span class="comment">// 前一节点</span></span><br><span class="line">                <span class="keyword">if</span> ( mindist[u] == INT_MAX ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [ v, weight ] : dist[u] ) &#123;</span><br><span class="line">                    <span class="keyword">long</span> newV = mindist[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span> ( newV &lt; newdist[v] ) &#123;</span><br><span class="line">                        newdist[v] = newV;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mindist.assign(newdist.begin(), newdist.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mindist[dst] == INT_MAX ? <span class="number">-1</span> : mindist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="基于「队列」优化的-Bellman-Ford-算法-—-SPFA-算法-Shortest-Path-Faster-Algorithm"><a href="#基于「队列」优化的-Bellman-Ford-算法-—-SPFA-算法-Shortest-Path-Faster-Algorithm" class="headerlink" title="基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法  Shortest Path Faster Algorithm"></a>基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法  Shortest Path Faster Algorithm</h3><p>「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。此时，我们就可以得到「图」中其他顶点到给定顶点的最短距离了。</p>]]></content>
    
    
    <summary type="html">总结了图的各种常见算法</summary>
    
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://tsuiwade.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>qt曲线图</title>
    <link href="https://tsuiwade.github.io/2022/04/08/blog46-myQChart/"/>
    <id>https://tsuiwade.github.io/2022/04/08/blog46-myQChart/</id>
    <published>2022-04-08T20:00:38.000Z</published>
    <updated>2022-04-08T20:00:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了做一个调节控制轴的上位机软件。</p><p>主要用到了QT chart， 并且大量学习内置的<code>example</code>，主要包括 QLineSeries、QSplineSeries，一个样条曲线和一个折线。</p><p>其中白色显示最为重要的RMS曲线，与黑色背景形成最鲜明对比。</p><p>还有一个QAreaSeries为了显示两个意义相同的位置信息（实际位置和设定位置），以亮蓝线表示实际位置，暗蓝色表示设定位置，中间的透明蓝表示两线围成的区域。</p><p>还有一个QStackedBarSeries，折叠柱状图，我的想法是设计红色为正误差，绿色为负误差，类似于股票的涨跌，其中柱状图包络线为实际值，并且整图来看，由于误差的累计在pid中是有所含义的，红绿色面积大小比较显眼。</p><p>还设置了多y轴，个人认为这是我设计最全的一个图了：各个颜色和图类分别表示不同的含义，我本想将左侧的红绿色y轴合二为一，但不太会且有bug，故放弃。</p><p>在图中还有点击图例的交互：实现图例闪烁和曲线现隐。</p><p>以及鼠标hover在scatter点上的显示反应。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220408194524894.png" alt="image-20220627204728330"></p><p>接下来还需要做协议的解析、动态调整y轴的范围、计算error值。计算rms值。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/image-20220627223625218.png" alt="image-20220627223625218"></p><p>最终经过调试完善项目界面如上图所示。</p><p>还添加了双轴双图显示、关掉界面再打开的文本框数据缓存功能、文本框重要数据的实时显示、qt chart的每隔一段时间更新画图、保存为csv文件的保存功能、status状态栏的qt组件控制、拖动条设置图像更新频率等功能。</p><p>源码已上传至github上。</p><hr><p>该代码前期耗费两周研究qt chart的诸多显示效果，结合项目实际意义设计最佳画图方案。后期结合望远镜实时数据，添加诸多功能。</p><hr><p>2022/6/27 还花时间修复了这半年来blog的一些问题。</p>]]></content>
    
    
    <summary type="html">使用了qt自带的qchart库实现一个多形态的曲线图，更好区分地进行调试，源码见仓库。</summary>
    
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/categories/qt/"/>
    
    
    <category term="qt" scheme="https://tsuiwade.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>研究一下星表</title>
    <link href="https://tsuiwade.github.io/2022/03/18/blog45-starCatalog/"/>
    <id>https://tsuiwade.github.io/2022/03/18/blog45-starCatalog/</id>
    <published>2022-03-18T17:24:41.000Z</published>
    <updated>2022-03-18T17:24:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/欧洲空间局/8769487">欧洲空间局</a>（ESA）在1989年8月8日成功地发射了依巴谷<a href="https://baike.baidu.com/item/天体测量卫星/15568941">天体测量卫星</a>，<a href="https://baike.baidu.com/item/依巴谷星表">依巴谷星表</a>和第谷星表是<a href="https://baike.baidu.com/item/依巴谷卫星/6240692">依巴谷卫星</a>的主要观测结果，依巴谷星表测定了约12万颗恒星，构成了均匀的<a href="https://baike.baidu.com/item/天球参考系/1453747">天球参考系</a>，极限星等达到13mag，其位置、自行与<a href="https://baike.baidu.com/item/视差">视差</a>的精度分别为±0.002″、±0.002″/yr、±0.002″。1997年在日本京都召开的IAU第23届大会给出了由212颗<a href="https://baike.baidu.com/item/河外致密射电源/9210040">河外致密射电源</a>构成的<a href="https://baike.baidu.com/item/国际天球参考系/15581252">国际天球参考系</a>（ICRS），决定由依巴谷星表取代已沿用10多年的FK5星表，成为ICRS在光学波段的实现，并将改进后的依巴谷框架称为依巴谷天球参考框架（HCRF）。</p><p>古希腊天文学家依巴谷以精确的天体测量著名于世，他发现了岁差，将三角学应用于天文学，首先提出了星等的概念并被后世进一步发展完善，被尊称为“方位天文学之父”。欧空局的依巴谷计划的英文缩写与依巴谷的名字非常相似，也正好纪念了这位天文学伟人。这项计划分为“依巴谷实验”和“第谷实验”两部分。前者最终测得118218颗恒星的高精度数据；后者测得数百万颗恒星的低精度数据。</p><h2 id="常用目视星表"><a href="#常用目视星表" class="headerlink" title="常用目视星表"></a>常用目视星表</h2><p>在实际应用中常用的目视星表中有：</p><p>（1）《<a href="https://baike.baidu.com/item/依巴谷星表">依巴谷星表</a>》（Hipparcos catalogue），简称HIP或HP</p><p>欧洲空间局（简称ESA）依巴谷<a href="https://baike.baidu.com/item/天体测量卫星/15568941">天体测量卫星</a>（Hipparcos）计划的主要成果。1997年发表的第2版，是位置精确度最高的科学数据，包括的恒星总数为120313个，极限星等为13等，精确度在千分之一弧秒，而第谷星表 列出的则略微超过1,050,000颗恒星。包括赤道坐标，自行，星等，光谱型、颜色、光谱型、视差、径向速度等信息。</p><p>（2）HD星表（Henry Draper Catalogue）或 耶鲁亮星星表编号HD。亨利·德雷伯星表（HD/HDE）</p><p>HD星表给出88 883颗恒星的2000年历元位置、星等、自行、光谱型等数据，是最传统的星表之一。耶鲁亮星星表包括25万颗全部 8等以上的恒星和很多暗达11等的恒星的著名星表。HD序号在没有拜耳字母或佛氏星数的恒星中被普遍的采用，在原始的HD星表中序号从1～225,300是依1900.0分点的赤经，从225,301～359,083是在1949年出版的亨利·德雷珀扩充星表中增加的，仍然使用HD表示。</p><p>（4）<a href="https://baike.baidu.com/item/SAO星表/6485132">SAO星表</a>（Smithsonian Astrophysical Observatory ，1966）史密松星表</p><p>SAO星表是天文观测最常用的星表，它给出了258 997颗星等亮于11m的恒星，有编号、自行值、光谱型、V星等，表内列有与HD星表和BD（DM）星表的交叉证认序号。</p><hr><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220321111520189.png" alt="image-20220321111520189"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220321121232624.png" alt="image-20220321121232624"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220321121314466.png" alt="image-20220321121314466"></p><p>能得到数据 也不知道怎么计算。。。</p><p>就用Stellarium里的数据吧</p>]]></content>
    
    
    <summary type="html">本文来研究一下依巴谷星表</summary>
    
    
    
    <category term="星表" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E8%A1%A8/"/>
    
    
    <category term="星表" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>编译Stellarium过程</title>
    <link href="https://tsuiwade.github.io/2022/03/15/blog44-buildStellarium/"/>
    <id>https://tsuiwade.github.io/2022/03/15/blog44-buildStellarium/</id>
    <published>2022-03-15T23:26:54.000Z</published>
    <updated>2022-03-15T23:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>首先下载qt，我这里使用的是qt5.14.2，下载挺快的。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316082552203.png" alt="image-20220316082852120"></p><p>We recommend to use Qt 5.12 or later. You must select Qt Script and msvc2017/msvc2019 among so many checkboxes.</p><p>Add <code>C:\Qt\Qt5.15.12</code> to your <code>PATH</code> variable - you should add string <code>C:\Qt\Qt5.15.12\msvc2019;C:\Qt\Qt5.15.12\msvc2019\bin</code> for 32-bit or <code>C:\Qt\Qt5.15.12\msvc2019_64;C:\Qt\Qt5.15.12\msvc2019_64\bin</code> for 64-bit to <code>PATH</code> variable. (Replace the version numbers of Qt and the version of Visual Studio (2017/2019) with the version that you have installed)</p><p><a href="https://github.com/Stellarium/stellarium/blob/master/BUILDING.md">https://github.com/Stellarium/stellarium/blob/master/BUILDING.md</a></p><p>接着下载github上stellarium的源码。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316082946891.png" alt="image-20220316082946891"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316084705332.png" alt="image-20220316084705332"></p><p>接着下载cmake </p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316083021304.png" alt="image-20220316083021304"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316085856109.png" alt="image-20220316085856109"></p><p>接着将stellarium文件中的CMakeLists.txt拖进qt creator中，将自动能展开，但出现一些问题</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220315234126876.png" alt="image-20220315234126876"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316085005174.png" alt="image-20220316085005174"></p><p>然后稍微改改字符，就可以运行了。</p><p>对代码的修改如下：</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img//img/image-20220316111236063.png" alt="image-20220316111236063"></p>]]></content>
    
    
    <summary type="html">由于莫名的原因，Stellarium编译运行出问题了，于是我重新进行进行配置，在此进行记录。</summary>
    
    
    
    <category term="Stellarium" scheme="https://tsuiwade.github.io/categories/Stellarium/"/>
    
    
    <category term="Stellarium" scheme="https://tsuiwade.github.io/tags/Stellarium/"/>
    
  </entry>
  
  <entry>
    <title>Zone Model</title>
    <link href="https://tsuiwade.github.io/2022/03/09/blog43-zoneModel/"/>
    <id>https://tsuiwade.github.io/2022/03/09/blog43-zoneModel/</id>
    <published>2022-03-09T16:40:27.000Z</published>
    <updated>2022-03-09T16:40:27.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220309194832300.png" alt="image-20220309194832300"></p><p>icosahedron</p><p>正二十面体 <a href="https://baike.baidu.com/item/%E6%AD%A3%E4%BA%8C%E5%8D%81%E9%9D%A2%E4%BD%93/1921640">https://baike.baidu.com/item/%E6%AD%A3%E4%BA%8C%E5%8D%81%E9%9D%A2%E4%BD%93/1921640</a></p><p>正二十面体(Regular icosahedron [2] ) 是由20个等边三角形所组成的<a href="https://baike.baidu.com/item/正多面体">正多面体</a>，共有12个顶点，30条棱，20个面。为五个<a href="https://baike.baidu.com/item/柏拉图多面体/2769757">柏拉图多面体</a>之一。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220309164132823.png" alt="image-20220309164132823"></p><p> sqrt(50-10*sqrt(5))/10 = 0.5257</p><p>sqrt(50+10*sqrt(5))/10 = 0.8507</p><hr><p>画图十分精美</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220321102438566.png" alt="image-20220321102438566"></p><p><a href="https://www.redblobgames.com/x/1842-delaunay-voronoi-sphere/">https://www.redblobgames.com/x/1842-delaunay-voronoi-sphere/</a></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220321101619465.png" alt="image-20220321101619465"></p><hr><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220309171100201.png" alt="image-20220309171100201"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% plot_triangle.m</span></span><br><span class="line">clear all; close all;</span><br><span class="line">m = <span class="built_in">sqrt</span>(<span class="number">50</span><span class="number">-10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">n = <span class="built_in">sqrt</span>(<span class="number">50</span>+<span class="number">10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">A = [</span><br><span class="line">    n,-m,<span class="number">0</span>;</span><br><span class="line">    n,m,<span class="number">0</span>;</span><br><span class="line">    -n,m,<span class="number">0</span>;</span><br><span class="line">    -n,-m,<span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>,n,-m;</span><br><span class="line">    <span class="number">0</span>,n,m;</span><br><span class="line">    <span class="number">0</span>,-n,m;</span><br><span class="line">    <span class="number">0</span>,-n,-m;</span><br><span class="line">    -m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,-n;</span><br><span class="line">    -m,<span class="number">0</span>,-n;</span><br><span class="line">    ];</span><br><span class="line"><span class="built_in">scatter3</span>(A(:,<span class="number">1</span>),A(:,<span class="number">2</span>),A(:,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">center=[];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">1</span>,<span class="number">0</span>,<span class="number">10</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">0</span>,<span class="number">9</span>,<span class="number">6</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">0</span>,<span class="number">7</span>,<span class="number">10</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">11</span>,<span class="number">10</span>,<span class="number">7</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">7</span>,<span class="number">3</span>,<span class="number">11</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">10</span>,<span class="number">11</span>,<span class="number">4</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">2</span>,<span class="number">4</span>,<span class="number">11</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">4</span>,<span class="number">1</span>,<span class="number">10</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">text(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line">axis equal;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plot_triangle</span><span class="params">(A,d1,d2,d3)</span></span></span><br><span class="line">d1 = d1 + <span class="number">1</span>;</span><br><span class="line">d2 = d2 + <span class="number">1</span>;</span><br><span class="line">d3 = d3 + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">line([A(d1,<span class="number">1</span>),A(d2,<span class="number">1</span>),A(d3,<span class="number">1</span>),A(d1,<span class="number">1</span>)],[A(d1,<span class="number">2</span>),A(d2,<span class="number">2</span>),A(d3,<span class="number">2</span>),A(d1,<span class="number">2</span>)],[A(d1,<span class="number">3</span>),A(d2,<span class="number">3</span>),A(d3,<span class="number">3</span>),A(d1,<span class="number">3</span>)]);</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220309194211980.png" alt="image-20220309194211980"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220312234651019.png" alt="image-20220312234651019"></p><hr><p>进入源码进行查看</p><p>StelGeodesicGrid::StelGeodesicGrid（StelGeodesicGrid.cpp） 被调用1次 调用20次<br>        StelGeodesicGrid::initTriangle（StelGeodesicGrid.cpp）被调用20次 c0/c1/c2为20个面的3个点，函数内的循环没进</p><p>下面6个点为 c0/c1/c2/e0/e1/e2</p><p>1 [0.850651, 0.525731, 0] [0.850651, -0.525731, 0] [0.525731, 0, -0.850651] [0.809017, -0.309017, -0.5] [0.809017, 0.309017, -0.5] [1, 0, 0]</p><p>2 [0.850651, -0.525731, 0] [0.850651, 0.525731, 0] [0.525731, 0, 0.850651] [0.809017, 0.309017, 0.5] [0.809017, -0.309017, 0.5] [1, 0, 0]</p><p>3 [0.850651, -0.525731, 0] [0.525731, 0, 0.850651] [0, -0.850651, 0.525731] [0.309017, -0.5, 0.809017] [0.5, -0.809017, 0.309017] [0.809017, -0.309017, 0.5]</p><p>4 [0.525731, 0, 0.850651] [-0.525731, 0, 0.850651] [0, -0.850651, 0.525731] [-0.309017, -0.5, 0.809017] [0.309017, -0.5, 0.809017] [0, 0, 1]</p><p>5 [0.850651, -0.525731, 0] [0, -0.850651, -0.525731] [0.525731, 0, -0.850651] [0.309017, -0.5, -0.809017] [0.809017, -0.309017, -0.5] [0.5, -0.809017, -0.309017]</p><p>6 [0, -0.850651, 0.525731] [0, -0.850651, -0.525731] [0.850651, -0.525731, 0] [0.5, -0.809017, -0.309017] [0.5, -0.809017, 0.309017] [0, -1, 0]</p><p>7 [0, -0.850651, -0.525731] [0, -0.850651, 0.525731] [-0.850651, -0.525731, 0] [-0.5, -0.809017, 0.309017] [-0.5, -0.809017, -0.309017] [0, -1, 0]</p><p>8 [0, -0.850651, 0.525731] [-0.525731, 0, 0.850651] [-0.850651, -0.525731, 0] [-0.809017, -0.309017, 0.5] [-0.5, -0.809017, 0.309017] [-0.309017, -0.5, 0.809017]</p><p>9 [-0.525731, 0, -0.850651] [0.525731, 0, -0.850651] [0, -0.850651, -0.525731] [0.309017, -0.5, -0.809017] [-0.309017, -0.5, -0.809017] [0, 0, -1]</p><p>10 [0, -0.850651, -0.525731] [-0.850651, -0.525731, 0] [-0.525731, 0, -0.850651] [-0.809017, -0.309017, -0.5] [-0.309017, -0.5, -0.809017] [-0.5, -0.809017, -0.309017]</p><p>11 [-0.850651, -0.525731, 0] [-0.850651, 0.525731, 0] [-0.525731, 0, -0.850651] [-0.809017, 0.309017, -0.5] [-0.809017, -0.309017, -0.5] [-1, 0, 0]</p><p>12 [-0.850651, 0.525731, 0] [-0.850651, -0.525731, 0] [-0.525731, 0, 0.850651] [-0.809017, -0.309017, 0.5] [-0.809017, 0.309017, 0.5] [-1, 0, 0]</p><p>13 [0.525731, 0, -0.850651] [-0.525731, 0, -0.850651] [0, 0.850651, -0.525731] [-0.309017, 0.5, -0.809017] [0.309017, 0.5, -0.809017] [0, 0, -1]</p><p>14 [-0.850651, 0.525731, 0] [0, 0.850651, -0.525731] [-0.525731, 0, -0.850651] [-0.309017, 0.5, -0.809017] [-0.809017, 0.309017, -0.5] [-0.5, 0.809017, -0.309017]</p><p>15 [0, 0.850651, 0.525731] [0, 0.850651, -0.525731] [-0.850651, 0.525731, 0] [-0.5, 0.809017, -0.309017] [-0.5, 0.809017, 0.309017] [0, 1, 0]</p><p>16 [-0.850651, 0.525731, 0] [-0.525731, 0, 0.850651] [0, 0.850651, 0.525731] [-0.309017, 0.5, 0.809017] [-0.5, 0.809017, 0.309017] [-0.809017, 0.309017, 0.5]</p><p>17 [0, 0.850651, -0.525731] [0.850651, 0.525731, 0] [0.525731, 0, -0.850651] [0.809017, 0.309017, -0.5] [0.309017, 0.5, -0.809017] [0.5, 0.809017, -0.309017]</p><p>18 [0, 0.850651, -0.525731] [0, 0.850651, 0.525731] [0.850651, 0.525731, 0] [0.5, 0.809017, 0.309017] [0.5, 0.809017, -0.309017] [0, 1, 0]</p><p>19 [0, 0.850651, 0.525731] [0.525731, 0, 0.850651] [0.850651, 0.525731, 0] [0.809017, 0.309017, 0.5] [0.5, 0.809017, 0.309017] [0.309017, 0.5, 0.809017]</p><p>20 [-0.525731, 0, 0.850651] [0.525731, 0, 0.850651] [0, 0.850651, 0.525731] [0.309017, 0.5, 0.809017] [-0.309017, 0.5, 0.809017] [0, 0, 1]</p><hr><p>然后才进入了下面的程序</p><p>StarMgr::init()<br>        StelGeodesicGrid::visitTriangles 被调用1次 调用20次函数<br>                StelGeodesicGrid::visitTriangles 被调用20次 再每次调用自身4次函数<br>                        (*func)(lev, index, c0, c1, c2, context);<br>                        initTriangleFunc （StarMgr.hpp）<br>                                StarMgr::initTriangle 被调用1次<br>                                        ZoneArray::initTriangle </p><p>​        </p><p>需要注意调用了100次的 StelGeodesicGrid::visitTriangles 中的 Triangle &amp;t(triangles [ lev ] [ index ] );</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Vec3f e0,e1,e2;   <span class="comment">// Seitenmittelpunkte</span></span><br><span class="line">&#125;;</span><br><span class="line">Triangle **triangles;</span><br></pre></td></tr></table></figure><p>triangles变量在StelGeodesicGrid::initTriangle中已经定义过</p><p>checkAndLoadCatal  visitTriangles  1</p><p> 1  z-&gt;center [0.934172, 0, -0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [0.850651, 0.525731, 0] c1 [0.850651, -0.525731, 0] c2 [0.525731, 0, -0.850651]</p><p> 2  z-&gt;center [0.939124, 0.294748, -0.176549] z-&gt;axis0 [-0.299452, 0.954111, 0]  z-&gt;axis1 [0.168448, 0.052868, 0.984292] star_position_scale 0.361541 c0 [0.850651, 0.525731, 0] c1 [1, 0, 0] c2 [0.809017, 0.309017, -0.5]</p><p> 3  z-&gt;center [0.939124, -0.294748, -0.176549] z-&gt;axis0 [0.299452, 0.954111, 0]  z-&gt;axis1 [0.168448, -0.052868, 0.984292] star_position_scale 0.361541 c0 [1, 0, 0] c1 [0.850651, -0.525731, 0] c2 [0.809017, -0.309017, -0.5]</p><p> 4  z-&gt;center [0.75696, 0, -0.653462] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [0.653462, 0, 0.75696] star_position_scale 0.361541 c0 [0.809017, 0.309017, -0.5] c1 [0.809017, -0.309017, -0.5] c2 [0.525731, 0, -0.850651]</p><p> 5  z-&gt;center [0.934172, 0, -0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [0.809017, -0.309017, -0.5] c1 [0.809017, 0.309017, -0.5] c2 [1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  2</p><p> 6  z-&gt;center [0.934172, 0, 0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [0.850651, -0.525731, 0] c1 [0.850651, 0.525731, 0] c2 [0.525731, 0, 0.850651]</p><p> 7  z-&gt;center [0.939124, -0.294748, 0.176549] z-&gt;axis0 [0.299452, 0.954111, 0]  z-&gt;axis1 [-0.168448, 0.052868, 0.984292] star_position_scale 0.381966 c0 [0.850651, -0.525731, 0] c1 [1, 0, 0] c2 [0.809017, -0.309017, 0.5]</p><p> 8  z-&gt;center [0.939124, 0.294748, 0.176549] z-&gt;axis0 [-0.299452, 0.954111, 0]  z-&gt;axis1 [-0.168448, -0.052868, 0.984292] star_position_scale 0.381966 c0 [1, 0, 0] c1 [0.850651, 0.525731, 0] c2 [0.809017, 0.309017, 0.5]</p><p> 9  z-&gt;center [0.75696, 0, 0.653462] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [-0.653462, 0, 0.75696] star_position_scale 0.381966 c0 [0.809017, -0.309017, 0.5] c1 [0.809017, 0.309017, 0.5] c2 [0.525731, 0, 0.850651]</p><p> 10  z-&gt;center [0.934172, 0, 0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [0.809017, 0.309017, 0.5] c1 [0.809017, -0.309017, 0.5] c2 [1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  3</p><p> 11  z-&gt;center [0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [0.850651, -0.525731, 0] c1 [0.525731, 0, 0.850651] c2 [0, -0.850651, 0.525731]</p><p> 12  z-&gt;center [0.762575, -0.580411, 0.285662] z-&gt;axis0 [0.605648, 0.795733, 0]  z-&gt;axis1 [-0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [0.850651, -0.525731, 0] c1 [0.809017, -0.309017, 0.5] c2 [0.5, -0.809017, 0.309017]</p><p> 13  z-&gt;center [0.580411, -0.285662, 0.762575] z-&gt;axis0 [0.441587, 0.897219, 0]  z-&gt;axis1 [-0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [0.809017, -0.309017, 0.5] c1 [0.525731, 0, 0.850651] c2 [0.309017, -0.5, 0.809017]</p><p> 14  z-&gt;center [0.285662, -0.762575, 0.580411] z-&gt;axis0 [0.936452, 0.350797, 0]  z-&gt;axis1 [-0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [0.5, -0.809017, 0.309017] c1 [0.309017, -0.5, 0.809017] c2 [0, -0.850651, 0.525731]</p><p> 15  z-&gt;center [0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [0.309017, -0.5, 0.809017] c1 [0.5, -0.809017, 0.309017] c2 [0.809017, -0.309017, 0.5]</p><p>checkAndLoadCatal  visitTriangles  4</p><p> 16  z-&gt;center [0, -0.356822, 0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.763932 c0 [0.525731, 0, 0.850651] c1 [-0.525731, 0, 0.850651] c2 [0, -0.850651, 0.525731]</p><p> 17  z-&gt;center [0.294748, -0.176549, 0.939124] z-&gt;axis0 [0.513854, 0.857878, 0]  z-&gt;axis1 [-0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0.525731, 0, 0.850651] c1 [0, 0, 1] c2 [0.309017, -0.5, 0.809017]</p><p> 18  z-&gt;center [-0.294748, -0.176549, 0.939124] z-&gt;axis0 [0.513854, -0.857878, 0]  z-&gt;axis1 [0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, 1] c1 [-0.525731, 0, 0.850651] c2 [-0.309017, -0.5, 0.809017]</p><p> 19  z-&gt;center [0, -0.653462, 0.75696] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, 0.75696, 0.653462] star_position_scale 0.381966 c0 [0.309017, -0.5, 0.809017] c1 [-0.309017, -0.5, 0.809017] c2 [0, -0.850651, 0.525731]</p><p> 20  z-&gt;center [0, -0.356822, 0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.381966 c0 [-0.309017, -0.5, 0.809017] c1 [0.309017, -0.5, 0.809017] c2 [0, 0, 1]</p><p>checkAndLoadCatal  visitTriangles  5</p><p> 21  z-&gt;center [0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [0.850651, -0.525731, 0] c1 [0, -0.850651, -0.525731] c2 [0.525731, 0, -0.850651]</p><p> 22  z-&gt;center [0.762575, -0.580411, -0.285662] z-&gt;axis0 [0.605648, 0.795733, 0]  z-&gt;axis1 [0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [0.850651, -0.525731, 0] c1 [0.5, -0.809017, -0.309017] c2 [0.809017, -0.309017, -0.5]</p><p> 23  z-&gt;center [0.285662, -0.762575, -0.580411] z-&gt;axis0 [0.936452, 0.350797, 0]  z-&gt;axis1 [0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [0.5, -0.809017, -0.309017] c1 [0, -0.850651, -0.525731] c2 [0.309017, -0.5, -0.809017]</p><p> 24  z-&gt;center [0.580411, -0.285662, -0.762575] z-&gt;axis0 [0.441587, 0.897219, 0]  z-&gt;axis1 [0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [0.809017, -0.309017, -0.5] c1 [0.309017, -0.5, -0.809017] c2 [0.525731, 0, -0.850651]</p><p> 25  z-&gt;center [0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [0.309017, -0.5, -0.809017] c1 [0.809017, -0.309017, -0.5] c2 [0.5, -0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  6</p><p> 26  z-&gt;center [0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, -0.850651, 0.525731] c1 [0, -0.850651, -0.525731] c2 [0.850651, -0.525731, 0]</p><p> 27  z-&gt;center [0.176549, -0.939124, 0.294748] z-&gt;axis0 [0.982784, 0.184757, 0]  z-&gt;axis1 [-0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -0.850651, 0.525731] c1 [0, -1, 0] c2 [0.5, -0.809017, 0.309017]</p><p> 28  z-&gt;center [0.176549, -0.939124, -0.294748] z-&gt;axis0 [0.982784, 0.184757, 0]  z-&gt;axis1 [0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -1, 0] c1 [0, -0.850651, -0.525731] c2 [0.5, -0.809017, -0.309017]</p><p> 29  z-&gt;center [0.653462, -0.75696, 0] z-&gt;axis0 [0.75696, 0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, -0.809017, 0.309017] c1 [0.5, -0.809017, -0.309017] c2 [0.850651, -0.525731, 0]</p><p> 30  z-&gt;center [0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, -0.809017, -0.309017] c1 [0.5, -0.809017, 0.309017] c2 [0, -1, 0]</p><p>checkAndLoadCatal  visitTriangles  7</p><p> 31  z-&gt;center [-0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, -0.850651, -0.525731] c1 [0, -0.850651, 0.525731] c2 [-0.850651, -0.525731, 0]</p><p> 32  z-&gt;center [-0.176549, -0.939124, -0.294748] z-&gt;axis0 [0.982784, -0.184757, 0]  z-&gt;axis1 [-0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -0.850651, -0.525731] c1 [0, -1, 0] c2 [-0.5, -0.809017, -0.309017]</p><p> 33  z-&gt;center [-0.176549, -0.939124, 0.294748] z-&gt;axis0 [0.982784, -0.184757, 0]  z-&gt;axis1 [0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -1, 0] c1 [0, -0.850651, 0.525731] c2 [-0.5, -0.809017, 0.309017]</p><p> 34  z-&gt;center [-0.653462, -0.75696, 0] z-&gt;axis0 [0.75696, -0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, -0.809017, -0.309017] c1 [-0.5, -0.809017, 0.309017] c2 [-0.850651, -0.525731, 0]</p><p> 35  z-&gt;center [-0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, -0.809017, 0.309017] c1 [-0.5, -0.809017, -0.309017] c2 [0, -1, 0]</p><p>checkAndLoadCatal  visitTriangles  8</p><p> 36  z-&gt;center [-0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [0, -0.850651, 0.525731] c1 [-0.525731, 0, 0.850651] c2 [-0.850651, -0.525731, 0]</p><p> 37  z-&gt;center [-0.285662, -0.762575, 0.580411] z-&gt;axis0 [0.936452, -0.350797, 0]  z-&gt;axis1 [0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [0, -0.850651, 0.525731] c1 [-0.309017, -0.5, 0.809017] c2 [-0.5, -0.809017, 0.309017]</p><p> 38  z-&gt;center [-0.580411, -0.285662, 0.762575] z-&gt;axis0 [0.441587, -0.897219, 0]  z-&gt;axis1 [0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.309017, -0.5, 0.809017] c1 [-0.525731, 0, 0.850651] c2 [-0.809017, -0.309017, 0.5]</p><p> 39  z-&gt;center [-0.762575, -0.580411, 0.285662] z-&gt;axis0 [0.605648, -0.795733, 0]  z-&gt;axis1 [0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.5, -0.809017, 0.309017] c1 [-0.809017, -0.309017, 0.5] c2 [-0.850651, -0.525731, 0]</p><p> 40  z-&gt;center [-0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.809017, -0.309017, 0.5] c1 [-0.5, -0.809017, 0.309017] c2 [-0.309017, -0.5, 0.809017]</p><p>checkAndLoadCatal  visitTriangles  9</p><p> 41  z-&gt;center [0, -0.356822, -0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.763932 c0 [-0.525731, 0, -0.850651] c1 [0.525731, 0, -0.850651] c2 [0, -0.850651, -0.525731]</p><p> 42  z-&gt;center [-0.294748, -0.176549, -0.939124] z-&gt;axis0 [0.513854, -0.857878, 0]  z-&gt;axis1 [-0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [-0.525731, 0, -0.850651] c1 [0, 0, -1] c2 [-0.309017, -0.5, -0.809017]</p><p> 43  z-&gt;center [0.294748, -0.176549, -0.939124] z-&gt;axis0 [0.513854, 0.857878, 0]  z-&gt;axis1 [0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, -1] c1 [0.525731, 0, -0.850651] c2 [0.309017, -0.5, -0.809017]</p><p> 44  z-&gt;center [0, -0.653462, -0.75696] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, -0.75696, 0.653462] star_position_scale 0.381966 c0 [-0.309017, -0.5, -0.809017] c1 [0.309017, -0.5, -0.809017] c2 [0, -0.850651, -0.525731]</p><p> 45  z-&gt;center [0, -0.356822, -0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.381966 c0 [0.309017, -0.5, -0.809017] c1 [-0.309017, -0.5, -0.809017] c2 [0, 0, -1]</p><p>checkAndLoadCatal  visitTriangles  10</p><p> 46  z-&gt;center [-0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [0, -0.850651, -0.525731] c1 [-0.850651, -0.525731, 0] c2 [-0.525731, 0, -0.850651]</p><p> 47  z-&gt;center [-0.285662, -0.762575, -0.580411] z-&gt;axis0 [0.936452, -0.350797, 0]  z-&gt;axis1 [-0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [0, -0.850651, -0.525731] c1 [-0.5, -0.809017, -0.309017] c2 [-0.309017, -0.5, -0.809017]</p><p> 48  z-&gt;center [-0.762575, -0.580411, -0.285662] z-&gt;axis0 [0.605648, -0.795733, 0]  z-&gt;axis1 [-0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.5, -0.809017, -0.309017] c1 [-0.850651, -0.525731, 0] c2 [-0.809017, -0.309017, -0.5]</p><p> 49  z-&gt;center [-0.580411, -0.285662, -0.762575] z-&gt;axis0 [0.441587, -0.897219, 0]  z-&gt;axis1 [-0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.309017, -0.5, -0.809017] c1 [-0.809017, -0.309017, -0.5] c2 [-0.525731, 0, -0.850651]</p><p> 50  z-&gt;center [-0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.809017, -0.309017, -0.5] c1 [-0.309017, -0.5, -0.809017] c2 [-0.5, -0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  11</p><p> 51  z-&gt;center [-0.934172, 0, -0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [-0.850651, -0.525731, 0] c1 [-0.850651, 0.525731, 0] c2 [-0.525731, 0, -0.850651]</p><p> 52  z-&gt;center [-0.939124, -0.294748, -0.176549] z-&gt;axis0 [0.299452, -0.954111, 0]  z-&gt;axis1 [-0.168448, -0.052868, 0.984292] star_position_scale 0.381966 c0 [-0.850651, -0.525731, 0] c1 [-1, 0, 0] c2 [-0.809017, -0.309017, -0.5]</p><p> 53  z-&gt;center [-0.939124, 0.294748, -0.176549] z-&gt;axis0 [-0.299452, -0.954111, 0]  z-&gt;axis1 [-0.168448, 0.052868, 0.984292] star_position_scale 0.381966 c0 [-1, 0, 0] c1 [-0.850651, 0.525731, 0] c2 [-0.809017, 0.309017, -0.5]</p><p> 54  z-&gt;center [-0.75696, 0, -0.653462] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [-0.653462, 0, 0.75696] star_position_scale 0.381966 c0 [-0.809017, -0.309017, -0.5] c1 [-0.809017, 0.309017, -0.5] c2 [-0.525731, 0, -0.850651]</p><p> 55  z-&gt;center [-0.934172, 0, -0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [-0.809017, 0.309017, -0.5] c1 [-0.809017, -0.309017, -0.5] c2 [-1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  12</p><p> 56  z-&gt;center [-0.934172, 0, 0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [-0.850651, 0.525731, 0] c1 [-0.850651, -0.525731, 0] c2 [-0.525731, 0, 0.850651]</p><p> 57  z-&gt;center [-0.939124, 0.294748, 0.176549] z-&gt;axis0 [-0.299452, -0.954111, 0]  z-&gt;axis1 [0.168448, -0.052868, 0.984292] star_position_scale 0.381966 c0 [-0.850651, 0.525731, 0] c1 [-1, 0, 0] c2 [-0.809017, 0.309017, 0.5]</p><p> 58  z-&gt;center [-0.939124, -0.294748, 0.176549] z-&gt;axis0 [0.299452, -0.954111, 0]  z-&gt;axis1 [0.168448, 0.052868, 0.984292] star_position_scale 0.381966 c0 [-1, 0, 0] c1 [-0.850651, -0.525731, 0] c2 [-0.809017, -0.309017, 0.5]</p><p> 59  z-&gt;center [-0.75696, 0, 0.653462] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [0.653462, 0, 0.75696] star_position_scale 0.381966 c0 [-0.809017, 0.309017, 0.5] c1 [-0.809017, -0.309017, 0.5] c2 [-0.525731, 0, 0.850651]</p><p> 60  z-&gt;center [-0.934172, 0, 0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [-0.809017, -0.309017, 0.5] c1 [-0.809017, 0.309017, 0.5] c2 [-1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  13</p><p> 61  z-&gt;center [0, 0.356822, -0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.763932 c0 [0.525731, 0, -0.850651] c1 [-0.525731, 0, -0.850651] c2 [0, 0.850651, -0.525731]</p><p> 62  z-&gt;center [0.294748, 0.176549, -0.939124] z-&gt;axis0 [-0.513854, 0.857878, 0]  z-&gt;axis1 [0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0.525731, 0, -0.850651] c1 [0, 0, -1] c2 [0.309017, 0.5, -0.809017]</p><p> 63  z-&gt;center [-0.294748, 0.176549, -0.939124] z-&gt;axis0 [-0.513854, -0.857878, 0]  z-&gt;axis1 [-0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, -1] c1 [-0.525731, 0, -0.850651] c2 [-0.309017, 0.5, -0.809017]</p><p> 64  z-&gt;center [0, 0.653462, -0.75696] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, 0.75696, 0.653462] star_position_scale 0.381966 c0 [0.309017, 0.5, -0.809017] c1 [-0.309017, 0.5, -0.809017] c2 [0, 0.850651, -0.525731]</p><p> 65  z-&gt;center [0, 0.356822, -0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.381966 c0 [-0.309017, 0.5, -0.809017] c1 [0.309017, 0.5, -0.809017] c2 [0, 0, -1]</p><p>checkAndLoadCatal  visitTriangles  14</p><p> 66  z-&gt;center [-0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [-0.850651, 0.525731, 0] c1 [0, 0.850651, -0.525731] c2 [-0.525731, 0, -0.850651]</p><p> 67  z-&gt;center [-0.762575, 0.580411, -0.285662] z-&gt;axis0 [-0.605648, -0.795733, 0]  z-&gt;axis1 [-0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.850651, 0.525731, 0] c1 [-0.5, 0.809017, -0.309017] c2 [-0.809017, 0.309017, -0.5]</p><p> 68  z-&gt;center [-0.285662, 0.762575, -0.580411] z-&gt;axis0 [-0.936452, -0.350797, 0]  z-&gt;axis1 [-0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [-0.5, 0.809017, -0.309017] c1 [0, 0.850651, -0.525731] c2 [-0.309017, 0.5, -0.809017]</p><p> 69  z-&gt;center [-0.580411, 0.285662, -0.762575] z-&gt;axis0 [-0.441587, -0.897219, 0]  z-&gt;axis1 [-0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.809017, 0.309017, -0.5] c1 [-0.309017, 0.5, -0.809017] c2 [-0.525731, 0, -0.850651]</p><p> 70  z-&gt;center [-0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.309017, 0.5, -0.809017] c1 [-0.809017, 0.309017, -0.5] c2 [-0.5, 0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  15</p><p> 71  z-&gt;center [-0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, 0.850651, 0.525731] c1 [0, 0.850651, -0.525731] c2 [-0.850651, 0.525731, 0]</p><p> 72  z-&gt;center [-0.176549, 0.939124, 0.294748] z-&gt;axis0 [-0.982784, -0.184757, 0]  z-&gt;axis1 [0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 0.850651, 0.525731] c1 [0, 1, 0] c2 [-0.5, 0.809017, 0.309017]</p><p> 73  z-&gt;center [-0.176549, 0.939124, -0.294748] z-&gt;axis0 [-0.982784, -0.184757, 0]  z-&gt;axis1 [-0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 1, 0] c1 [0, 0.850651, -0.525731] c2 [-0.5, 0.809017, -0.309017]</p><p> 74  z-&gt;center [-0.653462, 0.75696, 0] z-&gt;axis0 [-0.75696, -0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, 0.809017, 0.309017] c1 [-0.5, 0.809017, -0.309017] c2 [-0.850651, 0.525731, 0]</p><p> 75  z-&gt;center [-0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, 0.809017, -0.309017] c1 [-0.5, 0.809017, 0.309017] c2 [0, 1, 0]</p><p>checkAndLoadCatal  visitTriangles  16</p><p> 76  z-&gt;center [-0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [-0.850651, 0.525731, 0] c1 [-0.525731, 0, 0.850651] c2 [0, 0.850651, 0.525731]</p><p> 77  z-&gt;center [-0.762575, 0.580411, 0.285662] z-&gt;axis0 [-0.605648, -0.795733, 0]  z-&gt;axis1 [0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.850651, 0.525731, 0] c1 [-0.809017, 0.309017, 0.5] c2 [-0.5, 0.809017, 0.309017]</p><p> 78  z-&gt;center [-0.580411, 0.285662, 0.762575] z-&gt;axis0 [-0.441587, -0.897219, 0]  z-&gt;axis1 [0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.809017, 0.309017, 0.5] c1 [-0.525731, 0, 0.850651] c2 [-0.309017, 0.5, 0.809017]</p><p> 79  z-&gt;center [-0.285662, 0.762575, 0.580411] z-&gt;axis0 [-0.936452, -0.350797, 0]  z-&gt;axis1 [0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [-0.5, 0.809017, 0.309017] c1 [-0.309017, 0.5, 0.809017] c2 [0, 0.850651, 0.525731]</p><p> 80  z-&gt;center [-0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.309017, 0.5, 0.809017] c1 [-0.5, 0.809017, 0.309017] c2 [-0.809017, 0.309017, 0.5]</p><p>checkAndLoadCatal  visitTriangles  17</p><p> 81  z-&gt;center [0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [0, 0.850651, -0.525731] c1 [0.850651, 0.525731, 0] c2 [0.525731, 0, -0.850651]</p><p> 82  z-&gt;center [0.285662, 0.762575, -0.580411] z-&gt;axis0 [-0.936452, 0.350797, 0]  z-&gt;axis1 [0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [0, 0.850651, -0.525731] c1 [0.5, 0.809017, -0.309017] c2 [0.309017, 0.5, -0.809017]</p><p> 83  z-&gt;center [0.762575, 0.580411, -0.285662] z-&gt;axis0 [-0.605648, 0.795733, 0]  z-&gt;axis1 [0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [0.5, 0.809017, -0.309017] c1 [0.850651, 0.525731, 0] c2 [0.809017, 0.309017, -0.5]</p><p> 84  z-&gt;center [0.580411, 0.285662, -0.762575] z-&gt;axis0 [-0.441587, 0.897219, 0]  z-&gt;axis1 [0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [0.309017, 0.5, -0.809017] c1 [0.809017, 0.309017, -0.5] c2 [0.525731, 0, -0.850651]</p><p> 85  z-&gt;center [0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [0.809017, 0.309017, -0.5] c1 [0.309017, 0.5, -0.809017] c2 [0.5, 0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  18</p><p> 86  z-&gt;center [0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, 0.850651, -0.525731] c1 [0, 0.850651, 0.525731] c2 [0.850651, 0.525731, 0]</p><p> 87  z-&gt;center [0.176549, 0.939124, -0.294748] z-&gt;axis0 [-0.982784, 0.184757, 0]  z-&gt;axis1 [0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 0.850651, -0.525731] c1 [0, 1, 0] c2 [0.5, 0.809017, -0.309017]</p><p> 88  z-&gt;center [0.176549, 0.939124, 0.294748] z-&gt;axis0 [-0.982784, 0.184757, 0]  z-&gt;axis1 [-0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 1, 0] c1 [0, 0.850651, 0.525731] c2 [0.5, 0.809017, 0.309017]</p><p> 89  z-&gt;center [0.653462, 0.75696, 0] z-&gt;axis0 [-0.75696, 0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, 0.809017, -0.309017] c1 [0.5, 0.809017, 0.309017] c2 [0.850651, 0.525731, 0]</p><p> 90  z-&gt;center [0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, 0.809017, 0.309017] c1 [0.5, 0.809017, -0.309017] c2 [0, 1, 0]</p><p>checkAndLoadCatal  visitTriangles  19</p><p> 91  z-&gt;center [0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [0, 0.850651, 0.525731] c1 [0.525731, 0, 0.850651] c2 [0.850651, 0.525731, 0]</p><p> 92  z-&gt;center [0.285662, 0.762575, 0.580411] z-&gt;axis0 [-0.936452, 0.350797, 0]  z-&gt;axis1 [-0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [0, 0.850651, 0.525731] c1 [0.309017, 0.5, 0.809017] c2 [0.5, 0.809017, 0.309017]</p><p> 93  z-&gt;center [0.580411, 0.285662, 0.762575] z-&gt;axis0 [-0.441587, 0.897219, 0]  z-&gt;axis1 [-0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [0.309017, 0.5, 0.809017] c1 [0.525731, 0, 0.850651] c2 [0.809017, 0.309017, 0.5]</p><p> 94  z-&gt;center [0.762575, 0.580411, 0.285662] z-&gt;axis0 [-0.605648, 0.795733, 0]  z-&gt;axis1 [-0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [0.5, 0.809017, 0.309017] c1 [0.809017, 0.309017, 0.5] c2 [0.850651, 0.525731, 0]</p><p> 95  z-&gt;center [0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [0.809017, 0.309017, 0.5] c1 [0.5, 0.809017, 0.309017] c2 [0.309017, 0.5, 0.809017]</p><p>checkAndLoadCatal  visitTriangles  20</p><p> 96  z-&gt;center [0, 0.356822, 0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.763932 c0 [-0.525731, 0, 0.850651] c1 [0.525731, 0, 0.850651] c2 [0, 0.850651, 0.525731]</p><p> 97  z-&gt;center [-0.294748, 0.176549, 0.939124] z-&gt;axis0 [-0.513854, -0.857878, 0]  z-&gt;axis1 [0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [-0.525731, 0, 0.850651] c1 [0, 0, 1] c2 [-0.309017, 0.5, 0.809017]</p><p> 98  z-&gt;center [0.294748, 0.176549, 0.939124] z-&gt;axis0 [-0.513854, 0.857878, 0]  z-&gt;axis1 [-0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, 1] c1 [0.525731, 0, 0.850651] c2 [0.309017, 0.5, 0.809017]</p><p> 99  z-&gt;center [0, 0.653462, 0.75696] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, -0.75696, 0.653462] star_position_scale 0.381966 c0 [-0.309017, 0.5, 0.809017] c1 [0.309017, 0.5, 0.809017] c2 [0, 0.850651, 0.525731]</p><p> 100  z-&gt;center [0, 0.356822, 0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.381966 c0 [0.309017, 0.5, 0.809017] c1 [-0.309017, 0.5, 0.809017] c2 [0, 0, 1]</p><p><strong>重点结论：star_position_scale = 0.763932</strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mu0 = (A(<span class="number">11</span>,:) - center(<span class="number">1</span>,:)) * axis0.&#x27;;</span><br><span class="line">mu1 = (A(<span class="number">11</span>,:) - center(<span class="number">1</span>,:)) * axis1.&#x27;;</span><br><span class="line">f = <span class="number">1</span>/(<span class="built_in">sqrt</span>(<span class="number">1</span>-mu0^<span class="number">2</span> -mu1^<span class="number">2</span>));</span><br><span class="line">h = <span class="built_in">abs</span>(mu1)*f;</span><br></pre></td></tr></table></figure><hr><p>梳理好顺序之后，可以进入ZoneArray::initTriangle中进行查看，尝试第一个中点和轴的信息。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% plot_triangle.m </span></span><br><span class="line"><span class="comment">% 12个顶点，30条棱，20个面</span></span><br><span class="line">clear all; close all;</span><br><span class="line">m = <span class="built_in">sqrt</span>(<span class="number">50</span><span class="number">-10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">n = <span class="built_in">sqrt</span>(<span class="number">50</span>+<span class="number">10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">A = [ <span class="comment">% 12个顶点</span></span><br><span class="line">    n,-m,<span class="number">0</span>;</span><br><span class="line">    n,m,<span class="number">0</span>;</span><br><span class="line">    -n,m,<span class="number">0</span>;</span><br><span class="line">    -n,-m,<span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>,n,-m;</span><br><span class="line">    <span class="number">0</span>,n,m;</span><br><span class="line">    <span class="number">0</span>,-n,m;</span><br><span class="line">    <span class="number">0</span>,-n,-m;</span><br><span class="line">    -m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,-n;</span><br><span class="line">    -m,<span class="number">0</span>,-n;</span><br><span class="line">    ];</span><br><span class="line"><span class="built_in">scatter3</span>(A(:,<span class="number">1</span>),A(:,<span class="number">2</span>),A(:,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">center=[];c0=[];c1=[];c2=[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">1</span>,<span class="number">0</span>,<span class="number">10</span>); <span class="comment">% 20个面</span></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">0</span>,<span class="number">9</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">0</span>,<span class="number">7</span>,<span class="number">10</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">11</span>,<span class="number">10</span>,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">7</span>,<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">10</span>,<span class="number">11</span>,<span class="number">4</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">2</span>,<span class="number">4</span>,<span class="number">11</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">4</span>,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">text(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">text(A(<span class="number">2</span>,<span class="number">1</span>),A(<span class="number">2</span>,<span class="number">2</span>),A(<span class="number">2</span>,<span class="number">3</span>),<span class="string">&#x27;c0&#x27;</span>);</span><br><span class="line">text(A(<span class="number">1</span>,<span class="number">1</span>),A(<span class="number">1</span>,<span class="number">2</span>),A(<span class="number">1</span>,<span class="number">3</span>),<span class="string">&#x27;c1&#x27;</span>);</span><br><span class="line">text(A(<span class="number">11</span>,<span class="number">1</span>),A(<span class="number">11</span>,<span class="number">2</span>),A(<span class="number">11</span>,<span class="number">3</span>),<span class="string">&#x27;c2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">d1=<span class="number">2</span>;d2=<span class="number">1</span>;d3=<span class="number">11</span>;</span><br><span class="line">line([A(d1,<span class="number">1</span>),A(d2,<span class="number">1</span>),A(d3,<span class="number">1</span>),A(d1,<span class="number">1</span>)],[A(d1,<span class="number">2</span>),A(d2,<span class="number">2</span>),A(d3,<span class="number">2</span>),A(d1,<span class="number">2</span>)],[A(d1,<span class="number">3</span>),A(d2,<span class="number">3</span>),A(d3,<span class="number">3</span>),A(d1,<span class="number">3</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(center(<span class="number">1</span>,<span class="number">1</span>),center(<span class="number">1</span>,<span class="number">2</span>),center(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">axis0 = <span class="built_in">cross</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],center(<span class="number">1</span>,:));</span><br><span class="line">axis0 = axis0./norm(axis0);</span><br><span class="line">axis1 = <span class="built_in">cross</span>(center(<span class="number">1</span>,:),axis0);</span><br><span class="line">axis1 = axis1./norm(axis1);</span><br><span class="line">quiver3(center(<span class="number">1</span>,<span class="number">1</span>),center(<span class="number">1</span>,<span class="number">2</span>),center(<span class="number">1</span>,<span class="number">3</span>),axis0(<span class="number">1</span>,<span class="number">1</span>),axis0(<span class="number">1</span>,<span class="number">2</span>),axis0(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">quiver3(center(<span class="number">1</span>,<span class="number">1</span>),center(<span class="number">1</span>,<span class="number">2</span>),center(<span class="number">1</span>,<span class="number">3</span>),axis1(<span class="number">1</span>,<span class="number">1</span>),axis1(<span class="number">1</span>,<span class="number">2</span>),axis1(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axis equal;</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220313100715334.png" alt="image-20220313100715334"></p><p>​    // Initialize star_position_scale. This scale is used to multiply stars position<br>​    // encoded as integers so that it optimize precision over the triangle.<br>​    // It has to be computed for each triangle because the relative orientation of the 2 axis is different for each triangle.</p><p>// 初始化star_position_scale。 此比例用于乘以星星位置 </p><p>// 编码为整数，以便优化三角形的精度。 </p><p>// 必须为每个三角形计算它，因为每个三角形的 2 轴的相对方向不同。 </p><hr><p>MaxPosVal 2147483647=0x7fff ffff</p><p>20个大三角形 star_position_scale = 0.763932 </p><p>80个小三角形 star_position_scale 0.381966</p><p>在ZoneArray.cpp中 查看变量 star_position_scale</p><p>mag_min 这一层中星等的下界。单位:millimag（10−3）。对最亮的恒星可能是负的。-2000 和 6000 </p><p>mag_range 这一层星等的范围，都为12.8星等。单位:millimags</p><p>mag_steps 用于描述mag_range中的值的步骤数都为256 。总是正的。单个恒星的mag条目从0..mag_steps开始 256 12800/256=50 .每次移动 一步0.05mags，可以看到软件中最低分辨率为0.05星等。最多256步。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arg(level=<span class="number">0</span>和<span class="number">1</span>).arg(type=<span class="number">0</span>).arg(major=<span class="number">0</span>).arg(minor=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HipZoneArray</span> :</span> <span class="keyword">public</span> SpecialZoneArray&lt;Star1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialZoneArray</span> :</span> <span class="keyword">public</span> ZoneArray</span><br><span class="line">    </span><br><span class="line">rval = <span class="keyword">new</span> HipZoneArray(file, byte_swap, use_mmap, level, mag_min, mag_range, mag_steps);</span><br><span class="line">SpecialZoneArray&lt;Star&gt;::SpecialZoneArray();        </span><br></pre></td></tr></table></figure><p>在该函数中，可以得到star.hpp中的信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          _______________</span><br><span class="line">0     x0 |               |</span><br><span class="line">1        |___________    |</span><br><span class="line">2     x1 |           |___|</span><br><span class="line">3        |_______        |</span><br><span class="line">4     bV |_______|_______|</span><br><span class="line">5    mag |_________|_____| bV</span><br><span class="line"></span><br><span class="line">int x0               :18</span><br><span class="line">int x1               :18</span><br><span class="line">unsigned int bV      :7</span><br><span class="line">unsigned int mag     :5</span><br></pre></td></tr></table></figure><hr><p>点鼠标一下，这是可以触发的函数。</p><p>StelObjectMgr::cleverFind<br>    StarMgr::searchAround 指向 放大倍率<br>        SpecialZoneArray&lt; Star&gt;::searchAround<br>            s-&gt;getJ2000Pos(z, static_cast&lt; float&gt;(movementFactor), tmp);</p><hr><p>注意到只有这里一次调用了星表里的26785=4979+21806个数据。</p><p>StarMgr::loadData<br>z-&gt;updateHipIndex(hipIndex);</p><p>​    HipZoneArray::updateHipIndex</p><p>因此在ZoneArray.cpp中仿写saveHipIndex函数为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HipZoneArray::saveHipIndex</span><span class="params">(HipIndexStruct hipIndex[])</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    StelCore* core = StelApp::getInstance().getCore();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> d2000 = <span class="number">2451545.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> movementFactor = (M_PI / <span class="number">180.</span>) * (<span class="number">0.0001</span> / <span class="number">3600.</span>) * ((core-&gt;getJDE() - d2000) / <span class="number">365.25</span>) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(star_position_scale);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *z = getZones() + (nr_of_zones - <span class="number">1</span>); z &gt;= getZones(); z--) &#123; <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> Star1 *s = z-&gt;getStars() + z-&gt;size - <span class="number">1</span>; s &gt;= z-&gt;getStars(); s--) &#123;</span><br><span class="line">            Vec3f tmp;</span><br><span class="line">            s-&gt;getJ2000Pos(z, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(movementFactor), tmp);</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;checkAndLoadCatalogcheckAndLoadCatalog&quot;</span>  &lt;&lt; ++aa &lt;&lt;  s-&gt;getHip()  &lt;&lt; s-&gt;getX0() &lt;&lt; s-&gt;getX1() &lt;&lt; s-&gt;getDx0() &lt;&lt; s-&gt;getDx1() &lt;&lt; s-&gt;getBV() &lt;&lt; s-&gt;getMag()  &lt;&lt; s-&gt;getPlx() &lt;&lt; s-&gt;getSpInt() &lt;&lt; s-&gt;getBVIndex() &lt;&lt; s-&gt;hasName() &lt;&lt; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HipZoneArray::saveHipIndex</span><span class="params">(HipIndexStruct hipIndex[])</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile  <span class="title">myFile</span><span class="params">(<span class="string">&quot;C:/Users/hp/Desktop/catalog.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (myFile.open(QFile::WriteOnly | QFile::Append | QIODevice::Text)) &#123;</span><br><span class="line">        <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;myFile)</span></span>;</span><br><span class="line">        StelCore* core = StelApp::getInstance().getCore();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> d2000 = <span class="number">2451545.0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> movementFactor = (M_PI / <span class="number">180.</span>) * (<span class="number">0.0001</span> / <span class="number">3600.</span>) * ((core-&gt;getJDE() - d2000) / <span class="number">365.25</span>) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(star_position_scale);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *z = getZones() + (nr_of_zones - <span class="number">1</span>); z &gt;= getZones(); z--) &#123; <span class="comment">// 100次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> Star1 *s = z-&gt;getStars() + z-&gt;size - <span class="number">1</span>; s &gt;= z-&gt;getStars(); s--) &#123;</span><br><span class="line">                Vec3f tmp;</span><br><span class="line">                s-&gt;getJ2000Pos(z, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(movementFactor), tmp);</span><br><span class="line">                tmp.normalize();</span><br><span class="line">                Vec3d vel = core-&gt;getCurrentPlanet()-&gt;getHeliocentricEclipticVelocity();</span><br><span class="line">                vel       = StelCore::matVsop87ToJ2000 * vel * core-&gt;getAberrationFactor() * (AU / (<span class="number">86400.0</span> * SPEED_OF_LIGHT));</span><br><span class="line">                Vec3d pos = tmp.toVec3d() + vel;</span><br><span class="line">                pos.normalize();</span><br><span class="line">                qDebug() &lt;&lt; <span class="string">&quot;checkAndLoadCatalogcheckAndLoadCatalog&quot;</span>  &lt;&lt; ++aa &lt;&lt; s-&gt;getHip()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getBV() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getMag()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getPlx() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getSpInt() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getBVIndex() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;hasName() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  tmp  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; z-&gt;getNrOfStars()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; star_position_scale &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                out  &lt;&lt;  aa &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getHip()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getBV() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getMag()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getPlx() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getSpInt() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getBVIndex() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;hasName() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  pos[<span class="number">0</span>] &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt; pos[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  pos[<span class="number">2</span>]  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; z-&gt;getNrOfStars()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; star_position_scale &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    myFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在StarMgr.cpp的StarMgr::searchAround中添加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qDebug() &lt;&lt; <span class="string">&quot;searchAround&quot;</span> &lt;&lt; ++bbbb &lt;&lt; vv &lt;&lt; limFov;</span><br><span class="line"><span class="keyword">if</span>(bbbb &gt;= <span class="number">23</span> )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* z : gridLevels)</span><br><span class="line">        z-&gt;saveHipIndex( hipIndex);</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220316101930812.png" alt="image-20220316101930812"></p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;close all;clc;</span><br><span class="line">tic</span><br><span class="line">A = importdata(<span class="string">&quot;catalog.txt&quot;</span>);</span><br><span class="line">hip = A(:,<span class="number">2</span>);</span><br><span class="line">x0 = A(:,<span class="number">3</span>);</span><br><span class="line">x1 = A(:,<span class="number">4</span>);</span><br><span class="line">dx0 =  A(:,<span class="number">5</span>);</span><br><span class="line">dx1 =  A(:,<span class="number">6</span>);</span><br><span class="line">bv = A(:,<span class="number">7</span>);</span><br><span class="line">mag = A(:,<span class="number">8</span>);</span><br><span class="line">plx = A(:,<span class="number">9</span>);</span><br><span class="line">spInt = A(:,<span class="number">10</span>);</span><br><span class="line">bvIndex = A(:,<span class="number">11</span>);</span><br><span class="line">hasName = A(:,<span class="number">12</span>);</span><br><span class="line">xyz = A(:,<span class="number">13</span>:<span class="number">15</span>);</span><br><span class="line">level = A(:,<span class="number">16</span>);</span><br><span class="line">getNrOfStars = A(:,<span class="number">17</span>);</span><br><span class="line">star_position_scale = A(:,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">mag_<span class="built_in">true</span> = mag .* <span class="number">0.05</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">asind</span>(xyz(:,<span class="number">3</span>));</span><br><span class="line">a = <span class="built_in">acosd</span>(xyz(:,<span class="number">1</span>)./<span class="built_in">sqrt</span>(<span class="number">1</span>-xyz(:,<span class="number">3</span>).^<span class="number">2</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(b)</span><br><span class="line">    <span class="keyword">if</span>(xyz(<span class="built_in">i</span>,<span class="number">2</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        a(<span class="built_in">i</span>,:)=<span class="number">360</span>-a(<span class="built_in">i</span>,:);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span>(level(<span class="built_in">i</span>)==<span class="number">0</span>)</span><br><span class="line">        mag_<span class="built_in">true</span>(<span class="built_in">i</span>) = <span class="number">-2</span> + mag(<span class="built_in">i</span>) * <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hh1 = (a./<span class="number">15</span>);</span><br><span class="line">hh = <span class="built_in">fix</span>(hh1);</span><br><span class="line">mm1 = (a./<span class="number">15</span> - hh)*<span class="number">60</span>;</span><br><span class="line">mm = <span class="built_in">fix</span>(mm1);</span><br><span class="line">ss = (mm1 - mm)*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">al_hh = <span class="built_in">fix</span>(b);</span><br><span class="line">al_mm1 = (<span class="built_in">abs</span>(b)-<span class="built_in">abs</span>(al_hh))*<span class="number">60</span>;</span><br><span class="line">al_mm = <span class="built_in">fix</span>(al_mm1);</span><br><span class="line">al_ss = (al_mm1 - al_mm)*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A=[A,a,b,hh,mm,ss,al_hh,al_mm,al_ss,mag_<span class="built_in">true</span>];</span><br><span class="line"></span><br><span class="line">xlswrite(<span class="string">&#x27;catal&#x27;</span>,A);</span><br><span class="line">toc</span><br></pre></td></tr></table></figure></h2><p>getJ2000Pos 函数</p><p>getJ2000EquatorialPos （StarWrapper.hpp）</p><p>只有StarWrapper.cpp 和 ZoneArray.cpp 包含 #include “StarWrapper.hpp”</p><p>ZoneArray.cpp<br>    StarMgr.hpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StelRegionObject</span> //抽象基类 </span></span><br><span class="line"><span class="class"><span class="title">virtual</span> <span class="title">Vec3d</span> <span class="title">getPointInRegion</span>() <span class="title">const</span>=</span><span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StelObject</span> :</span> <span class="keyword">public</span> StelRegionObject </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QString <span class="title">getInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *, <span class="keyword">const</span> InfoStringGroup&amp; )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">//抽象基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exoplanet</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeteorShower</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nova</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pulsar</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quasar</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Satellite</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supernova</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelescopeClient</span> :</span> <span class="keyword">public</span> QObject, <span class="keyword">public</span> StelObject</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientASCOM</span> :</span> <span class="keyword">public</span> TelescopeClient</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientINDI</span> :</span> <span class="keyword">public</span> TelescopeClient</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientDirectLx200</span> :</span> <span class="keyword">public</span> TelescopeClient, <span class="keyword">public</span> Server</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientDirectNexStar</span> :</span> <span class="keyword">public</span> TelescopeClient, <span class="keyword">public</span> Server</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientJsonRts2</span> :</span> <span class="keyword">public</span> TelescopeClient</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Asterism</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Constellation</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CustomObject</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nebula</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">NomenclatureItem</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Planet</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">            </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">StarWrapperBase</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">StarWrapper</span> :</span> <span class="keyword">public</span> StarWrapperBase</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Vec3d <span class="title">getJ2000EquatorialPos</span><span class="params">(<span class="keyword">const</span> StelCore * core)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span></span><br><span class="line"><span class="function">           class StarWrapper1 : <span class="keyword">public</span> StarWrapper&lt;Star1&gt;</span></span><br><span class="line"><span class="function">                class StarWrapper2 : <span class="keyword">public</span> StarWrapper&lt;Star2&gt;</span></span><br><span class="line"><span class="function">                class StarWrapper3 : <span class="keyword">public</span> StarWrapper&lt;Star3&gt;</span></span><br></pre></td></tr></table></figure><hr><p>验证从二进制文件到赤经赤纬</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qDebug() &lt;&lt; <span class="string">&quot;checkAndLoadCatalogcheckAndLoadCatalog&quot;</span>  &lt;&lt; ++aa &lt;&lt; s-&gt;getHip()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getBV() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getMag()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getPlx() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getSpInt() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getBVIndex() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;hasName() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  tmp  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; z-&gt;getNrOfStars()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; star_position_scale &lt;&lt; movementFactor &lt;&lt; core-&gt;getJDE() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220317144732768.png" alt="image-20220317144732768"></p><p>验证最后一个星</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s-&gt;getJ2000Pos(z, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(movementFactor), tmp);</span><br></pre></td></tr></table></figure><p>进入函数<br>        pos = (z-&gt;center) + (getX0())+movementFactor<em>getDx0()) </em> (z-&gt;axis0) + (getX1())+movementFactor<em>getDx1()) </em> (z-&gt;axis1);</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">-623411838</span>+ans*(<span class="number">-37</span>) )* [<span class="number">-5.32625e-11</span>, <span class="number">1.69705e-10</span>, <span class="number">0</span>]+(<span class="number">-188238807</span>+ans*(<span class="number">-2097</span>))*[<span class="number">2.99612e-11</span>, <span class="number">9.40346e-12</span>, <span class="number">1.75073e-10</span>]+[<span class="number">0.939124</span>, <span class="number">0.294748</span>, <span class="number">-0.176549</span>]</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9667</span>    <span class="number">0.1872</span>   <span class="number">-0.2095</span></span><br><span class="line">ans./norm(ans)</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9603</span>    <span class="number">0.1859</span>   <span class="number">-0.2081</span></span><br><span class="line">    [<span class="number">0.960264</span>, <span class="number">0.185937</span>, <span class="number">-0.208135</span>]差不多</span><br><span class="line">    </span><br><span class="line">ans +[<span class="number">-7.89179e-06</span>, <span class="number">-9.1333e-05</span>, <span class="number">-3.95923e-05</span>] </span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9603</span>    <span class="number">0.1858</span>   <span class="number">-0.2082</span></span><br></pre></td></tr></table></figure><p> movementFactor = (M_PI / 180.) <em> (0.0001 / 3600.) </em> ((core-&gt;getJDE() - d2000) / 365.25) /(star_position_scale);</p><p>core-&gt;getJDE() = 2459656</p><p>d2000 = 2451545.0  截止2022.3.17 差距8111天</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159265358979323846</span> / <span class="number">180.0</span> * <span class="number">0.0001</span>/<span class="number">3600.0</span>*<span class="number">8111</span>/<span class="number">365.25</span>/<span class="number">60.5274</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.7787e-10</span></span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220317145315365.png" alt="image-20220317145315365"></p><p>最终得到包含赤经赤纬星等的表</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220317161906242.png" alt="image-20220317161906242"></p>]]></content>
    
    
    <summary type="html">一直对Stellarium的星表文件充满好奇，在看了该二进制文件后不知该如何解析；在解析了从二进制文件到赤经赤纬表之后，推导从赤经赤纬前向到</summary>
    
    
    
    <category term="星表" scheme="https://tsuiwade.github.io/categories/%E6%98%9F%E8%A1%A8/"/>
    
    
    <category term="星表" scheme="https://tsuiwade.github.io/tags/%E6%98%9F%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>赤道坐标转为地平坐标</title>
    <link href="https://tsuiwade.github.io/2022/03/07/blog42-Equatorial2Horizontal/"/>
    <id>https://tsuiwade.github.io/2022/03/07/blog42-Equatorial2Horizontal/</id>
    <published>2022-03-07T20:14:46.000Z</published>
    <updated>2022-03-07T20:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>地平坐标系统是：<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E5%9D%90%E6%A8%99%E7%B3%BB">https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E5%9D%90%E6%A8%99%E7%B3%BB</a></p><ul><li>高度角（Altitude, Alt）或仰角又称<a href="https://zh.wikipedia.org/wiki/天球坐标系统">地平纬度</a>，是天体和观测者所在地的地平线的夹角，有时就称为<a href="https://zh.wikipedia.org/wiki/相对高度">高度</a>或<a href="https://zh.wikipedia.org/wiki/海拔">海拔</a>标高（elevation, geometric height）。</li><li><a href="https://zh.wikipedia.org/wiki/方位角">方位角</a>（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。</li></ul><p><strong>sin高度 = sin地球观察者纬度 <em> sin赤纬 + cos地球观察者纬度 </em> cos赤纬 * cos时角</strong></p><p><strong>cos方位 <em> cos高度 = - cos地球观察者纬度 </em> sin赤纬 + sin地球观察者纬度 <em> cos赤纬 </em> cos时角</strong></p><p><strong>sin方位 <em> cos高度 = cos赤纬 </em> sin 时角</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307203646304.png" alt="image-20220307203646304"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307210913618.png" alt="image-20220307210913618"></p><p><a href="https://encyclopedia.thefreedictionary.com/Astronomical+coordinate+systems">https://encyclopedia.thefreedictionary.com/Astronomical+coordinate+systems</a></p><hr><p>《地平式望远镜轴系误差对指向精度和跟踪精度的影响》</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307201531562.png" alt="image-20220307201531562"></p><hr><p><a href="https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/">https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</a></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307202417544.png" alt="image-20220307202417544"></p><p>//    A: azimuth方位角<br>//    h: elevation仰角<br>//    φ: latitude of observer on Earth观测纬度<br>//    ψ: longitude of observer on Earth观测经度<br>//    st: sidereal time at Greenwich at time of observation.恒星时</p><p>//    α: right ascension赤经（时角）<br>//    δ: declination赤纬</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307202425679.png" alt="image-20220307202425679"></p><p>//    α: right ascension coordinate to transform<br>//    δ: declination coordinate to transform<br>//    φ: latitude of observer on Earth 地球上观察者的纬度<br>//    ψ: longitude of observer on Earth 地球上观察者的经度<br>//    st: sidereal time at Greenwich at time of observation. 格林威治观测时的恒星时间。</p><p>//    A: azimuth of observed point, measured westward from the South.<br>//    h: elevation, or height of observed point above horizon.</p><hr><p>知乎 <a href="https://zhuanlan.zhihu.com/p/97325585">https://zhuanlan.zhihu.com/p/97325585</a></p><hr><p><em><code>UTC时间</code></em>(世界协调时间,UTC + 00:00)转北京(北京,UTC + 8:00)时间. 世界时钟, 时间转换, 计算与对照表.</p><p>一个地方的当地<code>恒星时</code>与<a href="https://baike.baidu.com/item/格林尼治天文台">格林尼治天文台</a>的恒星时之间的差就是这个地方的经度（参见天体导航）。因此通过观测恒星时可以确定当地的经度（假如格林尼治天文台的恒星时已知的话）或者可以确定时间（假如当地的经度已知的话）。</p><ul><li>一颗恒星的时角<em>t</em>、它的赤经<em>α</em>和当地的恒星时<em>θ</em>之间的关系为<em>t</em>=<em>θ</em>-<em>α</em></li><li>当地的恒星时等于位于<a href="https://baike.baidu.com/item/天顶">天顶</a>的恒星的赤经</li><li>当地的恒星时等于正位于<a href="https://baike.baidu.com/item/中天">中天</a>恒星的赤经</li></ul><p>通过确定恒星时可以简化天文学的计算，比如通过恒星时和当地的纬度可以很方便地计算出哪些星正好在地平线以上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;地平坐标系统是：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E5%9D%90%E6%A8%99%E7%B3%BB&quot;&gt;https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>指向精度的研究</title>
    <link href="https://tsuiwade.github.io/2022/03/05/blog41-point-1/"/>
    <id>https://tsuiwade.github.io/2022/03/05/blog41-point-1/</id>
    <published>2022-03-05T16:36:20.000Z</published>
    <updated>2022-03-05T16:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然寥寥无几的引用量，但该文可能确实是我司使用的机架模型的源头。</p><p><strong>Luck J M. Mount model stability[C]//14th International Workshop on Laser Ranging Instrumentation. 2004.</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220306221746844.png" alt="image-20220306221746844"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220306223205754.png" alt="image-20220306223205754"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220306221628712.png" alt="image-20220306221628712"></p><hr><p><strong>朱庆生, 陈伟民, 吴金虎. 卫星激光测距望远镜的指向改正[J]. 天文研究与技术: 国家天文台台刊, 2011, 8(3): 268-271.</strong></p><p>常用的指向误差模型有球谐函数模型、基本参数模型、机架模型等。球谐函数模型是对以球面为基准面的误差进行拟合，可以用于任何机架形式的望远镜，但其表达式的各项没有物理意义，模型不稳定，每次重测数据后，求得的模型参数变化极大。基本参数模型的模型参数有实际物理意义，参数之间相关性小，模型比较稳定，但需根据望远镜的机架形式，设计不同的模型，而且考虑的参数项比较少，有时会影响改正的精度。机架模型也有人称为转台模型，目前常用于地平式机架，通过对望远镜机架进行全面分析得出的模型，共有 23 项，每一项都有具体的物理意义。它是对基本参数模型的扩展，因此精度更高，模型的逼近能力强于基本参数模型，缺点是没有基本参数模型稳定。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220306103515401.png" alt="image-20220306103515401"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220306104049068.png" alt="image-20220306104049068"></p><p><img src="C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20220306222049071.png" alt="image-20220306222049071"></p><hr><hr><p><strong>严灵杰. 光电望远镜视轴指向及预测技术研究[J]. 成都: 中国科学院光电技术研究所, 2019, 1.</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220306110849188.png" alt="image-20220306110849188"></p><hr><p>张涯辉, 罗一涵, 徐伟峰, 等. 采用加权最小二乘法的恒星校正研究[J]. 光电工程, 2014, 41(5): 7-11. 用了该方法</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307213741142.png" alt="image-20220307213741142"></p><hr><p>张玉碟, 柳万胜, 罗一涵, 等. 一种三轴光电跟踪系统指向误差修正的方法[J]. 光电工程, 2014, 41(6): 51-55.</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307214621476.png" alt="image-20220307214621476"></p>]]></content>
    
    
    <summary type="html">一直想对我司使用的指向模型进行溯源研究</summary>
    
    
    
    <category term="指向模型" scheme="https://tsuiwade.github.io/categories/%E6%8C%87%E5%90%91%E6%A8%A1%E5%9E%8B/"/>
    
    
    <category term="指向模型" scheme="https://tsuiwade.github.io/tags/%E6%8C%87%E5%90%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>视场与赤经范围的关系</title>
    <link href="https://tsuiwade.github.io/2022/03/03/blog40-guide-Sel-4-raROV/"/>
    <id>https://tsuiwade.github.io/2022/03/03/blog40-guide-Sel-4-raROV/</id>
    <published>2022-03-03T23:37:17.000Z</published>
    <updated>2022-03-03T23:37:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>球面三角学</p><p><a href="https://mathworld.wolfram.com/SphericalTrigonometry.html">https://mathworld.wolfram.com/SphericalTrigonometry.html</a></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220304202743522.png" alt="image-20220304202743522"></p><hr><p>《一种快速搜索导航星表的方法》</p><p><a href="https://patentimages.storage.googleapis.com/36/8b/67/874c0824e15854/CN101995248B.pdf">https://patentimages.storage.googleapis.com/36/8b/67/874c0824e15854/CN101995248B.pdf</a></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220303233833640.png" alt="image-20220303233833640"></p><p>还是不明白为什么是正切公式</p><hr><p><strong>王海涌, 徐皓. 一种星敏感器导航星筛选算法[J]. 激光与光电子学进展, 2021, 58(1): 0135001.</strong></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220304142358967.png" alt="image-20220304142358967"></p><p><a href="https://web.math.sinica.edu.tw/math_media/d281/28104.pdf">https://web.math.sinica.edu.tw/math_media/d281/28104.pdf</a></p><p><a href="https://mathworld.wolfram.com/SphericalTrigonometry.html">https://mathworld.wolfram.com/SphericalTrigonometry.html</a></p><p>中提到球面三角正弦公式</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220304151000732.png" alt="image-20220304151000732"></p><hr><p>《16mv精细导星星库构建与评价》</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301210751502.png" alt="image-20220301210751502"></p><hr><p>《<a href="http://geotech.chinaxiv.org/user/download.htm?id=6065">基于坐标系转换与QTM 编码的天球面探测覆盖栅格化分析方法研究</a>》</p><p>矩形锥视场</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220305100713620.png" alt="image-20220305100713620"></p><p>圆锥视场</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220305100740048.png" alt="image-20220305100740048"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;球面三角学&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mathworld.wolfram.com/SphericalTrigonometry.html&quot;&gt;https://mathworld.wolfram.com/SphericalTrigonometry.html&lt;</summary>
      
    
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/categories/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/tags/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>K-vector算法</title>
    <link href="https://tsuiwade.github.io/2022/03/02/blog39-guideSel-3/"/>
    <id>https://tsuiwade.github.io/2022/03/02/blog39-guideSel-3/</id>
    <published>2022-03-02T21:21:40.000Z</published>
    <updated>2022-03-02T21:21:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文《Search-less algorithm for star pattern recognition》</p><p><a href="https://link.springer.com/content/pdf/10.1007/BF03546375.pdf">https://link.springer.com/content/pdf/10.1007/BF03546375.pdf</a> 引用数129</p><p>K矢量查找法</p><p>中文论文《基于导航星域和K矢量的快速星图识别算法》</p><p>《一种改进的基于Ｋ 矢量的星图识别算法》</p><hr><p>《基于导航星域和K矢量的快速星图识别算法》</p><p>假设待排序的值为0.01到0.99，共有83363个数值，数列平均递增。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line">n = <span class="number">83363</span>;</span><br><span class="line">data=<span class="built_in">linspace</span>(<span class="number">0.01</span>,<span class="number">0.99</span>,<span class="number">83363</span>);</span><br><span class="line">D = (data(n)-data(<span class="number">1</span>))/(n<span class="number">-1</span>);</span><br><span class="line">a1 = n*D/(n<span class="number">-1</span>);</span><br><span class="line">a0 = data(<span class="number">1</span>) - a1 -D/<span class="number">2</span>;</span><br><span class="line">k = <span class="number">1</span>: n;</span><br><span class="line">costhe = a1 .* k + a0;</span><br><span class="line">K=[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(k,data,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(k,costhe,<span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220303085357833.png" alt="image-20220303085357833"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220303085450014.png" alt="image-20220303085450014"></p><p>搭建完毕，现在开始使用。</p><p>假定范围为（0.55,0.59），假设theta=0.57，delta=0.02</p><p>ib=45935</p><p>it=49338</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line">tic</span><br><span class="line">n = <span class="number">83363</span>;</span><br><span class="line">data=<span class="built_in">linspace</span>(<span class="number">0.01</span>,<span class="number">0.99</span>,<span class="number">83363</span>);</span><br><span class="line">D = (data(n)-data(<span class="number">1</span>))/(n<span class="number">-1</span>);</span><br><span class="line">a1 = n*D/(n<span class="number">-1</span>);</span><br><span class="line">a0 = data(<span class="number">1</span>) - a1 -D/<span class="number">2</span>;</span><br><span class="line">k = <span class="number">1</span>: n;</span><br><span class="line">costhe = a1 .* k + a0;</span><br><span class="line">K(<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span>:n</span><br><span class="line">    K(<span class="built_in">j</span>) = sum(sum(data &lt; costhe(<span class="built_in">j</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ib = <span class="built_in">fix</span>((<span class="number">0.59</span>-a0)/a1);</span><br><span class="line">it = <span class="built_in">fix</span>((<span class="number">0.55</span>-a0)/a1)+<span class="number">1</span>;</span><br><span class="line">kstart = K(ib) +<span class="number">1</span> ;</span><br><span class="line">kend = K(it) +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>kstar=45936</p><p>kend=49339</p><p>历时 5.060949 秒。</p><hr><p>《一种改进的基于Ｋ 矢量的星图识别算法》</p><p>提到了该方法有问题</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220303171127111.png" alt="image-20220303171127111"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220303213921527.png" alt="image-20220303213921527"></p>]]></content>
    
    
    <summary type="html">本文研究K-vector搜索算法</summary>
    
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/categories/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/tags/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>均匀性-玻尔兹曼熵</title>
    <link href="https://tsuiwade.github.io/2022/02/28/blog38-guideSel-2/"/>
    <id>https://tsuiwade.github.io/2022/02/28/blog38-guideSel-2/</id>
    <published>2022-02-28T11:04:22.000Z</published>
    <updated>2022-02-28T11:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在多篇文章中提到玻尔兹曼熵来表征评价均匀性（还有各分区内的星数标准差）。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220228111816120.png" alt="image-20220228111816120"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301160342968.png" alt="image-20220301160342968"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301211333236.png" alt="image-20220301211333236"></p><h2 id="多尺度像面分割《CN201510107562-0-用于星敏感器的筛选导航星的方法》"><a href="#多尺度像面分割《CN201510107562-0-用于星敏感器的筛选导航星的方法》" class="headerlink" title="多尺度像面分割《CN201510107562.0-用于星敏感器的筛选导航星的方法》"></a>多尺度像面分割《CN201510107562.0-用于星敏感器的筛选导航星的方法》</h2><h3 id="玻尔兹曼熵《Boltzmann-entropy-based-guide-star-selection-algorithm-for-star-tracker》2005"><a href="#玻尔兹曼熵《Boltzmann-entropy-based-guide-star-selection-algorithm-for-star-tracker》2005" class="headerlink" title="玻尔兹曼熵《Boltzmann entropy-based guide star selection algorithm for star tracker》2005"></a>玻尔兹曼熵《Boltzmann entropy-based guide star selection algorithm for star tracker》2005</h3><h2 id="正交网格法《A-general-method-of-the-automatical-selection-of-guide-star》"><a href="#正交网格法《A-general-method-of-the-automatical-selection-of-guide-star》" class="headerlink" title="正交网格法《A general method of the automatical selection of guide star》"></a>正交网格法《A general method of the automatical selection of guide star》</h2><p>用到uniformity的计算</p><h3 id="均匀性计算《Star-trackers-star-catalogs-and-attitude-determination-Probabilistic-aspects-of-system-design》1993"><a href="#均匀性计算《Star-trackers-star-catalogs-and-attitude-determination-Probabilistic-aspects-of-system-design》1993" class="headerlink" title="均匀性计算《Star trackers, star catalogs, and attitude determination-Probabilistic aspects of system design》1993"></a>均匀性计算《Star trackers, star catalogs, and attitude determination-Probabilistic aspects of system design》1993</h3><h4 id="《基于螺旋基准点的导航星选取方法》"><a href="#《基于螺旋基准点的导航星选取方法》" class="headerlink" title="《基于螺旋基准点的导航星选取方法》"></a>《基于螺旋基准点的导航星选取方法》</h4><p>均匀性很好</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220302143041244.png" alt="image-20220302143041244"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220302151757196.png" alt="image-20220302151757196"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"></span><br><span class="line">z=[];</span><br><span class="line">theta=[];</span><br><span class="line">fai=[];</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span>;</span><br><span class="line">k = <span class="number">0</span>:n<span class="number">-1</span>;</span><br><span class="line">z = <span class="number">1</span>-(<span class="number">2</span>*k+<span class="number">1</span>)/n;</span><br><span class="line">theta=<span class="built_in">acos</span>(z);</span><br><span class="line">fai=<span class="built_in">sqrt</span>(n*<span class="built_in">pi</span>).*theta;</span><br><span class="line">x = <span class="built_in">sin</span>(theta).*<span class="built_in">cos</span>(fai);</span><br><span class="line">y = <span class="built_in">sin</span>(theta).*<span class="built_in">sin</span>(fai);</span><br><span class="line">A = [x.&#x27;, y.&#x27; ,z.&#x27;];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(A)<span class="number">-1</span> </span><br><span class="line">    delta(<span class="built_in">i</span>,:) = <span class="built_in">acosd</span>(A(<span class="built_in">i</span>,:)*A(<span class="built_in">i</span>+<span class="number">1</span>,:).&#x27;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">mean</span> = <span class="built_in">mean</span>(delta);</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z,<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">1.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.1</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,A(<span class="number">2</span>,<span class="number">1</span>),A(<span class="number">2</span>,<span class="number">2</span>),A(<span class="number">2</span>,<span class="number">3</span>),<span class="number">1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">s=<span class="number">20</span>;</span><br><span class="line">xmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">xmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">ymin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">ymax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">zmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line">zmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line">                     </span><br><span class="line">plotcube([xmax-xmin ymax-ymin zmax-zmin],[ xmin  ymin  zmin],<span class="number">.8</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220320155757356.png" alt="image-20220320155757356"></p><hr><p>后来我又看到 <a href="https://zhuanlan.zhihu.com/p/25988652?group_id=828963677192491008">https://zhuanlan.zhihu.com/p/25988652?group_id=828963677192491008</a> <strong>菲波那契网格</strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">axis equal;</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span>;</span><br><span class="line">k = <span class="number">1</span>:n;</span><br><span class="line">c = (<span class="built_in">sqrt</span>(<span class="number">5</span>)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">z = (<span class="number">2</span>*k<span class="number">-1</span>)/n - <span class="number">1</span>;</span><br><span class="line">x = <span class="built_in">sqrt</span>(<span class="number">1</span>-z.^<span class="number">2</span>).*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>.*k*c);</span><br><span class="line">y = <span class="built_in">sqrt</span>(<span class="number">1</span>-z.^<span class="number">2</span>).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>.*k*c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [x.&#x27;, y.&#x27; ,z.&#x27;];</span><br><span class="line"></span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220320160017779.png" alt="image-20220320160017779"></p><p>效果并不好</p><hr><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220321101324772.png" alt="image-20220321101324772"></p><hr><p>阿基米德螺旋线</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220320105605922.png" alt="image-20220320105605922"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all; close all;</span><br><span class="line">a=<span class="number">0</span>;<span class="comment">%起始位置</span></span><br><span class="line">b=<span class="number">3</span>;<span class="comment">%螺线间距参数</span></span><br><span class="line">theta = <span class="number">0</span>:<span class="number">0.05</span>*<span class="built_in">pi</span>:<span class="number">10</span>*<span class="built_in">pi</span>;<span class="comment">%θ的范围和步长，同时也可以控制螺线的旋转方向</span></span><br><span class="line">coe=a+b*theta;<span class="comment">%阿基米德螺线方程</span></span><br><span class="line">x = (coe.*<span class="built_in">cos</span>(theta));<span class="comment">%因使用需要，获取直角坐标系下x轴的坐标并进行四舍五入</span></span><br><span class="line">y = (coe.*<span class="built_in">sin</span>(theta));<span class="comment">%因使用需要，获取直角坐标系下y轴的坐标并进行四舍五入</span></span><br><span class="line">r = <span class="built_in">pi</span>*b;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> :<span class="built_in">length</span>(x)</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    rectangle(<span class="string">&#x27;Position&#x27;</span>,[x(<span class="built_in">i</span>)-r,y(<span class="built_in">i</span>)-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;Curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;c&#x27;</span>);<span class="comment">%将获取的坐标打印在图纸上</span></span><br><span class="line">xt=x&#x27;;<span class="comment">%将x轴数据转置成列，便于导出使用</span></span><br><span class="line">yt=y&#x27;;<span class="comment">%将y周数据转置成列，便于导出使用</span></span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220307114759208.png" alt="image-20220307114759208"></p><p>弧长公式 <a href="https://www.zhihu.com/question/27384632">https://www.zhihu.com/question/27384632</a></p><h4 id="《均匀快速的导航星选取方法》"><a href="#《均匀快速的导航星选取方法》" class="headerlink" title="《均匀快速的导航星选取方法》"></a>《均匀快速的导航星选取方法》</h4><p>在赤纬带平分点，矩形范围的代码见下。（两角和余弦公式）</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220302200145394.png" alt="image-20220302200145394"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220302211206988.png" alt="image-20220302211206988"></p><h4 id="《16mv精细导星星库构建与评价》"><a href="#《16mv精细导星星库构建与评价》" class="headerlink" title="《16mv精细导星星库构建与评价》"></a>《16mv精细导星星库构建与评价》</h4><p>分区后取最亮几个。</p><p>国内研究构建星库的方法主要分为两类:第一类从星表划分角度出发,通过不同的划分方式进行导星筛选,现有的星表划分方法主要有赤纬带法、圆锥法、球矩形法、内接正方体法等;第二类从局部天区出发,主要包括回归筛星法、星等加权算法等。</p><p>评价标准：完备性 、均匀性和冗余性。（均匀性、速度、多于3个星的分区数概率）</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301210751502.png" alt="image-20220301210751502"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301210838500.png" alt="image-20220301210838500"></p><h4 id="《适用于小视场星敏感器的导航星表构建方法》"><a href="#《适用于小视场星敏感器的导航星表构建方法》" class="headerlink" title="《适用于小视场星敏感器的导航星表构建方法》"></a>《适用于小视场星敏感器的导航星表构建方法》</h4><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220303214512056.png" alt="image-20220303214512056"></p><hr><p>在1993年的均匀性计算文章中提到这一计算方法</p><p>总体均匀性计算方法：</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220228225805510.png" alt="image-20220228225805510"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220228225835383.png" alt="image-20220228225835383"></p><p>局部均匀性计算方法：</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220304094711632.png" alt="image-20220304094711632"></p><hr><p>以上一篇《基于星座聚类的星敏感器导航星优选算法研究》为例，</p><p>所有4908个点的全局均匀性为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% boltzmannEntropy.m</span></span><br><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(:,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(:,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(:,<span class="number">3</span>))  ];</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line"></span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>newmatrix =</p><p>​    0.2799   -0.0070    0.0483<br>   -0.0070    0.3631    0.0007<br>​    0.0483    0.0007    0.3570</p><p>eigen =</p><p>​    0.2562<br>​    0.3632<br>​    0.3805</p><p>ans =</p><p>​    0.0142</p><p>均匀化后 得到39个点 data=</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">bandwidth = <span class="number">0</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line"><span class="comment">% : = 1:end;</span></span><br><span class="line">data =  [  <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(:,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(:,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(:,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line">x=data&#x27;;</span><br><span class="line"></span><br><span class="line">tic</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">150</span></span><br><span class="line">    bandwidth = bandwidth + <span class="number">0.1</span>;</span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"><span class="built_in">scatter3</span>(data(:,<span class="number">1</span>),data(:,<span class="number">2</span>),data(:,<span class="number">3</span>),<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br><span class="line"></span><br><span class="line">A  =  data;</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line"></span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>0.721096202739022    0.143274305623194    -0.677858937938827<br>0.968970810392417    0.208978537391637    0.131998255735122<br>0.569826352357379    0.276879108656515    0.773715637265177<br>0.228610689351435    0.164381998103028    -0.959539322494872<br>0.680467391588214    0.574452415904999    0.454937963733565<br>0.755501580234282    0.652710692710075    0.0564456719814448<br>0.504277122250002    0.768039960865827    -0.394739410863010<br>0.154912237007631    0.405692531666614    0.900786194707282<br>0.210384928706513    0.600544339596624    -0.771417317637872<br>0.143977198200687    0.816855223274374    0.558585813109905<br>-0.229099414143074    0.950795223816936    -0.208571092930452<br>-0.282616508078908    0.919125613504918    0.274474071563222<br>-0.273028245935124    0.599816587126275    0.752114112837791<br>-0.384654835774312    0.742153343311259    -0.548861614915233<br>-0.256254169146301    0.406094432070341    -0.877166525259945<br>-0.739931959521445    0.571829210408285    -0.354276797719793<br>-0.806338802865188    0.579353885367924    0.119024411374415<br>-0.760075452992603    0.337837739926240    0.555113472399671<br>-0.487550601625308    0.150466743789691    0.860031493532724<br>-0.987416677336434    0.156220148544471    0.0245676719820876<br>-0.898581139351745    -0.0465144783456416    0.436335122704501<br>-0.374139568095630    -0.0287413085026819    -0.926926923101692<br>-0.963578273457490    -0.260891712855464    -0.0587573406820316<br>-0.799916216534544    -0.556325600463240    0.225024160467884<br>-0.732478694296601    -0.536144597346316    -0.419552062487963<br>-0.478334336301847    -0.740621679799566    0.471885356973005<br>-0.194005559456996    -0.435699798511738    0.878935451826020<br>-0.314232785230549    -0.886073947077770    -0.340779572445699<br>-0.00720050076528926    -0.0591052787344646    0.998225785488659<br>-0.0490019433066575    -0.732931424546231    -0.678535434936750<br>0.0801942976395903    -0.872038194549829    0.482823220104800<br>0.368597406332163    -0.929570349282381    0.00590912685900466<br>0.323982389195822    -0.553545295684837    0.767217711680429<br>0.514345456211916    -0.579655346834382    -0.632019327679517<br>0.827337679920563    -0.510494571429276    -0.234323827053289<br>0.448212896485379    -0.212583754752496    -0.868281835949317<br>0.964675223452813    -0.215965114222275    0.150866771342216<br>0.724877321462857    -0.104703930494290    0.680874405281827<br>0.927771336185871    -0.108671846203537    -0.356974477511487</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301152248993.png" alt="image-20220301152248993"></p><p>newmatrix =</p><p>​    0.3527   -0.0057   -0.0221<br>   -0.0057    0.3007    0.0039<br>   -0.0221    0.0039    0.3466</p><p>eigen =</p><p>​    0.3001<br>​    0.3273<br>​    0.3726</p><p>ans =</p><p>​    0.0040</p><p>均匀性不错。</p><p>又做一次实验</p><p>newmatrix =<br>    0.3364   -0.0062   -0.0127<br>   -0.0062    0.3195    0.0007<br>   -0.0127    0.0007    0.3441</p><p>eigen =<br>    0.3169<br>    0.3290<br>    0.3541</p><p>ans =<br>    0.0011</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301165031830.png" alt="image-20220301165031830"></p><p>随机选取39个点</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">1</span>) = <span class="built_in">cos</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">2</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">3</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">A = star_data_xyz(randperm(<span class="built_in">length</span>(star_data_xyz), <span class="number">39</span>),:)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">scatter3</span>(star_data_xyz(:,<span class="number">1</span>),star_data_xyz(:,<span class="number">2</span>),star_data_xyz(:,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"><span class="built_in">scatter3</span>(A(:,<span class="number">1</span>),A(:,<span class="number">2</span>),A(:,<span class="number">3</span>),<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure><p>newmatrix =<br>    0.3068   -0.0422    0.0801<br>   -0.0422    0.3637   -0.0381<br>    0.0801   -0.0381    0.3295</p><p>eigen =<br>    0.2368<br>    0.3226<br>    0.4406</p><p>ans =<br>    0.0314</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301161540597.png" alt="image-20220301161540597"></p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 矩形范围</span></span><br><span class="line">clear all ;close all;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"></span><br><span class="line">z=[];</span><br><span class="line">theta=[];</span><br><span class="line">fai=[];</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span>;</span><br><span class="line">k = <span class="number">0</span>:n<span class="number">-1</span>;</span><br><span class="line">z = <span class="number">1</span>-(<span class="number">2</span>*k+<span class="number">1</span>)/n;</span><br><span class="line">theta=<span class="built_in">acos</span>(z);</span><br><span class="line">fai=<span class="built_in">sqrt</span>(n*<span class="built_in">pi</span>).*theta;</span><br><span class="line">x = <span class="built_in">sin</span>(theta).*<span class="built_in">cos</span>(fai);</span><br><span class="line">y = <span class="built_in">sin</span>(theta).*<span class="built_in">sin</span>(fai);</span><br><span class="line">A = [x.&#x27;, y.&#x27; ,z.&#x27;];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(A)<span class="number">-1</span> </span><br><span class="line">    delta(<span class="built_in">i</span>,:) = <span class="built_in">acosd</span>(A(<span class="built_in">i</span>,:)*A(<span class="built_in">i</span>+<span class="number">1</span>,:).&#x27;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">mean</span> = <span class="built_in">mean</span>(delta);</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z,<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">1.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.1</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,A(<span class="number">2</span>,<span class="number">1</span>),A(<span class="number">2</span>,<span class="number">2</span>),A(<span class="number">2</span>,<span class="number">3</span>),<span class="number">1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">s=<span class="number">20</span>;</span><br><span class="line">xmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">xmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">ymin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">ymax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">zmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line">zmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">plotcube([xmax-xmin ymax-ymin zmax-zmin],[ xmin  ymin  zmin],<span class="number">.8</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">接着上文求解球面上的均匀性</summary>
    
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/categories/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/tags/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>《基于星座聚类的星敏感器导航星优选算法研究》的复现</title>
    <link href="https://tsuiwade.github.io/2022/02/24/blog37-guideSel-1/"/>
    <id>https://tsuiwade.github.io/2022/02/24/blog37-guideSel-1/</id>
    <published>2022-02-24T17:20:11.000Z</published>
    <updated>2022-07-23T01:36:47.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一直对公司采用的指向模型修正过程中的选星过程很感兴趣，想知道是否有相关的文献。</p><p>的确有找到相关文献，想就此进行复现。先对下文进行复现。</p><p><code>吴峰, 朱锡芳, 相入喜, 等. 基于星座聚类的星敏感器导航星优选算法研究[J]. 微电子学与计算机, 2018, 35(3): 140-144.</code></p><p>主要涉及<code>Mean Shift</code>（均值漂移）算法</p><hr><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>一般对原始星表恒星数据做星等阈值处理， 即可得到导航星星库． <code>为提高星图识别稳定性， 增强星敏感器系统性能</code>， 通常要求导航星在天球上分布均匀． 为此， 国内外许多研究人员提出了进一步筛选导航星的算法．   </p><hr><h1 id="相关文献："><a href="#相关文献：" class="headerlink" title="相关文献："></a>相关文献：</h1><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220224211251099.png" alt="image-20220224211251099"></p><hr><h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>通常星座区域的恒星密度高， 星座和星座之间的区域星密度低． 为此， 本文首先借鉴Mean Shift（均值漂移）算法， 提出星座聚类算法， 将视场内的恒星划分到不同的星座． 然后， 提出基于星座聚类的导航星优选算法， 通过每次选择星数最多的一个星座， 并删除离该星座中心最近的一颗恒星， 最终实现导航星的均匀分布  </p><p>Mean Shift（均值漂移）是<strong>基于密度的非参数聚类算法</strong>，其算法思想是假设不同簇类的数据集符合不同的概率密度分布，找到任一样本点<strong>密度增大的最快方向</strong>（最快方向的含义就是Mean Shift），样本密度高的区域对应于该分布的最大值，这些样本点最终会在局部密度最大值收敛，且收敛到相同局部最大值的点被认为是同一簇类的成员。（<a href="https://cloud.tencent.com/developer/article/1459530）">https://cloud.tencent.com/developer/article/1459530）</a></p><p><strong>1.核密度估计</strong></p><p>Mean Shift算法用核函数估计样本的密度，最常用的核函数是高斯核。它的工作原理是在数据集上的<strong>每一个样本点</strong>都设置一个核函数，然后对所有的核函数相加，得到数据集的核密度估计（kernel density estimation）。</p><p>假设我们有大小为n的d维数据集</p><p>如下图，我们用高斯核估计一维数据集的密度，每个样本点都设置了以该样本点为中心的高斯分布，累加所有的高斯分布，得到该数据集的密度。</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220224212833039.png" alt="image-20220224212833039"></p><p>其中虚线表示每个样本点的高斯核，实线表示累加所有样本高斯核后的数据集密度。因此，我们通过高斯核来得到数据集的密度。</p><p><strong>5.图像分割</strong>示例</p><p>mean shift通过对像素空间进行聚类，达到图像分割的目的。</p><p>我们对下图进行图像分割：</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220224212938640.png" alt="image-20220224212938640"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220224212952595.png" alt="image-20220224212952595"></p><h2 id="Mean-Shift算法的优缺点"><a href="#Mean-Shift算法的优缺点" class="headerlink" title="Mean Shift算法的优缺点"></a><strong>Mean Shift算法的优缺点</strong></h2><p>优点：</p><p>不需要设置簇类的个数；</p><p>可以处理任意形状的簇类；</p><p>算法只需设置带宽这一个参数，带宽影响数据集的核密度估计</p><p>算法结果稳定，不需要进行类似K均值的样本初始化</p><p>缺点：</p><p>聚类结果取决于带宽的设置，带宽设置的太小，收敛太慢，簇类个数过多；带宽设置的太大，一些簇类可能会丢失。</p><p>对于较大的特征空间，计算量非常大。</p><h2 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h2><p><a href="https://blog.csdn.net/google19890102/article/details/51030884">https://blog.csdn.net/google19890102/article/details/51030884</a></p><h1 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h1><p><a href="https://blog.csdn.net/HJ199404182515/article/details/121694298">https://blog.csdn.net/HJ199404182515/article/details/121694298</a></p><p><strong><a href="https://www.cnblogs.com/kailugaji/p/11646167.html">https://www.cnblogs.com/kailugaji/p/11646167.html</a></strong></p><p>函数代码为MeanShiftCluster.m</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"> </span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line">    stInd           = initPtInds(tempInd);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">%*** plot stuff ****</span></span><br><span class="line">        <span class="keyword">if</span> plotFlag</span><br><span class="line">            <span class="built_in">figure</span>(<span class="number">1</span>),clf,<span class="built_in">hold</span> on</span><br><span class="line">            <span class="keyword">if</span> numDim == <span class="number">2</span></span><br><span class="line">                <span class="built_in">plot</span>(dataPts(<span class="number">1</span>,:),dataPts(<span class="number">2</span>,:),<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(dataPts(<span class="number">1</span>,myMembers),dataPts(<span class="number">2</span>,myMembers),<span class="string">&#x27;ys&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(myMean(<span class="number">1</span>),myMean(<span class="number">2</span>),<span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(myOldMean(<span class="number">1</span>),myOldMean(<span class="number">2</span>),<span class="string">&#x27;rd&#x27;</span>)</span><br><span class="line">                pause</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = numClust+<span class="number">1</span>;                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">[val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);                <span class="comment">%a point belongs to the cluster with the most votes</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="number">9.32</span>   <span class="number">8.16</span>  </span><br><span class="line"><span class="number">8.45</span>    <span class="number">-4.4</span></span><br><span class="line"><span class="number">7.67</span>    <span class="number">0.73</span></span><br><span class="line"><span class="number">7.3</span>    <span class="number">-3.38</span></span><br><span class="line"><span class="number">5.72</span>  <span class="number">2.38</span></span><br><span class="line"><span class="number">5.5</span>  <span class="number">-3.7</span></span><br><span class="line"><span class="number">5.31</span>  <span class="number">-9.36</span></span><br><span class="line"><span class="number">4.31</span>  <span class="number">-5.68</span></span><br><span class="line"><span class="number">4.08</span>  <span class="number">-6.6</span></span><br><span class="line"><span class="number">2.52</span>  <span class="number">3.26</span></span><br><span class="line"><span class="number">1.24</span> <span class="number">-3.63</span></span><br><span class="line"><span class="number">0.24</span> <span class="number">7.19</span></span><br><span class="line"><span class="number">-0.45</span>  <span class="number">4.09</span></span><br><span class="line"><span class="number">-0.76</span>  <span class="number">-2.59</span></span><br><span class="line"><span class="number">-3.54</span>  <span class="number">8.17</span></span><br><span class="line"><span class="number">-4.49</span>  <span class="number">0.34</span></span><br><span class="line"><span class="number">-4.61</span>  <span class="number">9.58</span></span><br><span class="line"><span class="number">-5.76</span>  <span class="number">-6.98</span></span><br><span class="line"><span class="number">-6.55</span>  <span class="number">7.11</span></span><br><span class="line"><span class="number">-7.79</span>  <span class="number">8.99</span></span><br><span class="line"><span class="number">-9.40</span>  <span class="number">-3.37</span></span><br></pre></td></tr></table></figure><p>测试代码testMeanShift.m为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line"> </span><br><span class="line">bandwidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data=data_load;</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line">[clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(x,bandwidth);</span><br><span class="line"><span class="comment">% clustCent：聚类中心 D*K, point2cluster：聚类结果 类标签, 1*N</span></span><br><span class="line">toc</span><br><span class="line"><span class="comment">%% 作图</span></span><br><span class="line">numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line"><span class="comment">%     plot(x(1,myMembers),x(2,myMembers),[cVec(k) &#x27;.&#x27;]);</span></span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%     plot(myClustCen(1),myClustCen(2),&#x27;o&#x27;,&#x27;MarkerEdgeColor&#x27;,&#x27;k&#x27;,&#x27;MarkerFaceColor&#x27;,cVec(k), &#x27;MarkerSize&#x27;,10)</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(data,<span class="number">1</span>)</span><br><span class="line">    text(data(<span class="built_in">j</span>,<span class="number">2</span>)+<span class="number">0.2</span>,data(<span class="built_in">j</span>,<span class="number">1</span>)<span class="number">-0.2</span>,num2str(<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220225104512976.png" alt="image-20220225104512976"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220225104550867.png" alt="image-20220225104550867"></p><p>结果不唯一，有时为18类。</p><p>clustCent 2*18 为中心坐标</p><p>point2cluster 1*21 为类别</p><p>clustMembsCell =</p><p>  18×1 cell 数组</p><p>{[   19]}<br>{[   11]}<br>{[15 17]}<br>{[    3]}<br>{[   21]}<br>{[   10]}<br>{[   13]}<br>{[    1]}<br>{[   16]}<br>{[   14]}<br>{[2 4 6]}<br>{[  8 9]}<br>{[    7]}<br>{[   18]}<br>{[   12]}<br>{[    5]}<br>{[   20]}</p><p>根据文章算法修改后MeanShiftCluster.m</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220226160621431.png" alt="image-20220226160621431"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line">nowNum = <span class="number">1</span>;</span><br><span class="line">outCom = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"></span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line"><span class="comment">%     stInd           = initPtInds(tempInd);                  %use this point as start of mean</span></span><br><span class="line">    stInd           = <span class="built_in">min</span>(initPtInds);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"><span class="comment">%     beyondMe=[];</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">length</span>(inInds)&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">min</span>(outCom(inInds))==<span class="number">0</span>)<span class="comment">% 2，6</span></span><br><span class="line">            beyondMe = inInds;</span><br><span class="line">            beyondMe(beyondMe == initPtInds(<span class="number">1</span>)) = [];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))</span><br><span class="line">                thisCluster = <span class="built_in">min</span>(outCom(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                outCom(stInd)=outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">% 4</span></span><br><span class="line">                outCom(stInd)=nowNum;</span><br><span class="line">                outCom(beyondMe)=nowNum;</span><br><span class="line">                nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> <span class="built_in">length</span>(inInds)==<span class="number">1</span> <span class="comment">% 1、3、5</span></span><br><span class="line">            outCom(stInd)=nowNum;</span><br><span class="line">            nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = outCom(stInd);                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line">    [val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data2cluster = outCom;</span><br><span class="line"></span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>outCom =</p><pre><code> 1     2     3     2     4     2     5     6     6     7     8     9    10    11    12    13    12    14    15    16    17</code></pre><p>clustCent 2*17 为中心坐标</p><p>point2cluster 1*21 为类别 1     1     3     2     4     2     5     6     6     7     8     9    10    11    12    13    12    14    15    16    17</p><p>根据文章算法修改后MeanShiftCluster.m</p><p>clustMembsCell =</p><p>  18×1 cell 数组</p><p>{[   19]}<br>{[   11]}<br>{[15 17]}<br>{[    3]}<br>{[   21]}<br>{[   10]}<br>{[   13]}<br>{[    1]}<br>{[   16]}<br>{[   14]}<br>{[2 4 6]}<br>{[  8 9]}<br>{[    7]}<br>{[   18]}<br>{[   12]}<br>{[    5]}<br>{[   20]}</p><p>经过第一轮循环，删除了第4/8/15个星。</p><p>再正式修改为MeanShiftCluster.m</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line">nowNum = <span class="number">1</span>;</span><br><span class="line">outCom = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"></span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line">    stInd           = initPtInds(tempInd);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"><span class="comment">%     beyondMe=[];</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">length</span>(inInds)&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">min</span>(outCom(inInds))==<span class="number">0</span>)<span class="comment">% 2，6</span></span><br><span class="line">            beyondMe = inInds;</span><br><span class="line">            beyondMe(beyondMe == stInd) = [];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))</span><br><span class="line">                thisCluster = <span class="built_in">min</span>(outCom(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                outCom(stInd)=<span class="built_in">min</span>(outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))));</span><br><span class="line">                outCom(beyondMe)=<span class="built_in">min</span>(outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))));</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">% 4</span></span><br><span class="line">                outCom(stInd)=nowNum;</span><br><span class="line">                outCom(beyondMe)=nowNum;</span><br><span class="line">                nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> <span class="built_in">length</span>(inInds)==<span class="number">1</span> <span class="comment">% 1、3、5</span></span><br><span class="line">            outCom(stInd)=nowNum;</span><br><span class="line">            nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = outCom(stInd);                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line">    [val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data2cluster = outCom;</span><br><span class="line"></span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>testMeanShift.m为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line"> </span><br><span class="line">bandwidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data=data_load;</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">6</span></span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bandwidth = bandwidth + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>得到不多于6个点的几个测试结果为：</p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220227002446282.png" alt="image-20220227002446282"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220227002502414.png" alt="image-20220227002502414"></p><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220227002520760.png" alt="image-20220227002520760"></p><p>通常以玻尔兹曼熵评价导航星的全天球分布均匀性， 以视场内捕获恒星数的最大值、 最小值、 均值和标准差等评价局部天球分布均匀。</p><p>但我还不知道如何求解玻尔兹曼熵。（下文求解）</p><hr><p>带入星图数据（下代码有误，请看后一篇博客）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">bandwidth = <span class="number">5</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data = star_data(:,<span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line"><span class="comment">% data = data_load(:,1:2);</span></span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">150</span></span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        bandwidth = bandwidth + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p><img src="https://images-1312692717.cos.ap-nanjing.myqcloud.com/img/img/image-20220301103413554.png" alt="image-20220301103413554"></p><p>历时 3101.811945 秒。</p>]]></content>
    
    
    <summary type="html">从本文起将开启研究导航星的筛选问题，本文首先研究 《基于星座聚类的星敏感器导航星优选算法研究》。</summary>
    
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/categories/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
    
    <category term="导航星筛选" scheme="https://tsuiwade.github.io/tags/%E5%AF%BC%E8%88%AA%E6%98%9F%E7%AD%9B%E9%80%89/"/>
    
  </entry>
  
</feed>
