<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>冲毕业结束</title>
      <link href="2023/04/24/blog71-studyover/"/>
      <url>2023/04/24/blog71-studyover/</url>
      
        <content type="html"><![CDATA[<p>还有部署的bug 同步gitee的bug </p><p>在根目录_config.yml</p><p># Deployment</p><p>## Docs: <a href="https://hexo.io/docs/one-command-deployment">https://hexo.io/docs/one-command-deployment</a></p><p>deploy:</p><p> type: git</p><p> # repo: <a href="https://github.com/tsuiwade/tsuiwade.github.io">https://github.com/tsuiwade/tsuiwade.github.io</a></p><p> repo:</p><p>  # gitee: <a href="https://gitee.com/tsuiwade/tsuiwade">https://gitee.com/tsuiwade/tsuiwade</a></p><p>  # github: <a href="https://github.com/tsuiwade/tsuiwade.github.io">https://github.com/tsuiwade/tsuiwade.github.io</a></p><p>  gitee: <a href="https://tsuiwade:私人令牌@gitee.com/tsuiwade/tsuiwade.git">https://tsuiwade:私人令牌@gitee.com/tsuiwade/tsuiwade.git</a></p><p>  github: <a href="https://tsuiwade:私人令牌@github.com/tsuiwade/tsuiwade.github.io.git">https://tsuiwade:私人令牌@github.com/tsuiwade/tsuiwade.github.io.git</a></p><p> branch: master</p><p>设置aactions -》settings -》 Actions secrets and variables  -》 GITEE_RSA_PRIVATE_KEY  -》为私钥.ssh  id_rsa</p><p>搞了很久！</p><hr><p>还是非常感谢 <a href="https://www.zhihu.com/question/373117145">https://www.zhihu.com/question/373117145</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230106213047672.png" alt="image-20230106213047672"></p><hr><p>接下来需要考虑二维的问题了。</p><p>突然发现一个这个算法</p><p><a href="https://stackoverflow.com/questions/18227014/selecting-evenly-distributed-points-algorithm">https://stackoverflow.com/questions/18227014/selecting-evenly-distributed-points-algorithm</a></p><p>算法是遍历前面的最小cost</p><p>double tempcost = solutions[j].cost + std::abs(dis[i] - dis[j] - 0.1);</p><p>0.1为1/10 但问题是凑不到10个点</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230110193501924.png" alt="image-20230110193501924"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230110193718928.png" alt="image-20230110193718928"></p><p>在下面的回答中看到了</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230110202736178.png" alt="image-20230110202736178"></p><p>提到了ANMS算法<em>自适应非</em>极大值<em>抑制算法</em></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230110202840779.png" alt="image-20230110202840779"></p><p>有点像那么回事</p><hr><p>应该会有一些对比实验： 非极大值抑制算法ANMS、bucketing算法 <a href="https://blog.csdn.net/frozenspring/article/details/117174032">https://blog.csdn.net/frozenspring/article/details/117174032</a> </p><p><a href="https://blog.csdn.net/u013453604/article/details/45350653">https://blog.csdn.net/u013453604/article/details/45350653</a>  ANMS</p><p>对比实验</p><p>EFFICIENTLY SELECTING SPATIALLY DISTRIBUTED KEYPOINTS FOR VISUAL TRACKING 2011</p><p>2005年 Matthew Brown在论文Multi-Image Matching using Multi-<a href="https://so.csdn.net/so/search?q=Scale&amp;spm=1001.2101.3001.7020">Scale</a> Oriented Patches提出了自适应非极大值抑制算法（Adaptive Non-Maximum Suppression，ANMS</p><p>最近有一篇论文讨论了图像上均匀关键点分布的问题。这个资源库提供了 C + + 、 Python 和 Matlab 接口</p><p>There is a recent <a href="https://www.researchgate.net/publication/323388062_Efficient_adaptive_non-maximal_suppression_algorithms_for_homogeneous_spatial_keypoint_distribution">paper</a> that tackles the problem of homogeneous keypoint distribution on the image. C++, Python, and Matlab interfaces are provided in this <a href="https://github.com/BAILOOL/ANMS-Codes">repository</a> </p><hr><p>L. F. Kozachenko and N. N. Leonenko. Sample estimate of entropy of a random vector. Problems of Information Transmission, 23:95–101, 1987.</p><p><a href="https://kaba.hilvi.org/tim-1.3.0/tim/core/differential_entropy_kl_details.htm">https://kaba.hilvi.org/tim-1.3.0/tim/core/differential_entropy_kl_details.htm</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230113120228341.png" alt="image-20230113120228341"></p><hr><p>学习b站kd树</p><p><a href="https://www.bilibili.com/video/BV1d5411w7f5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8">https://www.bilibili.com/video/BV1d5411w7f5/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230113203850687.png" alt="image-20230113203850687"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230113144914106.png" alt="image-20230113144914106"></p><p>后来在思考我的矩形是首尾相连的，该怎么办呢。</p><p>学习kd树的搜索原理，自己画了个图就能理解了，当点的最小半径 &lt; 该点的x，说明会和x=0相交，那么将该点的x轴加360，再进行搜索，最终比较两个半径，取最小的半径作为distance。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.special <span class="keyword">import</span> gamma, digamma</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> entropy_estimators <span class="keyword">import</span> continuous</span><br><span class="line">X = np.loadtxt(<span class="built_in">open</span>(<span class="string">&quot;J2000_5_hor2.csv&quot;</span>, <span class="string">&quot;rb&quot;</span>), delimiter=<span class="string">&quot;,&quot;</span>, skiprows=<span class="number">0</span>)</span><br><span class="line">print(X.shape)</span><br><span class="line">kozachenko = continuous.get_h(X, k=<span class="number">1</span>, norm=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f&quot;K-L estimator: <span class="subst">&#123;kozachenko:<span class="number">.5</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有点的 K-L estimator: 11.33121（魔改distance前）</p><p>魔改效果为 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230113164347580.png" alt="image-20230113164347580"></p><p>改善第51个点，魔改算法为</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n, d = x.shape</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> norm == <span class="string">&#x27;max&#x27;</span>:  <span class="comment"># max norm:</span></span><br><span class="line">    p = np.inf</span><br><span class="line">    log_c_d = <span class="number">0</span>  <span class="comment"># volume of the d-dimensional unit ball</span></span><br><span class="line"><span class="keyword">elif</span> norm == <span class="string">&#x27;euclidean&#x27;</span>:  <span class="comment"># euclidean norm</span></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    log_c_d = (d/<span class="number">2.</span>) * log(np.pi) - log(gamma(d/<span class="number">2.</span> + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError(</span><br><span class="line">        <span class="string">&quot;Variable &#x27;norm&#x27; either &#x27;max&#x27; or &#x27;euclidean&#x27;&quot;</span>)</span><br><span class="line">kdtree = cKDTree(x)</span><br><span class="line"><span class="comment"># query all points -- k+1 as query point also in initial set</span></span><br><span class="line"><span class="comment"># distances, _ = kdtree.query(x, k + 1, eps=0, p=norm)</span></span><br><span class="line">distances, _ = kdtree.query(x, k + <span class="number">1</span>, eps=<span class="number">0</span>, p=p)</span><br><span class="line">distances = distances[:, -<span class="number">1</span>]</span><br><span class="line">print(<span class="string">&quot;distances11 &quot;</span>, <span class="built_in">len</span>(distances))</span><br><span class="line">print(<span class="string">&quot;x11 &quot;</span>, x[<span class="number">0</span>, <span class="number">1</span>], <span class="string">&quot; distances &quot;</span>, distances[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span> cur <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    <span class="keyword">if</span> (x[cur, <span class="number">0</span>] &lt; distances[cur]):</span><br><span class="line">        value = x[cur, <span class="number">0</span>] + <span class="number">360.0</span></span><br><span class="line">        distances1, _ = kdtree.query([value, x[cur, <span class="number">1</span>]], k, eps=<span class="number">0</span>, p=p)</span><br><span class="line">        print(<span class="string">&quot; cur &quot;</span>, cur, <span class="string">&quot; va &quot;</span>, value, <span class="string">&quot; distances1 &quot;</span>,</span><br><span class="line">              distances1, <span class="string">&quot; qian &quot;</span>, distances[cur])</span><br><span class="line">        <span class="comment"># print(&quot; distances1 &quot;, distances[cur])</span></span><br><span class="line">        distances[cur] = <span class="built_in">min</span>(distances[cur], distances1)</span><br><span class="line">    <span class="keyword">elif</span> (x[cur, <span class="number">0</span>] &gt; <span class="number">360.0</span>-distances[cur]):</span><br><span class="line">        value = x[cur, <span class="number">0</span>] - <span class="number">360.0</span></span><br><span class="line">        print(<span class="string">&quot; va &quot;</span>, value)</span><br><span class="line">        distances1, _ = kdtree.query([value,  x[cur, <span class="number">1</span>]], k, eps=<span class="number">0</span>, p=p)</span><br><span class="line">        distances[cur] = <span class="built_in">min</span>(distances[cur], distances1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;distances &quot;, distances)</span></span><br><span class="line"><span class="comment"># enforce non-zero distances</span></span><br><span class="line">distances[distances &lt; min_dist] = min_dist</span><br><span class="line"></span><br><span class="line"><span class="comment"># where did the 2 come from? radius -&gt; diameter</span></span><br><span class="line">sum_log_dist = np.<span class="built_in">sum</span>(log(<span class="number">2</span>*distances))</span><br><span class="line">h = -digamma(k) + digamma(n) + log_c_d + (d / <span class="built_in">float</span>(n)) * sum_log_dist</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>h值为11.33087（魔改后，虽然变小 ，考虑到左右宽度）</p><hr><p>接下来改为matlab</p><p>网上找的代码</p><p><a href="https://blog.csdn.net/john_xia/article/details/107563005">https://blog.csdn.net/john_xia/article/details/107563005</a> 不好用 直接用内置函数</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">data = [<span class="number">2</span> <span class="number">3</span>;</span><br><span class="line">    <span class="number">5</span> <span class="number">4</span>;</span><br><span class="line">    <span class="number">9</span> <span class="number">6</span>;</span><br><span class="line">    <span class="number">4</span> <span class="number">7</span>;</span><br><span class="line">    <span class="number">8</span> <span class="number">1</span>;</span><br><span class="line">    <span class="number">7</span> <span class="number">2</span>];</span><br><span class="line">Mdl = KDTreeSearcher(data)</span><br><span class="line">[n,d] = knnsearch(Mdl,[<span class="number">6</span>,<span class="number">3.1</span>],<span class="string">&#x27;k&#x27;</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>n =</p><pre><code> 2     6     5     1     3     4</code></pre><p>d =</p><pre><code>1.3454    1.4866    2.9000    4.0012    4.1725    4.3829</code></pre><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear;close all;clc;</span><br><span class="line">tic;</span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">points = M(:, <span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">Mdl = KDTreeSearcher(points);</span><br><span class="line">[n,d] = knnsearch(Mdl,points,<span class="string">&#x27;k&#x27;</span>,k+<span class="number">1</span>);</span><br><span class="line">distances = d(:,<span class="keyword">end</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(points)</span><br><span class="line">    <span class="keyword">if</span> ( points(<span class="built_in">i</span>,<span class="number">1</span>) &lt; distances(<span class="built_in">i</span>) ) </span><br><span class="line">        value = points(<span class="built_in">i</span>,<span class="number">1</span>) + <span class="number">360.0</span>;</span><br><span class="line">        [~, dd] = knnsearch(Mdl,[value, points(<span class="built_in">i</span>, <span class="number">2</span>)],<span class="string">&#x27;k&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        distances(<span class="built_in">i</span>) = <span class="built_in">min</span>(distances(<span class="built_in">i</span>), dd);</span><br><span class="line">    <span class="keyword">elseif</span> (points(<span class="built_in">i</span>, <span class="number">1</span>) &gt; <span class="number">360.0</span>-distances(<span class="built_in">i</span>) ) </span><br><span class="line">        value = points(<span class="built_in">i</span>,<span class="number">1</span>) - <span class="number">360.0</span>;</span><br><span class="line">        [~, dd] = knnsearch(Mdl,[value, points(<span class="built_in">i</span>, <span class="number">2</span>)],<span class="string">&#x27;k&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        distances(<span class="built_in">i</span>) = <span class="built_in">min</span>(distances(<span class="built_in">i</span>), dd);        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Copy_2_of_totalH(distances,<span class="built_in">length</span>(points))</span><br><span class="line">toc;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">h</span> =  <span class="title">Copy_2_of_totalH</span><span class="params">(distances, len)</span></span></span><br><span class="line">    d = <span class="number">2</span>;</span><br><span class="line">    log_c_d = (d/<span class="number">2.</span>) * <span class="built_in">log</span>(<span class="built_in">pi</span>) - <span class="built_in">log</span>(<span class="built_in">gamma</span>(d/<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    sum_log_dist = sum(<span class="built_in">log</span>(<span class="number">2</span>*distances));</span><br><span class="line">    h = - <span class="built_in">psi</span>(<span class="number">1</span>) + <span class="built_in">psi</span>(len) + log_c_d + (d/len) * sum_log_dist;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>验证是对的</p><p>接着</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 模拟退火求解选点问题 直接计算h 更慢  % 466</span></span><br><span class="line">clear all; clc; close all;</span><br><span class="line">tic</span><br><span class="line"><span class="comment">% load points;</span></span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">points = M(:, <span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line"><span class="comment">% points = sort(points);</span></span><br><span class="line">rng(<span class="string">&#x27;shuffle&#x27;</span>)  <span class="comment">% 控制随机数的生成，否则每次打开matlab得到的结果都一样</span></span><br><span class="line">len = <span class="number">50</span>;</span><br><span class="line">map = [<span class="number">1</span>:len,<span class="number">1</span>:len];</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line">T0 = <span class="number">1000</span>;   <span class="comment">% 初始温度</span></span><br><span class="line">T = T0; <span class="comment">% 迭代中温度会发生改变，第一次迭代时温度就是T0</span></span><br><span class="line">maxgen = <span class="number">800</span>;  <span class="comment">% 最大迭代次数</span></span><br><span class="line">Lk = <span class="number">200</span>;  <span class="comment">% 每个温度下的迭代次数</span></span><br><span class="line">alfa = <span class="number">0.95</span>;  <span class="comment">% 温度衰减系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  随机生成一个初始解</span></span><br><span class="line">A = int32(<span class="number">1</span>:<span class="built_in">length</span>(points));</span><br><span class="line">random_num = A(randperm(<span class="built_in">numel</span>(A),len));</span><br><span class="line">index0 = <span class="built_in">sort</span>(random_num);</span><br><span class="line">h0 = Copy_2_of_totalH(points, index0);</span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;初始方案是：&#x27;</span>); <span class="built_in">disp</span>(mat2str(index0))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(h0)</span><br><span class="line">min_money = h0;     <span class="comment">% 初始化找到的最佳的解对应的花费为money0</span></span><br><span class="line">MONEY = <span class="built_in">zeros</span>(maxgen,<span class="number">1</span>); <span class="comment">% 记录每一次外层循环结束后找到的min_money (方便画图）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 模拟退火过程</span></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span> : maxgen  <span class="comment">% 外循环, 我这里采用的是指定最大迭代次数</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : Lk  <span class="comment">%  内循环，在每个温度下开始迭代</span></span><br><span class="line">        index = index0;</span><br><span class="line">        x_num = index(randperm(<span class="built_in">numel</span>(index),<span class="number">1</span>));</span><br><span class="line">        x = <span class="built_in">find</span>(index == x_num);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        shengxia = setxor(A, index);</span><br><span class="line">        y_num = shengxia(randperm(<span class="built_in">numel</span>(shengxia),<span class="number">1</span>));</span><br><span class="line">        index(x) = y_num;</span><br><span class="line">        index = <span class="built_in">sort</span>(index);</span><br><span class="line"></span><br><span class="line">        index1 = index;  <span class="comment">% 调用我们自己写的gen_new_way函数生成新的方案</span></span><br><span class="line"></span><br><span class="line">        h1 = Copy_2_of_totalH(points, index1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> h1 &gt; h0    <span class="comment">% 如果新方案的花费小于当前方案的花费</span></span><br><span class="line">            index0 = index1; <span class="comment">% 更新当前方案为新方案</span></span><br><span class="line">            h0 = h1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = <span class="built_in">exp</span>((h1 - h0)/T); <span class="comment">% 根据Metropolis准则计算一个概率</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>(<span class="number">1</span>) &lt; p   <span class="comment">% 生成一个随机数和这个概率比较，如果该随机数小于这个概率</span></span><br><span class="line">                index0 = index1; <span class="comment">% 更新当前方案为新方案</span></span><br><span class="line">                h0 = h1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 判断是否要更新找到的最佳的解</span></span><br><span class="line">        <span class="keyword">if</span> h0 &gt; min_money  <span class="comment">% 如果当前解更好，则对其进行更新</span></span><br><span class="line">            min_money = h0;  <span class="comment">% 更新最大的花费</span></span><br><span class="line">            best_way = index1;  <span class="comment">% 更新找到的最佳方案</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MONEY(iter) = min_money; <span class="comment">% 保存本轮外循环结束后找到的最小花费</span></span><br><span class="line">    T = alfa*T;   <span class="comment">% 温度下降</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最佳的方案是：&#x27;</span>); <span class="built_in">disp</span>(mat2str(best_way))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(min_money)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画出每次迭代后找到的最佳方案的图形</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:maxgen,MONEY,<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;最小花费&#x27;</span>);</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">h</span> =  <span class="title">Copy_2_of_totalH</span><span class="params">(points,index)</span></span></span><br><span class="line">    len = <span class="built_in">length</span>(index);</span><br><span class="line">    point = points(index, :);</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    Mdl = KDTreeSearcher(point);</span><br><span class="line">    [n,d] = knnsearch(Mdl,point,<span class="string">&#x27;k&#x27;</span>,k+<span class="number">1</span>);</span><br><span class="line">    distances = d(:,<span class="keyword">end</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(point)</span><br><span class="line">        <span class="keyword">if</span> ( point(<span class="built_in">i</span>,<span class="number">1</span>) &lt; distances(<span class="built_in">i</span>) ) </span><br><span class="line">            value = point(<span class="built_in">i</span>,<span class="number">1</span>) + <span class="number">360.0</span>;</span><br><span class="line">            [~, dd] = knnsearch(Mdl,[value, point(<span class="built_in">i</span>, <span class="number">2</span>)],<span class="string">&#x27;k&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            distances(<span class="built_in">i</span>) = <span class="built_in">min</span>(distances(<span class="built_in">i</span>), dd);</span><br><span class="line">        <span class="keyword">elseif</span> (point(<span class="built_in">i</span>, <span class="number">1</span>) &gt; <span class="number">360.0</span>-distances(<span class="built_in">i</span>) ) </span><br><span class="line">            value = point(<span class="built_in">i</span>,<span class="number">1</span>) - <span class="number">360.0</span>;</span><br><span class="line">            [~, dd] = knnsearch(Mdl,[value, point(<span class="built_in">i</span>, <span class="number">2</span>)],<span class="string">&#x27;k&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            distances(<span class="built_in">i</span>) = <span class="built_in">min</span>(distances(<span class="built_in">i</span>), dd);        </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    d = <span class="number">2</span>;</span><br><span class="line">    log_c_d = (d/<span class="number">2.</span>) * <span class="built_in">log</span>(<span class="built_in">pi</span>) - <span class="built_in">log</span>(<span class="built_in">gamma</span>(d/<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    sum_log_dist = sum(<span class="built_in">log</span>(<span class="number">2</span>*distances));</span><br><span class="line">    h = - <span class="built_in">psi</span>(<span class="number">1</span>) + <span class="built_in">psi</span>(len) + log_c_d + (d/len) * sum_log_dist;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>初始方案是：<br>[34 38 53 80 81 111 121 134 140 143 194 203 217 230 233 242 246 253 260 271 272 273 287 288 364 370 371 373 411 413 420 472 479 488 500 508 527 571 593 603 615 624 628 632 641 642 647 651 673 684]<br>此时最优值是：<br>   11.6156</p><p>最佳的方案是：<br>[16 20 22 31 36 40 41 50 52 53 66 68 75 77 85 93 131 149 150 156 164 194 213 244 274 323 345 351 355 388 394 403 415 426 447 490 493 504 510 557 565 566 616 637 645 658 660 664 665 703]<br>此时最优值是：<br>   13.4517</p><p><code>历时 57.334977 秒。</code></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230114090732190.png" alt="image-20230114090732190"></p><p>vscode python 验证</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230114091618050.png" alt="image-20230114091618050"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230114093427744.png" alt="image-20230114093427744"></p><p>选择了这些点</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230114093457076.png" alt="image-20230114093457076"></p><hr><p>2023/2/3 续</p><p>但是耗时过长</p><p>由于每次只替换一个点，因此可以快速计算，函数(一堆点集，要替换的点，新点)</p><p>现在还需要增加一个功能，就是记录那50个点中最近的点的序号</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230203213229514.png" alt="image-20230203213229514"></p><p>找最近的点，如果是要被删的，那么就重新计算这些点，但是要增加的点呢</p><p>还是需要全部进行查询最近点 </p><p>所以该改进点只得作罢</p><hr><p>开始写文章吧</p><hr><p>画圆</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230208160758706.png" alt="image-20230208160758706"></p><p><a href="https://ww2.mathworks.cn/help/matlab/ref/cylinder.html">https://ww2.mathworks.cn/help/matlab/ref/cylinder.html</a></p><p><a href="https://blog.csdn.net/weixin_40525909/article/details/106636093">https://blog.csdn.net/weixin_40525909/article/details/106636093</a></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear all;</span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">1</span>);</span><br><span class="line">a = <span class="built_in">size</span>(t); </span><br><span class="line">r = <span class="number">1</span> * <span class="built_in">ones</span>(a);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">% polar(t,r,&#x27;w&#x27;);</span></span><br><span class="line">polar([<span class="number">0</span>],[<span class="number">0</span>],<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="comment">% cylinder()</span></span><br><span class="line">[X,Y,Z] = cylinder(<span class="number">1</span>,<span class="number">400</span>);</span><br><span class="line">Z = Z+<span class="number">0.3</span>;</span><br><span class="line">surf(X,Y,Z);</span><br><span class="line">view(<span class="number">90</span>,<span class="number">30</span>)</span><br><span class="line">shading flat </span><br><span class="line">colorbar</span><br><span class="line">opengl(<span class="string">&#x27;save&#x27;</span>,<span class="string">&#x27;hardwarebasic&#x27;</span>)</span><br></pre></td></tr></table></figure><p>画好红 插入灯光，修改颜色，去除坐标点，加上°，加上colorbar,右击打开颜色图编辑器，指定颜色，删除颜色 设置两头黑，P图。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230209143812223.png" alt="image-20230209143812223"></p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clf;</span><br><span class="line"><span class="comment">% box on;</span></span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-10</span> <span class="number">370</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">100</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>([<span class="number">10</span>,<span class="number">20</span>,<span class="number">350</span>,<span class="number">370</span>],[<span class="number">45</span>,<span class="number">20</span>,<span class="number">50</span>,<span class="number">45</span>],<span class="number">12</span>);</span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% xlabel(&#x27;\bf 方位轴&#x27;);</span></span><br><span class="line"><span class="comment">% ylabel(&#x27;\bf 高度轴&#x27;);</span></span><br><span class="line">r = pdist([[<span class="number">10</span>,<span class="number">45</span>];[<span class="number">20</span>,<span class="number">20</span>]],<span class="string">&#x27;euclidean&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;position&#x27;</span>,[<span class="number">10</span>-r,<span class="number">45</span>-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">rectangle(<span class="string">&#x27;position&#x27;</span>,[<span class="number">370</span>-r,<span class="number">45</span>-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">theta=<span class="number">0</span>:<span class="number">0.001</span>:<span class="number">2</span>*<span class="built_in">pi</span>;</span><br><span class="line">Circle1=<span class="number">10</span>+r*<span class="built_in">cos</span>(theta);</span><br><span class="line">Circle2=<span class="number">45</span>+r*<span class="built_in">sin</span>(theta);</span><br><span class="line">Circle1(Circle1 &lt; <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">plot</span>(Circle1,Circle2,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">Circle1=<span class="number">370</span>+r*<span class="built_in">cos</span>(theta);</span><br><span class="line">Circle2=<span class="number">45</span>+r*<span class="built_in">sin</span>(theta);</span><br><span class="line">Circle1(Circle1 &gt; <span class="number">360</span>) = <span class="number">360</span>;</span><br><span class="line"><span class="built_in">plot</span>(Circle1,Circle2,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">0.5</span>);</span><br><span class="line">txt = <span class="string">&#x27; M&#x27;</span>;</span><br><span class="line">text(<span class="number">10</span>,<span class="number">45</span>,txt);</span><br><span class="line">txt = <span class="string">&#x27; N&#x27;</span>;</span><br><span class="line">text(<span class="number">20</span>,<span class="number">20</span>,txt)</span><br><span class="line">txt = <span class="string">&#x27; M^&#123;&#x27;&#x27;&#125;&#x27;</span>;</span><br><span class="line">text(<span class="number">360</span>,<span class="number">45</span>,txt);</span><br><span class="line">txt = <span class="string">&#x27; P&#x27;</span>;</span><br><span class="line">text(<span class="number">350</span>,<span class="number">50</span>,txt)</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230209164542299.png" alt="image-20230209164542299"></p><p><a href="https://blog.csdn.net/luochao5862426/article/details/89219311">https://blog.csdn.net/luochao5862426/article/details/89219311</a></p><p>Matlab图形高清插入word文档的几种方法。</p><hr><p>在选取恒星点的k近邻时，需要考虑的问题是如何对星点进行快速k近邻搜索。k近邻最简单的实现是枚举搜索，即对选取星点与其他星点计算距离，时间复杂度为                                。当恒星点集很大时，计算非常耗时。可以使用特殊的数据结构存储星点位置，减小计算次数，以提高k近邻搜索效率。</p><p>​    KD树是一种对K维空间中的数据进行组织和存储以便进行快速搜索查找的二叉树形数据结构，用垂直于坐标轴的超平面将K维空间划分成一系列的K维超矩形区域。在本文中，KD树的每个节点对应于一个由方位轴和高度轴组成的二维矩形区域，构造得到的KD树是平衡二叉树，搜索查找的时间复杂度为  。</p><p>​    </p><p>对于输入的恒星坐标点集  ，其中  ，  ，  ，<strong>构造**</strong>KD<strong>**树</strong>的方法如下：</p><div class="table-container"><table><thead><tr><th>BuildKDTree(star pointsT, tree_depth)</th></tr></thead><tbody><tr><td>1)     //  根据树深度的奇偶性来选择AE维度</td></tr><tr><td>2)     axis  = tree_depth &amp; 1</td></tr><tr><td>3)     //  选择第axis维度的中间值为根节点进行KD树的构造  4)     Select  median by axis from points  5)     //  构造节点和子树  6)     node  = median  7)     node.left  = KDTree(points in subList(0, median), axis, tree_depth + 1)  8)     node.right  = KDTree(points in subList(median+1, points.end()), axis, tree_depth + 1)  9)     return  node</td></tr><tr><td></td></tr><tr><td></td></tr></tbody></table></div><p>（1）构造根节点：根节点的深度为0，对应于望远镜两轴指向上半天区所组成的二维空间，其中方位轴范围为0°至360°，高度轴范围为0°至90°。接着，重复通过下面（2）的递归方法，不断地对二维空间进行切分，生成子节点。</p><p>（2）重复：对深度为奇数/偶数j的节点重复E/A轴切分：选择E/A轴为坐标轴，以该节点的区域中所有恒星的E/A坐标中位数为切分点，将该节点对应的二维区域切分为两个子区域。由该节点生成深度为j+1的左右子节点，左子节点对应坐标E/A小于切分点的子区域，右子节点对应坐标E/A大于切分点的子区域。并将落在该二维平面上的恒星点保存在该节点。</p><p>（3）直到两个子区域内没有恒星时，构造KD树停止，完成划分。</p><hr><p>​    利用KD树可以减少搜索的计算量。在望远镜两轴指向形成的圆柱面上，为一个恒星点搜索其k近邻与传统的KD树搜索策略有所差异，本文提出改进的KD树搜索策略IKDS，首先找到包含选取点的叶子节点，然后由该节点出发，依次回退到父节点；不断查找所选星点的最近邻，当不存在更近的节点时中止。具体方法如下：</p><hr><p>利用KD树可以省去对大部分数据点的搜索，从而减少搜索的计算量。给定一个恒星点，搜索其最近邻，首先找到包含选取点的叶子节点，然后由该节点出发，依次回退到父节点；不断查找所选星点的最近邻，当不存在更近的节点时中止。具体方法如下</p><hr><p><strong>适应于圆柱面上的**</strong>KD<strong>**树搜索策略</strong></p><p>​    利用KD树可以省去对大部分数据点的搜索，从而减少搜索的计算量。给定一个恒星点，搜索其最近邻，首先找到包含选取点的叶子节点，然后由该节点出发，依次回退到父节点；不断查找所选星点的最近邻，当不存在更近的节点时中止。由于恒星位于高度轴和方位轴两个垂直轴所组成的圆柱面上，KD树的搜索策略有所不同，具体方法如下：</p><p>​    （1）在KD树种找到包含选取点的叶子节点，并以此叶子节点为“当前最近点”。递归地向上回退，在每个节点进行以下（2）（3）操作：</p><p>​    （2）如果该节点保存的恒星点比当前最近点更接近选取点，则该节点为当前最近点。</p><p>（3）当前最近点一定存在于该节点的一个子节点所对应的区域。检查该子节点的父节点的另一个子节点所对应的区域是否有更近的点。具体的，检查另一个子节点对应的区域是否与目标点为圆心，与目标点与当前最近点间的距离为半径的圆相交。如果相交，可能在另一个子节点对应的区域内存在距离目标更近的点，移动到另一个子节点。接着，递归地进行最近邻搜索。如果不相交，往上回退。</p><p>（4）当回退到根节点时，搜索结束。搜索得到的“当前最近点”即为选取点的最近邻。当选取点的方位轴                                坐标减去最近邻距离小于0°时，以选取点为中心，最近邻距离为半径的最近邻圆与0°方位轴相切，可能存在方位轴为  （  为一个较小的数）的星点距离选取星点更近。如上图所示，使用原始KD树搜索找到目标星点M的最近邻N，但方位轴尾端可能存在星点P，距离选取星点M更近。因此需要重新计算选取虚拟星点  的最近邻距离，与  的最近邻距离相比取较小值；同样的，当方位轴  坐标加上最近邻距离大于360°时，还需要计算选取虚拟星点  的最近邻距离。</p><hr><p>正交网格法</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line"><span class="comment">% tic</span></span><br><span class="line"><span class="comment">% load points;</span></span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">points = M(:, <span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line"><span class="comment">% points = sortrows(points,1);</span></span><br><span class="line">rng(<span class="string">&#x27;shuffle&#x27;</span>)  <span class="comment">% 控制随机数的生成，否则每次打开matlab得到的结果都一样</span></span><br><span class="line">len = <span class="number">50</span>;</span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">jiange = <span class="number">5</span>;</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line">ret = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt; <span class="number">90</span></span><br><span class="line">    tmp = <span class="built_in">find</span>( (points(:,<span class="number">1</span>)&gt; x) &amp; (points(:,<span class="number">2</span>) &gt;y) &amp; (points(:,<span class="number">1</span>)&lt;= x+ jiange) &amp; (points(:,<span class="number">2</span>)&lt;= y+ jiange) );</span><br><span class="line">    <span class="keyword">if</span> ( ~<span class="built_in">isempty</span>(tmp) )</span><br><span class="line">        ret = [ret; points(tmp(<span class="number">1</span>),:)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt;= <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% scatter(points(:,1), points(:,2));</span></span><br><span class="line"><span class="built_in">scatter</span>(ret(:,<span class="number">1</span>), ret(:,<span class="number">2</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>选自 Vedder, J. D., STAR TRACKERS, STAR CATALOGS, AND ATTITUDE DETERMINATION - PROBABILISTIC ASPECTS OF SYSTEM-DESIGN. <em>J. Guid. Control Dyn.</em> <strong>1993,</strong> 16, (3), 498-504.</p><p>例如间隔为5°，选择了487个点</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230215113153528.png" alt="image-20230215113153528"></p><p>间隔26.6°可以选择50个星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230215113339772.png" alt="image-20230215113339772"></p><p>选择索引 ret = [ret; tmp(1)];</p><p>计算Copy_2_of_totalH(points,ret)熵值，12.5235，所有星是11.3309</p><p>找寻最近点 确实很快 0.05秒但存在问题 就是找寻50个点需要的jiange</p><p>用二分法试试</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">tic</span><br><span class="line"><span class="comment">% load points;</span></span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">points = M(:, <span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line"><span class="comment">% points = sortrows(points,1);</span></span><br><span class="line">rng(<span class="string">&#x27;shuffle&#x27;</span>)  <span class="comment">% 控制随机数的生成，否则每次打开matlab得到的结果都一样</span></span><br><span class="line">len = <span class="number">50</span>;</span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="comment">% jiange = 26.6;</span></span><br><span class="line">left = <span class="number">0</span>;</span><br><span class="line">right = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> left &lt; right</span><br><span class="line">    ret = [];</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    jiange = double( left + right ) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt; <span class="number">90</span></span><br><span class="line">        tmp = <span class="built_in">find</span>( (points(:,<span class="number">1</span>)&gt; x) &amp; (points(:,<span class="number">2</span>) &gt;y) &amp; (points(:,<span class="number">1</span>)&lt;= x+ jiange) &amp; (points(:,<span class="number">2</span>)&lt;= y+ jiange) );</span><br><span class="line">        <span class="keyword">if</span> ( ~<span class="built_in">isempty</span>(tmp) )</span><br><span class="line">    <span class="comment">%         ret = [ret; points(tmp(1),:)];</span></span><br><span class="line">                ret = [ret; tmp(<span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        y = y + jiange;</span><br><span class="line">        <span class="keyword">if</span> ( y &gt;= <span class="number">90</span> ) </span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">            x = x + jiange;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">length</span>(ret)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">length</span>(ret) == <span class="number">50</span> ) </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">elseif</span> ( <span class="built_in">length</span>(ret) &gt; <span class="number">50</span> ) </span><br><span class="line">        left = jiange;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        right = jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">toc;</span><br><span class="line"><span class="comment">% scatter(points(:,1), points(:,2));</span></span><br><span class="line"><span class="comment">% scatter(ret(:,1), ret(:,2));</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>jiange =</p><p>   26.3672</p><p>ans =50</p><p>历时 0.044573 秒。 很快</p><hr><p>画结果图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">plot</span>([<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>],[<span class="number">11.4426</span><span class="number">11.5679</span><span class="number">11.5762</span><span class="number">11.6659</span>],<span class="string">&#x27;-bo&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>],[<span class="number">12.5960</span><span class="number">12.5311</span><span class="number">12.6415</span><span class="number">12.6410</span>],<span class="string">&#x27;-v&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>]);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>],[<span class="number">12.8165</span><span class="number">12.7812</span><span class="number">12.8322</span><span class="number">12.8459</span>],<span class="string">&#x27;-^&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>]);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>],[<span class="number">13.5425</span>,<span class="number">13.4567</span>,<span class="number">13.4374</span>,<span class="number">13.3992</span>],<span class="string">&#x27;-rsquare&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">30</span>,<span class="number">60</span>],[<span class="number">11.3309</span>,<span class="number">11.3309</span>],<span class="string">&#x27;--k&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line">xticks([<span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span>])</span><br><span class="line">yticks([<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>])</span><br><span class="line">xlim([<span class="number">27</span> <span class="number">63</span>]);</span><br><span class="line">ylim([<span class="number">11</span> <span class="number">14.5</span>]);</span><br><span class="line"><span class="built_in">legend</span>( <span class="string">&#x27;1:Random&#x27;</span>,<span class="string">&#x27;2:RGM&#x27;</span>, <span class="string">&#x27;3:SO&#x27;</span>, <span class="string">&#x27;4:MKLE&#x27;</span>,<span class="string">&#x27;5:All&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;KL 熵&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">27</span>,<span class="number">30</span>,<span class="number">44</span>,<span class="number">48</span>, <span class="number">52</span>],[<span class="number">11.0260</span><span class="number">11.5331</span><span class="number">11.4096</span><span class="number">11.0756</span><span class="number">11.8410</span>],<span class="string">&#x27;-bo&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">27</span>,<span class="number">30</span>,<span class="number">44</span>,<span class="number">48</span>, <span class="number">52</span>],[<span class="number">12.2689</span><span class="number">12.5960</span><span class="number">12.5225</span><span class="number">12.5195</span><span class="number">12.6379</span>],<span class="string">&#x27;-v&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>]);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">27</span>,<span class="number">30</span>,<span class="number">44</span>,<span class="number">48</span>, <span class="number">52</span>],[<span class="number">13.5609</span><span class="number">13.5329</span><span class="number">13.4409</span><span class="number">13.4240</span><span class="number">13.3890</span>],<span class="string">&#x27;-^&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>]);<span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">27</span>,<span class="number">30</span>,<span class="number">44</span>,<span class="number">48</span>, <span class="number">52</span>],[<span class="number">13.5537</span><span class="number">13.3811</span><span class="number">13.3753</span><span class="number">13.4138</span><span class="number">13.2940</span>],<span class="string">&#x27;-rsquare&#x27;</span>);<span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xticks([<span class="number">27</span> <span class="number">30</span> <span class="number">44</span> <span class="number">48</span> <span class="number">52</span>])</span><br><span class="line">yticks([<span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span>])</span><br><span class="line">xlim([<span class="number">25</span> <span class="number">55</span>]);</span><br><span class="line">ylim([<span class="number">11</span> <span class="number">14.5</span>]);</span><br><span class="line"><span class="built_in">legend</span>( <span class="string">&#x27;Random&#x27;</span>,<span class="string">&#x27;RGM&#x27;</span>, <span class="string">&#x27;MKLE&#x27;</span>, <span class="string">&#x27;ETRP&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;KL 熵&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>仿真平台为Windows11操作系统下的Matlab，计算机配置为Intel(R) Core i5-11400F@ 2.6GHz，16GB内存。</p><p>没敢写时间</p><hr><p>初始方案是：<br>[30 43 86 126 134 146 152 183 214 216 232 263 265 278 283 299 307 309 354 363 376 377 379 396 406 424 425 429 435 439 478 485 490 499 522 526 535 556 561 576 602 611 615 625 638 639 692 698 702 705]<br>此时最优值是：<br>   11.1946</p><p>最佳的方案是：<br>[8 20 22 36 40 41 42 43 50 53 54 68 74 75 93 97 104 133 150 158 162 189 206 248 274 325 331 343 378 379 380 394 399 413 424 432 460 490 510 514 517 546 576 612 624 647 660 664 699 702]<br>此时最优值是：<br>   13.4316</p><p>历时 88.230554 秒。</p><hr><p>画结果图。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(points(:,<span class="number">1</span>), points(:,<span class="number">2</span>), <span class="number">8</span>)</span><br><span class="line">box on; </span><br><span class="line">axis equal;</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">90</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line"><span class="comment">% title(&#x27;Distribution of all stars&#x27;);</span></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(points(best_way,<span class="number">1</span>), points(best_way,<span class="number">2</span>), <span class="number">12</span>)</span><br><span class="line">box on; </span><br><span class="line">axis equal;</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">90</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;\bf Azimuth axis&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;\bf Elevation axis&#x27;</span>);</span><br><span class="line">title(<span class="string">&#x27;Distribution of selected stars&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230216153601776.png" alt="image-20230216153601776"></p><p>或者</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>;</span><br><span class="line"><span class="built_in">scatter</span>(points(:,<span class="number">1</span>), points(:,<span class="number">2</span>), <span class="number">8</span>)</span><br><span class="line">box on; </span><br><span class="line">axis equal;</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">110</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;Azimuth axis&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;Elevation axis&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(points(best_way,<span class="number">1</span>), points(best_way,<span class="number">2</span>), <span class="number">20</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;#FF8000&#x27;</span>)</span><br><span class="line">xtickformat(<span class="string">&#x27;usd&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;All stars&#x27;</span>, <span class="string">&#x27;Selected stars&#x27;</span>)</span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line">ytickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230216154546130.png" alt="image-20230216154546130"></p><hr><p>画环形图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">ax = polaraxes;</span><br><span class="line">ax.RAxis.Label.String = <span class="string">&#x27;Elevation&#x27;</span>;</span><br><span class="line">ax.ThetaAxis.Label.String = <span class="string">&#x27;Azimuth&#x27;</span>;</span><br><span class="line">ax.ThetaZeroLocation = <span class="string">&#x27;bottom&#x27;</span>;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">polarscatter(double(points(:,<span class="number">1</span>))./<span class="number">180.0</span> * <span class="built_in">pi</span>,points(:,<span class="number">2</span>),<span class="number">20</span>)</span><br><span class="line">thetalim([<span class="number">0</span> <span class="number">360</span>])</span><br><span class="line">rticks(<span class="number">0</span>:<span class="number">22.5</span>:<span class="number">90</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">polarscatter(double(points(best_way,<span class="number">1</span>))./<span class="number">180.0</span> * <span class="built_in">pi</span>,points(best_way,<span class="number">2</span>), <span class="number">30</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;All stars&#x27;</span>, <span class="string">&#x27;Selected stars&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = polaraxes;</span><br><span class="line">ax.RAxis.Label.String = <span class="string">&#x27;Elevation axis&#x27;</span>;</span><br><span class="line">ax.ThetaAxis.Label.String = <span class="string">&#x27;Azimuth axis&#x27;</span>;</span><br><span class="line">ax.ThetaZeroLocation = <span class="string">&#x27;bottom&#x27;</span>;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">polarscatter(double(points(:,<span class="number">1</span>))./<span class="number">180.0</span> * <span class="built_in">pi</span>, <span class="number">90</span>-points(:,<span class="number">2</span>),<span class="number">20</span>)</span><br><span class="line">thetalim([<span class="number">0</span> <span class="number">360</span>])</span><br><span class="line">rticks(<span class="number">0</span>:<span class="number">22.5</span>:<span class="number">90</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">polarscatter(double(points(best_way,<span class="number">1</span>))./<span class="number">180.0</span> * <span class="built_in">pi</span>, <span class="number">90</span>-points(best_way,<span class="number">2</span>), <span class="number">30</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,<span class="string">&#x27;#FF8000&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;All stars&#x27;</span>, <span class="string">&#x27;Selected stars&#x27;</span>)</span><br><span class="line">ax.ThetaTickLabel = string(ax.ThetaTickLabel) + char(<span class="number">176</span>)</span><br><span class="line">rticks([<span class="number">0</span> <span class="number">22.5</span> <span class="number">45</span>  <span class="number">67.5</span> <span class="number">90</span>])                        <span class="comment">% 在r = 50,100,200处显示刻度</span></span><br><span class="line">rticklabels(&#123;<span class="string">&#x27;90&#x27;</span>,<span class="string">&#x27;67.5&#x27;</span>,<span class="string">&#x27;45&#x27;</span>,<span class="string">&#x27;22.5&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;)            <span class="comment">% 在刻度线处加标记</span></span><br><span class="line">ax.RTickLabel = string(ax.RTickLabel) + char(<span class="number">176</span>)</span><br><span class="line">ax.RAxisLocation = <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = polaraxes;</span><br><span class="line">ax.RAxis.Label.String = <span class="string">&#x27;高度轴&#x27;</span>;</span><br><span class="line">ax.ThetaAxis.Label.String = <span class="string">&#x27;方位轴&#x27;</span>;</span><br><span class="line">ax.ThetaZeroLocation = <span class="string">&#x27;bottom&#x27;</span>;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">polarscatter(double(points(best_way,<span class="number">1</span>))./<span class="number">180.0</span> * <span class="built_in">pi</span>, <span class="number">90</span>-points(best_way,<span class="number">2</span>), <span class="number">20</span>)</span><br><span class="line">thetalim([<span class="number">0</span> <span class="number">360</span>])</span><br><span class="line">rticks(<span class="number">0</span>:<span class="number">22.5</span>:<span class="number">90</span>)</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">ax.ThetaTickLabel = string(ax.ThetaTickLabel) + char(<span class="number">176</span>)</span><br><span class="line">rticks([<span class="number">0</span> <span class="number">22.5</span> <span class="number">45</span>  <span class="number">67.5</span> <span class="number">90</span>])                        <span class="comment">% 在r = 50,100,200处显示刻度</span></span><br><span class="line">rticklabels(&#123;<span class="string">&#x27;90&#x27;</span>,<span class="string">&#x27;67.5&#x27;</span>,<span class="string">&#x27;45&#x27;</span>,<span class="string">&#x27;22.5&#x27;</span>,<span class="string">&#x27;0&#x27;</span>&#125;)            <span class="comment">% 在刻度线处加标记</span></span><br><span class="line">ax.RTickLabel = string(ax.RTickLabel) + char(<span class="number">176</span>)</span><br><span class="line">ax.RAxisLocation = <span class="number">90</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>接着做实验</p><p>画一个图</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">tic</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> </span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt; <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">toc;</span><br></pre></td></tr></table></figure><p>3个图拼一起</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line">jiange = <span class="number">30</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> </span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt; <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret1 = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line">    ret1 = [ret1; x, y];</span><br><span class="line"> </span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt; <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">jiange = <span class="number">18</span>;</span><br><span class="line">ret2 = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line">    ret2 = [ret2; x, y];</span><br><span class="line"> </span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt; <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clf;</span><br><span class="line"><span class="comment">% box on;</span></span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-10</span> <span class="number">370</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">100</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(ret1(:,<span class="number">1</span>), ret1(:,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230224205020024.png" alt="image-20230224205020024"></p><p>n = 120, distances = 18; KL = 18.0668</p><p>去掉任意一个星 distance不变 kl = 18.05834851010958</p><p>n = 80, distances = 22.5; KL = 18.551770401636414</p><p>去掉任意一个星 distance不变 kl = 18.53911217378831</p><p>n = 48 dis = 30; KL = 19.187483254228805</p><p>19.16620665848412</p><hr><p>试试三角形</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230224211806401.png" alt="image-20230224211806401"></p><p>存在这种情况</p><hr><p>试试六边形</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230224213629088.png" alt="image-20230224213629088"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">jiange = <span class="number">18</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ret1 = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">120</span></span><br><span class="line">    <span class="keyword">if</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &gt; <span class="number">31</span> &amp;&amp; ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">32</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">31</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">0</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &gt; <span class="number">60</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">2</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &gt; <span class="number">32</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% for i = 1 : 120</span></span><br><span class="line"><span class="comment">%     if mod(i, 3) ~= 0</span></span><br><span class="line"><span class="comment">%         ret1 = [ret1;ret(i,:)];</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line">clear all;  close all;clc;</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ret1 = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">80</span></span><br><span class="line">    <span class="keyword">if</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">0</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &gt; <span class="number">19</span> &amp;&amp; ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">20</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">2</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">39</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">2</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &gt; <span class="number">60</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &gt; <span class="number">32</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">            ret1 = [ret1;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jiange = <span class="number">30</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ret2 = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">48</span></span><br><span class="line">    <span class="keyword">if</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">3</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">0</span></span><br><span class="line">            ret2 = [ret2;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">39</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">            ret2 = [ret2;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">elseif</span> ret(<span class="built_in">i</span>,<span class="number">2</span>) &lt; <span class="number">60</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">0</span></span><br><span class="line">            ret2 = [ret2;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">mod</span>(<span class="built_in">i</span>, <span class="number">3</span>) ~= <span class="number">1</span></span><br><span class="line">            ret2 = [ret2;ret(<span class="built_in">i</span>,:)];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>81个点  17.6717</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230224232242545.png" alt="image-20230224232242545"></p><p>随机点</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tic</span><br><span class="line">ret = [];</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">len = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : len</span><br><span class="line">    x = <span class="number">360.</span>*<span class="built_in">rand</span>(<span class="number">48</span>, <span class="number">1</span>);</span><br><span class="line">    y = <span class="number">90.</span>*<span class="built_in">rand</span>(<span class="number">48</span>, <span class="number">1</span>);</span><br><span class="line">    sum = sum + Copy_3_of_totalH([x,y]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">av = sum / len</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>随机加扰动</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tic</span><br><span class="line"><span class="comment">% ret = [];</span></span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">len = <span class="number">100000</span>;</span><br><span class="line">len1 = <span class="number">48</span>;</span><br><span class="line">minv = <span class="number">60</span>;</span><br><span class="line">maxv = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : len</span><br><span class="line">    ret1 = ret;</span><br><span class="line">    ret1 = ret1 + <span class="number">5</span>*<span class="built_in">rand</span>(len1,<span class="number">2</span>)<span class="number">-2.5</span>;</span><br><span class="line">    tmp = Copy_3_of_totalH(ret1);</span><br><span class="line">    minv = <span class="built_in">min</span>(minv, tmp);</span><br><span class="line">    maxv = <span class="built_in">max</span>(maxv, tmp);</span><br><span class="line">    sum = sum + tmp;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">av = sum / len</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>随机加点</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tic</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> </span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt; <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">len = <span class="number">100000</span>;</span><br><span class="line">minv = <span class="number">60</span>;</span><br><span class="line">maxv = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : len</span><br><span class="line">    ret1 = ret;</span><br><span class="line">    x = <span class="number">360</span> * <span class="built_in">rand</span>;</span><br><span class="line">    y = <span class="number">90</span> * <span class="built_in">rand</span>;</span><br><span class="line">    ret1 = [ret1;x,y];</span><br><span class="line">    tmp = Copy_3_of_totalH(ret1);</span><br><span class="line">    minv = <span class="built_in">min</span>(minv, tmp);</span><br><span class="line">    maxv = <span class="built_in">max</span>(maxv, tmp);</span><br><span class="line">    sum = sum + tmp;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">av = sum / len</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><hr><p>画图 随机扰动</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.7714</span>,<span class="number">13.7110</span>,<span class="number">13.6724</span>],<span class="string">&#x27;-ksquare&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.7436</span>,<span class="number">13.6732</span>,<span class="number">13.6244</span>],<span class="string">&#x27;-o&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.6305</span>,<span class="number">13.5185</span>,<span class="number">13.4272</span>],<span class="string">&#x27;-^&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">xlim([<span class="number">43</span>, <span class="number">125</span>])</span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.7311</span>,<span class="number">13.7311</span>],<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.7549</span>,<span class="number">13.7549</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span>,<span class="number">48</span>],[<span class="number">13.7311</span>,<span class="number">13.7549</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.6591</span>,<span class="number">13.6591</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.6844</span>,<span class="number">13.6844</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span>,<span class="number">80</span>],[<span class="number">13.6844</span>,<span class="number">13.6591</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.6115</span>,<span class="number">13.6115</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.6364</span>,<span class="number">13.6364</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span>,<span class="number">120</span>],[<span class="number">13.6115</span>,<span class="number">13.6364</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.5590</span>,<span class="number">13.5590</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.6914</span>,<span class="number">13.6914</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span>,<span class="number">48</span>],[<span class="number">13.6914</span>,<span class="number">13.5590</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.4549</span>,<span class="number">13.4549</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.5855</span>,<span class="number">13.5855</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span>,<span class="number">80</span>],[<span class="number">13.5855</span>,<span class="number">13.4549</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.3566</span>,<span class="number">13.3566</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.4927</span>,<span class="number">13.4927</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span>,<span class="number">120</span>],[<span class="number">13.3566</span>,<span class="number">13.4927</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">box on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;正方形网格点分布&#x27;</span>,<span class="string">&#x27;网格点附近扰动±1°&#x27;</span>,<span class="string">&#x27;网格点附近扰动±5°&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;KL熵&#x27;</span>);</span><br><span class="line">xticks([<span class="number">48</span> <span class="number">80</span> <span class="number">120</span>]);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/clip_image002.jpg" alt="img"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.7714</span>,<span class="number">13.7110</span>,<span class="number">13.6724</span>],<span class="string">&#x27;-ksquare&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.7501</span>,<span class="number">13.6984</span>,<span class="number">13.6639</span>],<span class="string">&#x27;-o&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.6847</span>,<span class="number">13.6586</span>,<span class="number">13.6372</span>],<span class="string">&#x27;-^&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0.5</span> <span class="number">0</span> <span class="number">0.8</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">xlim([<span class="number">43</span>, <span class="number">125</span>])</span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.1914</span>,<span class="number">13.1914</span>],<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.7214</span>,<span class="number">13.7214</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span>,<span class="number">48</span>],[<span class="number">13.1914</span>,<span class="number">13.7214</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.3497</span>,<span class="number">13.3497</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.6806</span>,<span class="number">13.6806</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span>,<span class="number">80</span>],[<span class="number">13.3497</span>,<span class="number">13.6806</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.4646</span>,<span class="number">13.4646</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.6520</span>,<span class="number">13.6520</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span>,<span class="number">120</span>],[<span class="number">13.4646</span>,<span class="number">13.6520</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0</span> <span class="number">0.6</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"></span><br><span class="line">box on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;正方形网格点分布&#x27;</span>,<span class="string">&#x27;网格点附近扰动±1°&#x27;</span>,<span class="string">&#x27;网格点附近扰动±5°&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;KL熵&#x27;</span>);</span><br><span class="line">xticks([<span class="number">48</span> <span class="number">80</span> <span class="number">120</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.7714</span>,<span class="number">13.7110</span>,<span class="number">13.6724</span>],<span class="string">&#x27;-ksquare&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">48</span>,<span class="number">80</span>,<span class="number">120</span>],[<span class="number">13.6630</span>,<span class="number">13.6456</span>,<span class="number">13.6286</span>],<span class="string">&#x27;-v&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.1646</span>,<span class="number">13.1646</span>],<span class="string">&#x27;Color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span><span class="number">-1.000</span>,<span class="number">48</span>+<span class="number">1.000</span>],[<span class="number">13.7697</span>,<span class="number">13.7697</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">48</span>,<span class="number">48</span>],[<span class="number">13.1646</span>,<span class="number">13.7697</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.3706</span>,<span class="number">13.3706</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span><span class="number">-1.000</span>,<span class="number">80</span>+<span class="number">1.000</span>],[<span class="number">13.7095</span>,<span class="number">13.7095</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">80</span>,<span class="number">80</span>],[<span class="number">13.3706</span>,<span class="number">13.7095</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.4553</span>,<span class="number">13.4553</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span><span class="number">-1.000</span>,<span class="number">120</span>+<span class="number">1.000</span>],[<span class="number">13.6715</span>,<span class="number">13.6715</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">line([<span class="number">120</span>,<span class="number">120</span>],[<span class="number">13.4553</span>,<span class="number">13.6715</span>],<span class="string">&#x27;color&#x27;</span>,[<span class="number">0.6</span> <span class="number">0.1</span> <span class="number">0.1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">box on;</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;正方形网格点分布&#x27;</span>,<span class="string">&#x27;随机替换一个点&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;KL熵&#x27;</span>);</span><br><span class="line">xticks([<span class="number">48</span> <span class="number">80</span> <span class="number">120</span>]);</span><br></pre></td></tr></table></figure><p>随机替换一个点</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;tic;</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> </span><br><span class="line">    y = y + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( y &gt; <span class="number">90</span> ) </span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        x = x + jiange;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">ret(<span class="keyword">end</span>,:)=[];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line">len = <span class="number">100000</span>;</span><br><span class="line">minv = <span class="number">60</span>;</span><br><span class="line">maxv = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : len</span><br><span class="line">    ret1 = ret;</span><br><span class="line">    x = <span class="number">360</span> * <span class="built_in">rand</span>;</span><br><span class="line">    y = <span class="number">90</span> * <span class="built_in">rand</span>;</span><br><span class="line">    ret1 = [ret1;x,y];</span><br><span class="line">    tmp = Copy_3_of_totalH(ret1);</span><br><span class="line">    minv = <span class="built_in">min</span>(minv, tmp);</span><br><span class="line">    <span class="keyword">if</span> ( tmp &gt; maxv ) </span><br><span class="line">    maxv = tmp;</span><br><span class="line">    x</span><br><span class="line">    y</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    sum = sum + tmp;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">av = sum / len</span><br><span class="line">toc</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我本章的实验基于的是同n值的，因为n值大，KL熵小 ，不同n值不能说明均匀性。</p><hr><p>正三角形网格点旋转</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">rec = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    rec = [rec; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = <span class="number">15</span>;</span><br><span class="line">rec1(:,<span class="number">1</span>) = rec(:,<span class="number">1</span>)*<span class="built_in">cosd</span>(d) - rec(:,<span class="number">2</span>)*<span class="built_in">sind</span>(d);</span><br><span class="line">rec1(:,<span class="number">2</span>) = rec(:,<span class="number">1</span>)*<span class="built_in">sind</span>(d) + rec(:,<span class="number">2</span>)*<span class="built_in">cosd</span>(d);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-30</span> <span class="number">400</span>]);</span><br><span class="line">ylim([<span class="number">-30</span> <span class="number">140</span>]);</span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(rec1(:,<span class="number">1</span>), rec1(:,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">rec2 = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = -jiange *<span class="built_in">sqrt</span>(<span class="number">3</span>) ;</span><br><span class="line"><span class="keyword">while</span> x &lt;= <span class="number">360</span>+jiange &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    rec2 = [rec2; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span>+jiange ) </span><br><span class="line">        x = x<span class="number">-360</span> -jiange/<span class="number">2.0</span> - jiange;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = <span class="number">15</span>;</span><br><span class="line">rec3(:,<span class="number">1</span>) = rec2(:,<span class="number">1</span>)*<span class="built_in">cosd</span>(d) - rec2(:,<span class="number">2</span>)*<span class="built_in">sind</span>(d);</span><br><span class="line">rec3(:,<span class="number">2</span>) = rec2(:,<span class="number">1</span>)*<span class="built_in">sind</span>(d) + rec2(:,<span class="number">2</span>)*<span class="built_in">cosd</span>(d);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-30</span> <span class="number">400</span>]);</span><br><span class="line">ylim([<span class="number">-30</span> <span class="number">140</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(rec3(:,<span class="number">1</span>), rec3(:,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230228142912992.png" alt="image-20230228142912992"></p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">jiange = <span class="number">22.5</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">0</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">360</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">clf;</span><br><span class="line"><span class="comment">% box on;</span></span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-10</span> <span class="number">370</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">100</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(ret(:,<span class="number">1</span>), ret(:,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>选取点建KD树， 对600个星点找最近邻 ，算出每个星的权值，再遍历一遍每个星，为每个星的空间不断替换最优值。遍历一遍也行</p><p>从哪个点找哪个点更快</p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">tic;</span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">points = M(:, <span class="number">2</span>:<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">jiange = <span class="number">360.0</span>/<span class="number">9</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">-0.001</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">359</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">length</span>(ret);</span><br><span class="line">tmp = <span class="built_in">ones</span>(n,<span class="number">1</span>)*<span class="number">360</span>;</span><br><span class="line">rev = <span class="built_in">ones</span>(n,<span class="number">2</span>)*<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Mdl = KDTreeSearcher(ret);</span><br><span class="line">kk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(points)</span><br><span class="line">    [nn,d] = knnsearch(Mdl,points(<span class="built_in">i</span>,<span class="number">1</span>:<span class="number">2</span>),<span class="string">&#x27;k&#x27;</span>,kk+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> d &lt; tmp(nn)</span><br><span class="line">        tmp(nn) = d;</span><br><span class="line">        rev(nn,:) = points(<span class="built_in">i</span>,<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf;</span><br><span class="line"><span class="comment">% box on;</span></span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-10</span> <span class="number">370</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">100</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(ret(:,<span class="number">1</span>), ret(:,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">scatter</span>(points(:,<span class="number">1</span>), points(:,<span class="number">2</span>),<span class="number">5</span>)</span><br><span class="line"><span class="built_in">scatter</span>(rev(:,<span class="number">1</span>), rev(:,<span class="number">2</span>),<span class="number">50</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">toc;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230302142722831.png" alt="image-20230302142722831"></p><p>纯距离  </p><p>共27个</p><p>随机KL熵 11.7958</p><p>距离最近加权 13.4318   历时 0.078488 秒。</p><p>星等加权 随机 13.4006      ，总权值 -247.0324</p><p>优化后  13.5629  总权值 -195  最好的位移是 32.5583  6.7  历时25s</p><p>粒子50 迭代30  13.5537  -190.6025  位移30 7  30.2979600360942    7.02950188386670  25s</p><p>粒子15迭代10  13.5537  -190.6025  位移30.1858 6.9537   历时 2.705201 秒。</p><p>-196.325020765185    -196.325020765185    -196.325020765185    -196.325020765185    -191.733361560326    -190.655450867045    -190.655450867045    -190.655450867045    -190.655450867045    -190.655450867045</p><p>   暴力点 13.5557   -190.6024   30.299  7.036   300粒子500迭代  历时 2638.095214 秒。</p><p>模拟退火最大化 13.6253   历时 74.406457 秒。</p><p>模拟点 13.7632</p><hr><p>权值 = -距离 + -星等  ，星等越亮，越小，-星等越大，距离越近，越好，-距离越大，越好 权值越大</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Mdl = KDTreeSearcher(ret);</span><br><span class="line">kk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">length</span>(points)</span><br><span class="line">    [nn,d] = knnsearch(Mdl,points(<span class="built_in">i</span>,<span class="number">1</span>:<span class="number">2</span>),<span class="string">&#x27;k&#x27;</span>,kk+<span class="number">1</span>);</span><br><span class="line">    value = -d - points(<span class="built_in">i</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> value &gt; tmp(nn)</span><br><span class="line">        tmp(nn) = value;</span><br><span class="line">        rev(nn,:) = points(<span class="built_in">i</span>,<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">toc;</span><br><span class="line">Copy_3_of_totalH(rev)</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230302144029305.png" alt="image-20230302144029305"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;  close all;clc;</span><br><span class="line">tic;</span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">points = M(:, <span class="number">2</span>:<span class="number">4</span>);</span><br><span class="line">jiange = <span class="number">360.0</span>/<span class="number">10</span>;</span><br><span class="line">ret = [];</span><br><span class="line">x = <span class="number">0</span>;</span><br><span class="line">y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> x &lt; <span class="number">360</span> &amp;&amp; y &lt;= <span class="number">90</span></span><br><span class="line"><span class="keyword">if</span> x &gt;= <span class="number">-0.0000001</span></span><br><span class="line">    ret = [ret; x, y];</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line">    x = x + jiange;</span><br><span class="line">    <span class="keyword">if</span> ( x &gt;= <span class="number">359.9999999</span> ) </span><br><span class="line">        x = x - <span class="number">360</span> -jiange/<span class="number">2.0</span>;</span><br><span class="line">        y = y + jiange/<span class="number">2.0</span>*<span class="built_in">sqrt</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">N = <span class="number">50</span>;                           <span class="comment">% 初始种群个数</span></span><br><span class="line">d = <span class="number">2</span>;                             <span class="comment">% 空间维数（参看上述的函数表达式）</span></span><br><span class="line">ger = <span class="number">30</span>;                         <span class="comment">% 最大迭代次数     </span></span><br><span class="line">plimit = [<span class="number">0</span>,jiange;<span class="number">0</span>,<span class="number">90</span>-ret(<span class="keyword">end</span>)];              <span class="comment">% 设置位置参数限制(矩阵的形式可以多维)，现在2X2矩阵</span></span><br><span class="line">vlimit = [<span class="number">-1.5</span>, <span class="number">1.5</span>;<span class="number">-1.5</span>, <span class="number">1.5</span>];    <span class="comment">% 设置速度限制</span></span><br><span class="line">w = <span class="number">0.8</span>;                           <span class="comment">% 惯性权重,个体历史成绩对现在的影响0.5~1之间</span></span><br><span class="line">c1 = <span class="number">0.5</span>;                          <span class="comment">% 自我学习因子</span></span><br><span class="line">c2 = <span class="number">0.5</span>;                          <span class="comment">% 群体学习因子 </span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:d</span><br><span class="line">    xx(:,<span class="built_in">i</span>) = plimit(<span class="built_in">i</span>, <span class="number">1</span>) + (plimit(<span class="built_in">i</span>, <span class="number">2</span>) - plimit(<span class="built_in">i</span>, <span class="number">1</span>)) * <span class="built_in">rand</span>(N, <span class="number">1</span>);<span class="comment">%初始种群的位置</span></span><br><span class="line"><span class="keyword">end</span>                              <span class="comment">%rand(N,1)产生N行一列范围在1之内的随机数</span></span><br><span class="line">                              <span class="comment">%第一列,第二列：x=0+（20-0）*（1之内的随机数）                                    </span></span><br><span class="line">v = <span class="built_in">rand</span>(N, d);                   <span class="comment">% 初始种群的速度,500行2列分别在两个维度上</span></span><br><span class="line">xm = xx;                           <span class="comment">% 每个个体的历史最佳位置</span></span><br><span class="line">ym = <span class="built_in">zeros</span>(<span class="number">1</span>, d);                 <span class="comment">% 种群的历史最佳位置，两个维度，设置为0</span></span><br><span class="line">fxm = <span class="built_in">ones</span>(N, <span class="number">1</span>) * (-<span class="built_in">inf</span>);                <span class="comment">% 每个个体的历史最佳适应度，设置为0</span></span><br><span class="line">fym = -<span class="built_in">inf</span>;                       <span class="comment">% 种群历史最佳适应度,求最大值先设置成负无穷</span></span><br><span class="line">kk = <span class="number">0</span>;</span><br><span class="line">iter = <span class="number">1</span>;  </span><br><span class="line">n = <span class="built_in">length</span>(ret);</span><br><span class="line">tmp = <span class="built_in">ones</span>(n,<span class="number">1</span>)*(<span class="number">-500</span>);</span><br><span class="line">rev = <span class="built_in">ones</span>(n,<span class="number">2</span>)*(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fx = <span class="built_in">ones</span>(n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> iter &lt;= ger</span><br><span class="line"></span><br><span class="line"><span class="comment">%     fx = f(xx(:,1),xx(:,2));         % 代入x中的二维数据，算出个体当前适应度,为500行1列的数据   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:N                   <span class="comment">%对每一个个体做判断</span></span><br><span class="line">        ret1 = ret + xx(<span class="built_in">i</span>,:);</span><br><span class="line">        ret1(ret1(:,<span class="number">1</span>) &gt; <span class="number">360</span>) = ret1(ret1(:,<span class="number">1</span>) &gt; <span class="number">360</span>) - <span class="number">360</span>;</span><br><span class="line">        </span><br><span class="line">        Mdl = KDTreeSearcher(ret1);</span><br><span class="line">        tmp = <span class="built_in">ones</span>(n,<span class="number">1</span>)*(<span class="number">-500</span>);</span><br><span class="line">        rev = <span class="built_in">ones</span>(n,<span class="number">2</span>)*(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> ii = <span class="number">1</span> : <span class="built_in">length</span>(points)</span><br><span class="line">          </span><br><span class="line">            [nn,ddd] = knnsearch(Mdl,points(ii,<span class="number">1</span>:<span class="number">2</span>),<span class="string">&#x27;k&#x27;</span>,kk+<span class="number">1</span>);</span><br><span class="line">            value = -ddd - points(ii,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span> value &gt; tmp(nn)</span><br><span class="line">                tmp(nn) = value;</span><br><span class="line">                rev(nn,:) = points(ii,<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        fx(<span class="built_in">i</span>) = sum(tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> fxm(<span class="built_in">i</span>) &lt; fx(<span class="built_in">i</span>)           <span class="comment">%如果每个个体的历史最佳适应度小于个体当前适应度</span></span><br><span class="line">            fxm(<span class="built_in">i</span>) = fx(<span class="built_in">i</span>);         <span class="comment">% 更新个体历史最佳适应度,第一轮就是把小于零的清除</span></span><br><span class="line">            xm(<span class="built_in">i</span>,:) = xx(<span class="built_in">i</span>,:);       <span class="comment">% 更新个体历史最佳位置</span></span><br><span class="line">        <span class="keyword">end</span> </span><br><span class="line">     <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> fym &lt; <span class="built_in">max</span>(fxm)                  <span class="comment">%种群历史最佳适应度小于个体里面最佳适应度的最大值</span></span><br><span class="line">            [fym, nmax] = <span class="built_in">max</span>(fxm);    <span class="comment">% 更新群体历史最佳适应度,取出最大适应度的值和所在行数即位置</span></span><br><span class="line">            ym = xm(nmax, :);          <span class="comment">% 更新群体历史最佳位置</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">     v = v * w + c1 * <span class="built_in">rand</span> *(xm - xx) + c2 * <span class="built_in">rand</span> *(<span class="built_in">repmat</span>(ym, N, <span class="number">1</span>) - xx); <span class="comment">% 速度更新公式,repmat函数把ym矩阵扩充成N行1列</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">%%边界速度处理</span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:d </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">            <span class="keyword">if</span>  v(<span class="built_in">j</span>,<span class="built_in">i</span>)&gt;vlimit(<span class="built_in">i</span>,<span class="number">2</span>);      <span class="comment">%如果速度大于边界速度，则把速度拉回边界</span></span><br><span class="line">                v(<span class="built_in">j</span>,<span class="built_in">i</span>)=vlimit(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span>  v(<span class="built_in">j</span>,<span class="built_in">i</span>) &lt; vlimit(<span class="built_in">i</span>,<span class="number">1</span>)     <span class="comment">%如果速度小于边界速度，则把速度拉回边界</span></span><br><span class="line">                v(<span class="built_in">j</span>,<span class="built_in">i</span>)=vlimit(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">end</span>      </span><br><span class="line">       </span><br><span class="line">     xx = xx + v;                          <span class="comment">% 位置更新</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:d </span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:N</span><br><span class="line">            <span class="keyword">if</span>  xx(<span class="built_in">j</span>,<span class="built_in">i</span>)&gt;plimit(<span class="built_in">i</span>,<span class="number">2</span>)</span><br><span class="line">                xx(<span class="built_in">j</span>,<span class="built_in">i</span>)=plimit(<span class="built_in">i</span>,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span>  xx(<span class="built_in">j</span>,<span class="built_in">i</span>) &lt; plimit(<span class="built_in">i</span>,<span class="number">1</span>)</span><br><span class="line">                xx(<span class="built_in">j</span>,<span class="built_in">i</span>)=plimit(<span class="built_in">i</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      </span><br><span class="line">      record(iter) = fym;            <span class="comment">%记录最大值</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">%    if times &gt;= 10</span></span><br><span class="line"><span class="comment">%         cla;                    %清除轴线图形</span></span><br><span class="line"><span class="comment">%         mesh(x0_1, x0_2, y0);</span></span><br><span class="line"><span class="comment">%         plot3(x(:,1),x(:,2),f(x(:,1),x(:,2)), &#x27;ro&#x27;);title(&#x27;状态位置变化&#x27;);</span></span><br><span class="line"><span class="comment">%         pause(0.5);</span></span><br><span class="line"><span class="comment">%        times=0;</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line">    iter = iter+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">toc;</span><br><span class="line"></span><br><span class="line">ret2 = ret + ym;</span><br><span class="line">ret2(ret2(:,<span class="number">1</span>) &gt; <span class="number">360</span>) = ret2(ret2(:,<span class="number">1</span>) &gt; <span class="number">360</span>) - <span class="number">360</span>;</span><br><span class="line">Mdl = KDTreeSearcher(ret2);</span><br><span class="line">tmp = <span class="built_in">ones</span>(n,<span class="number">1</span>)*(<span class="number">-500</span>);</span><br><span class="line">rev = <span class="built_in">ones</span>(n,<span class="number">2</span>)*(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span> : <span class="built_in">length</span>(points)</span><br><span class="line">    [nn,ddd] = knnsearch(Mdl,points(ii,<span class="number">1</span>:<span class="number">2</span>),<span class="string">&#x27;k&#x27;</span>,kk+<span class="number">1</span>);</span><br><span class="line">    value = -ddd - points(ii,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> value &gt; tmp(nn)</span><br><span class="line">        tmp(nn) = value;</span><br><span class="line">        rev(nn,:) = points(ii,<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">aaan = sum(tmp);</span><br><span class="line"></span><br><span class="line">Copy_3_of_totalH(rev)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf;</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">scatter</span>(ret2(:,<span class="number">1</span>), ret2(:,<span class="number">2</span>))</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">p2 = <span class="built_in">scatter</span>(points(:,<span class="number">1</span>), points(:,<span class="number">2</span>),<span class="number">5</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">p3 = <span class="built_in">scatter</span>(rev(:,<span class="number">1</span>), rev(:,<span class="number">2</span>),<span class="number">50</span>,<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% box on;</span></span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-10</span> <span class="number">370</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">120</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>([p1, p2,p3],&#123;<span class="string">&#x27;三角形网格点&#x27;</span>,<span class="string">&#x27;上半天区所有点&#x27;</span>,<span class="string">&#x27;距离最近点&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230302215728987.png" alt="image-20230302215728987"></p><p>距离-星等加权法</p><p>基于正三角形网格点的均匀选取方法，寻求变换</p><p>基于粒子群算法的最大化总体评价权值</p><p>总体评价权值<em>V</em></p><p>综合评价权值</p><p>贡献度</p><hr><p>计算实时最远距离</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dddd = <span class="number">0</span>;</span><br><span class="line">tmp =[];</span><br><span class="line">iii = <span class="number">0</span>;</span><br><span class="line">tic;</span><br><span class="line">Mdl = KDTreeSearcher(rev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span> : <span class="built_in">length</span>(points)</span><br><span class="line">    [nn,ddd] = knnsearch(Mdl, points(ii,<span class="number">1</span>:<span class="number">2</span>),<span class="string">&#x27;k&#x27;</span>,kk+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ( ddd &gt; points(ii,<span class="number">1</span>) )</span><br><span class="line">    [~, dd] = knnsearch(Mdl,[points(ii,<span class="number">1</span>) + <span class="number">360.0</span>, points(ii, <span class="number">2</span>)],<span class="string">&#x27;k&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">    ddd = <span class="built_in">min</span>(ddd, dd);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> (ddd &gt; <span class="number">360</span> - points(ii,<span class="number">1</span>) )</span><br><span class="line">    [~, dd] = knnsearch(Mdl,[points(ii,<span class="number">1</span>) - <span class="number">360.0</span>, points(ii, <span class="number">2</span>)],<span class="string">&#x27;k&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">    ddd = <span class="built_in">min</span>(ddd, dd);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> ddd &gt; dddd</span><br><span class="line">        dddd = ddd;</span><br><span class="line">        iii = ii;</span><br><span class="line">        tmp = points(ii,<span class="number">1</span>:<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">toc;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">p4 = <span class="built_in">scatter</span>(tmp(<span class="number">1</span>), tmp(<span class="number">2</span>),<span class="string">&#x27;k&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">legend</span>([p1, p2,p3, p4],&#123;<span class="string">&#x27;三角形网格点&#x27;</span>,<span class="string">&#x27;上半天区所有点&#x27;</span>,<span class="string">&#x27;距离最近点&#x27;</span>,<span class="string">&#x27;增补的一个星&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">pdist([<span class="number">137.3420</span>  , <span class="number">87.7710</span>;<span class="number">117.085</span>,<span class="number">73.8926</span>],<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line">pdist([<span class="number">137.3420</span>  , <span class="number">87.7710</span>;<span class="number">158.055</span>,<span class="number">72.5033</span>],<span class="string">&#x27;euclidean&#x27;</span>)</span><br></pre></td></tr></table></figure><hr><p>15<em>(cosd(weidu) </em> cosd(A) / tand(90-h) + sind(weidu))</p><hr><p>重新做一下星图软件</p><p>假设五等星 1471个星</p><p>纯计算方位角 需要10ms，显示成表格 12ms  显示出星图 229ms （加上地平380ms） 加个判断显示在地平上的 95ms </p><p>显示表格+视赤道 14ms  235ms</p><p>6等星 纯计算方位角 需要30ms，显示成表格 36ms  显示出星图 </p><hr><p>方位角误差</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% function  requation()</span></span><br><span class="line"></span><br><span class="line">clc;clear;</span><br><span class="line">load data1.csv</span><br><span class="line"></span><br><span class="line">azimuth=data1(:,<span class="number">1</span>)/<span class="number">180</span>*<span class="built_in">pi</span>; <span class="comment">%#ok&lt;*NODEF&gt;</span></span><br><span class="line">altitude=data1(:,<span class="number">2</span>)/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">deltaA=<span class="number">0</span>-data1(:,<span class="number">3</span>)/<span class="number">3600.0</span>; <span class="comment">% °</span></span><br><span class="line">deltaH=<span class="number">0</span>-data1(:,<span class="number">4</span>)/<span class="number">3600.0</span>; </span><br><span class="line"></span><br><span class="line">X=[<span class="number">0.</span>*altitude+<span class="number">1</span> <span class="number">0.</span>*altitude -<span class="built_in">cos</span>(azimuth).*<span class="built_in">tan</span>(altitude) -<span class="built_in">sin</span>(azimuth).*<span class="built_in">tan</span>(altitude) <span class="built_in">sec</span>(altitude) -<span class="built_in">tan</span>(altitude) <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude];</span><br><span class="line">y=[<span class="number">0.</span>*altitude <span class="number">0.</span>*altitude+<span class="number">1</span> <span class="built_in">sin</span>(azimuth) -<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">cot</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) altitude.*<span class="built_in">sin</span>(azimuth) altitude.*<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth)];</span><br><span class="line"></span><br><span class="line">A=[X;y];</span><br><span class="line">Y=[deltaA;deltaH]; <span class="comment">% °</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Res 为方程系数 Y° = A(弧度) * Res -&gt; </span></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line"><span class="comment">%E 为残差</span></span><br><span class="line">E = (A*Res - Y)*<span class="number">3600</span>;</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultXISHU.txt Res -ascii; </span></span><br><span class="line">file1=fopen(<span class="string">&#x27;ResultXISHU.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(Res)</span><br><span class="line">   fprintf(file1,<span class="string">&#x27;%5.5f\r\n&#x27;</span>,Res(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">EA = E(<span class="number">1</span>:<span class="number">64</span>);</span><br><span class="line">EE = E(<span class="number">65</span>:<span class="keyword">end</span>);</span><br><span class="line">RMSA = <span class="built_in">sqrt</span>(mse(EA));</span><br><span class="line"></span><br><span class="line">RMSE = <span class="built_in">sqrt</span>(mse(EE));</span><br><span class="line"><span class="comment">% aa = </span></span><br><span class="line"></span><br><span class="line">fclose(file1);</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultRMS.txt RMS -ascii; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> :<span class="number">64</span></span><br><span class="line">    <span class="keyword">if</span> data1(<span class="built_in">i</span>,<span class="number">1</span>) &lt; <span class="number">0</span> </span><br><span class="line">        data1(<span class="built_in">i</span>,<span class="number">1</span>) = data1(<span class="built_in">i</span>,<span class="number">1</span>) + <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.5</span> <span class="number">0.8</span> <span class="number">0.5</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正前的方位角偏差&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line">box on; </span><br><span class="line">axis equal;</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">-80</span> <span class="number">50</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;误差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data1(:,<span class="number">1</span>), data1(:,<span class="number">3</span>), <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.05</span> <span class="number">0.8</span> <span class="number">0.45</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正后的方位角残差&#x27;</span>)</span><br><span class="line">box on; </span><br><span class="line">axis equal;</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">-50</span> <span class="number">50</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">-50</span> <span class="number">-40</span> <span class="number">-30</span> <span class="number">-20</span> <span class="number">-10</span> <span class="number">0</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;残差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data1(:,<span class="number">1</span>), EA, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% function  requation()</span></span><br><span class="line"></span><br><span class="line">clc;clear;</span><br><span class="line">load data1.csv</span><br><span class="line"></span><br><span class="line">azimuth=data1(:,<span class="number">1</span>)/<span class="number">180</span>*<span class="built_in">pi</span>; <span class="comment">%#ok&lt;*NODEF&gt;</span></span><br><span class="line">altitude=data1(:,<span class="number">2</span>)/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">deltaA=<span class="number">0</span>-data1(:,<span class="number">3</span>)/<span class="number">3600.0</span>; <span class="comment">% °</span></span><br><span class="line">deltaH=<span class="number">0</span>-data1(:,<span class="number">4</span>)/<span class="number">3600.0</span>; </span><br><span class="line"></span><br><span class="line">X=[<span class="number">0.</span>*altitude+<span class="number">1</span> <span class="number">0.</span>*altitude -<span class="built_in">cos</span>(azimuth).*<span class="built_in">tan</span>(altitude) -<span class="built_in">sin</span>(azimuth).*<span class="built_in">tan</span>(altitude) <span class="built_in">sec</span>(altitude) -<span class="built_in">tan</span>(altitude) <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude];</span><br><span class="line">y=[<span class="number">0.</span>*altitude <span class="number">0.</span>*altitude+<span class="number">1</span> <span class="built_in">sin</span>(azimuth) -<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">cot</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) altitude.*<span class="built_in">sin</span>(azimuth) altitude.*<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth)];</span><br><span class="line"></span><br><span class="line">A=[X;y];</span><br><span class="line">Y=[deltaA;deltaH]; <span class="comment">% °</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Res 为方程系数 Y° = A(弧度) * Res -&gt; </span></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line"><span class="comment">%E 为残差</span></span><br><span class="line">E = (A*Res - Y)*<span class="number">3600</span>;</span><br><span class="line">E = E / <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultXISHU.txt Res -ascii; </span></span><br><span class="line">file1=fopen(<span class="string">&#x27;ResultXISHU.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(Res)</span><br><span class="line">   fprintf(file1,<span class="string">&#x27;%5.5f\r\n&#x27;</span>,Res(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">EA = E(<span class="number">1</span>:<span class="number">64</span>);</span><br><span class="line">EE = E(<span class="number">65</span>:<span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">RMSA = <span class="built_in">sqrt</span>(mse(EA));</span><br><span class="line"></span><br><span class="line">RMSE = <span class="built_in">sqrt</span>(mse(EE));</span><br><span class="line"><span class="comment">% aa = </span></span><br><span class="line"></span><br><span class="line">fclose(file1);</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultRMS.txt RMS -ascii; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> :<span class="number">64</span></span><br><span class="line">    <span class="keyword">if</span> data1(<span class="built_in">i</span>,<span class="number">1</span>) &lt; <span class="number">0</span> </span><br><span class="line">        data1(<span class="built_in">i</span>,<span class="number">1</span>) = data1(<span class="built_in">i</span>,<span class="number">1</span>) + <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.5</span> <span class="number">0.8</span> <span class="number">0.5</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正前的方位角偏差&#x27;</span>,<span class="string">&#x27;FontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">grid on;</span><br><span class="line">box on; </span><br><span class="line">axis equal;</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">-80</span> <span class="number">50</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;误差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data1(:,<span class="number">1</span>), data1(:,<span class="number">3</span>), <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.8</span> <span class="number">0.3</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正后的方位角残差&#x27;</span>,<span class="string">&#x27;FontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">10</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">-50</span> <span class="number">-40</span> <span class="number">-30</span> <span class="number">-20</span> <span class="number">-10</span> <span class="number">0</span> <span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;残差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">2</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data1(:,<span class="number">1</span>), EA, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% function  requation()</span></span><br><span class="line"></span><br><span class="line">clc;clear;</span><br><span class="line">load data1.csv</span><br><span class="line"></span><br><span class="line">azimuth=data1(:,<span class="number">1</span>)/<span class="number">180</span>*<span class="built_in">pi</span>; <span class="comment">%#ok&lt;*NODEF&gt;</span></span><br><span class="line">altitude=data1(:,<span class="number">2</span>)/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">deltaA=<span class="number">0</span>-data1(:,<span class="number">3</span>)/<span class="number">3600.0</span>; <span class="comment">% °</span></span><br><span class="line">deltaH=<span class="number">0</span>-data1(:,<span class="number">4</span>)/<span class="number">3600.0</span>; </span><br><span class="line"></span><br><span class="line">X=[<span class="number">0.</span>*altitude+<span class="number">1</span> <span class="number">0.</span>*altitude -<span class="built_in">cos</span>(azimuth).*<span class="built_in">tan</span>(altitude) -<span class="built_in">sin</span>(azimuth).*<span class="built_in">tan</span>(altitude) <span class="built_in">sec</span>(altitude) -<span class="built_in">tan</span>(altitude) <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude];</span><br><span class="line">y=[<span class="number">0.</span>*altitude <span class="number">0.</span>*altitude+<span class="number">1</span> <span class="built_in">sin</span>(azimuth) -<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">cot</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) altitude.*<span class="built_in">sin</span>(azimuth) altitude.*<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth)];</span><br><span class="line"></span><br><span class="line">A=[X;y];</span><br><span class="line">Y=[deltaA;deltaH]; <span class="comment">% °</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Res 为方程系数 Y° = A(弧度) * Res -&gt; </span></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line"><span class="comment">%E 为残差</span></span><br><span class="line">E = (A*Res - Y)*<span class="number">3600</span>;</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultXISHU.txt Res -ascii; </span></span><br><span class="line">file1=fopen(<span class="string">&#x27;ResultXISHU.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(Res)</span><br><span class="line">   fprintf(file1,<span class="string">&#x27;%5.5f\r\n&#x27;</span>,Res(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">EA = E(<span class="number">1</span>:<span class="number">64</span>);</span><br><span class="line">EE = E(<span class="number">65</span>:<span class="keyword">end</span>);</span><br><span class="line">RMSA = <span class="built_in">sqrt</span>(mse(EA));</span><br><span class="line"></span><br><span class="line">RMSE = <span class="built_in">sqrt</span>(mse(EE));</span><br><span class="line"><span class="comment">% aa = </span></span><br><span class="line"></span><br><span class="line">fclose(file1);</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultRMS.txt RMS -ascii; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% for i = 1 :64</span></span><br><span class="line"><span class="comment">%     if data1(i,1) &lt; 0 </span></span><br><span class="line"><span class="comment">%         data1(i,1) = data1(i,1) + 360;</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.55</span> <span class="number">0.8</span> <span class="number">0.4</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正前的高度角偏差&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">90</span>]);</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">300</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">15</span> <span class="number">30</span> <span class="number">45</span> <span class="number">60</span> <span class="number">75</span> <span class="number">90</span>]);</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;误差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data1(:,<span class="number">2</span>), data1(:,<span class="number">4</span>), <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.8</span> <span class="number">0.35</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正后的高度角残差&#x27;</span>)</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">90</span>]);</span><br><span class="line">ylim([<span class="number">-20</span> <span class="number">20</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">15</span> <span class="number">30</span> <span class="number">45</span> <span class="number">60</span> <span class="number">75</span> <span class="number">90</span>]);</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;残差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data1(:,<span class="number">2</span>), EE, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% function  requation()</span></span><br><span class="line"></span><br><span class="line">clc;clear;</span><br><span class="line">load data2.csv</span><br><span class="line"></span><br><span class="line">azimuth=data2(:,<span class="number">1</span>)/<span class="number">180</span>*<span class="built_in">pi</span>; <span class="comment">%#ok&lt;*NODEF&gt;</span></span><br><span class="line">altitude=data2(:,<span class="number">2</span>)/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">deltaA=<span class="number">0</span>-data2(:,<span class="number">3</span>)/<span class="number">3600.0</span>; <span class="comment">% °</span></span><br><span class="line">deltaH=<span class="number">0</span>-data2(:,<span class="number">5</span>)/<span class="number">3600.0</span>; </span><br><span class="line"></span><br><span class="line">X=[<span class="number">0.</span>*altitude+<span class="number">1</span> <span class="number">0.</span>*altitude -<span class="built_in">cos</span>(azimuth).*<span class="built_in">tan</span>(altitude) -<span class="built_in">sin</span>(azimuth).*<span class="built_in">tan</span>(altitude) <span class="built_in">sec</span>(altitude) -<span class="built_in">tan</span>(altitude) <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude];</span><br><span class="line">y=[<span class="number">0.</span>*altitude <span class="number">0.</span>*altitude+<span class="number">1</span> <span class="built_in">sin</span>(azimuth) -<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">cot</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) altitude.*<span class="built_in">sin</span>(azimuth) altitude.*<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth)];</span><br><span class="line"></span><br><span class="line">A=[X;y];</span><br><span class="line">Y=[deltaA;deltaH]; <span class="comment">% °</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Res 为方程系数 Y° = A(弧度) * Res -&gt; </span></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line"><span class="comment">%E 为残差</span></span><br><span class="line">E = (A*Res - Y)*<span class="number">3600</span>;</span><br><span class="line">E = E/<span class="number">2.0</span>;</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultXISHU.txt Res -ascii; </span></span><br><span class="line">file1=fopen(<span class="string">&#x27;ResultXISHU.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(Res)</span><br><span class="line">   fprintf(file1,<span class="string">&#x27;%5.5f\r\n&#x27;</span>,Res(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">EA = E(<span class="number">1</span>:<span class="number">64</span>);</span><br><span class="line">EE = E(<span class="number">65</span>:<span class="keyword">end</span>);</span><br><span class="line">RMSA = <span class="built_in">sqrt</span>(mse(EA));</span><br><span class="line"></span><br><span class="line">RMSE = <span class="built_in">sqrt</span>(mse(EE));</span><br><span class="line"><span class="comment">% aa = </span></span><br><span class="line"></span><br><span class="line">fclose(file1);</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultRMS.txt RMS -ascii; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% for i = 1 :64</span></span><br><span class="line"><span class="comment">%     if data2(i,1) &lt; 0 </span></span><br><span class="line"><span class="comment">%         data2(i,1) = data2(i,1) + 360;</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.55</span> <span class="number">0.8</span> <span class="number">0.4</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正前的高度角偏差&#x27;</span>,<span class="string">&#x27;FontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">grid on;</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">90</span>]);</span><br><span class="line">ylim([<span class="number">-100</span> <span class="number">200</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">15</span> <span class="number">30</span> <span class="number">45</span> <span class="number">60</span> <span class="number">75</span> <span class="number">90</span>]);</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;误差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data2(:,<span class="number">2</span>), data2(:,<span class="number">5</span>), <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.8</span> <span class="number">0.33</span>]);</span><br><span class="line">title(<span class="string">&#x27;模型校正后的高度角残差&#x27;</span>,<span class="string">&#x27;FontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">12</span>)</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">0</span> <span class="number">90</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">10</span>]);</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">15</span> <span class="number">30</span> <span class="number">45</span> <span class="number">60</span> <span class="number">75</span> <span class="number">90</span>]);</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;高度角&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;残差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">5</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data2(:,<span class="number">2</span>), EE, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line">xtickformat(<span class="string">&#x27;degrees&#x27;</span>)</span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230323111042404.png" alt="image-20230323111042404"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% function  requation()</span></span><br><span class="line"></span><br><span class="line">clc;clear;</span><br><span class="line">load data2.csv</span><br><span class="line"></span><br><span class="line">azimuth=data2(:,<span class="number">1</span>)/<span class="number">180</span>*<span class="built_in">pi</span>; <span class="comment">%#ok&lt;*NODEF&gt;</span></span><br><span class="line">altitude=data2(:,<span class="number">2</span>)/<span class="number">180</span>*<span class="built_in">pi</span>;</span><br><span class="line">deltaA=<span class="number">0</span>-data2(:,<span class="number">3</span>)/<span class="number">3600.0</span>; <span class="comment">% °</span></span><br><span class="line">deltaH=<span class="number">0</span>-data2(:,<span class="number">5</span>)/<span class="number">3600.0</span>; </span><br><span class="line"></span><br><span class="line">X=[<span class="number">0.</span>*altitude+<span class="number">1</span> <span class="number">0.</span>*altitude -<span class="built_in">cos</span>(azimuth).*<span class="built_in">tan</span>(altitude) -<span class="built_in">sin</span>(azimuth).*<span class="built_in">tan</span>(altitude) <span class="built_in">sec</span>(altitude) -<span class="built_in">tan</span>(altitude) <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth).*<span class="built_in">sec</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude];</span><br><span class="line">y=[<span class="number">0.</span>*altitude <span class="number">0.</span>*altitude+<span class="number">1</span> <span class="built_in">sin</span>(azimuth) -<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">cot</span>(altitude) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(azimuth) <span class="built_in">cos</span>(azimuth) altitude.*<span class="built_in">sin</span>(azimuth) altitude.*<span class="built_in">cos</span>(azimuth) <span class="number">0.</span>*altitude <span class="number">0.</span>*altitude <span class="built_in">sin</span>(<span class="number">2.</span>*azimuth) <span class="built_in">cos</span>(<span class="number">2.</span>*azimuth)];</span><br><span class="line"></span><br><span class="line">A=[X;y];</span><br><span class="line">Y=[deltaA;deltaH]; <span class="comment">% °</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%Res 为方程系数 Y° = A(弧度) * Res -&gt; </span></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line"><span class="comment">%E 为残差</span></span><br><span class="line">E = (A*Res - Y)*<span class="number">3600</span>;</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultXISHU.txt Res -ascii; </span></span><br><span class="line">file1=fopen(<span class="string">&#x27;ResultXISHU.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(Res)</span><br><span class="line">   fprintf(file1,<span class="string">&#x27;%5.5f\r\n&#x27;</span>,Res(<span class="built_in">i</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">EA = E(<span class="number">1</span>:<span class="number">64</span>);</span><br><span class="line">EE = E(<span class="number">65</span>:<span class="keyword">end</span>);</span><br><span class="line">RMSA = <span class="built_in">sqrt</span>(mse(EA));</span><br><span class="line"></span><br><span class="line">RMSE = <span class="built_in">sqrt</span>(mse(EE));</span><br><span class="line"><span class="comment">% aa = </span></span><br><span class="line"></span><br><span class="line">fclose(file1);</span><br><span class="line"><span class="comment">%输出 到TXT文件 科学计算法</span></span><br><span class="line"><span class="comment">%save ResultRMS.txt RMS -ascii; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> :<span class="number">64</span></span><br><span class="line">    <span class="keyword">if</span> data2(<span class="built_in">i</span>,<span class="number">1</span>) &lt; <span class="number">0</span> </span><br><span class="line">        data2(<span class="built_in">i</span>,<span class="number">1</span>) = data2(<span class="built_in">i</span>,<span class="number">1</span>) + <span class="number">360</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.55</span> <span class="number">0.8</span> <span class="number">0.4</span>]);</span><br><span class="line">title(<span class="string">&#x27;指向校正前高度角误差分布图&#x27;</span>,FontWeight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">grid on;</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">-80</span> <span class="number">80</span>]);</span><br><span class="line">ylim([<span class="number">-100</span> <span class="number">200</span>]);</span><br><span class="line">xticks([<span class="number">-80</span> <span class="number">-60</span> <span class="number">-40</span> <span class="number">-20</span>  <span class="number">0</span>  <span class="number">20</span>  <span class="number">40</span> <span class="number">60</span> <span class="number">80</span>])</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;校正前方位角偏差（角秒）&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;校正前高度角偏差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line">r = pdist([[<span class="number">0</span>,<span class="number">0</span>];[<span class="number">50</span>,<span class="number">0</span>]],<span class="string">&#x27;euclidean&#x27;</span>);</span><br><span class="line">p1 = rectangle(<span class="string">&#x27;position&#x27;</span>,[<span class="number">0</span>-r,<span class="number">0</span>-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">r = pdist([[<span class="number">0</span>,<span class="number">0</span>];[<span class="number">150</span>,<span class="number">0</span>]],<span class="string">&#x27;euclidean&#x27;</span>);</span><br><span class="line">p2 = rectangle(<span class="string">&#x27;position&#x27;</span>,[<span class="number">0</span>-r,<span class="number">0</span>-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;-.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(data2(:,<span class="number">3</span>), data2(:,<span class="number">5</span>), <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line">a = <span class="built_in">plot</span>([[<span class="number">1000</span>,<span class="number">2000</span>],[<span class="number">1000</span>,<span class="number">2000</span>]],<span class="string">&#x27;--k&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">b = <span class="built_in">plot</span>([[<span class="number">1000</span>,<span class="number">2000</span>],[<span class="number">1000</span>,<span class="number">2000</span>]],<span class="string">&#x27;-.k&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">legend</span>([a, b],&#123;<span class="string">&#x27;50 arcsec&#x27;</span>,<span class="string">&#x27;150 arcsec&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Position&#x27;</span>,[<span class="number">0.1</span> <span class="number">0.1</span> <span class="number">0.8</span> <span class="number">0.35</span>]);</span><br><span class="line">title(<span class="string">&#x27;指向校正后高度角残差分布图&#x27;</span>,FontWeight=<span class="string">&#x27;bold&#x27;</span>)</span><br><span class="line">box on; </span><br><span class="line"><span class="comment">% axis equal;</span></span><br><span class="line">xlim([<span class="number">-60</span> <span class="number">60</span>]);</span><br><span class="line">ylim([<span class="number">-20</span> <span class="number">20</span>]);</span><br><span class="line">xticks([<span class="number">-80</span> <span class="number">-60</span> <span class="number">-40</span> <span class="number">-20</span>  <span class="number">0</span>  <span class="number">20</span>  <span class="number">40</span> <span class="number">60</span> <span class="number">80</span>])</span><br><span class="line"><span class="comment">% yticks([0 30 60 90])</span></span><br><span class="line">xlabel(<span class="string">&#x27;校正后方位角残差（角秒）&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;校正后高度角残差（角秒）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"></span><br><span class="line">r = pdist([[<span class="number">0</span>,<span class="number">0</span>];[<span class="number">10</span>,<span class="number">0</span>]],<span class="string">&#x27;euclidean&#x27;</span>);</span><br><span class="line">p1 = rectangle(<span class="string">&#x27;position&#x27;</span>,[<span class="number">0</span>-r,<span class="number">0</span>-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;--&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">r = pdist([[<span class="number">0</span>,<span class="number">0</span>];[<span class="number">15</span>,<span class="number">0</span>]],<span class="string">&#x27;euclidean&#x27;</span>);</span><br><span class="line">p2 = rectangle(<span class="string">&#x27;position&#x27;</span>,[<span class="number">0</span>-r,<span class="number">0</span>-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;LineStyle&#x27;</span>,<span class="string">&#x27;-.&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(EA, EE, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% scatter(points(best_way,1), points(best_way,2), 20,&#x27;filled&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;#FF8000&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;usd&#x27;)</span></span><br><span class="line"><span class="comment">% legend(&#x27;All stars&#x27;, &#x27;Selected stars&#x27;)</span></span><br><span class="line"><span class="comment">% xtickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"><span class="comment">% ytickformat(&#x27;degrees&#x27;)</span></span><br><span class="line"><span class="built_in">hold</span> on; </span><br><span class="line">a = <span class="built_in">plot</span>([[<span class="number">100</span>,<span class="number">200</span>],[<span class="number">100</span>,<span class="number">200</span>]],<span class="string">&#x27;--k&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">b = <span class="built_in">plot</span>([[<span class="number">100</span>,<span class="number">200</span>],[<span class="number">100</span>,<span class="number">200</span>]],<span class="string">&#x27;-.k&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">legend</span>([a, b],&#123;<span class="string">&#x27;10 arcsec&#x27;</span>,<span class="string">&#x27;15 arcsec&#x27;</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear; </span><br><span class="line"><span class="comment">% M = csvread(&#x27;J2000_5hor.csv&#x27;);</span></span><br><span class="line">MM = csvread(<span class="string">&#x27;J2000_5horzhengfangxing.csv&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% MM = sortrows(M,4);</span></span><br><span class="line"><span class="comment">% MMM = MM(22:85,:);</span></span><br><span class="line"></span><br><span class="line">clf;</span><br><span class="line"><span class="comment">% box on;</span></span><br><span class="line">axis equal;</span><br><span class="line">xticks([<span class="number">0</span> <span class="number">60</span> <span class="number">120</span> <span class="number">180</span> <span class="number">240</span> <span class="number">300</span> <span class="number">360</span>])</span><br><span class="line">yticks([<span class="number">0</span> <span class="number">30</span> <span class="number">60</span> <span class="number">90</span>])</span><br><span class="line">xlim([<span class="number">-10</span> <span class="number">370</span>]);</span><br><span class="line">ylim([<span class="number">-10</span> <span class="number">100</span>]);</span><br><span class="line"><span class="comment">% grid on;</span></span><br><span class="line">ax = gca;</span><br><span class="line">ax.XAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.XAxis.MinorTickValues = ax.XAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.XAxis.Limits(<span class="number">2</span>);</span><br><span class="line">ax.YAxis.MinorTick = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">ax.YAxis.MinorTickValues = ax.YAxis.Limits(<span class="number">1</span>):<span class="number">10</span>:ax.YAxis.Limits(<span class="number">2</span>);</span><br><span class="line">grid minor;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">xt=get(gca,<span class="string">&#x27;xtick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(xt);</span><br><span class="line">xt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,xt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;xticklabel&#x27;</span>,xt1);</span><br><span class="line">yt=get(gca,<span class="string">&#x27;ytick&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:<span class="built_in">numel</span>(yt);</span><br><span class="line">yt1&#123;k&#125;=sprintf(<span class="string">&#x27;%d°&#x27;</span>,yt(k));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">set(gca,<span class="string">&#x27;yticklabel&#x27;</span>,yt1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xlabel(<span class="string">&#x27;方位轴&#x27;</span>,<span class="string">&#x27;FontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;高度轴&#x27;</span>,<span class="string">&#x27;FontWeight&#x27;</span>,<span class="string">&#x27;bold&#x27;</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">90</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">line([<span class="number">0</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">0</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line">line([<span class="number">360</span>,<span class="number">360</span>],[<span class="number">0</span>,<span class="number">90</span>],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1.5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(MM(:,<span class="number">2</span>), MM(:,<span class="number">3</span>))</span><br><span class="line">Copy_3_of_totalH(MM(:,<span class="number">2</span>:<span class="number">3</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冲毕业第六七八周记录</title>
      <link href="2023/01/06/blog70-study5/"/>
      <url>2023/01/06/blog70-study5/</url>
      
        <content type="html"><![CDATA[<p>一些相关的文章</p><p><a href="https://stackoverflow.com/questions/34313200/distribute-points-evenly-on-a-unit-hemisphere">Distribute points evenly on a unit hemisphere</a></p><p><a href="https://zhuanlan.zhihu.com/p/25998937">https://zhuanlan.zhihu.com/p/25998937</a></p><p>但并不适用于矩形上选择</p><hr><p>突然发现一个很大的问题，我不能使用该方法来寻找星点，因为这种均匀分布是星点之间的角距的均匀分布，在观测时高度越高观测点越少，在高度低的地方观测点较多，其实并不适用于机架的校正。机架的校正应该按照经纬度网格来均匀选取。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214161314056.png" alt="image-20221214161314056"></p><p>那么其实就可以将头顶的天区展开为一个矩形，方位和高度为边的矩形，研究在矩形上的二维均匀分布。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214161442139.png" alt="image-20221214161442139"></p><p>浅画一下二维的高度方位图（5等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214164714085.png" alt="image-20221214164714085"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214174203207.png" alt="image-20221214174203207"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214174257089.png" alt="image-20221214174257089"></p><hr><p>论文</p><p>Vedder, J.D.: ‘Star trackers, star catalog, and attitude determination: probabilistic aspects of system design’, J. Guid. Control Dyn., 1993, 16, (3), pp. 499–504</p><p>专利 《用于星敏感器的筛选导航星的方法》</p><p>2004 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221216005037292.png" alt="image-20221216005037292"></p><hr><p>在Stack Overflow中找到了我想问问题的答案 </p><p><a href="https://stackoverflow.com/questions/13005294/measure-the-uniformity-of-distribution-of-points-in-a-2d-square">https://stackoverflow.com/questions/13005294/measure-the-uniformity-of-distribution-of-points-in-a-2d-square</a></p><p>通常在统计学中，我们需要了解给定的样本是否来自特定的分布，最常见的是正态分布(或高斯分布)。为此，我们有所谓的正态性检验，如夏皮罗-威尔克，安德森-达林或Kolmogorov-Smirnov检验。</p><p>它们都测量样本来自正态分布的可能性有多大，并有相关的p值来支持这种测量。</p><hr><p>就是KS检验。Kolmogorov-Smirnov test是一个有用的非参数（nonparmetric）假设检验，主要是用来检验一组样本是否来自于某个概率分布（one-sample K-S test），或者比较两组样本的分布是否相同（two-sample K-S test）。</p><p>ks检验返回两个值，pvalue是越高越好，统计量D-statistic越低越好</p><p>值的解释 </p><p><a href="https://stats.stackexchange.com/questions/57885/how-to-interpret-p-value-of-kolmogorov-smirnov-test-python">https://stats.stackexchange.com/questions/57885/how-to-interpret-p-value-of-kolmogorov-smirnov-test-python</a></p><p><a href="https://en.m.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">https://en.m.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test</a></p><p>D 统计量是两个样本的 CDF 之间的绝对最大距离(最大值)。这个数字越接近于0，这两个样本就越有可能来自同一个分布。</p><p>K-s 检验返回的 p 值与其他 p 值具有相同的解释。如果 p 值小于你的显著性水平，那么你就拒绝了两个样本来自同一个分布的无效假设。如果您对该过程感兴趣，可以在线找到将 D 统计量转换为 p 值的表。</p><blockquote><p>最终返回的结果，p-value=4.7405805465370525e-159，比指定的显著水平（假设为5%）小，则我们完全可以拒绝假设：beta和norm不服从同一分布。</p></blockquote><p>学习一下ks检验 <strong>柯尔莫哥洛夫-斯米尔诺夫检验</strong>（英语：Kolmogorov-Smirnov test，简称K-S test），是一种基于累计分布函数的非参数检验，用以检验两个经验分布是否不同或一个经验分布与另一个理想分布是否不同。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221216153934258.png" alt="image-20221216153934258"></p><p><a href="https://zhuanlan.zhihu.com/p/292678346">https://zhuanlan.zhihu.com/p/292678346</a></p><p>α是置信系数</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/v2-a831d74d745ccaf7ceb57110850bce5e_720w.webp" alt="img"></p><p><a href="https://zhuanlan.zhihu.com/p/26477641">https://zhuanlan.zhihu.com/p/26477641</a></p><hr><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> ks_2samp</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> kstest</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">norm1 = [<span class="number">105</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">112</span>, <span class="number">113</span>, <span class="number">113</span>, <span class="number">117</span>, <span class="number">128</span>, <span class="number">130</span>, <span class="number">131</span>]</span><br><span class="line">print(norm1)</span><br><span class="line">ks_value = kstest(norm1, <span class="string">&#x27;norm&#x27;</span>, args=(<span class="number">120</span>, <span class="number">10</span>))</span><br><span class="line">print(ks_value)</span><br></pre></td></tr></table></figure><p>KstestResult(statistic=0.35803634777692694, pvalue=0.11834016917515)</p><p>用一种简单的方式，我们可以将2样本检验的<code>KS统计量</code>D 定义为每个样本的cdf(累积分布函数)之间的最大距离，cdf 累计分布函数 <a href="https://towardsdatascience.com/comparing-sample-distributions-with-the-kolmogorov-smirnov-ks-test-a2292ad6fee5">https://towardsdatascience.com/comparing-sample-distributions-with-the-kolmogorov-smirnov-ks-test-a2292ad6fee5</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221216193356448.png" alt="image-20221216193356448"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> kstest</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">norm1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">print(norm1)</span><br><span class="line">ks_value = kstest(norm1, <span class="string">&#x27;uniform&#x27;</span>, args=(<span class="number">0</span>, <span class="number">10</span>), N=<span class="number">12</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">KstestResult(statistic=<span class="number">0.09090909090909094</span>, pvalue=<span class="number">0.9998600940511319</span>)</span><br><span class="line">print(ks_value)</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221216203303976.png" alt="image-20221216203303976"></p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</span><br><span class="line">pd2 = makedist(<span class="string">&#x27;Uniform&#x27;</span>,<span class="string">&#x27;lower&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;upper&#x27;</span>,<span class="number">10</span>); <span class="comment">% Uniform distribution with a = -2 and b = 2</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">.01</span>:<span class="number">10</span>;</span><br><span class="line">cdf2 = cdf(pd2, t);</span><br><span class="line">h1 = cdfplot(x);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,cdf2,<span class="string">&#x27;k:&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;样本数据&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;累积分布函数F(x)&#x27;</span>);</span><br></pre></td></tr></table></figure></h2><p>试试实时方位数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> kstest</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">user_cols = [<span class="string">&#x27;hip&#x27;</span>, <span class="string">&#x27;az&#x27;</span>, <span class="string">&#x27;alt&#x27;</span>, <span class="string">&#x27;mag&#x27;</span>]</span><br><span class="line">pd_reader = pd.read_csv(<span class="string">&quot;./J2000_5_hor.csv&quot;</span>, header=<span class="literal">None</span>,</span><br><span class="line">                        engine=<span class="string">&#x27;python&#x27;</span>, index_col=<span class="number">0</span>, usecols=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)), names=user_cols)</span><br><span class="line">print(pd_reader.head())</span><br><span class="line">norm1 = pd_reader[<span class="string">&#x27;az&#x27;</span>]</span><br><span class="line">print(norm1)</span><br><span class="line">ks_value = kstest(norm1, <span class="string">&#x27;uniform&#x27;</span>, args=(<span class="number">0</span>, <span class="number">360</span>))</span><br><span class="line">print(ks_value)</span><br></pre></td></tr></table></figure><p>KstestResult(statistic=0.06621370056497172, pvalue=0.0038362399448040162)</p><p>实验感觉有问题 <a href="https://bbs.pinggu.org/thread-2983774-1-1.html">https://bbs.pinggu.org/thread-2983774-1-1.html</a></p><p><a href="https://stats.stackexchange.com/questions/153249/non-uniform-distribution-of-p-values-when-simulating-binomial-tests-under-the-nu/">https://stats.stackexchange.com/questions/153249/non-uniform-distribution-of-p-values-when-simulating-binomial-tests-under-the-nu/</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221216203556995.png" alt="image-20221216203556995"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line">M = csvread(<span class="string">&#x27;J2000_5_hor.csv&#x27;</span>);</span><br><span class="line">x = M(:, <span class="number">2</span>);</span><br><span class="line">pd2 = makedist(<span class="string">&#x27;Uniform&#x27;</span>,<span class="string">&#x27;lower&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;upper&#x27;</span>,<span class="number">360</span>); <span class="comment">% Uniform distribution with a = -2 and b = 2</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">.01</span>:<span class="number">360</span>;</span><br><span class="line">cdf2 = cdf(pd2, t);</span><br><span class="line">h1 = cdfplot(x);</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(t,cdf2,<span class="string">&#x27;k:&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;样本数据&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;累积分布函数F(x)&#x27;</span>);</span><br><span class="line">xlim([<span class="number">0</span> <span class="number">360</span>])</span><br><span class="line">ylim([<span class="number">0</span> <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221230230221109.png" alt="image-20221230230221109"></p><hr><p>ks检验还是到此为止了，毕竟还只是个检验方法，不算指标</p><p>检验数据是否服从指定分布的方法有</p><p><a href="https://blog.csdn.net/Datawhale/article/details/120558925">https://blog.csdn.net/Datawhale/article/details/120558925</a></p><p>可知 KS检验的灵敏度没有相应的检验来的高</p><p>在该文中提到KL 散度是一种衡量两个概率分布的匹配程度的指标，两个分布差异越大，KL散度越大。KL越小越接近。</p><p>有人会把KL散度认为是一种距离指标，然而，KL散度不能用来衡量两个分布的距离。其原因在于KL散度不是对称的。举例来说，如果用观测分布来近似二项分布，其KL散度为</p><p><a href="https://zhuanlan.zhihu.com/p/153492607">https://zhuanlan.zhihu.com/p/153492607</a></p><p>感觉不太合适，所以作罢</p><hr><p><a href="https://blog.csdn.net/qq_45654781/article/details/126862808">https://blog.csdn.net/qq_45654781/article/details/126862808</a></p><p><strong><code>计算 Kozachenko-Leonenko的k最近邻估计熵</code></strong></p><p><a href="https://github.com/kuxing-pretty/entropy_estimators">https://github.com/paulbrodersen/entropy_estimators</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230103103217539.png" alt="image-20230103103217539"></p><p>4等星 214个选20个</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230103155149727.png" alt="image-20230103155149727"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230103155239749.png" alt="image-20230103155239749"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">from scipy.special <span class="keyword">import</span> gamma, digamma</span><br><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line">from entropy_estimators <span class="keyword">import</span> continuous</span><br><span class="line"></span><br><span class="line"><span class="meta"># create some normal test data</span></span><br><span class="line"># X = np.random.randn(<span class="number">20000</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"># X = np.arange(<span class="number">0</span>, <span class="number">0.09</span>, <span class="number">0.01</span>)</span><br><span class="line"># X = np.<span class="built_in">array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"># X = np.<span class="built_in">array</span>([<span class="number">189.83</span> <span class="number">195.095</span> <span class="number">195.192</span> <span class="number">196.886</span> <span class="number">198.814</span> <span class="number">203.376</span> <span class="number">204.429</span> <span class="number">218.318</span> <span class="number">227.266</span> <span class="number">261.36</span> <span class="number">301.009</span> <span class="number">308.907</span> <span class="number">345.333</span>])</span><br><span class="line"><span class="meta"># dp 前a个点 选b个点 最后一次选的是c点 倒数第二次选的是d点</span></span><br><span class="line"><span class="meta"># dp[3][3][3][2] dp[4][4][4][3]</span></span><br><span class="line">X = np.<span class="built_in">array</span>([<span class="number">189.83</span>, <span class="number">261.36</span>, <span class="number">301.009</span>, <span class="number">345.333</span>])</span><br><span class="line">#            <span class="number">261</span><span class="number">-189</span>  <span class="number">301</span><span class="number">-261</span> <span class="number">301</span><span class="number">-261</span>  <span class="number">345</span><span class="number">-301</span></span><br><span class="line"></span><br><span class="line">print(X.shape)</span><br><span class="line"><span class="meta"># compute the entropy from the determinant of the multivariate normal distribution:</span></span><br><span class="line">analytic = continuous.get_h_mvn(X)</span><br><span class="line"></span><br><span class="line"><span class="meta"># compute the entropy using the k-nearest neighbour approach</span></span><br><span class="line"><span class="meta"># developed by Kozachenko and Leonenko (1,987):</span></span><br><span class="line">kozachenko = continuous.get_h(X, k=1, norm=&#x27;euclidean&#x27;)</span><br><span class="line"></span><br><span class="line">print(f<span class="string">&quot;analytic result: &#123;analytic:.5f&#125;&quot;</span>)</span><br><span class="line">print(f<span class="string">&quot;K-L estimator: &#123;kozachenko:.5f&#125;&quot;</span>)</span><br><span class="line">print(digamma(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>运算时间很慢</p><p>用c++写dp（这个dp还没考虑球体的循环问题）</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/math/special_functions/digamma.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/STACK:1073741824&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">// vector&lt;double&gt; points = &#123;0.1, 1.2, 1.9, 2.3, 2.9, 3.9&#125;;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; points = &#123;<span class="number">261.36</span>, <span class="number">345.333</span>, <span class="number">218.318</span>, <span class="number">196.886</span>, <span class="number">187.195</span>, <span class="number">187.387</span>, <span class="number">349.435</span>, <span class="number">262.478</span>, <span class="number">352.194</span>, <span class="number">186.59</span>, <span class="number">355.361</span>, <span class="number">358.033</span>, <span class="number">347.135</span>, <span class="number">179.794</span>, <span class="number">179.51</span>, <span class="number">178.597</span>, <span class="number">14.876</span>, <span class="number">172.61</span>, <span class="number">5.50809</span>, <span class="number">175.587</span>, <span class="number">158.055</span>, <span class="number">175.579</span>, <span class="number">18.0717</span>, <span class="number">18.0694</span>, <span class="number">167.389</span>, <span class="number">163.211</span>, <span class="number">98.636</span>, <span class="number">135.693</span>, <span class="number">10.1721</span>, <span class="number">131.4</span>, <span class="number">172.071</span>, <span class="number">152.177</span>, <span class="number">6.69029</span>, <span class="number">43.8872</span>, <span class="number">117.085</span>, <span class="number">72.1644</span>, <span class="number">168.928</span>, <span class="number">0.366764</span>, <span class="number">135.911</span>, <span class="number">94.3341</span>, <span class="number">29.6564</span>, <span class="number">158.157</span>, <span class="number">129.038</span>, <span class="number">35.8318</span>, <span class="number">65.4447</span>, <span class="number">60.8557</span>, <span class="number">52.6322</span>, <span class="number">150.143</span>, <span class="number">144.502</span>, <span class="number">44.7996</span>, <span class="number">117.286</span>, <span class="number">115.854</span>, <span class="number">133.016</span>, <span class="number">50.1732</span>, <span class="number">130.872</span>, <span class="number">78.2541</span>, <span class="number">92.0012</span>, <span class="number">59.5689</span>, <span class="number">91.4648</span>, <span class="number">91.6474</span>, <span class="number">91.4945</span>, <span class="number">78.2767</span>, <span class="number">64.2761</span>, <span class="number">130.576</span>, <span class="number">105.338</span>, <span class="number">112.139</span>, <span class="number">51.6668</span>, <span class="number">140.95</span>, <span class="number">98.267</span>, <span class="number">95.4699</span>, <span class="number">92.6435</span>, <span class="number">96.5942</span>, <span class="number">135.931</span>, <span class="number">94.7702</span>, <span class="number">114.749</span>, <span class="number">113.036</span>, <span class="number">102.779</span>, <span class="number">103.887</span>, <span class="number">106.395</span>, <span class="number">71.9267</span>, <span class="number">57.5453</span>, <span class="number">61.2187</span>, <span class="number">125.211</span>, <span class="number">60.8502</span>, <span class="number">110.887</span>, <span class="number">119.231</span>, <span class="number">112.454</span>, <span class="number">54.2793</span>, <span class="number">110.83</span>, <span class="number">105.955</span>, <span class="number">97.9926</span>, <span class="number">74.9688</span>, <span class="number">120.518</span>, <span class="number">102.988</span>, <span class="number">117.519</span>, <span class="number">93.22</span>, <span class="number">107.316</span>, <span class="number">103.157</span>, <span class="number">81.8369</span>, <span class="number">103.996</span>, <span class="number">103.994</span>, <span class="number">103.133</span>, <span class="number">119.554</span>, <span class="number">113.025</span>, <span class="number">108.66</span>, <span class="number">117.34</span>, <span class="number">92.8309</span>, <span class="number">111.149</span>, <span class="number">42.8763</span>, <span class="number">53.886</span>, <span class="number">62.5918</span>, <span class="number">76.2882</span>, <span class="number">75.3801</span>, <span class="number">100.752</span>, <span class="number">79.2899</span>, <span class="number">70.6052</span>, <span class="number">81.4649</span>, <span class="number">61.3945</span>, <span class="number">74.194</span>, <span class="number">69.2536</span>, <span class="number">63.5351</span>, <span class="number">58.963</span>, <span class="number">64.2205</span>, <span class="number">61.0484</span>, <span class="number">28.6315</span>, <span class="number">36.2729</span>, <span class="number">36.4375</span>, <span class="number">22.0025</span>, <span class="number">29.8624</span>, <span class="number">22.9935</span>, <span class="number">16.475</span>, <span class="number">13.928</span>, <span class="number">8.27138</span>, <span class="number">2.78788</span>, <span class="number">353.602</span>, <span class="number">352.709</span>, <span class="number">349.577</span>, <span class="number">342.741</span>, <span class="number">338.205</span>, <span class="number">337.806</span>, <span class="number">314.748</span>, <span class="number">325.078</span>, <span class="number">319.051</span>, <span class="number">327.003</span>, <span class="number">322.017</span>, <span class="number">303.285</span>, <span class="number">301.663</span>, <span class="number">340.939</span>, <span class="number">307.003</span>, <span class="number">300.783</span>, <span class="number">310.137</span>, <span class="number">299.254</span>, <span class="number">281.805</span>, <span class="number">334.071</span>, <span class="number">318.207</span>, <span class="number">269.96</span>, <span class="number">315.802</span>, <span class="number">291.564</span>, <span class="number">307.793</span>, <span class="number">273.792</span>, <span class="number">280.855</span>, <span class="number">336.666</span>, <span class="number">271.656</span>, <span class="number">268.879</span>, <span class="number">280.421</span>, <span class="number">260.389</span>, <span class="number">308.107</span>, <span class="number">249.547</span>, <span class="number">247.287</span>, <span class="number">300.084</span>, <span class="number">268.299</span>, <span class="number">270.919</span>, <span class="number">271.962</span>, <span class="number">305.234</span>, <span class="number">326.502</span>, <span class="number">291.083</span>, <span class="number">247.667</span>, <span class="number">299.381</span>, <span class="number">302.746</span>, <span class="number">284.357</span>, <span class="number">294.458</span>, <span class="number">328.324</span>, <span class="number">231.173</span>, <span class="number">338.978</span>, <span class="number">243.665</span>, <span class="number">233.148</span>, <span class="number">324.253</span>, <span class="number">256.191</span>, <span class="number">232.279</span>, <span class="number">216.426</span>, <span class="number">241.766</span>, <span class="number">272.257</span>, <span class="number">208.418</span>, <span class="number">247.348</span>, <span class="number">325.249</span>, <span class="number">237.343</span>, <span class="number">236.978</span>, <span class="number">314.613</span>, <span class="number">245.759</span>, <span class="number">203.524</span>, <span class="number">276.607</span>, <span class="number">200.523</span>, <span class="number">339.604</span>, <span class="number">265.049</span>, <span class="number">224.551</span>, <span class="number">218.172</span>, <span class="number">209.523</span>, <span class="number">302.305</span>, <span class="number">269.956</span>, <span class="number">245.845</span>, <span class="number">211.412</span>, <span class="number">227.112</span>, <span class="number">317.642</span>, <span class="number">353.915</span>&#125;;</span><br><span class="line"><span class="comment">// vector&lt;double&gt; points(point.begin(), point.begin() + 50);</span></span><br><span class="line"><span class="keyword">double</span> log_c_d = (<span class="number">1</span> / <span class="number">2.</span>) * <span class="built_in">log</span>(M_PI) - <span class="built_in">log</span>(tgamma(<span class="number">1</span> / <span class="number">2.</span> + <span class="number">1</span>));</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> distances = points[j - <span class="number">1</span>] - points[k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">double</span> sum_log_dist = <span class="number">2</span> * <span class="built_in">log</span>(<span class="number">2</span> * distances);</span><br><span class="line">    <span class="keyword">double</span> h = -boost::math::digamma(<span class="number">1</span>) + boost::math::digamma(<span class="number">2</span>) + log_c_d + (<span class="number">1</span> / <span class="number">2.0</span>) * sum_log_dist;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = points.size();</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; n &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sort(points.begin(), points.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> num : points)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double dp[51][21][51][51];</span></span><br><span class="line">    <span class="comment">// memset(dp, 0, sizeof(dp));</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&gt;(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;(n + <span class="number">1</span>))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 1&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i - <span class="number">1</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            dp[i][<span class="number">2</span>][i][k] = func(i, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">3</span>; a &lt;= n; a++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">2</span>; b &lt;= m; b++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = b; c &lt;= a; c++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> d = b - <span class="number">1</span>; d &lt;= a - <span class="number">1</span> &amp;&amp; d &lt;= c - <span class="number">1</span>; d++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c == a &amp;&amp; b == <span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (c != a)</span><br><span class="line">                    &#123; <span class="comment">// 没选a</span></span><br><span class="line">                        dp[a][b][c][d] = dp[a - <span class="number">1</span>][b][c][d];<span class="comment">//120^4 * 20 dp 前a个点 选b个点 最后一次选的是c点 倒数第二次选的是d点  筛选问题 700 选 50 </span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> e = b - <span class="number">2</span>; e &lt;= d - <span class="number">1</span>; e++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">double</span> last = dp[a - <span class="number">1</span>][b - <span class="number">1</span>][d][e];</span><br><span class="line">                            <span class="keyword">double</span> newv = ((last + boost::math::digamma(<span class="number">1</span>) - boost::math::digamma(b - <span class="number">1</span>) - log_c_d) * (b - <span class="number">1</span>) - <span class="built_in">log</span>(<span class="number">2</span> * (points[d - <span class="number">1</span>] - points[e - <span class="number">1</span>])) + <span class="built_in">log</span>(<span class="number">2</span> * (points[c - <span class="number">1</span>] - points[d - <span class="number">1</span>])) + <span class="built_in">log</span>(<span class="number">2</span> * min(points[c - <span class="number">1</span>] - points[d - <span class="number">1</span>], points[d - <span class="number">1</span>] - points[e - <span class="number">1</span>]))) / <span class="keyword">double</span>(b) - boost::math::digamma(<span class="number">1</span>) + boost::math::digamma(b) + log_c_d;</span><br><span class="line">                            <span class="comment">// if ( a == 4 &amp;&amp; b == 3 &amp;&amp; c)</span></span><br><span class="line">                            dp[a][b][c][d] = max(dp[a][b][c][d], newv);</span><br><span class="line">                            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot; d &quot;</span> &lt;&lt; d &lt;&lt; <span class="string">&quot; e &quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot; dp &quot;</span> &lt;&lt; dp[a][b][c][d] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// double maxv = 0.0;</span></span><br><span class="line">    <span class="comment">// int a = 13, b = 4;</span></span><br><span class="line">    <span class="comment">// int cc, dd;</span></span><br><span class="line">    <span class="comment">// // while (d &gt; 1)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for (int c = b; c &lt;= a; c++)</span></span><br><span class="line">    <span class="comment">//         for (int d = b - 1; d &lt;= a - 1 &amp;&amp; d &lt;= c - 1; d++)</span></span><br><span class="line">    <span class="comment">//             if (dp[a][b][c][d] &gt; maxv)</span></span><br><span class="line">    <span class="comment">//             &#123;</span></span><br><span class="line">    <span class="comment">//                 maxv = dp[a][b][c][d];</span></span><br><span class="line">    <span class="comment">//                 cc = c;</span></span><br><span class="line">    <span class="comment">//                 dd = d;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; &quot; cc &quot; &lt;&lt; cc &lt;&lt; &quot; dd &quot; &lt;&lt; dd &lt;&lt; &quot; dp &quot; &lt;&lt; maxv &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> maxv = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a = n, b = m, c = a;</span><br><span class="line">    <span class="keyword">int</span> dd = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (dd &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = c - <span class="number">1</span>; d &gt;= b - <span class="number">1</span>; d--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[a][b][c][d] &gt; maxv)</span><br><span class="line">            &#123;</span><br><span class="line">                maxv = dp[a][b][c][d];</span><br><span class="line">                dd = d;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; dd &quot;</span> &lt;&lt; dd &lt;&lt; <span class="string">&quot; dp &quot;</span> &lt;&lt; maxv &lt;&lt; <span class="string">&quot; a &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; c &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        a = dd;</span><br><span class="line">        c = a;</span><br><span class="line">        maxv = <span class="number">0.0</span>;</span><br><span class="line">        b--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>采用模拟退火进行加速运算</p><p><a href="https://www.bilibili.com/video/BV1hK41157JL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8">https://www.bilibili.com/video/BV1hK41157JL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8</a></p><p>b站教程不错</p><p>选用第三个例题《书店买书》的案例</p><p><a href="https://mp.weixin.qq.com/s/001Klrt7jjf8s5rI3py7Yg">https://mp.weixin.qq.com/s/001Klrt7jjf8s5rI3py7Yg</a></p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;close all; clc;</span><br><span class="line">points = [<span class="number">261.36</span>,<span class="number">345.333</span>,<span class="number">218.318</span>,<span class="number">196.886</span>,<span class="number">187.195</span>,<span class="number">187.387</span>,<span class="number">349.435</span>,<span class="number">262.478</span>,<span class="number">352.194</span>,<span class="number">186.59</span>,<span class="number">355.361</span>,<span class="number">358.033</span>,<span class="number">347.135</span>,<span class="number">179.794</span>,<span class="number">179.51</span>,<span class="number">178.597</span>,<span class="number">14.876</span>,<span class="number">172.61</span>,<span class="number">5.50809</span>,<span class="number">175.587</span>,<span class="number">158.055</span>,<span class="number">175.579</span>,<span class="number">18.0717</span>,<span class="number">18.0694</span>,<span class="number">167.389</span>,<span class="number">163.211</span>,<span class="number">98.636</span>,<span class="number">135.693</span>,<span class="number">10.1721</span>,<span class="number">131.4</span>,<span class="number">172.071</span>,<span class="number">152.177</span>,<span class="number">6.69029</span>,<span class="number">43.8872</span>,<span class="number">117.085</span>,<span class="number">72.1644</span>,<span class="number">168.928</span>,<span class="number">0.366764</span>,<span class="number">135.911</span>,<span class="number">94.3341</span>,<span class="number">29.6564</span>,<span class="number">158.157</span>,<span class="number">129.038</span>,<span class="number">35.8318</span>,<span class="number">65.4447</span>,<span class="number">60.8557</span>,<span class="number">52.6322</span>,<span class="number">150.143</span>,<span class="number">144.502</span>,<span class="number">44.7996</span>,<span class="number">117.286</span>,<span class="number">115.854</span>,<span class="number">133.016</span>,<span class="number">50.1732</span>,<span class="number">130.872</span>,<span class="number">78.2541</span>,<span class="number">92.0012</span>,<span class="number">59.5689</span>,<span class="number">91.4648</span>,<span class="number">91.6474</span>,<span class="number">91.4945</span>,<span class="number">78.2767</span>,<span class="number">64.2761</span>,<span class="number">130.576</span>,<span class="number">105.338</span>,<span class="number">112.139</span>,<span class="number">51.6668</span>,<span class="number">140.95</span>,<span class="number">98.267</span>,<span class="number">95.4699</span>,<span class="number">92.6435</span>,<span class="number">96.5942</span>,<span class="number">135.931</span>,<span class="number">94.7702</span>,<span class="number">114.749</span>,<span class="number">113.036</span>,<span class="number">102.779</span>,<span class="number">103.887</span>,<span class="number">106.395</span>,<span class="number">71.9267</span>,<span class="number">57.5453</span>,<span class="number">61.2187</span>,<span class="number">125.211</span>,<span class="number">60.8502</span>,<span class="number">110.887</span>,<span class="number">119.231</span>,<span class="number">112.454</span>,<span class="number">54.2793</span>,<span class="number">110.83</span>,<span class="number">105.955</span>,<span class="number">97.9926</span>,<span class="number">74.9688</span>,<span class="number">120.518</span>,<span class="number">102.988</span>,<span class="number">117.519</span>,<span class="number">93.22</span>,<span class="number">107.316</span>,<span class="number">103.157</span>,<span class="number">81.8369</span>,<span class="number">103.996</span>,<span class="number">103.994</span>,<span class="number">103.133</span>,<span class="number">119.554</span>,<span class="number">113.025</span>,<span class="number">108.66</span>,<span class="number">117.34</span>,<span class="number">92.8309</span>,<span class="number">111.149</span>,<span class="number">42.8763</span>,<span class="number">53.886</span>,<span class="number">62.5918</span>,<span class="number">76.2882</span>,<span class="number">75.3801</span>,<span class="number">100.752</span>,<span class="number">79.2899</span>,<span class="number">70.6052</span>,<span class="number">81.4649</span>,<span class="number">61.3945</span>,<span class="number">74.194</span>,<span class="number">69.2536</span>,<span class="number">63.5351</span>,<span class="number">58.963</span>,<span class="number">64.2205</span>,<span class="number">61.0484</span>,<span class="number">28.6315</span>,<span class="number">36.2729</span>,<span class="number">36.4375</span>,<span class="number">22.0025</span>,<span class="number">29.8624</span>,<span class="number">22.9935</span>,<span class="number">16.475</span>,<span class="number">13.928</span>,<span class="number">8.27138</span>,<span class="number">2.78788</span>,<span class="number">353.602</span>,<span class="number">352.709</span>,<span class="number">349.577</span>,<span class="number">342.741</span>,<span class="number">338.205</span>,<span class="number">337.806</span>,<span class="number">314.748</span>,<span class="number">325.078</span>,<span class="number">319.051</span>,<span class="number">327.003</span>,<span class="number">322.017</span>,<span class="number">303.285</span>,<span class="number">301.663</span>,<span class="number">340.939</span>,<span class="number">307.003</span>,<span class="number">300.783</span>,<span class="number">310.137</span>,<span class="number">299.254</span>,<span class="number">281.805</span>,<span class="number">334.071</span>,<span class="number">318.207</span>,<span class="number">269.96</span>,<span class="number">315.802</span>,<span class="number">291.564</span>,<span class="number">307.793</span>,<span class="number">273.792</span>,<span class="number">280.855</span>,<span class="number">336.666</span>,<span class="number">271.656</span>,<span class="number">268.879</span>,<span class="number">280.421</span>,<span class="number">260.389</span>,<span class="number">308.107</span>,<span class="number">249.547</span>,<span class="number">247.287</span>,<span class="number">300.084</span>,<span class="number">268.299</span>,<span class="number">270.919</span>,<span class="number">271.962</span>,<span class="number">305.234</span>,<span class="number">326.502</span>,<span class="number">291.083</span>,<span class="number">247.667</span>,<span class="number">299.381</span>,<span class="number">302.746</span>,<span class="number">284.357</span>,<span class="number">294.458</span>,<span class="number">328.324</span>,<span class="number">231.173</span>,<span class="number">338.978</span>,<span class="number">243.665</span>,<span class="number">233.148</span>,<span class="number">324.253</span>,<span class="number">256.191</span>,<span class="number">232.279</span>,<span class="number">216.426</span>,<span class="number">241.766</span>,<span class="number">272.257</span>,<span class="number">208.418</span>,<span class="number">247.348</span>,<span class="number">325.249</span>,<span class="number">237.343</span>,<span class="number">236.978</span>,<span class="number">314.613</span>,<span class="number">245.759</span>,<span class="number">203.524</span>,<span class="number">276.607</span>,<span class="number">200.523</span>,<span class="number">339.604</span>,<span class="number">265.049</span>,<span class="number">224.551</span>,<span class="number">218.172</span>,<span class="number">209.523</span>,<span class="number">302.305</span>,<span class="number">269.956</span>,<span class="number">245.845</span>,<span class="number">211.412</span>,<span class="number">227.112</span>,<span class="number">317.642</span>,<span class="number">353.915</span>];</span><br><span class="line"></span><br><span class="line">points = <span class="built_in">sort</span>(points);</span><br><span class="line"></span><br><span class="line">chose = int16([<span class="number">1</span> <span class="number">12</span> <span class="number">15</span> <span class="number">50</span> <span class="number">60</span> <span class="number">89</span> <span class="number">98</span> <span class="number">99</span> <span class="number">106</span> <span class="number">124</span> <span class="number">126</span> <span class="number">131</span> <span class="number">133</span> <span class="number">134</span> <span class="number">150</span> <span class="number">151</span> <span class="number">165</span> <span class="number">202</span> <span class="number">206</span> <span class="number">207</span>]);</span><br><span class="line">chose = <span class="built_in">sort</span>(chose);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter</span>(points,<span class="number">0</span>,<span class="string">&#x27;k.&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">for</span> s = chose</span><br><span class="line">    <span class="built_in">disp</span>(s);</span><br><span class="line">    <span class="built_in">scatter</span>(points(s), <span class="number">0</span>,<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>初始方案是：<br>[1 12 15 50 60 89 98 99 106 124 126 131 133 134 150 151 165 202 206 207]<br>此时最优值是：<br>   46.3648</p><p>最佳的方案是：<br>[7 15 21 28 42 53 60 78 96 105 109 118 127 137 150 166 176 190 203 214]<br>此时最优值是：<br>   93.4483</p><p>初始点：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230106151805242.png" alt="image-20230106151805242"></p><p>优化方案：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230106185939040.png" alt="image-20230106185939040"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 模拟退火解决书店买书问题  % 466</span></span><br><span class="line">clear all; clc; close all;</span><br><span class="line"><span class="comment">% tic</span></span><br><span class="line">load points;</span><br><span class="line">points = <span class="built_in">sort</span>(points);</span><br><span class="line">rng(<span class="string">&#x27;shuffle&#x27;</span>)  <span class="comment">% 控制随机数的生成，否则每次打开matlab得到的结果都一样</span></span><br><span class="line">len = <span class="number">20</span>;</span><br><span class="line">map = [<span class="number">1</span>:len,<span class="number">1</span>:len];</span><br><span class="line"><span class="comment">% 这个数据文件里面保存了两个矩阵：M是每本书在每家店的价格; freight表示每家店的运费</span></span><br><span class="line"><span class="comment">% [s, b] = size(M);  % s是书店的数量，b是要购买的书的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line">T0 = <span class="number">1000</span>;   <span class="comment">% 初始温度</span></span><br><span class="line">T = T0; <span class="comment">% 迭代中温度会发生改变，第一次迭代时温度就是T0</span></span><br><span class="line">maxgen = <span class="number">500</span>;  <span class="comment">% 最大迭代次数</span></span><br><span class="line">Lk = <span class="number">200</span>;  <span class="comment">% 每个温度下的迭代次数</span></span><br><span class="line">alfa = <span class="number">0.95</span>;  <span class="comment">% 温度衰减系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  随机生成一个初始解</span></span><br><span class="line">A = int32(<span class="number">1</span>:<span class="built_in">length</span>(points));</span><br><span class="line">random_num = A(randperm(<span class="built_in">numel</span>(A),len));</span><br><span class="line">index0 = <span class="built_in">sort</span>(random_num);</span><br><span class="line">h0 = Copy_of_totalH(points, index0, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">% way0 = randi([1, s],1,b); % 在1-s这些整数中随机抽取一个1*b的向量，表示这b本书分别在哪家书店购买</span></span><br><span class="line"><span class="comment">% money0 = calculate_money(way0,freight,M,b); % 调用我们自己写的calculate_money函数计算这个方案的花费</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;初始方案是：&#x27;</span>); <span class="built_in">disp</span>(mat2str(index0))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(h0)</span><br><span class="line"><span class="comment">%% 定义一些保存中间过程的量，方便输出结果和画图</span></span><br><span class="line">min_money = h0;     <span class="comment">% 初始化找到的最佳的解对应的花费为money0</span></span><br><span class="line">MONEY = <span class="built_in">zeros</span>(maxgen,<span class="number">1</span>); <span class="comment">% 记录每一次外层循环结束后找到的min_money (方便画图）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 模拟退火过程</span></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span> : maxgen  <span class="comment">% 外循环, 我这里采用的是指定最大迭代次数</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : Lk  <span class="comment">%  内循环，在每个温度下开始迭代</span></span><br><span class="line">        index = index0;</span><br><span class="line">        x_num = index(randperm(<span class="built_in">numel</span>(index),<span class="number">1</span>));</span><br><span class="line">        x = <span class="built_in">find</span>(index == x_num);</span><br><span class="line">   </span><br><span class="line">        delta = <span class="number">0</span>;</span><br><span class="line">        delta = delta ...</span><br><span class="line">            - <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(x<span class="number">-1</span>+len)))-points(index(map(x<span class="number">-2</span>+len))) + <span class="number">360</span>, <span class="number">360</span>), <span class="built_in">mod</span>( points( index(x)) - points(index(map(x<span class="number">-1</span>+len))) + <span class="number">360</span>, <span class="number">360</span>) )) ...</span><br><span class="line">            - <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(x)) - points(index(map(x<span class="number">-1</span>+len))) + <span class="number">360</span> , <span class="number">360</span>) , <span class="built_in">mod</span>( points(index(map(x+<span class="number">1</span>))) - points(index(x)) + <span class="number">360</span> , <span class="number">360</span> ) )) ...</span><br><span class="line">            - <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(x+<span class="number">1</span>))) - points(index(x)) + <span class="number">360</span> , <span class="number">360</span>), <span class="built_in">mod</span>(points(index(map(x+<span class="number">2</span>))) - points(index(map(x+<span class="number">1</span>))) + <span class="number">360</span>, <span class="number">360</span> ) )) ...</span><br><span class="line">            + <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(x<span class="number">-1</span>+len))) - points(index(map(x<span class="number">-2</span>+len))) + <span class="number">360</span>, <span class="number">360</span>), <span class="built_in">mod</span>(points(index(map(x+<span class="number">1</span>))) - points(index(map(x<span class="number">-1</span>+len))) + <span class="number">360</span>, <span class="number">360</span>) )) ...</span><br><span class="line">            + <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(x+<span class="number">2</span>))) - points(index(map(x+<span class="number">1</span>))) + <span class="number">360</span>, <span class="number">360</span>), <span class="built_in">mod</span>(points(index(map(x+<span class="number">1</span>))) - points(index(map(x<span class="number">-1</span>+len))) + <span class="number">360</span>, <span class="number">360</span>) ));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        shengxia = setxor(A, index);</span><br><span class="line">        y_num = shengxia(randperm(<span class="built_in">numel</span>(shengxia),<span class="number">1</span>));</span><br><span class="line">        index(x) = y_num;</span><br><span class="line">        index = <span class="built_in">sort</span>(index);</span><br><span class="line">        y = <span class="built_in">find</span>(index == y_num);</span><br><span class="line">        delta = delta ...</span><br><span class="line">            - <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(y<span class="number">-1</span>+len)))-points(index(map(y<span class="number">-2</span>+len))) + <span class="number">360</span>, <span class="number">360</span>), <span class="built_in">mod</span>( points( index(map(y+<span class="number">1</span>))) - points(index(map(y<span class="number">-1</span>+len))) + <span class="number">360</span>, <span class="number">360</span>) )) ...</span><br><span class="line">            - <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(y+<span class="number">1</span>))) - points(index(map(y<span class="number">-1</span>+len))) + <span class="number">360</span> , <span class="number">360</span>) , <span class="built_in">mod</span>( points(index(map(y+<span class="number">2</span>))) - points(index(map(y+<span class="number">1</span>))) + <span class="number">360</span> , <span class="number">360</span> ) )) ...</span><br><span class="line">            + <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(y<span class="number">-1</span> + len))) - points(index(map(y<span class="number">-2</span>+len))) + <span class="number">360</span> , <span class="number">360</span>), <span class="built_in">mod</span>(points(index(y)) - points(index(map(y<span class="number">-1</span> + len))) + <span class="number">360</span>, <span class="number">360</span> ) )) ...</span><br><span class="line">            + <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(y)) - points(index(map(y<span class="number">-1</span>+len))) + <span class="number">360</span>, <span class="number">360</span>), <span class="built_in">mod</span>(points(index(map(y+<span class="number">1</span>))) - points(index(y)) + <span class="number">360</span>, <span class="number">360</span>) )) ...</span><br><span class="line">            + <span class="built_in">log</span>(<span class="number">2</span>* <span class="built_in">min</span>( <span class="built_in">mod</span>(points(index(map(y+<span class="number">1</span>))) - points(index(y)) + <span class="number">360</span>, <span class="number">360</span>), <span class="built_in">mod</span>(points(index(map(y+<span class="number">2</span>))) - points(index(map(y+<span class="number">1</span>))) + <span class="number">360</span>, <span class="number">360</span>) ));</span><br><span class="line">        </span><br><span class="line">        index1 = index;  <span class="comment">% 调用我们自己写的gen_new_way函数生成新的方案</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> delta &gt; <span class="number">0</span>    <span class="comment">% 如果新方案的花费小于当前方案的花费</span></span><br><span class="line">            index0 = index1; <span class="comment">% 更新当前方案为新方案</span></span><br><span class="line">            h0 = h0 + delta;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="comment">%             p = exp(-(money1 - money0)/T); % 根据Metropolis准则计算一个概率</span></span><br><span class="line">            p = <span class="built_in">exp</span>(delta/T); <span class="comment">% 根据Metropolis准则计算一个概率</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>(<span class="number">1</span>) &lt; p   <span class="comment">% 生成一个随机数和这个概率比较，如果该随机数小于这个概率</span></span><br><span class="line">                index0 = index1; <span class="comment">% 更新当前方案为新方案</span></span><br><span class="line">                h0 = h0 + delta;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 判断是否要更新找到的最佳的解</span></span><br><span class="line">        <span class="keyword">if</span> h0 &gt; min_money  <span class="comment">% 如果当前解更好，则对其进行更新</span></span><br><span class="line">            min_money = h0;  <span class="comment">% 更新最大的花费</span></span><br><span class="line">            best_way = index1;  <span class="comment">% 更新找到的最佳方案</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MONEY(iter) = min_money; <span class="comment">% 保存本轮外循环结束后找到的最小花费</span></span><br><span class="line">    T = alfa*T;   <span class="comment">% 温度下降</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最佳的方案是：&#x27;</span>); <span class="built_in">disp</span>(mat2str(best_way))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(min_money)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画出每次迭代后找到的最佳方案的图形</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:maxgen,MONEY,<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;最小花费&#x27;</span>);</span><br><span class="line"><span class="comment">% toc</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230106185725474.png" alt="image-20230106185725474"></p><p>用py验证一下</p><p>改变一下distance的定义，由于要循环</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_h</span>(<span class="params">x, k=<span class="number">1</span>, norm=<span class="string">&#x27;max&#x27;</span>, min_dist=<span class="number">0.</span></span>):</span></span><br><span class="line">    n, d = x.shape</span><br><span class="line"></span><br><span class="line">    p = <span class="number">2</span></span><br><span class="line">    log_c_d = (d/<span class="number">2.</span>) * log(np.pi) - log(gamma(d/<span class="number">2.</span> + <span class="number">1</span>))</span><br><span class="line">    print(log_c_d)</span><br><span class="line"></span><br><span class="line">    kdtree = cKDTree(x)</span><br><span class="line"></span><br><span class="line">    distances, _ = kdtree.query(x, k + <span class="number">1</span>, eps=<span class="number">0</span>, p=p)</span><br><span class="line">    distances = distances[:, -<span class="number">1</span>]</span><br><span class="line">    distances[<span class="number">0</span>] = <span class="built_in">min</span>(x[<span class="number">1</span>] - x[<span class="number">0</span>], x[<span class="number">0</span>] + <span class="number">360</span> - x[-<span class="number">1</span>])</span><br><span class="line">    distances[-<span class="number">1</span>] = <span class="built_in">min</span>(x[-<span class="number">1</span>] - x[-<span class="number">2</span>], x[<span class="number">0</span>] + <span class="number">360</span> - x[-<span class="number">1</span>])</span><br><span class="line">    print(<span class="string">&quot;distance&quot;</span>, distances)</span><br><span class="line">    <span class="comment"># enforce non-zero distances</span></span><br><span class="line">    distances[distances &lt; min_dist] = min_dist</span><br><span class="line">    <span class="comment"># where did the 2 come from? radius -&gt; diameter</span></span><br><span class="line">    sum_log_dist = np.<span class="built_in">sum</span>(log(<span class="number">2</span>*distances))</span><br><span class="line">    h = sum_log_dist</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h</span><br></pre></td></tr></table></figure><p>初始方案是：<br>[26 27 36 38 52 64 69 77 86 102 132 149 150 154 156 157 173 187 199 201]<br>此时最优值是：<br>   26.7911</p><p>最佳的方案是：<br>[5 12 19 27 44 57 87 103 110 120 126 132 138 147 152 165 172 188 198 210]<br>此时最优值是：<br>   70.6790</p><p>历时 3.124118 秒。</p><p>迭代计算只需要计算那改变的6个点，试试直接计算h0 看时间会多慢</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%% 模拟退火解决书店买书问题  % 466</span></span><br><span class="line">clear all; clc; close all;</span><br><span class="line">tic</span><br><span class="line">load points;</span><br><span class="line">points = <span class="built_in">sort</span>(points);</span><br><span class="line">rng(<span class="string">&#x27;shuffle&#x27;</span>)  <span class="comment">% 控制随机数的生成，否则每次打开matlab得到的结果都一样</span></span><br><span class="line">len = <span class="number">20</span>;</span><br><span class="line">map = [<span class="number">1</span>:len,<span class="number">1</span>:len];</span><br><span class="line"><span class="comment">% 这个数据文件里面保存了两个矩阵：M是每本书在每家店的价格; freight表示每家店的运费</span></span><br><span class="line"><span class="comment">% [s, b] = size(M);  % s是书店的数量，b是要购买的书的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line">T0 = <span class="number">1000</span>;   <span class="comment">% 初始温度</span></span><br><span class="line">T = T0; <span class="comment">% 迭代中温度会发生改变，第一次迭代时温度就是T0</span></span><br><span class="line">maxgen = <span class="number">500</span>;  <span class="comment">% 最大迭代次数</span></span><br><span class="line">Lk = <span class="number">200</span>;  <span class="comment">% 每个温度下的迭代次数</span></span><br><span class="line">alfa = <span class="number">0.95</span>;  <span class="comment">% 温度衰减系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  随机生成一个初始解</span></span><br><span class="line">A = int32(<span class="number">1</span>:<span class="built_in">length</span>(points));</span><br><span class="line">random_num = A(randperm(<span class="built_in">numel</span>(A),len));</span><br><span class="line">index0 = <span class="built_in">sort</span>(random_num);</span><br><span class="line">h0 = Copy_of_totalH(points, index0, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">% way0 = randi([1, s],1,b); % 在1-s这些整数中随机抽取一个1*b的向量，表示这b本书分别在哪家书店购买</span></span><br><span class="line"><span class="comment">% money0 = calculate_money(way0,freight,M,b); % 调用我们自己写的calculate_money函数计算这个方案的花费</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;初始方案是：&#x27;</span>); <span class="built_in">disp</span>(mat2str(index0))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(h0)</span><br><span class="line"><span class="comment">%% 定义一些保存中间过程的量，方便输出结果和画图</span></span><br><span class="line">min_money = h0;     <span class="comment">% 初始化找到的最佳的解对应的花费为money0</span></span><br><span class="line">MONEY = <span class="built_in">zeros</span>(maxgen,<span class="number">1</span>); <span class="comment">% 记录每一次外层循环结束后找到的min_money (方便画图）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 模拟退火过程</span></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span> : maxgen  <span class="comment">% 外循环, 我这里采用的是指定最大迭代次数</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : Lk  <span class="comment">%  内循环，在每个温度下开始迭代</span></span><br><span class="line">        index = index0;</span><br><span class="line">        x_num = index(randperm(<span class="built_in">numel</span>(index),<span class="number">1</span>));</span><br><span class="line">        x = <span class="built_in">find</span>(index == x_num);</span><br><span class="line">        shengxia = setxor(A, index);</span><br><span class="line">        y_num = shengxia(randperm(<span class="built_in">numel</span>(shengxia),<span class="number">1</span>));</span><br><span class="line">        index(x) = y_num;</span><br><span class="line">        index = <span class="built_in">sort</span>(index);      </span><br><span class="line">        index1 = index;  <span class="comment">% 调用我们自己写的gen_new_way函数生成新的方案</span></span><br><span class="line"></span><br><span class="line">        h1 = Copy_of_totalH(points, index1, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> h1 &gt; h0    <span class="comment">% 如果新方案的花费小于当前方案的花费</span></span><br><span class="line">            index0 = index1; <span class="comment">% 更新当前方案为新方案</span></span><br><span class="line">            h0 = h1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line"><span class="comment">%             p = exp(-(money1 - money0)/T); % 根据Metropolis准则计算一个概率</span></span><br><span class="line">            p = <span class="built_in">exp</span>((h1 - h0)/T); <span class="comment">% 根据Metropolis准则计算一个概率</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>(<span class="number">1</span>) &lt; p   <span class="comment">% 生成一个随机数和这个概率比较，如果该随机数小于这个概率</span></span><br><span class="line">                index0 = index1; <span class="comment">% 更新当前方案为新方案</span></span><br><span class="line">                h0 = h1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 判断是否要更新找到的最佳的解</span></span><br><span class="line">        <span class="keyword">if</span> h0 &gt; min_money  <span class="comment">% 如果当前解更好，则对其进行更新</span></span><br><span class="line">            min_money = h0;  <span class="comment">% 更新最大的花费</span></span><br><span class="line">            best_way = index1;  <span class="comment">% 更新找到的最佳方案</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MONEY(iter) = min_money; <span class="comment">% 保存本轮外循环结束后找到的最小花费</span></span><br><span class="line">    T = alfa*T;   <span class="comment">% 温度下降</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最佳的方案是：&#x27;</span>); <span class="built_in">disp</span>(mat2str(best_way))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(min_money)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 画出每次迭代后找到的最佳方案的图形</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:maxgen,MONEY,<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;最小花费&#x27;</span>);</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>历时 3.305654 秒。</p><p>但耗时也不多</p><p>但增加迭代次数</p><p>maxgen = 1000;  % 最大迭代次数<br>Lk = 1000;  % 每个温度下的迭代次数</p><p>初始方案是：<br>[10 26 35 62 76 77 91 120 129 130 141 151 163 166 176 180 182 208 209 214]<br>此时最优值是：<br>   43.8157</p><p>最佳的方案是：<br>[10 17 23 40 53 67 90 105 110 120 126 131 138 148 153 166 172 188 200 214]<br>此时最优值是：<br>   70.7798</p><p><strong>历时 31.648947 秒。</strong></p><p>而只用6个点的数据</p><p><strong>历时 29.961089 秒。</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230106194131081.png" alt="image-20230106194131081"></p><p>708个点选50个点也只需要4s</p><p>初始方案是：<br>[7 32 33 83 98 103 106 113 139 152 161 164 171 201 220 229 235 257 280 298 299 319 332 349 352 355 360 365 373 393 401 407 434 450 455 470 479 506 508 531 540 548 565 566 589 603 640 679 689 707]<br>此时最优值是：<br>   73.5312</p><p>最佳的方案是：<br>[12 26 39 52 64 74 82 93 119 132 151 166 184 208 230 255 271 285 296 305 320 329 342 350 359 367 379 389 406 427 439 455 466 474 486 492 503 519 530 544 561 577 598 615 630 639 651 672 686 708]<br>此时最优值是：<br>  130.3724</p><p>历时 4.013932 秒。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20230106195352809.png" alt="image-20230106195352809"></p><p>绝对完美的20个点是怎么样的</p><p>K-L estimator: 71.67038</p><p>50个点则是</p><p>K-L estimator: 133.36141</p><hr><p>研究一下归一化</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冲毕业第五周记录</title>
      <link href="2022/12/19/blog69-study4/"/>
      <url>2022/12/19/blog69-study4/</url>
      
        <content type="html"><![CDATA[<p>接下来将由已经处理过的j2000转为视赤经赤纬，再转为地平坐标 J2000_x_hor。</p><p>设定时间为2022.12.10. 20：00，儒略日为2459924，经纬度为合肥{31.8642, 117.287}</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;C:\\Users\\hp\\Downloads\\hip2.dat\\J2000_2.csv&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;C:\\Users\\hp\\Downloads\\hip2.dat\\J2000_2_hor.csv&quot;</span>)</span></span>;</span><br><span class="line">    cat_entry fk5;</span><br><span class="line">    site_info loc = &#123;<span class="number">31.8642</span>, <span class="number">117.287</span>&#125;; <span class="comment">// 温度10摄氏度 高度10米 大气压1013毫巴=1013百帕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ra, dec, zd, az, hgmag;</span><br><span class="line">    <span class="built_in">string</span> lineStr;</span><br><span class="line">    <span class="keyword">double</span> tjd = <span class="number">2459924</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (getline(inFile, lineStr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(lineStr)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        fk5.starnumber = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        fk5.ra = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        fk5.dec = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        fk5.promora = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        fk5.promodec = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        fk5.parallax = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        hgmag = stod(str);</span><br><span class="line">        app_star(tjd, &amp;fk5, &amp;ra, &amp;dec);</span><br><span class="line">        <span class="comment">// outFile &lt;&lt; fk5.starnumber &lt;&lt; &quot;,&quot; &lt;&lt; ra &lt;&lt; &quot;,&quot; &lt;&lt; dec &lt;&lt; &quot;,&quot; &lt;&lt; hgmag &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line">        equ2hor(tjd, &amp;loc, ra, dec, &amp;zd, &amp;az);</span><br><span class="line">        outFile &lt;&lt; fk5.starnumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; az &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; <span class="number">90</span> - zd &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; hgmag &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算6.5等星也只需0.131s</p><p>2等星 46个星 当前时刻地平以上的有20个</p><p>3等星 165个星 当前时刻地平以上的有67个</p><p>4等星 480个星 当前时刻地平以上的有214个</p><p>5等星 1471个星 当前时刻地平以上的有708个</p><p>6等星 4559个星 当前时刻地平以上的有2219个</p><p>6.5等星 7982个星 当前时刻地平以上的有3933个</p><p>目前文件夹目录下有这些文件</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221213110004613.png" alt="image-20221213110004613"></p><hr><p>试试用qt显示</p><p>2等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212201307020.png" alt="image-20221212201307020"></p><p>3等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212201202828.png" alt="image-20221212201202828"></p><p>和下方对比 差不多</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212201154933.png" alt="image-20221212201154933"></p><p>4等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212201741568.png" alt="image-20221212201741568"></p><p>5等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212201732161.png" alt="image-20221212201732161"></p><p>画到五等星还算较快，后面就很慢了 可以尝试用qpen来画</p><p>6等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212201933313.png" alt="image-20221212201933313"></p><p>6.5等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221212202045109.png" alt="image-20221212202045109"></p><hr><p>研究半圆球上的基准点的均匀性问题。还是很难实现，并且没有玻尔兹曼熵来作为参考，并且需要从天顶出发实时计算高度方位，当我望远镜转至该位置时，其他星点已离开螺旋基准点 最终形成的星点方位高度可能不均匀。</p><p>还是决定使用全天球的螺旋基准点，并且所有恒星围绕极轴转是一个天然的性质。并且可以一次选取 终生可用 任意时间可用。（但这也是错的想法，并不适用于地平式望远镜选星，只适用于星敏感器的导航星筛选。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221213170528293.png" alt="image-20221213170528293"></p><p>将赤经赤纬坐标转为xyz轴</p><p>以右手坐标系为例，z轴指向北极点（高度角90度），x指向东（方位角90度），y指向北（方位角0度）</p><p>极坐标转xyz轴</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="built_in">sin</span>(ra) * <span class="built_in">sin</span>(dec);</span><br><span class="line"><span class="keyword">double</span> y = <span class="built_in">cos</span>(ra) * <span class="built_in">sin</span>(dec);</span><br><span class="line"><span class="keyword">double</span> z = <span class="built_in">cos</span>(dec);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> num = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> DEG2RAD = <span class="number">0.017453292519943296</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ra, dec, x, y, z;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;C:\\Users\\hp\\Desktop\\hip2.dat\\J2000_&quot;</span> + num + <span class="string">&quot;.csv&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;C:\\Users\\hp\\Desktop\\hip2.dat\\J2000_&quot;</span> + num + <span class="string">&quot;_xyz.csv&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> lineStr;</span><br><span class="line">    <span class="keyword">while</span> (getline(inFile, lineStr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(lineStr)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> str;</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="built_in">string</span> starnumber = str;</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">double</span> ra = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">double</span> dec = stod(str);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">double</span> hgmag = stod(str);</span><br><span class="line"></span><br><span class="line">        ra *= DEG2RAD;</span><br><span class="line">        dec *= DEG2RAD;</span><br><span class="line">        x = <span class="built_in">sin</span>(ra) * <span class="built_in">cos</span>(dec);</span><br><span class="line">        y = <span class="built_in">cos</span>(ra) * <span class="built_in">cos</span>(dec);</span><br><span class="line">        z = <span class="built_in">sin</span>(dec);</span><br><span class="line">        outFile &lt;&lt; starnumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; hgmag &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>测了一下正20面体的12个顶点的玻尔兹曼熵为0</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.850650808352040-0.5257311121191340</span><br><span class="line">0.8506508083520400.5257311121191340</span><br><span class="line">-0.8506508083520400.5257311121191340</span><br><span class="line">-0.850650808352040-0.5257311121191340</span><br><span class="line">00.850650808352040-0.525731112119134</span><br><span class="line">00.8506508083520400.525731112119134</span><br><span class="line">0-0.8506508083520400.525731112119134</span><br><span class="line">0-0.850650808352040-0.525731112119134</span><br><span class="line">-0.52573111211913400.850650808352040</span><br><span class="line">0.52573111211913400.850650808352040</span><br><span class="line">0.5257311121191340-0.850650808352040</span><br><span class="line">-0.5257311121191340-0.850650808352040</span><br></pre></td></tr></table></figure><p>再测个足球 <a href="https://blog.sciencenet.cn/blog-2321-383987.html">https://blog.sciencenet.cn/blog-2321-383987.html</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.850651,0,2.327438;</span><br><span class="line">.262866,.809017,2.327438;</span><br><span class="line">.262866,-.809017,2.327438;</span><br><span class="line">-.688191,.5,2.327438;</span><br><span class="line">-.688191,-.5,2.327438;</span><br><span class="line">1.701301,0,1.801708;</span><br><span class="line">.52573,1.618035,1.801708;</span><br><span class="line">.52573,-1.618035,1.801708;</span><br><span class="line">-1.376383,.999999,1.801708;</span><br><span class="line">-1.376383,-.999999,1.801708;</span><br><span class="line">1.964166,.809017,1.275977;</span><br><span class="line">1.964166,-.809017,1.275977;</span><br><span class="line">1.376381,1.618035,1.275977;</span><br><span class="line">1.376381,-1.618035,1.275977;</span><br><span class="line">-.162461,2.118035,1.275977;</span><br><span class="line">-.162461,-2.118035,1.275977;</span><br><span class="line">-1.113517,1.809017,1.275977;</span><br><span class="line">-1.113517,-1.809017,1.275977;</span><br><span class="line">-2.064574,.5,1.275977;</span><br><span class="line">-2.064574,-.5,1.275977;</span><br><span class="line">2.389492,.5,.425326;</span><br><span class="line">2.389492,-.5,.425326;</span><br><span class="line">1.213921,2.118035,.425326;</span><br><span class="line">1.213921,-2.118035,.425326;</span><br><span class="line">.262865,2.427051,.425326;</span><br><span class="line">.262865,-2.427051,.425326;</span><br><span class="line">-1.639248,1.809017,.425326;</span><br><span class="line">-1.639248,-1.809017,.425326;</span><br><span class="line">-2.227033,.999999,.425326;</span><br><span class="line">-2.227033,-.999999,.425326;</span><br><span class="line">2.227033,.999999,-.425326;</span><br><span class="line">2.227033,-.999999,-.425326;</span><br><span class="line">1.639248,1.809017,-.425326;</span><br><span class="line">1.639248,-1.809017,-.425326;</span><br><span class="line">-.262865,2.427051,-.425326;</span><br><span class="line">-.262865,-2.427051,-.425326;</span><br><span class="line">-1.213921,2.118035,-.425326;</span><br><span class="line">-1.213921,-2.118035,-.425326;</span><br><span class="line">-2.389492,.5,-.425326;</span><br><span class="line">-2.389492,-.5,-.425326;</span><br><span class="line">2.064574,.5,-1.275977;</span><br><span class="line">2.064574,-.5,-1.275977;</span><br><span class="line">1.113517,1.809017,-1.275977;</span><br><span class="line">1.113517,-1.809017,-1.275977;</span><br><span class="line">.162461,2.118035,-1.275977;</span><br><span class="line">.162461,-2.118035,-1.275977;</span><br><span class="line">-1.376381,1.618035,-1.275977;</span><br><span class="line">-1.376381,-1.618035,-1.275977;</span><br><span class="line">-1.964166,.809017,-1.275977;</span><br><span class="line">-1.964166,-.809017,-1.275977;</span><br><span class="line">1.376383,.999999,-1.801708;</span><br><span class="line">1.376383,-.999999,-1.801708;</span><br><span class="line">-.52573,1.618035,-1.801708;</span><br><span class="line">-.52573,-1.618035,-1.801708;</span><br><span class="line">-1.701301,0,-1.801708;</span><br><span class="line">.688191,.5,-2.327438;</span><br><span class="line">.688191,-.5,-2.327438;</span><br><span class="line">-.262866,.809017,-2.327438;</span><br><span class="line">-.262866,-.809017,-2.327438;</span><br><span class="line">-.850651,0,-2.327438</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221213231323743.png" alt="image-20221213231323743"></p><p>正四面体也同样</p><p><a href="http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere">http://web.archive.org/web/20120421191837/http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere</a> 中提到</p><p>均匀分布没有得到很好的定义。从最严格的意义上来说，只有五个柏拉图立体(以及在一个大圆上所有节点间距相等的退化排列的无限族)可以符合条件: 每个节点有相同数量的邻居，在相同的距离，相同的间距。</p><p>突然发现一个很大的问题，我不能使用该方法来寻找星点，因为这种均匀分布是星点之间的角距的均匀分布，在观测时高度越高观测点越少，在高度低的地方观测点较多，其实并不适用于机架的校正。机架的校正应该按照经纬度网格来均匀选取。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214161314056.png" alt="image-20221214161314056"></p><p>那么其实就可以将头顶的天区展开为一个矩形，方位和高度为边的矩形，研究在矩形上的二维均匀分布。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214161442139.png" alt="image-20221214161442139"></p><p>浅画一下二维的高度方位图（5等星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214164714085.png" alt="image-20221214164714085"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214174203207.png" alt="image-20221214174203207"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221214174257089.png" alt="image-20221214174257089"></p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冲毕业第四周记录</title>
      <link href="2022/12/10/blog68-study3/"/>
      <url>2022/12/10/blog68-study3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221210165212635.png" alt="image-20221210165212635"></p><p>很奇怪j2000不是一个固定的值吗（其实自己也不是很清楚</p><p>但Stellarium软件的J2000值在变</p><p>问了天文同学也不太清楚， 直接在Stellarium的github 讨论区问作者。</p><p>作者回答</p><p>Please do not use Stellarium as source or reference for own work. It has its own errors.</p><p>That said, to compare, set Stellarium to J1991.25 (to set proper motion自行), and observe the J2000 1月1日12时 儒略日 coordinates. At least disable aberration and probably even nutation章动. Or observe from the center of the Sun.</p><p>当我从设置观测点为太阳时，设置儒略日 <code>完美对上!</code></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221206205114703.png" alt="image-20221206205114703"></p><p>得到的J2000</p><p>与</p><p><a href="https://github.com/gmiller123456/hip2000">https://github.com/gmiller123456/hip2000</a></p><p>项目中 使用NOVAS（Naval Observatory Vector Astrometry Subroutines）库的transform_hip功能</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221206205154919.png" alt="image-20221206205154919"></p><p>一致</p><hr><p>hipparcos源文件中的北落师门 hip = 113368 </p><p>ra = 6.011119421 rad</p><p>ra = 344.411772972423023020 度 </p><p>ra = 22.960784864828202245 h</p><p>ra = h: 22 m: 57 s: 38.825513381528082846</p><p>dec = -29.621836820143990110</p><p>dec =  h: -29 m: 37 s: 18.612552518364395837</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI acos(-1);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ra = <span class="number">6.011119421</span>;</span><br><span class="line">    <span class="keyword">double</span> dec = <span class="number">-0.516998583</span>;</span><br><span class="line">    <span class="keyword">double</span> decd = dec * <span class="number">180</span> / PI;</span><br><span class="line">    <span class="keyword">double</span> rad = ra * <span class="number">180</span> / PI;</span><br><span class="line">    <span class="keyword">double</span> rah = rad / <span class="number">15</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">18</span>) &lt;&lt; rad &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; rah &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; h: &quot;</span> &lt;&lt; (<span class="keyword">int</span>)rah &lt;&lt; <span class="string">&quot; m: &quot;</span> &lt;&lt; <span class="keyword">int</span>((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span>) &lt;&lt; <span class="string">&quot; s: &quot;</span> &lt;&lt; <span class="number">60</span> * ((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span> - <span class="keyword">int</span>((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; decd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; h: &quot;</span> &lt;&lt; (<span class="keyword">int</span>)decd &lt;&lt; <span class="string">&quot; m: &quot;</span> &lt;&lt; <span class="built_in">abs</span>(<span class="keyword">int</span>((decd - <span class="keyword">int</span>(decd)) * <span class="number">60</span>)) &lt;&lt; <span class="string">&quot; s: &quot;</span> &lt;&lt; <span class="built_in">abs</span>(<span class="number">60</span> * ((decd - <span class="keyword">int</span>(decd)) * <span class="number">60</span> - <span class="keyword">int</span>((decd - <span class="keyword">int</span>(decd)) * <span class="number">60</span>))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>研究一下novas库如何实现将j1991.25到J2000的</p><p><a href="https://github.com/brandon-rhodes/python-novas">https://github.com/brandon-rhodes/python-novas</a></p><p>看说明先装novas库，可惜不能支持windows</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221206215016569.png" alt="image-20221206215016569"></p><p>这是已易于使用的Hipparcos目录的更改版本。原始目录具有1991.25的Equinox的RA/DEC坐标。在这里，我使用NOVA函数“ transform_hip”将坐标转换为J2000。</p><hr><p>在海军天文台novas.c中有一个函数transform_hip，作用是将 依巴谷原始星表中的J1991.25纪元的数据转换为FK5形式的数据，专用于依巴谷星表，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/********transform_hip */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform_hip</span> <span class="params">(cat_entry *hipparcos, cat_entry *fk5)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">------------------------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">   PURPOSE:</span></span></span><br><span class="line"><span class="function"><span class="comment">      To convert Hipparcos data at epoch J1991.25 to epoch J2000.0 and</span></span></span><br><span class="line"><span class="function"><span class="comment">      FK5-style units.  To be used only for Hipparcos or Tycho stars </span></span></span><br><span class="line"><span class="function"><span class="comment">      with linear space motion.</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">   INPUT</span></span></span><br><span class="line"><span class="function"><span class="comment">   ARGUMENTS:</span></span></span><br><span class="line"><span class="function"><span class="comment">      *hipparcos (struct cat_entry)</span></span></span><br><span class="line"><span class="function"><span class="comment">         An entry from the Hipparcos catalog, at epoch J1991.25, with </span></span></span><br><span class="line"><span class="function"><span class="comment">         all members having Hipparcos catalog units.  See Note 1</span></span></span><br><span class="line"><span class="function"><span class="comment">         below (struct defined in novas.h).</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">   OUTPUT</span></span></span><br><span class="line"><span class="function"><span class="comment">   ARGUMENTS:</span></span></span><br><span class="line"><span class="function"><span class="comment">      *fk5 (struct cat_entry)</span></span></span><br><span class="line"><span class="function"><span class="comment">         The transformed input entry, at epoch J2000.0, with all </span></span></span><br><span class="line"><span class="function"><span class="comment">         members having FK5 catalog units.  See Note 2 below (struct </span></span></span><br><span class="line"><span class="function"><span class="comment">         defined in novas.h).</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">   NOTES:</span></span></span><br><span class="line"><span class="function"><span class="comment">      1. Hipparcos epoch and units:</span></span></span><br><span class="line"><span class="function"><span class="comment">         Epoch: J1991.25</span></span></span><br><span class="line"><span class="function"><span class="comment">         Right ascension (RA): degrees</span></span></span><br><span class="line"><span class="function"><span class="comment">         Declination (Dec): degrees</span></span></span><br><span class="line"><span class="function"><span class="comment">         Proper motion in RA * cos (Dec): milliarcseconds per year</span></span></span><br><span class="line"><span class="function"><span class="comment">         Proper motion in Dec: milliarcseconds per year</span></span></span><br><span class="line"><span class="function"><span class="comment">         Parallax: milliarcseconds</span></span></span><br><span class="line"><span class="function"><span class="comment">         Radial velocity: kilometers per second (not in catalog)</span></span></span><br><span class="line"><span class="function"><span class="comment">      2. FK5 epoch and units:</span></span></span><br><span class="line"><span class="function"><span class="comment">         Epoch: J2000.0</span></span></span><br><span class="line"><span class="function"><span class="comment">         Right ascension: hours</span></span></span><br><span class="line"><span class="function"><span class="comment">         Declination: degrees</span></span></span><br><span class="line"><span class="function"><span class="comment">         Proper motion in RA: seconds of time per Julian century</span></span></span><br><span class="line"><span class="function"><span class="comment">         Proper motion in Dec: arcseconds per Julian century</span></span></span><br><span class="line"><span class="function"><span class="comment">         Parallax: arcseconds</span></span></span><br><span class="line"><span class="function"><span class="comment">         Radial velocity: kilometers per second</span></span></span><br><span class="line"><span class="function"><span class="comment">      3. This function based on subroutine &#x27;gethip&#x27; from NOVAS Fortran.</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">------------------------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="comment">*/</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">double</span> epoch_hip = <span class="number">2448349.0625</span>;</span><br><span class="line">   <span class="keyword">double</span> epoch_fk5 = <span class="number">2451545.0000</span>;</span><br><span class="line"></span><br><span class="line">   cat_entry scratch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   The &quot;scratch&quot; catalog entry contains data with FK5-like units at </span></span><br><span class="line"><span class="comment">   epoch J1991.25.  Copy the catalog entry quantities that don&#x27;t </span></span><br><span class="line"><span class="comment">   change from the Hipparcos catalog entry to the &quot;scratch&quot; entry.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span> (scratch.starname, hipparcos-&gt;starname);</span><br><span class="line">   scratch.starnumber = hipparcos-&gt;starnumber;</span><br><span class="line">   scratch.dec = hipparcos-&gt;dec;</span><br><span class="line">   scratch.radialvelocity = hipparcos-&gt;radialvelocity;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">strcpy</span> (scratch.catalog, <span class="string">&quot;SCR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Convert Hipparcos units to FK5-like units; insert transformed</span></span><br><span class="line"><span class="comment">   quantities into the &quot;scratch&quot; catalog entry.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">   scratch.ra = hipparcos-&gt;ra / <span class="number">15.0</span>;</span><br><span class="line">   scratch.promora = hipparcos-&gt;promora / (<span class="number">150.0</span> * </span><br><span class="line">      <span class="built_in">cos</span> (hipparcos-&gt;dec * DEG2RAD));</span><br><span class="line">   scratch.promodec = hipparcos-&gt;promodec / <span class="number">10.0</span>;</span><br><span class="line">   scratch.parallax = hipparcos-&gt;parallax / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Change the epoch of the Hipparcos data from J1991.25 to J2000.0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">   transform_cat (<span class="number">1</span>,epoch_hip,&amp;scratch,epoch_fk5,<span class="string">&quot;FK5&quot;</span>, fk5);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user guide中写道：Radial velocity (hipparcos-&gt;radialvelocity) is not given in the Hipparcos catalog. If a value is not known, set hipparcos-&gt;radialvelocity = 0.0. The radial velocity is important for only a small number of nearby, high proper motion stars.</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221207150407348.png" alt="image-20221207150407348"></p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> TWOPI = <span class="number">6.28318530717958647692</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> DEG2RAD = <span class="number">0.017453292519943296</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> RAD2DEG = <span class="number">57.295779513082321</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> RAD2SEC = <span class="number">206264.806247096355</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epoch_hip = <span class="number">2448349.0625</span>; <span class="comment">// J1991.25</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epoch_fk5 = <span class="number">2451545.0000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ARGUMENTS:</span></span><br><span class="line"><span class="comment">    in :</span></span><br><span class="line"><span class="comment">        hip_ra (rad)</span></span><br><span class="line"><span class="comment">        hip_dec (rad)</span></span><br><span class="line"><span class="comment">        hip_promora (mas/yr)</span></span><br><span class="line"><span class="comment">        hip_promodec (mas/yr)</span></span><br><span class="line"><span class="comment">        hip_parallax (mas)</span></span><br><span class="line"><span class="comment">    out :</span></span><br><span class="line"><span class="comment">        fk5_ra(h)</span></span><br><span class="line"><span class="comment">        fk5_dec(degree)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(<span class="keyword">double</span> hip_ra, <span class="keyword">double</span> hip_dec, <span class="keyword">double</span> hip_promora, <span class="keyword">double</span> hip_promodec, <span class="keyword">double</span> hip_parallax, <span class="keyword">double</span> &amp;fk5_ra, <span class="keyword">double</span> &amp;fk5_dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hip_ra = hip_ra * RAD2DEG / <span class="number">15.0</span>;</span><br><span class="line">    hip_promora = hip_promora / (<span class="number">150.0</span> * <span class="built_in">cos</span>(hip_dec));</span><br><span class="line">    hip_dec *= RAD2DEG;</span><br><span class="line">    hip_promodec /= <span class="number">10.0</span>;</span><br><span class="line">    hip_parallax /= <span class="number">1000.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (hip_parallax &lt;= <span class="number">0.0</span>)</span><br><span class="line">        hip_parallax = <span class="number">1.0e-7</span>;</span><br><span class="line">    <span class="keyword">double</span> dist = RAD2SEC / hip_parallax;</span><br><span class="line">    <span class="keyword">double</span> r = hip_ra * <span class="number">54000.0</span> / RAD2SEC;</span><br><span class="line">    <span class="keyword">double</span> d = hip_dec * <span class="number">3600.0</span> / RAD2SEC;</span><br><span class="line">    <span class="keyword">double</span> cra, sra, cdc, sdc, pos1[<span class="number">3</span>], term1, pmr, pmd, vel1[<span class="number">3</span>], pos2[<span class="number">3</span>], xyproj;</span><br><span class="line">    cra = <span class="built_in">cos</span>(r);</span><br><span class="line">    sra = <span class="built_in">sin</span>(r);</span><br><span class="line">    cdc = <span class="built_in">cos</span>(d);</span><br><span class="line">    sdc = <span class="built_in">sin</span>(d);</span><br><span class="line">    pos1[<span class="number">0</span>] = dist * cdc * cra;</span><br><span class="line">    pos1[<span class="number">1</span>] = dist * cdc * sra;</span><br><span class="line">    pos1[<span class="number">2</span>] = dist * sdc;</span><br><span class="line">    term1 = hip_parallax * <span class="number">36525.0</span>;</span><br><span class="line">    pmr = hip_promora * <span class="number">15.0</span> * cdc / term1;</span><br><span class="line">    pmd = hip_promodec / term1;</span><br><span class="line">    vel1[<span class="number">0</span>] = -pmr * sra - pmd * sdc * cra;</span><br><span class="line">    vel1[<span class="number">1</span>] = pmr * cra - pmd * sdc * sra;</span><br><span class="line">    vel1[<span class="number">2</span>] = pmd * cdc;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos2[j] = pos1[j] + vel1[j] * (epoch_fk5 - epoch_hip);</span><br><span class="line">    &#125;</span><br><span class="line">    xyproj = <span class="built_in">sqrt</span>(pos2[<span class="number">0</span>] * pos2[<span class="number">0</span>] + pos2[<span class="number">1</span>] * pos2[<span class="number">1</span>]);</span><br><span class="line">    r = <span class="built_in">atan2</span>(pos2[<span class="number">1</span>], pos2[<span class="number">0</span>]);</span><br><span class="line">    d = <span class="built_in">atan2</span>(pos2[<span class="number">2</span>], xyproj);</span><br><span class="line">    fk5_ra = r * RAD2SEC / <span class="number">54000.0</span>;</span><br><span class="line">    fk5_dec = d * RAD2SEC / <span class="number">3600.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (fk5_ra &lt; <span class="number">0.0</span>)</span><br><span class="line">        fk5_ra += <span class="number">24.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> hip_ra = <span class="number">6.011119421</span>;</span><br><span class="line">    <span class="keyword">double</span> hip_dec = <span class="number">-0.516998583</span>;</span><br><span class="line">    <span class="keyword">double</span> hip_promora = <span class="number">328.95</span>;</span><br><span class="line">    <span class="keyword">double</span> hip_promodec = <span class="number">-164.67</span>;</span><br><span class="line">    <span class="keyword">double</span> hip_parallax = <span class="number">129.81</span>;</span><br><span class="line">    <span class="keyword">double</span> fk5_ra, fk5_dec;</span><br><span class="line"></span><br><span class="line">    convert(hip_ra, hip_dec, hip_promora, hip_promodec, hip_parallax, fk5_ra, fk5_dec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> rah = fk5_ra;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; ra: &quot;</span> &lt;&lt; fk5_ra;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; rah: &quot;</span> &lt;&lt; <span class="keyword">int</span>(rah) &lt;&lt; <span class="string">&quot; ram: &quot;</span> &lt;&lt; <span class="keyword">int</span>((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span>) &lt;&lt; <span class="string">&quot; ras: &quot;</span> &lt;&lt; <span class="number">60</span> * ((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span> - <span class="keyword">int</span>((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fk5_dec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">double</span> dech = fk5_dec;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; dech &quot;</span> &lt;&lt; <span class="keyword">int</span>(dech) &lt;&lt; <span class="string">&quot; ram: &quot;</span> &lt;&lt; <span class="keyword">int</span>((dech - <span class="keyword">int</span>(dech)) * <span class="number">60</span>) &lt;&lt; <span class="string">&quot; ras: &quot;</span> &lt;&lt; <span class="number">60</span> * ((dech - <span class="keyword">int</span>(dech)) * <span class="number">60</span> - <span class="keyword">int</span>((dech - <span class="keyword">int</span>(dech)) * <span class="number">60</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>研究一下j2000转 <code>视赤道坐标</code> 的转换</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">app_star</span> <span class="params">(<span class="keyword">double</span> tjd, body *earth, cat_entry *star, <span class="keyword">double</span> *ra, <span class="keyword">double</span> *dec)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*   PURPOSE:</span></span></span><br><span class="line"><span class="function"><span class="comment">      Computes the apparent place of a star at date &#x27;tjd&#x27;, given its mean place, proper motion, parallax, and radial velocity for J2000.0.</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">get_earth</span> <span class="params">(<span class="keyword">double</span> tjd, body *earth,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">double</span> *tdb,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">double</span> *bary_earthp, <span class="keyword">double</span> *bary_earthv,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">double</span> *helio_earthp, <span class="keyword">double</span> *helio_earthv)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//  Obtains the barycentric &amp; heliocentric positions and velocities of the Earth from the solar system ephemeris. 从太阳系星历表中获取地球的重心和日心位置和速度。</span></span></span><br></pre></td></tr></table></figure><p>在novas第一个函数中</p><p>TDB：质心力学时 和 tjd：在novas中就是儒略日；</p><p>TT：Terrestrial Time (TT) 地球时</p><p>TDT：Terrestrial Dynamical Time </p><p>UTC：协调世界时</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221207192519170.png" alt="image-20221207192519170"></p><p>Barycentric动力学时间（TDB，来自法国温度动态Barycentrique）是一个相对论坐标时间尺度，旨在在计算轨道，小型小行星，彗星和彗星和彗星和彗星和彗星，彗星和彗星，彗星和彗星，彗星和彗星，彗星和彗星，彗星和天文学的轨道和天文学时，供天文使用作为时间标准[1]太阳系中的星际航天器。</p><hr><p>c++时间转换</p><p>得到UTC时间 <a href="https://www.runoob.com/cplusplus/cpp-date-time.html">https://www.runoob.com/cplusplus/cpp-date-time.html</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> now = time(<span class="number">0</span>);</span><br><span class="line">tm *utc = gmtime(&amp;now);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>) &lt;&lt; julian_date(<span class="number">1900</span> + utc-&gt;tm_year, <span class="number">1</span> + utc-&gt;tm_mon, utc-&gt;tm_mday, utc-&gt;tm_hour + utc-&gt;tm_min / <span class="number">60.0</span> + utc-&gt;tm_sec / <span class="number">3600.0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算儒略日</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">julian_date</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> year, <span class="keyword">short</span> <span class="keyword">int</span> month, <span class="keyword">short</span> <span class="keyword">int</span> day, <span class="keyword">double</span> hour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> jd12h = (<span class="keyword">long</span>)day - <span class="number">32075L</span> + <span class="number">1461L</span> * ((<span class="keyword">long</span>)year + <span class="number">4800L</span> + ((<span class="keyword">long</span>)month - <span class="number">14L</span>) / <span class="number">12L</span>) / <span class="number">4L</span> + <span class="number">367L</span> * ((<span class="keyword">long</span>)month - <span class="number">2L</span> - ((<span class="keyword">long</span>)month - <span class="number">14L</span>) / <span class="number">12L</span> * <span class="number">12L</span>) / <span class="number">12L</span> - <span class="number">3L</span> * (((<span class="keyword">long</span>)year + <span class="number">4900L</span> + ((<span class="keyword">long</span>)month - <span class="number">14L</span>) / <span class="number">12L</span>) / <span class="number">100L</span>) / <span class="number">4L</span>;</span><br><span class="line">    <span class="keyword">double</span> tjd = (<span class="keyword">double</span>)jd12h - <span class="number">0.5</span> + hour / <span class="number">24.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (tjd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><a href="https://en.wikipedia.org/wiki/%CE%94T_(timekeeping">https://en.wikipedia.org/wiki/%CE%94T_(timekeeping</a>)</p><p>为了求 The difference between terrestrial dynamical time system 1 time, and universal time.</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221208114456687.png" alt="image-20221208114456687"></p><p>设置为deltat = 67.</p><p>但事实上该值设置完之后反而和软件中的值不一致，因此设为0；</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221208202842675.png" alt="image-20221208202842675"></p><p>方位角和两个软件误差2’’和0.2’’，高度角相差7’’和0.8’’ ，非常准，验证成功！</p><p>关键函数讲解</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equ2hor</span><span class="params">(<span class="keyword">double</span> tjd, <span class="keyword">double</span> deltat, <span class="keyword">double</span> x, <span class="keyword">double</span> y, site_info *location, <span class="keyword">double</span> ra, <span class="keyword">double</span> dec, <span class="keyword">short</span> <span class="keyword">int</span> ref_option, <span class="keyword">double</span> *zd, <span class="keyword">double</span> *az, <span class="keyword">double</span> *rar, <span class="keyword">double</span> *decr)</span></span></span><br><span class="line"><span class="function"><span class="comment">// tjd 为儒略日</span></span></span><br><span class="line"><span class="function"><span class="comment">// deltat应该为 TT (or TDT)-UT1 大约70  但设置了值之后反而和软件中的值不一样 故设为0</span></span></span><br><span class="line"><span class="function"><span class="comment">// x y 设为0</span></span></span><br><span class="line"><span class="function"><span class="comment">// site_info loc = &#123;32.08, 118.8, 10, 10, 1013&#125;; 温度和高度都设为10，压强毫巴和百帕一致</span></span></span><br><span class="line"><span class="function"><span class="comment">// ref_option设为0 no refraction 不考虑蒙气差</span></span></span><br><span class="line"><span class="function"><span class="comment">// </span></span></span><br></pre></td></tr></table></figure><hr><p>现在研究一下从hipparcos星表 根据星等 处理为J1991.25</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">user_cols = [<span class="string">&#x27;hip&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;ra&#x27;</span>, <span class="string">&#x27;dec&#x27;</span>, <span class="string">&#x27;plx&#x27;</span>, <span class="string">&#x27;pmra&#x27;</span>, <span class="string">&#x27;pmdec&#x27;</span>, <span class="string">&#x27;era&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;ede&#x27;</span>, <span class="string">&#x27;eplx&#x27;</span>, <span class="string">&#x27;epmra&#x27;</span>, <span class="string">&#x27;epmde&#x27;</span>, <span class="string">&#x27;ntr&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;var&#x27;</span>, <span class="string">&#x27;ic&#x27;</span>, <span class="string">&#x27;hpmag&#x27;</span>]</span><br><span class="line">mag = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6.5</span>]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> mag:</span><br><span class="line">    df = pd.read_table(<span class="string">&quot;hip2.dat&quot;</span>, sep=<span class="string">&#x27;\s+&#x27;</span>, header=<span class="literal">None</span>,</span><br><span class="line">                       engine=<span class="string">&#x27;python&#x27;</span>, index_col=<span class="number">0</span>, usecols=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">20</span>)), names=user_cols)</span><br><span class="line"></span><br><span class="line">    df1 = df[df[<span class="string">&#x27;hpmag&#x27;</span>] &lt;= m]</span><br><span class="line"></span><br><span class="line">    tmp = df1[<span class="string">&#x27;ra&#x27;</span>] * <span class="number">180</span> / math.pi</span><br><span class="line">    df1.insert(df1.shape[<span class="number">1</span>], <span class="string">&#x27;ra_d&#x27;</span>, tmp)</span><br><span class="line"></span><br><span class="line">    tmp = df1[<span class="string">&#x27;dec&#x27;</span>] * <span class="number">180</span> / math.pi</span><br><span class="line">    df1.insert(df1.shape[<span class="number">1</span>], <span class="string">&#x27;dec_d&#x27;</span>, tmp)</span><br><span class="line">    newdf = df1[[<span class="string">&#x27;ra_d&#x27;</span>, <span class="string">&#x27;dec_d&#x27;</span>, <span class="string">&#x27;pmra&#x27;</span>, <span class="string">&#x27;pmdec&#x27;</span>, <span class="string">&#x27;plx&#x27;</span>, <span class="string">&#x27;hpmag&#x27;</span>]]</span><br><span class="line">    newdf.to_csv(<span class="string">&#x27;J1991_25_&#x27;</span>+<span class="built_in">str</span>(m)+<span class="string">&#x27;.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221209181128304.png" alt="image-20221209181128304"></p><p>单位分别为：hip、度、度、mas/year、mas/year、mas、星等</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221209181146712.png" alt="image-20221209181146712"></p><p>hip_main.dat文件中有118322个星</p><p>有两种星表</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221209162226229.png" alt="image-20221209162226229"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">user_cols = [<span class="string">&#x27;hip&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>,  <span class="string">&#x27;a5&#x27;</span>,   <span class="string">&#x27;ra&#x27;</span>, <span class="string">&#x27;a6&#x27;</span>]</span><br><span class="line">df = pd.read_table(<span class="string">&quot;hip_main.dat&quot;</span>, delimiter=<span class="string">&#x27;|&#x27;</span>, header=<span class="literal">None</span>,usecols=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">7</span>)),names=user_cols)</span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;ra&quot;</span>] = [<span class="built_in">float</span>(<span class="built_in">str</span>(i).replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;0&quot;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> df[<span class="string">&quot;ra&quot;</span>]]</span><br><span class="line">df[<span class="string">&#x27;ra&#x27;</span>].astype(<span class="built_in">float</span>)</span><br><span class="line"></span><br><span class="line">df1 = df[df[<span class="string">&#x27;ra&#x27;</span>] &lt;= <span class="number">6.5</span>]</span><br></pre></td></tr></table></figure><p>针对的是Magnitude in Johnson V 而hip2只有Hpmag  Hipparcos magnitude</p><p>前为hip1  后为hip2</p><p>&lt;= 6.5 有8875个星  7982</p><p>&lt; 6.5  8790个星  7982</p><p>&lt;= 6.0 5045个星    4559</p><p>&lt; 6.0 4996个星   4559</p><p>&lt;= 5.0 1628个星  1471</p><p>&lt; 5.0 1609个星  1471</p><p>&lt;= 4.0 520个星  480</p><p>&lt; 4.0 517个星   480 </p><p>&lt;= 3.0 178个星  165</p><p>&lt; 3.0 173个星   165</p><p>&lt;= 2.0 50个星  46 </p><p>&lt; 2.0 50个星   46 </p><p>&lt;= 1.0 16个星  15</p><p>&lt; 1.0 16个星  15</p><p>一是  <a href="https://heasarc.gsfc.nasa.gov/W3Browse/all/hipparcos.html">https://heasarc.gsfc.nasa.gov/W3Browse/all/hipparcos.html</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221209162308287.png" alt="image-20221209162308287"></p><p>二是 <a href="http://vizier.cds.unistra.fr/viz-bin/VizieR-3?-source=I/311/hip2">http://vizier.cds.unistra.fr/viz-bin/VizieR-3?-source=I/311/hip2</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221209162337713.png" alt="image-20221209162337713"></p><p>2007年发布了由Hipparcos任务产生的天文数据的新降低，声称几乎全明星的精度比HP = 8的幅度更明亮，要比原始目录中的幅度更好，最高为4。该目录被称为Hipparcos-2目录。</p><hr><p>J1991.25 转 J2000</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221210161025540.png" alt="image-20221210161025540"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221210161117925.png" alt="image-20221210161117925"></p><p>经过验证 没问题，</p><p>除了6种星等 只需要0.2s</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BARYC 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELIOC 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> KMAU = <span class="number">1.49597870e+8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> TWOPI = <span class="number">6.28318530717958647692</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> RAD2SEC = <span class="number">206264.806247096355</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> DEG2RAD = <span class="number">0.017453292519943296</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epoch_hip = <span class="number">2448349.0625</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epoch_fk5 = <span class="number">2451545.0000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> starnumber;</span><br><span class="line">    <span class="keyword">double</span> ra;</span><br><span class="line">    <span class="keyword">double</span> dec;</span><br><span class="line">    <span class="keyword">double</span> promora;</span><br><span class="line">    <span class="keyword">double</span> promodec;</span><br><span class="line">    <span class="keyword">double</span> parallax;</span><br><span class="line">    <span class="keyword">double</span> radialvelocity = <span class="number">0</span>;</span><br><span class="line">&#125; cat_entry;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform_cat</span><span class="params">(cat_entry *incat, cat_entry *newcat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> paralx, dist, r, d, cra, sra, cdc, sdc, pos1[<span class="number">3</span>], term1, pmr, pmd, rvl, vel1[<span class="number">3</span>], pos2[<span class="number">3</span>], vel2[<span class="number">3</span>], xyproj;</span><br><span class="line"></span><br><span class="line">    paralx = incat-&gt;parallax;</span><br><span class="line">    <span class="keyword">if</span> (paralx &lt;= <span class="number">0.0</span>)</span><br><span class="line">        paralx = <span class="number">1.0e-7</span>;</span><br><span class="line"></span><br><span class="line">    dist = RAD2SEC / paralx;</span><br><span class="line">    r = incat-&gt;ra * <span class="number">54000.0</span> / RAD2SEC;</span><br><span class="line">    d = incat-&gt;dec * <span class="number">3600.0</span> / RAD2SEC;</span><br><span class="line">    cra = <span class="built_in">cos</span>(r);</span><br><span class="line">    sra = <span class="built_in">sin</span>(r);</span><br><span class="line">    cdc = <span class="built_in">cos</span>(d);</span><br><span class="line">    sdc = <span class="built_in">sin</span>(d);</span><br><span class="line">    pos1[<span class="number">0</span>] = dist * cdc * cra;</span><br><span class="line">    pos1[<span class="number">1</span>] = dist * cdc * sra;</span><br><span class="line">    pos1[<span class="number">2</span>] = dist * sdc;</span><br><span class="line"></span><br><span class="line">    term1 = paralx * <span class="number">36525.0</span>;</span><br><span class="line">    pmr = incat-&gt;promora * <span class="number">15.0</span> * cdc / term1;</span><br><span class="line">    pmd = incat-&gt;promodec / term1;</span><br><span class="line"></span><br><span class="line">    vel1[<span class="number">0</span>] = -pmr * sra - pmd * sdc * cra;</span><br><span class="line">    vel1[<span class="number">1</span>] = pmr * cra - pmd * sdc * sra;</span><br><span class="line">    vel1[<span class="number">2</span>] = pmd * cdc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos2[j] = pos1[j] + vel1[j] * (epoch_fk5 - epoch_hip);</span><br><span class="line">        vel2[j] = vel1[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xyproj = <span class="built_in">sqrt</span>(pos2[<span class="number">0</span>] * pos2[<span class="number">0</span>] + pos2[<span class="number">1</span>] * pos2[<span class="number">1</span>]);</span><br><span class="line">    r = <span class="built_in">atan2</span>(pos2[<span class="number">1</span>], pos2[<span class="number">0</span>]);</span><br><span class="line">    d = <span class="built_in">atan2</span>(pos2[<span class="number">2</span>], xyproj);</span><br><span class="line">    newcat-&gt;ra = r * RAD2SEC / <span class="number">54000.0</span>;</span><br><span class="line">    newcat-&gt;dec = d * RAD2SEC / <span class="number">3600.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (newcat-&gt;ra &lt; <span class="number">0.0</span>)</span><br><span class="line">        newcat-&gt;ra += <span class="number">24.0</span>;</span><br><span class="line"></span><br><span class="line">    dist = <span class="built_in">sqrt</span>(pos2[<span class="number">0</span>] * pos2[<span class="number">0</span>] + pos2[<span class="number">1</span>] * pos2[<span class="number">1</span>] +</span><br><span class="line">                pos2[<span class="number">2</span>] * pos2[<span class="number">2</span>]);</span><br><span class="line">    paralx = RAD2SEC / dist;</span><br><span class="line">    newcat-&gt;parallax = paralx;</span><br><span class="line"></span><br><span class="line">    cra = <span class="built_in">cos</span>(r);</span><br><span class="line">    sra = <span class="built_in">sin</span>(r);</span><br><span class="line">    cdc = <span class="built_in">cos</span>(d);</span><br><span class="line">    sdc = <span class="built_in">sin</span>(d);</span><br><span class="line">    pmr = -vel2[<span class="number">0</span>] * sra + vel2[<span class="number">1</span>] * cra;</span><br><span class="line">    pmd = -vel2[<span class="number">0</span>] * cra * sdc - vel2[<span class="number">1</span>] * sra * sdc + vel2[<span class="number">2</span>] * cdc;</span><br><span class="line">    rvl = vel2[<span class="number">0</span>] * cra * cdc + vel2[<span class="number">1</span>] * sra * cdc + vel2[<span class="number">2</span>] * sdc;</span><br><span class="line"></span><br><span class="line">    newcat-&gt;promora = pmr * paralx * <span class="number">36525.0</span> / (<span class="number">15.0</span> * cdc);</span><br><span class="line">    newcat-&gt;promodec = pmd * paralx * <span class="number">36525.0</span>;</span><br><span class="line">    newcat-&gt;radialvelocity = rvl * KMAU / <span class="number">86400.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newcat-&gt;parallax &lt;= <span class="number">1.01e-7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newcat-&gt;parallax = <span class="number">0.0</span>;</span><br><span class="line">        newcat-&gt;radialvelocity = incat-&gt;radialvelocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newcat-&gt;starnumber = incat-&gt;starnumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform_hip</span><span class="params">(cat_entry *hipparcos, cat_entry *fk5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cat_entry scratch;</span><br><span class="line">    scratch.starnumber = hipparcos-&gt;starnumber;</span><br><span class="line">    scratch.dec = hipparcos-&gt;dec;</span><br><span class="line">    scratch.radialvelocity = hipparcos-&gt;radialvelocity;</span><br><span class="line"></span><br><span class="line">    scratch.ra = hipparcos-&gt;ra / <span class="number">15.0</span>;</span><br><span class="line">    scratch.promora = hipparcos-&gt;promora / (<span class="number">150.0</span> *</span><br><span class="line">                                            <span class="built_in">cos</span>(hipparcos-&gt;dec * DEG2RAD));</span><br><span class="line">    scratch.promodec = hipparcos-&gt;promodec / <span class="number">10.0</span>;</span><br><span class="line">    scratch.parallax = hipparcos-&gt;parallax / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">    transform_cat(&amp;scratch, fk5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start, end; <span class="comment">// 定义clock_t变量</span></span><br><span class="line"></span><br><span class="line">    start = clock(); <span class="comment">// 开始时间</span></span><br><span class="line"></span><br><span class="line">    cat_entry hip, fk5;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files = &#123;<span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>, <span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>, <span class="string">&quot;6.5&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;C:\\Users\\hp\\Downloads\\hip2.dat\\J1991_25_&quot;</span> + files[i] + <span class="string">&quot;.csv&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;C:\\Users\\hp\\Downloads\\hip2.dat\\J2000_&quot;</span> + files[i] + <span class="string">&quot;.csv&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> lineStr;</span><br><span class="line">        <span class="keyword">double</span> hgmag;</span><br><span class="line">        getline(inFile, lineStr); <span class="comment">// 跳过列名，第一行不做处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (getline(inFile, lineStr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; lineStr &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// 存成二维表结构</span></span><br><span class="line">            <span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(lineStr)</span></span>;</span><br><span class="line">            <span class="built_in">string</span> str;</span><br><span class="line">            <span class="comment">// 按照逗号分隔</span></span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hip.starnumber = stod(str);</span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hip.ra = stod(str);</span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hip.dec = stod(str);</span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hip.promora = stod(str);</span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hip.promodec = stod(str);</span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hip.parallax = stod(str);</span><br><span class="line">            getline(ss, str, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            hgmag = stod(str);</span><br><span class="line"></span><br><span class="line">            transform_hip(&amp;hip, &amp;fk5);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot; hip &quot; &lt;&lt; hip.starnumber &lt;&lt; &quot; ra &quot; &lt;&lt; hip.ra &lt;&lt; &quot; dec &quot; &lt;&lt; hip.dec &lt;&lt; &quot; promora: &quot; &lt;&lt; hip.promora &lt;&lt; &quot; promodec: &quot; &lt;&lt; hip.promodec &lt;&lt; &quot; para &quot; &lt;&lt; hip.parallax &lt;&lt; endl;</span></span><br><span class="line">            outFile &lt;&lt; fk5.starnumber &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; fk5.ra &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; fk5.dec &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; fk5.promora &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; fk5.promodec &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; fk5.parallax &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; hgmag &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    end = clock();                                                            <span class="comment">// 结束时间</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;time = &quot;</span> &lt;&lt; <span class="keyword">double</span>(end - start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出时间（单位：ｓ）</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>最终代码（novas有阉割）为</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BARYC 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELIOC 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> T0 = <span class="number">2451545.00000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> KMAU = <span class="number">1.49597870e+8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MAU = <span class="number">1.49597870e+11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> C = <span class="number">173.14463348</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> GS = <span class="number">1.32712438e+20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> TWOPI = <span class="number">6.28318530717958647692</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> RAD2SEC = <span class="number">206264.806247096355</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> DEG2RAD = <span class="number">0.017453292519943296</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> RAD2DEG = <span class="number">57.295779513082321</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epoch_hip = <span class="number">2448349.0625</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> epoch_fk5 = <span class="number">2451545.0000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> PSI_COR = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">double</span> EPS_COR = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">short</span> <span class="keyword">int</span> FN0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> starnumber;</span><br><span class="line">    <span class="keyword">double</span> ra;</span><br><span class="line">    <span class="keyword">double</span> dec;</span><br><span class="line">    <span class="keyword">double</span> promora;</span><br><span class="line">    <span class="keyword">double</span> promodec;</span><br><span class="line">    <span class="keyword">double</span> parallax;</span><br><span class="line">    <span class="keyword">double</span> radialvelocity;</span><br><span class="line">&#125; cat_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="keyword">double</span> longitude;</span><br><span class="line">&#125; site_info;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">vector2radec</span><span class="params">(<span class="keyword">double</span> *pos, <span class="keyword">double</span> *ra, <span class="keyword">double</span> *dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> xyproj;</span><br><span class="line"></span><br><span class="line">    xyproj = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[<span class="number">0</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos[<span class="number">1</span>], <span class="number">2.0</span>));</span><br><span class="line">    <span class="keyword">if</span> ((xyproj == <span class="number">0.0</span>) &amp;&amp; (pos[<span class="number">2</span>] == <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        *ra = <span class="number">0.0</span>;</span><br><span class="line">        *dec = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (xyproj == <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *ra = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (pos[<span class="number">2</span>] &lt; <span class="number">0.0</span>)</span><br><span class="line">            *dec = <span class="number">-90.0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *dec = <span class="number">90.0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *ra = <span class="built_in">atan2</span>(pos[<span class="number">1</span>], pos[<span class="number">0</span>]) * RAD2SEC / <span class="number">54000.0</span>;</span><br><span class="line">        *dec = <span class="built_in">atan2</span>(pos[<span class="number">2</span>], xyproj) * RAD2SEC / <span class="number">3600.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*ra &lt; <span class="number">0.0</span>)</span><br><span class="line">            *ra += <span class="number">24.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fund_args</span><span class="params">(<span class="keyword">double</span> t, <span class="keyword">double</span> a[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">2.3555483935439407</span> + t * (<span class="number">8328.691422883896</span> + t * (<span class="number">1.517951635553957e-4</span> + <span class="number">3.1028075591010306e-7</span> * t));</span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">6.240035939326023</span> + t * (<span class="number">628.3019560241842</span> + t * (<span class="number">-2.7973749400020225e-6</span> - <span class="number">5.817764173314431e-8</span> * t));</span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">1.6279019339719611</span> + t * (<span class="number">8433.466158318453</span> + t * (<span class="number">-6.427174970469119e-5</span> + <span class="number">5.332950492204896e-8</span> * t));</span><br><span class="line">    a[<span class="number">3</span>] = <span class="number">5.198469513579922</span> + t * (<span class="number">7771.377146170642</span> + t * (<span class="number">-3.340851076525812e-5</span> + <span class="number">9.211459941081184e-8</span> * t));</span><br><span class="line">    a[<span class="number">4</span>] = <span class="number">2.1824386243609943</span> + t * (<span class="number">-33.75704593375351</span> + t * (<span class="number">3.614285992671591e-5</span> + <span class="number">3.878509448876288e-8</span> * t));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">fmod</span>(a[i], TWOPI);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; <span class="number">0.0</span>)</span><br><span class="line">            a[i] += TWOPI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">nutation_angles</span><span class="params">(<span class="keyword">double</span> t, <span class="keyword">double</span> *longnutation, <span class="keyword">double</span> *obliqnutation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> clng[<span class="number">106</span>] = &#123;<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>,</span><br><span class="line">                        <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>,</span><br><span class="line">                        <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>,</span><br><span class="line">                        <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>,</span><br><span class="line">                        <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>,</span><br><span class="line">                        <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>, <span class="number">-2.0</span>, <span class="number">2.0</span>, <span class="number">2.0</span>,</span><br><span class="line">                        <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">-3.0</span>, <span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">-3.0</span>, <span class="number">3.0</span>,</span><br><span class="line">                        <span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">4.0</span>, <span class="number">-4.0</span>, <span class="number">-4.0</span>, <span class="number">4.0</span>,</span><br><span class="line">                        <span class="number">-4.0</span>, <span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">5.0</span>, <span class="number">-5.0</span>, <span class="number">6.0</span>, <span class="number">6.0</span>,</span><br><span class="line">                        <span class="number">6.0</span>, <span class="number">-6.0</span>, <span class="number">6.0</span>, <span class="number">-7.0</span>, <span class="number">7.0</span>, <span class="number">7.0</span>, <span class="number">-7.0</span>,</span><br><span class="line">                        <span class="number">-8.0</span>, <span class="number">10.0</span>, <span class="number">11.0</span>, <span class="number">12.0</span>, <span class="number">-13.0</span>, <span class="number">-15.0</span>, <span class="number">-16.0</span>,</span><br><span class="line">                        <span class="number">-16.0</span>, <span class="number">17.0</span>, <span class="number">-21.0</span>, <span class="number">-22.0</span>, <span class="number">26.0</span>, <span class="number">29.0</span>, <span class="number">29.0</span>,</span><br><span class="line">                        <span class="number">-31.0</span>, <span class="number">-38.0</span>, <span class="number">-46.0</span>, <span class="number">48.0</span>, <span class="number">-51.0</span>, <span class="number">58.0</span>, <span class="number">59.0</span>,</span><br><span class="line">                        <span class="number">63.0</span>, <span class="number">63.0</span>, <span class="number">-123.0</span>, <span class="number">129.0</span>, <span class="number">-158.0</span>, <span class="number">-217.0</span>, <span class="number">-301.0</span>,</span><br><span class="line">                        <span class="number">-386.0</span>, <span class="number">-517.0</span>, <span class="number">712.0</span>, <span class="number">1426.0</span>, <span class="number">2062.0</span>, <span class="number">-2274.0</span>,</span><br><span class="line">                        <span class="number">-13187.0</span>, <span class="number">-171996.0</span>&#125;,</span><br><span class="line">           clngx[<span class="number">14</span>] = &#123;<span class="number">0.1</span>, <span class="number">-0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">-0.2</span>, <span class="number">-0.4</span>, <span class="number">0.5</span>, <span class="number">1.2</span>,</span><br><span class="line">                        <span class="number">-1.6</span>, <span class="number">-3.4</span>, <span class="number">-174.2</span>&#125;,</span><br><span class="line">           cobl[<span class="number">64</span>] = &#123;<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>,</span><br><span class="line">                       <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>,</span><br><span class="line">                       <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>,</span><br><span class="line">                       <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-2.0</span>,</span><br><span class="line">                       <span class="number">-2.0</span>, <span class="number">-2.0</span>, <span class="number">3.0</span>, <span class="number">3.0</span>, <span class="number">-3.0</span>, <span class="number">3.0</span>,</span><br><span class="line">                       <span class="number">3.0</span>, <span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">3.0</span>, <span class="number">-3.0</span>, <span class="number">3.0</span>,</span><br><span class="line">                       <span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">-7.0</span>, <span class="number">7.0</span>,</span><br><span class="line">                       <span class="number">-8.0</span>, <span class="number">9.0</span>, <span class="number">-10.0</span>, <span class="number">-12.0</span>, <span class="number">13.0</span>, <span class="number">16.0</span>,</span><br><span class="line">                       <span class="number">-24.0</span>, <span class="number">26.0</span>, <span class="number">27.0</span>, <span class="number">32.0</span>, <span class="number">-33.0</span>, <span class="number">-53.0</span>,</span><br><span class="line">                       <span class="number">54.0</span>, <span class="number">-70.0</span>, <span class="number">-95.0</span>, <span class="number">129.0</span>, <span class="number">200.0</span>, <span class="number">224.0</span>,</span><br><span class="line">                       <span class="number">-895.0</span>, <span class="number">977.0</span>, <span class="number">5736.0</span>, <span class="number">92025.0</span>&#125;,</span><br><span class="line">           coblx[<span class="number">8</span>] = &#123;<span class="number">-0.1</span>, <span class="number">-0.1</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">-0.5</span>, <span class="number">-0.6</span>, <span class="number">-3.1</span>, <span class="number">8.9</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> i, ii, i1, i2, iop;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> nav1[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>&#125;,</span><br><span class="line">              nav2[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;,</span><br><span class="line">              nav[<span class="number">183</span>] = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">8</span>,</span><br><span class="line">                          <span class="number">1</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">1</span>,</span><br><span class="line">                          <span class="number">2</span>, <span class="number">21</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">29</span>, <span class="number">1</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">29</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>,</span><br><span class="line">                          <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>,</span><br><span class="line">                          <span class="number">1</span>, <span class="number">14</span>, <span class="number">44</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">44</span>, <span class="number">2</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">36</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">45</span>,</span><br><span class="line">                          <span class="number">1</span>, <span class="number">37</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">44</span>, <span class="number">2</span>, <span class="number">53</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">40</span>, <span class="number">3</span>,</span><br><span class="line">                          <span class="number">2</span>, <span class="number">17</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">1</span>, <span class="number">39</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">27</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">21</span>, <span class="number">47</span>,</span><br><span class="line">                          <span class="number">2</span>, <span class="number">44</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">44</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">46</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">67</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">74</span>,</span><br><span class="line">                          <span class="number">1</span>, <span class="number">0</span>, <span class="number">74</span>, <span class="number">2</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="number">53</span>, <span class="number">2</span>, <span class="number">53</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">80</span>,</span><br><span class="line">                          <span class="number">2</span>, <span class="number">0</span>, <span class="number">81</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">79</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">81</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">81</span>, <span class="number">2</span>, <span class="number">24</span>, <span class="number">44</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">79</span>,</span><br><span class="line">                          <span class="number">2</span>, <span class="number">27</span>, <span class="number">44</span>&#125;,</span><br><span class="line">              llng[<span class="number">106</span>] = &#123;<span class="number">57</span>, <span class="number">25</span>, <span class="number">82</span>, <span class="number">34</span>, <span class="number">41</span>, <span class="number">66</span>, <span class="number">33</span>, <span class="number">36</span>, <span class="number">19</span>, <span class="number">88</span>, <span class="number">18</span>, <span class="number">104</span>, <span class="number">93</span>,</span><br><span class="line">                           <span class="number">84</span>, <span class="number">47</span>, <span class="number">28</span>, <span class="number">83</span>, <span class="number">86</span>, <span class="number">69</span>, <span class="number">75</span>, <span class="number">89</span>, <span class="number">30</span>, <span class="number">58</span>, <span class="number">73</span>, <span class="number">46</span>, <span class="number">77</span>,</span><br><span class="line">                           <span class="number">23</span>, <span class="number">32</span>, <span class="number">59</span>, <span class="number">72</span>, <span class="number">31</span>, <span class="number">16</span>, <span class="number">74</span>, <span class="number">22</span>, <span class="number">98</span>, <span class="number">38</span>, <span class="number">62</span>, <span class="number">96</span>, <span class="number">37</span>,</span><br><span class="line">                           <span class="number">35</span>, <span class="number">6</span>, <span class="number">76</span>, <span class="number">85</span>, <span class="number">51</span>, <span class="number">26</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">63</span>, <span class="number">105</span>, <span class="number">52</span>, <span class="number">102</span>, <span class="number">67</span>,</span><br><span class="line">                           <span class="number">99</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">65</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">68</span>, <span class="number">20</span>, <span class="number">87</span>, <span class="number">64</span>,</span><br><span class="line">                           <span class="number">95</span>, <span class="number">27</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">80</span>, <span class="number">91</span>, <span class="number">94</span>, <span class="number">12</span>, <span class="number">43</span>, <span class="number">71</span>, <span class="number">42</span>, <span class="number">97</span>, <span class="number">70</span>,</span><br><span class="line">                           <span class="number">7</span>, <span class="number">49</span>, <span class="number">29</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">92</span>, <span class="number">50</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">17</span>, <span class="number">48</span>, <span class="number">40</span>, <span class="number">90</span>,</span><br><span class="line">                           <span class="number">8</span>, <span class="number">39</span>, <span class="number">54</span>, <span class="number">81</span>, <span class="number">21</span>, <span class="number">103</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">101</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">44</span>,</span><br><span class="line">                           <span class="number">79</span>, <span class="number">4</span>&#125;,</span><br><span class="line">              llngx[<span class="number">14</span>] = &#123;<span class="number">81</span>, <span class="number">7</span>, <span class="number">97</span>, <span class="number">0</span>, <span class="number">39</span>, <span class="number">40</span>, <span class="number">9</span>, <span class="number">44</span>, <span class="number">45</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">79</span>, <span class="number">1</span>, <span class="number">4</span>&#125;,</span><br><span class="line">              lobl[<span class="number">64</span>] = &#123;<span class="number">51</span>, <span class="number">98</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">63</span>, <span class="number">105</span>, <span class="number">38</span>, <span class="number">52</span>, <span class="number">102</span>, <span class="number">62</span>, <span class="number">96</span>,</span><br><span class="line">                          <span class="number">37</span>, <span class="number">35</span>, <span class="number">76</span>, <span class="number">36</span>, <span class="number">88</span>, <span class="number">85</span>, <span class="number">104</span>, <span class="number">93</span>, <span class="number">84</span>, <span class="number">83</span>, <span class="number">67</span>, <span class="number">99</span>, <span class="number">8</span>,</span><br><span class="line">                          <span class="number">68</span>, <span class="number">100</span>, <span class="number">60</span>, <span class="number">61</span>, <span class="number">91</span>, <span class="number">87</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">95</span>, <span class="number">65</span>, <span class="number">55</span>, <span class="number">94</span>, <span class="number">43</span>,</span><br><span class="line">                          <span class="number">97</span>, <span class="number">0</span>, <span class="number">71</span>, <span class="number">70</span>, <span class="number">42</span>, <span class="number">49</span>, <span class="number">92</span>, <span class="number">50</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">90</span>, <span class="number">48</span>, <span class="number">40</span>,</span><br><span class="line">                          <span class="number">39</span>, <span class="number">54</span>, <span class="number">1</span>, <span class="number">81</span>, <span class="number">103</span>, <span class="number">53</span>, <span class="number">45</span>, <span class="number">101</span>, <span class="number">9</span>, <span class="number">44</span>, <span class="number">79</span>, <span class="number">4</span>&#125;,</span><br><span class="line">              loblx[<span class="number">8</span>] = &#123;<span class="number">53</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">9</span>, <span class="number">44</span>, <span class="number">101</span>, <span class="number">79</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> a[<span class="number">5</span>], angle, cc, ss1, cs, sc, c[<span class="number">106</span>], s[<span class="number">106</span>], lng, lngx, obl,</span><br><span class="line">        oblx;</span><br><span class="line"></span><br><span class="line">    fund_args(t, a);</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        angle = a[nav1[ii]] * (<span class="keyword">double</span>)(nav1[<span class="number">1</span> + ii] + <span class="number">1</span>);</span><br><span class="line">        c[i] = <span class="built_in">cos</span>(angle);</span><br><span class="line">        s[i] = <span class="built_in">sin</span>(angle);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i1 = nav2[ii];</span><br><span class="line">        i2 = nav2[<span class="number">1</span> + ii];</span><br><span class="line"></span><br><span class="line">        c[i] = c[i1] * c[i2] - s[i1] * s[i2];</span><br><span class="line">        s[i] = s[i1] * c[i2] + c[i1] * s[i2];</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">183</span>; ii += <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iop = nav[ii];</span><br><span class="line">        i1 = nav[<span class="number">1</span> + ii];</span><br><span class="line">        i2 = nav[<span class="number">2</span> + ii];</span><br><span class="line">        <span class="keyword">switch</span> (iop)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            c[i] = c[i1] * c[i2] - s[i1] * s[i2];</span><br><span class="line">            s[i] = s[i1] * c[i2] + c[i1] * s[i2];</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            c[i] = c[i1] * c[i2] + s[i1] * s[i2];</span><br><span class="line">            s[i] = s[i1] * c[i2] - c[i1] * s[i2];</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            cc = c[i1] * c[i2];</span><br><span class="line">            ss1 = s[i1] * s[i2];</span><br><span class="line">            sc = s[i1] * c[i2];</span><br><span class="line">            cs = c[i1] * s[i2];</span><br><span class="line">            c[i] = cc - ss1;</span><br><span class="line">            s[i] = sc + cs;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            c[i] = cc + ss1;</span><br><span class="line">            s[i] = sc - cs;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iop == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lng = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">106</span>; i++)</span><br><span class="line">        lng += clng[i] * s[llng[i]];</span><br><span class="line"></span><br><span class="line">    lngx = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++)</span><br><span class="line">        lngx += clngx[i] * s[llngx[i]];</span><br><span class="line"></span><br><span class="line">    obl = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">64</span>; i++)</span><br><span class="line">        obl += cobl[i] * c[lobl[i]];</span><br><span class="line"></span><br><span class="line">    oblx = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        oblx += coblx[i] * c[loblx[i]];</span><br><span class="line"></span><br><span class="line">    *longnutation = (lng + t * lngx) / <span class="number">10000.0</span>;</span><br><span class="line">    *obliqnutation = (obl + t * oblx) / <span class="number">10000.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">earthtilt</span><span class="params">(<span class="keyword">double</span> tjd, <span class="keyword">double</span> *mobl, <span class="keyword">double</span> *tobl, <span class="keyword">double</span> *eq, <span class="keyword">double</span> *dpsi, <span class="keyword">double</span> *deps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> tjd_last = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> t, dp, de;</span><br><span class="line">    <span class="keyword">double</span> mean_obliq, true_obliq, eq_eq, args[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    t = (tjd - T0) / <span class="number">36525.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(tjd - tjd_last) &gt; <span class="number">1.0e-6</span>)</span><br><span class="line">        nutation_angles(t, &amp;dp, &amp;de);</span><br><span class="line"></span><br><span class="line">    mean_obliq = <span class="number">84381.4480</span> - <span class="number">46.8150</span> * t - <span class="number">0.00059</span> * <span class="built_in">pow</span>(t, <span class="number">2.0</span>) + <span class="number">0.001813</span> * <span class="built_in">pow</span>(t, <span class="number">3.0</span>);</span><br><span class="line"></span><br><span class="line">    true_obliq = mean_obliq + de;</span><br><span class="line"></span><br><span class="line">    mean_obliq /= <span class="number">3600.0</span>;</span><br><span class="line">    true_obliq /= <span class="number">3600.0</span>;</span><br><span class="line"></span><br><span class="line">    fund_args(t, args);</span><br><span class="line"></span><br><span class="line">    eq_eq = dp * <span class="built_in">cos</span>(mean_obliq * DEG2RAD) +</span><br><span class="line">            (<span class="number">0.00264</span> * <span class="built_in">sin</span>(args[<span class="number">4</span>]) + <span class="number">0.000063</span> * <span class="built_in">sin</span>(<span class="number">2.0</span> * args[<span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line">    eq_eq /= <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">    *dpsi = dp;</span><br><span class="line">    *deps = de;</span><br><span class="line">    *eq = eq_eq;</span><br><span class="line">    *mobl = mean_obliq;</span><br><span class="line">    *tobl = true_obliq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starvectors</span><span class="params">(cat_entry *star, <span class="keyword">double</span> *pos, <span class="keyword">double</span> *vel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> paralx, dist, r, d, cra, sra, cdc, sdc, pmr, pmd, rvl;</span><br><span class="line"></span><br><span class="line">    paralx = star-&gt;parallax;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (star-&gt;parallax &lt;= <span class="number">0.0</span>)</span><br><span class="line">        paralx = <span class="number">1.0e-7</span>;</span><br><span class="line"></span><br><span class="line">    dist = RAD2SEC / paralx;</span><br><span class="line">    r = (star-&gt;ra) * <span class="number">15.0</span> * DEG2RAD;</span><br><span class="line">    d = (star-&gt;dec) * DEG2RAD;</span><br><span class="line">    cra = <span class="built_in">cos</span>(r);</span><br><span class="line">    sra = <span class="built_in">sin</span>(r);</span><br><span class="line">    cdc = <span class="built_in">cos</span>(d);</span><br><span class="line">    sdc = <span class="built_in">sin</span>(d);</span><br><span class="line"></span><br><span class="line">    pos[<span class="number">0</span>] = dist * cdc * cra;</span><br><span class="line">    pos[<span class="number">1</span>] = dist * cdc * sra;</span><br><span class="line">    pos[<span class="number">2</span>] = dist * sdc;</span><br><span class="line"></span><br><span class="line">    pmr = star-&gt;promora * <span class="number">15.0</span> * cdc / (paralx * <span class="number">36525.0</span>);</span><br><span class="line">    pmd = star-&gt;promodec / (paralx * <span class="number">36525.0</span>);</span><br><span class="line">    rvl = star-&gt;radialvelocity * <span class="number">86400.0</span> / KMAU;</span><br><span class="line">    vel[<span class="number">0</span>] = -pmr * sra - pmd * sdc * cra + rvl * cdc * cra;</span><br><span class="line">    vel[<span class="number">1</span>] = pmr * cra - pmd * sdc * sra + rvl * cdc * sra;</span><br><span class="line">    vel[<span class="number">2</span>] = pmd * cdc + rvl * sdc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tdb2tdt</span><span class="params">(<span class="keyword">double</span> tdb, <span class="keyword">double</span> *tdtjd, <span class="keyword">double</span> *secdiff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ecc = <span class="number">0.01671022</span>;</span><br><span class="line">    <span class="keyword">double</span> rev = <span class="number">1296000.0</span>;</span><br><span class="line">    <span class="keyword">double</span> tdays, m, l, lj, e;</span><br><span class="line"></span><br><span class="line">    tdays = tdb - T0;</span><br><span class="line">    m = (<span class="number">357.51716</span> + <span class="number">0.985599987</span> * tdays) * <span class="number">3600.0</span>;</span><br><span class="line">    l = (<span class="number">280.46435</span> + <span class="number">0.985609100</span> * tdays) * <span class="number">3600.0</span>;</span><br><span class="line">    lj = (<span class="number">34.40438</span> + <span class="number">0.083086762</span> * tdays) * <span class="number">3600.0</span>;</span><br><span class="line">    m = <span class="built_in">fmod</span>(m, rev) / RAD2SEC;</span><br><span class="line">    l = <span class="built_in">fmod</span>(l, rev) / RAD2SEC;</span><br><span class="line">    lj = <span class="built_in">fmod</span>(lj, rev) / RAD2SEC;</span><br><span class="line">    e = m + ecc * <span class="built_in">sin</span>(m) + <span class="number">0.5</span> * ecc * ecc * <span class="built_in">sin</span>(<span class="number">2.0</span> * m);</span><br><span class="line">    *secdiff = <span class="number">1.658e-3</span> * <span class="built_in">sin</span>(e) + <span class="number">20.73e-6</span> * <span class="built_in">sin</span>(l - lj);</span><br><span class="line">    *tdtjd = tdb - *secdiff / <span class="number">86400.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">precession</span><span class="params">(<span class="keyword">double</span> tjd1, <span class="keyword">double</span> *pos, <span class="keyword">double</span> tjd2, <span class="keyword">double</span> *pos2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform_cat</span><span class="params">(cat_entry *incat, cat_entry *newcat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> paralx, dist, r, d, cra, sra, cdc, sdc, pos1[<span class="number">3</span>], term1, pmr, pmd, rvl, vel1[<span class="number">3</span>], pos2[<span class="number">3</span>], vel2[<span class="number">3</span>], xyproj;</span><br><span class="line"></span><br><span class="line">    paralx = incat-&gt;parallax;</span><br><span class="line">    <span class="keyword">if</span> (paralx &lt;= <span class="number">0.0</span>)</span><br><span class="line">        paralx = <span class="number">1.0e-7</span>;</span><br><span class="line"></span><br><span class="line">    dist = RAD2SEC / paralx;</span><br><span class="line">    r = incat-&gt;ra * <span class="number">54000.0</span> / RAD2SEC;</span><br><span class="line">    d = incat-&gt;dec * <span class="number">3600.0</span> / RAD2SEC;</span><br><span class="line">    cra = <span class="built_in">cos</span>(r);</span><br><span class="line">    sra = <span class="built_in">sin</span>(r);</span><br><span class="line">    cdc = <span class="built_in">cos</span>(d);</span><br><span class="line">    sdc = <span class="built_in">sin</span>(d);</span><br><span class="line">    pos1[<span class="number">0</span>] = dist * cdc * cra;</span><br><span class="line">    pos1[<span class="number">1</span>] = dist * cdc * sra;</span><br><span class="line">    pos1[<span class="number">2</span>] = dist * sdc;</span><br><span class="line"></span><br><span class="line">    term1 = paralx * <span class="number">36525.0</span>;</span><br><span class="line">    pmr = incat-&gt;promora * <span class="number">15.0</span> * cdc / term1;</span><br><span class="line">    pmd = incat-&gt;promodec / term1;</span><br><span class="line"></span><br><span class="line">    vel1[<span class="number">0</span>] = -pmr * sra - pmd * sdc * cra;</span><br><span class="line">    vel1[<span class="number">1</span>] = pmr * cra - pmd * sdc * sra;</span><br><span class="line">    vel1[<span class="number">2</span>] = pmd * cdc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos2[j] = pos1[j] + vel1[j] * (epoch_fk5 - epoch_hip);</span><br><span class="line">        vel2[j] = vel1[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xyproj = <span class="built_in">sqrt</span>(pos2[<span class="number">0</span>] * pos2[<span class="number">0</span>] + pos2[<span class="number">1</span>] * pos2[<span class="number">1</span>]);</span><br><span class="line">    r = <span class="built_in">atan2</span>(pos2[<span class="number">1</span>], pos2[<span class="number">0</span>]);</span><br><span class="line">    d = <span class="built_in">atan2</span>(pos2[<span class="number">2</span>], xyproj);</span><br><span class="line">    newcat-&gt;ra = r * RAD2SEC / <span class="number">54000.0</span>;</span><br><span class="line">    newcat-&gt;dec = d * RAD2SEC / <span class="number">3600.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (newcat-&gt;ra &lt; <span class="number">0.0</span>)</span><br><span class="line">        newcat-&gt;ra += <span class="number">24.0</span>;</span><br><span class="line"></span><br><span class="line">    dist = <span class="built_in">sqrt</span>(pos2[<span class="number">0</span>] * pos2[<span class="number">0</span>] + pos2[<span class="number">1</span>] * pos2[<span class="number">1</span>] +</span><br><span class="line">                pos2[<span class="number">2</span>] * pos2[<span class="number">2</span>]);</span><br><span class="line">    paralx = RAD2SEC / dist;</span><br><span class="line">    newcat-&gt;parallax = paralx;</span><br><span class="line"></span><br><span class="line">    cra = <span class="built_in">cos</span>(r);</span><br><span class="line">    sra = <span class="built_in">sin</span>(r);</span><br><span class="line">    cdc = <span class="built_in">cos</span>(d);</span><br><span class="line">    sdc = <span class="built_in">sin</span>(d);</span><br><span class="line">    pmr = -vel2[<span class="number">0</span>] * sra + vel2[<span class="number">1</span>] * cra;</span><br><span class="line">    pmd = -vel2[<span class="number">0</span>] * cra * sdc - vel2[<span class="number">1</span>] * sra * sdc + vel2[<span class="number">2</span>] * cdc;</span><br><span class="line">    rvl = vel2[<span class="number">0</span>] * cra * cdc + vel2[<span class="number">1</span>] * sra * cdc + vel2[<span class="number">2</span>] * sdc;</span><br><span class="line"></span><br><span class="line">    newcat-&gt;promora = pmr * paralx * <span class="number">36525.0</span> / (<span class="number">15.0</span> * cdc);</span><br><span class="line">    newcat-&gt;promodec = pmd * paralx * <span class="number">36525.0</span>;</span><br><span class="line">    newcat-&gt;radialvelocity = rvl * KMAU / <span class="number">86400.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newcat-&gt;parallax &lt;= <span class="number">1.01e-7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        newcat-&gt;parallax = <span class="number">0.0</span>;</span><br><span class="line">        newcat-&gt;radialvelocity = incat-&gt;radialvelocity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newcat-&gt;starnumber = incat-&gt;starnumber;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform_hip</span><span class="params">(cat_entry *hipparcos, cat_entry *fk5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cat_entry scratch;</span><br><span class="line">    scratch.starnumber = hipparcos-&gt;starnumber;</span><br><span class="line">    scratch.dec = hipparcos-&gt;dec;</span><br><span class="line">    scratch.radialvelocity = hipparcos-&gt;radialvelocity;</span><br><span class="line"></span><br><span class="line">    scratch.ra = hipparcos-&gt;ra / <span class="number">15.0</span>;</span><br><span class="line">    scratch.promora = hipparcos-&gt;promora / (<span class="number">150.0</span> *</span><br><span class="line">                                            <span class="built_in">cos</span>(hipparcos-&gt;dec * DEG2RAD));</span><br><span class="line">    scratch.promodec = hipparcos-&gt;promodec / <span class="number">10.0</span>;</span><br><span class="line">    scratch.parallax = hipparcos-&gt;parallax / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">    transform_cat(&amp;scratch, fk5);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sun_eph</span><span class="params">(<span class="keyword">double</span> jd, <span class="keyword">double</span> *ra, <span class="keyword">double</span> *dec, <span class="keyword">double</span> *dis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum_lon = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum_r = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> factor = <span class="number">1.0e-07</span>;</span><br><span class="line">    <span class="keyword">double</span> u, arg, lon, lat, t, t2, emean, sin_lon;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sun_con</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">double</span> l;</span><br><span class="line">        <span class="keyword">double</span> r;</span><br><span class="line">        <span class="keyword">double</span> alpha;</span><br><span class="line">        <span class="keyword">double</span> nu;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sun_con</span> <span class="title">con</span>[50] =</span></span><br><span class="line">        &#123;&#123;<span class="number">403406.0</span>, <span class="number">0.0</span>, <span class="number">4.721964</span>, <span class="number">1.621043</span>&#125;,</span><br><span class="line">         &#123;<span class="number">195207.0</span>, <span class="number">-97597.0</span>, <span class="number">5.937458</span>, <span class="number">62830.348067</span>&#125;,</span><br><span class="line">         &#123;<span class="number">119433.0</span>, <span class="number">-59715.0</span>, <span class="number">1.115589</span>, <span class="number">62830.821524</span>&#125;,</span><br><span class="line">         &#123;<span class="number">112392.0</span>, <span class="number">-56188.0</span>, <span class="number">5.781616</span>, <span class="number">62829.634302</span>&#125;,</span><br><span class="line">         &#123;<span class="number">3891.0</span>, <span class="number">-1556.0</span>, <span class="number">5.5474</span>, <span class="number">125660.5691</span>&#125;,</span><br><span class="line">         &#123;<span class="number">2819.0</span>, <span class="number">-1126.0</span>, <span class="number">1.5120</span>, <span class="number">125660.9845</span>&#125;,</span><br><span class="line">         &#123;<span class="number">1721.0</span>, <span class="number">-861.0</span>, <span class="number">4.1897</span>, <span class="number">62832.4766</span>&#125;,</span><br><span class="line">         &#123;<span class="number">0.0</span>, <span class="number">941.0</span>, <span class="number">1.163</span>, <span class="number">0.813</span>&#125;,</span><br><span class="line">         &#123;<span class="number">660.0</span>, <span class="number">-264.0</span>, <span class="number">5.415</span>, <span class="number">125659.310</span>&#125;,</span><br><span class="line">         &#123;<span class="number">350.0</span>, <span class="number">-163.0</span>, <span class="number">4.315</span>, <span class="number">57533.850</span>&#125;,</span><br><span class="line">         &#123;<span class="number">334.0</span>, <span class="number">0.0</span>, <span class="number">4.553</span>, <span class="number">-33.931</span>&#125;,</span><br><span class="line">         &#123;<span class="number">314.0</span>, <span class="number">309.0</span>, <span class="number">5.198</span>, <span class="number">777137.715</span>&#125;,</span><br><span class="line">         &#123;<span class="number">268.0</span>, <span class="number">-158.0</span>, <span class="number">5.989</span>, <span class="number">78604.191</span>&#125;,</span><br><span class="line">         &#123;<span class="number">242.0</span>, <span class="number">0.0</span>, <span class="number">2.911</span>, <span class="number">5.412</span>&#125;,</span><br><span class="line">         &#123;<span class="number">234.0</span>, <span class="number">-54.0</span>, <span class="number">1.423</span>, <span class="number">39302.098</span>&#125;,</span><br><span class="line">         &#123;<span class="number">158.0</span>, <span class="number">0.0</span>, <span class="number">0.061</span>, <span class="number">-34.861</span>&#125;,</span><br><span class="line">         &#123;<span class="number">132.0</span>, <span class="number">-93.0</span>, <span class="number">2.317</span>, <span class="number">115067.698</span>&#125;,</span><br><span class="line">         &#123;<span class="number">129.0</span>, <span class="number">-20.0</span>, <span class="number">3.193</span>, <span class="number">15774.337</span>&#125;,</span><br><span class="line">         &#123;<span class="number">114.0</span>, <span class="number">0.0</span>, <span class="number">2.828</span>, <span class="number">5296.670</span>&#125;,</span><br><span class="line">         &#123;<span class="number">99.0</span>, <span class="number">-47.0</span>, <span class="number">0.52</span>, <span class="number">58849.27</span>&#125;,</span><br><span class="line">         &#123;<span class="number">93.0</span>, <span class="number">0.0</span>, <span class="number">4.65</span>, <span class="number">5296.11</span>&#125;,</span><br><span class="line">         &#123;<span class="number">86.0</span>, <span class="number">0.0</span>, <span class="number">4.35</span>, <span class="number">-3980.70</span>&#125;,</span><br><span class="line">         &#123;<span class="number">78.0</span>, <span class="number">-33.0</span>, <span class="number">2.75</span>, <span class="number">52237.69</span>&#125;,</span><br><span class="line">         &#123;<span class="number">72.0</span>, <span class="number">-32.0</span>, <span class="number">4.50</span>, <span class="number">55076.47</span>&#125;,</span><br><span class="line">         &#123;<span class="number">68.0</span>, <span class="number">0.0</span>, <span class="number">3.23</span>, <span class="number">261.08</span>&#125;,</span><br><span class="line">         &#123;<span class="number">64.0</span>, <span class="number">-10.0</span>, <span class="number">1.22</span>, <span class="number">15773.85</span>&#125;,</span><br><span class="line">         &#123;<span class="number">46.0</span>, <span class="number">-16.0</span>, <span class="number">0.14</span>, <span class="number">188491.03</span>&#125;,</span><br><span class="line">         &#123;<span class="number">38.0</span>, <span class="number">0.0</span>, <span class="number">3.44</span>, <span class="number">-7756.55</span>&#125;,</span><br><span class="line">         &#123;<span class="number">37.0</span>, <span class="number">0.0</span>, <span class="number">4.37</span>, <span class="number">264.89</span>&#125;,</span><br><span class="line">         &#123;<span class="number">32.0</span>, <span class="number">-24.0</span>, <span class="number">1.14</span>, <span class="number">117906.27</span>&#125;,</span><br><span class="line">         &#123;<span class="number">29.0</span>, <span class="number">-13.0</span>, <span class="number">2.84</span>, <span class="number">55075.75</span>&#125;,</span><br><span class="line">         &#123;<span class="number">28.0</span>, <span class="number">0.0</span>, <span class="number">5.96</span>, <span class="number">-7961.39</span>&#125;,</span><br><span class="line">         &#123;<span class="number">27.0</span>, <span class="number">-9.0</span>, <span class="number">5.09</span>, <span class="number">188489.81</span>&#125;,</span><br><span class="line">         &#123;<span class="number">27.0</span>, <span class="number">0.0</span>, <span class="number">1.72</span>, <span class="number">2132.19</span>&#125;,</span><br><span class="line">         &#123;<span class="number">25.0</span>, <span class="number">-17.0</span>, <span class="number">2.56</span>, <span class="number">109771.03</span>&#125;,</span><br><span class="line">         &#123;<span class="number">24.0</span>, <span class="number">-11.0</span>, <span class="number">1.92</span>, <span class="number">54868.56</span>&#125;,</span><br><span class="line">         &#123;<span class="number">21.0</span>, <span class="number">0.0</span>, <span class="number">0.09</span>, <span class="number">25443.93</span>&#125;,</span><br><span class="line">         &#123;<span class="number">21.0</span>, <span class="number">31.0</span>, <span class="number">5.98</span>, <span class="number">-55731.43</span>&#125;,</span><br><span class="line">         &#123;<span class="number">20.0</span>, <span class="number">-10.0</span>, <span class="number">4.03</span>, <span class="number">60697.74</span>&#125;,</span><br><span class="line">         &#123;<span class="number">18.0</span>, <span class="number">0.0</span>, <span class="number">4.27</span>, <span class="number">2132.79</span>&#125;,</span><br><span class="line">         &#123;<span class="number">17.0</span>, <span class="number">-12.0</span>, <span class="number">0.79</span>, <span class="number">109771.63</span>&#125;,</span><br><span class="line">         &#123;<span class="number">14.0</span>, <span class="number">0.0</span>, <span class="number">4.24</span>, <span class="number">-7752.82</span>&#125;,</span><br><span class="line">         &#123;<span class="number">13.0</span>, <span class="number">-5.0</span>, <span class="number">2.01</span>, <span class="number">188491.91</span>&#125;,</span><br><span class="line">         &#123;<span class="number">13.0</span>, <span class="number">0.0</span>, <span class="number">2.65</span>, <span class="number">207.81</span>&#125;,</span><br><span class="line">         &#123;<span class="number">13.0</span>, <span class="number">0.0</span>, <span class="number">4.98</span>, <span class="number">29424.63</span>&#125;,</span><br><span class="line">         &#123;<span class="number">12.0</span>, <span class="number">0.0</span>, <span class="number">0.93</span>, <span class="number">-7.99</span>&#125;,</span><br><span class="line">         &#123;<span class="number">10.0</span>, <span class="number">0.0</span>, <span class="number">2.21</span>, <span class="number">46941.14</span>&#125;,</span><br><span class="line">         &#123;<span class="number">10.0</span>, <span class="number">0.0</span>, <span class="number">3.59</span>, <span class="number">-68.29</span>&#125;,</span><br><span class="line">         &#123;<span class="number">10.0</span>, <span class="number">0.0</span>, <span class="number">1.50</span>, <span class="number">21463.25</span>&#125;,</span><br><span class="line">         &#123;<span class="number">10.0</span>, <span class="number">-9.0</span>, <span class="number">2.55</span>, <span class="number">157208.40</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    u = (jd - T0) / <span class="number">3652500.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arg = con[i].alpha + con[i].nu * u;</span><br><span class="line">        sum_lon += con[i].l * <span class="built_in">sin</span>(arg);</span><br><span class="line">        sum_r += con[i].r * <span class="built_in">cos</span>(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lon = <span class="number">4.9353929</span> + <span class="number">62833.1961680</span> * u + factor * sum_lon;</span><br><span class="line"></span><br><span class="line">    lon = <span class="built_in">fmod</span>(lon, TWOPI);</span><br><span class="line">    <span class="keyword">if</span> (lon &lt; <span class="number">0.0</span>)</span><br><span class="line">        lon += TWOPI;</span><br><span class="line"></span><br><span class="line">    lat = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    *dis = <span class="number">1.0001026</span> + factor * sum_r;</span><br><span class="line"></span><br><span class="line">    t = u * <span class="number">100.0</span>;</span><br><span class="line">    t2 = t * t;</span><br><span class="line">    emean = (<span class="number">0.001813</span> * t2 * t - <span class="number">0.00059</span> * t2 - <span class="number">46.8150</span> * t + <span class="number">84381.448</span>) / RAD2SEC;</span><br><span class="line"></span><br><span class="line">    sin_lon = <span class="built_in">sin</span>(lon);</span><br><span class="line">    *ra = <span class="built_in">atan2</span>((<span class="built_in">cos</span>(emean) * sin_lon), <span class="built_in">cos</span>(lon)) * RAD2DEG;</span><br><span class="line">    *ra = <span class="built_in">fmod</span>(*ra, <span class="number">360.0</span>);</span><br><span class="line">    <span class="keyword">if</span> (*ra &lt; <span class="number">0.0</span>)</span><br><span class="line">        *ra += <span class="number">360.0</span>;</span><br><span class="line">    *ra = *ra / <span class="number">15.0</span>;</span><br><span class="line"></span><br><span class="line">    *dec = <span class="built_in">asin</span>(<span class="built_in">sin</span>(emean) * sin_lon) * RAD2DEG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">precession</span><span class="params">(<span class="keyword">double</span> tjd1, <span class="keyword">double</span> *pos, <span class="keyword">double</span> tjd2, <span class="keyword">double</span> *pos2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> xx, yx, zx, xy, yy, zy, xz, yz, zz, t, t1, t02, t2, t3, zeta0, zee, theta;</span><br><span class="line"></span><br><span class="line">    t = (tjd1 - T0) / <span class="number">36525.0</span>;</span><br><span class="line">    t1 = (tjd2 - tjd1) / <span class="number">36525.0</span>;</span><br><span class="line">    t02 = t * t;</span><br><span class="line">    t2 = t1 * t1;</span><br><span class="line">    t3 = t2 * t1;</span><br><span class="line">    zeta0 = (<span class="number">2306.2181</span> + <span class="number">1.39656</span> * t - <span class="number">0.000139</span> * t02) * t1 + (<span class="number">0.30188</span> - <span class="number">0.000344</span> * t) * t2 + <span class="number">0.017998</span> * t3;</span><br><span class="line"></span><br><span class="line">    zee = (<span class="number">2306.2181</span> + <span class="number">1.39656</span> * t - <span class="number">0.000139</span> * t02) * t1 + (<span class="number">1.09468</span> + <span class="number">0.000066</span> * t) * t2 + <span class="number">0.018203</span> * t3;</span><br><span class="line"></span><br><span class="line">    theta = (<span class="number">2004.3109</span> - <span class="number">0.85330</span> * t - <span class="number">0.000217</span> * t02) * t1 + (<span class="number">-0.42665</span> - <span class="number">0.000217</span> * t) * t2 - <span class="number">0.041833</span> * t3;</span><br><span class="line"></span><br><span class="line">    zeta0 /= RAD2SEC;</span><br><span class="line">    zee /= RAD2SEC;</span><br><span class="line">    theta /= RAD2SEC;</span><br><span class="line">    xx = <span class="built_in">cos</span>(zeta0) * <span class="built_in">cos</span>(theta) * <span class="built_in">cos</span>(zee) - <span class="built_in">sin</span>(zeta0) * <span class="built_in">sin</span>(zee);</span><br><span class="line">    yx = -<span class="built_in">sin</span>(zeta0) * <span class="built_in">cos</span>(theta) * <span class="built_in">cos</span>(zee) - <span class="built_in">cos</span>(zeta0) *</span><br><span class="line">                                                   <span class="built_in">sin</span>(zee);</span><br><span class="line">    zx = -<span class="built_in">sin</span>(theta) * <span class="built_in">cos</span>(zee);</span><br><span class="line">    xy = <span class="built_in">cos</span>(zeta0) * <span class="built_in">cos</span>(theta) * <span class="built_in">sin</span>(zee) + <span class="built_in">sin</span>(zeta0) * <span class="built_in">cos</span>(zee);</span><br><span class="line">    yy = -<span class="built_in">sin</span>(zeta0) * <span class="built_in">cos</span>(theta) * <span class="built_in">sin</span>(zee) + <span class="built_in">cos</span>(zeta0) *</span><br><span class="line">                                                   <span class="built_in">cos</span>(zee);</span><br><span class="line">    zy = -<span class="built_in">sin</span>(theta) * <span class="built_in">sin</span>(zee);</span><br><span class="line">    xz = <span class="built_in">cos</span>(zeta0) * <span class="built_in">sin</span>(theta);</span><br><span class="line">    yz = -<span class="built_in">sin</span>(zeta0) * <span class="built_in">sin</span>(theta);</span><br><span class="line">    zz = <span class="built_in">cos</span>(theta);</span><br><span class="line">    pos2[<span class="number">0</span>] = xx * pos[<span class="number">0</span>] + yx * pos[<span class="number">1</span>] + zx * pos[<span class="number">2</span>];</span><br><span class="line">    pos2[<span class="number">1</span>] = xy * pos[<span class="number">0</span>] + yy * pos[<span class="number">1</span>] + zy * pos[<span class="number">2</span>];</span><br><span class="line">    pos2[<span class="number">2</span>] = xz * pos[<span class="number">0</span>] + yz * pos[<span class="number">1</span>] + zz * pos[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radec2vector</span><span class="params">(<span class="keyword">double</span> ra, <span class="keyword">double</span> dec, <span class="keyword">double</span> dist, <span class="keyword">double</span> *<span class="built_in">vector</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">0</span>] = dist * <span class="built_in">cos</span>(DEG2RAD * dec) * <span class="built_in">cos</span>(DEG2RAD * <span class="number">15.0</span> * ra);</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">1</span>] = dist * <span class="built_in">cos</span>(DEG2RAD * dec) * <span class="built_in">sin</span>(DEG2RAD * <span class="number">15.0</span> * ra);</span><br><span class="line">    <span class="built_in">vector</span>[<span class="number">2</span>] = dist * <span class="built_in">sin</span>(DEG2RAD * dec);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">solarsystem</span><span class="params">(<span class="keyword">double</span> tjd, <span class="keyword">short</span> <span class="keyword">int</span> origin, <span class="keyword">double</span> *pos, <span class="keyword">double</span> *vel)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> ierr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> pm[<span class="number">4</span>] = &#123;<span class="number">1047.349</span>, <span class="number">3497.898</span>, <span class="number">22903.0</span>, <span class="number">19412.2</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> pa[<span class="number">4</span>] = &#123;<span class="number">5.203363</span>, <span class="number">9.537070</span>, <span class="number">19.191264</span>, <span class="number">30.068963</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> pl[<span class="number">4</span>] = &#123;<span class="number">0.600470</span>, <span class="number">0.871693</span>, <span class="number">5.466933</span>, <span class="number">5.321160</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> pn[<span class="number">4</span>] = &#123;<span class="number">1.450138e-3</span>, <span class="number">5.841727e-4</span>, <span class="number">2.047497e-4</span>, <span class="number">1.043891e-4</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> obl = <span class="number">23.43929111</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> tlast = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> sine, cose, tmass, pbary[<span class="number">3</span>], vbary[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> oblr, qjd, ras, decs, diss, pos1[<span class="number">3</span>], p[<span class="number">3</span>][<span class="number">3</span>], dlon, sinl, cosl, x, y, z, xdot, ydot, zdot, f;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tlast == <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oblr = obl * TWOPI / <span class="number">360.0</span>;</span><br><span class="line">        sine = <span class="built_in">sin</span>(oblr);</span><br><span class="line">        cose = <span class="built_in">cos</span>(oblr);</span><br><span class="line">        tmass = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            tmass += <span class="number">1.0</span> / pm[i];</span><br><span class="line">        tlast = <span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((tjd &lt; <span class="number">2340000.5</span>) || (tjd &gt; <span class="number">2560000.5</span>))</span><br><span class="line">        <span class="keyword">return</span> (ierr = <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        qjd = tjd + (<span class="keyword">double</span>)(i - <span class="number">1</span>) * <span class="number">0.1</span>;</span><br><span class="line">        sun_eph(qjd, &amp;ras, &amp;decs, &amp;diss);</span><br><span class="line">        radec2vector(ras, decs, diss, pos1);</span><br><span class="line">        precession(qjd, pos1, T0, pos);</span><br><span class="line">        p[i][<span class="number">0</span>] = -pos[<span class="number">0</span>];</span><br><span class="line">        p[i][<span class="number">1</span>] = -pos[<span class="number">1</span>];</span><br><span class="line">        p[i][<span class="number">2</span>] = -pos[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos[i] = p[<span class="number">1</span>][i];</span><br><span class="line">        vel[i] = (p[<span class="number">2</span>][i] - p[<span class="number">0</span>][i]) / <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (origin == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(tjd - tlast) &gt;= <span class="number">1.0e-06</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">                pbary[i] = vbary[i] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                dlon = pl[i] + pn[i] * (tjd - T0);</span><br><span class="line">                dlon = <span class="built_in">fmod</span>(dlon, TWOPI);</span><br><span class="line">                sinl = <span class="built_in">sin</span>(dlon);</span><br><span class="line">                cosl = <span class="built_in">cos</span>(dlon);</span><br><span class="line"></span><br><span class="line">                x = pa[i] * cosl;</span><br><span class="line">                y = pa[i] * sinl * cose;</span><br><span class="line">                z = pa[i] * sinl * sine;</span><br><span class="line">                xdot = -pa[i] * pn[i] * sinl;</span><br><span class="line">                ydot = pa[i] * pn[i] * cosl * cose;</span><br><span class="line">                zdot = pa[i] * pn[i] * cosl * sine;</span><br><span class="line"></span><br><span class="line">                f = <span class="number">1.0</span> / (pm[i] * tmass);</span><br><span class="line"></span><br><span class="line">                pbary[<span class="number">0</span>] += x * f;</span><br><span class="line">                pbary[<span class="number">1</span>] += y * f;</span><br><span class="line">                pbary[<span class="number">2</span>] += z * f;</span><br><span class="line">                vbary[<span class="number">0</span>] += xdot * f;</span><br><span class="line">                vbary[<span class="number">1</span>] += ydot * f;</span><br><span class="line">                vbary[<span class="number">2</span>] += zdot * f;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tlast = tjd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pos[i] -= pbary[i];</span><br><span class="line">            vel[i] -= vbary[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (ierr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proper_motion</span><span class="params">(<span class="keyword">double</span> tjd1, <span class="keyword">double</span> *pos, <span class="keyword">double</span> *vel, <span class="keyword">double</span> tjd2, <span class="keyword">double</span> *pos2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        pos2[j] = pos[j] + (vel[j] * (tjd2 - tjd1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">get_earth</span><span class="params">(<span class="keyword">double</span> tjd, <span class="keyword">double</span> *tdb, <span class="keyword">double</span> *bary_earthp, <span class="keyword">double</span> *bary_earthv, <span class="keyword">double</span> *helio_earthp, <span class="keyword">double</span> *helio_earthv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> tjd_last = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> time1, peb[<span class="number">3</span>], veb[<span class="number">3</span>], pes[<span class="number">3</span>], ves[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">double</span> dummy, secdiff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(tjd - tjd_last) &gt; <span class="number">1.0e-6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tdb2tdt(tjd, &amp;dummy, &amp;secdiff);</span><br><span class="line">        time1 = tjd + secdiff / <span class="number">86400.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error = solarsystem(time1, BARYC, peb, veb))</span><br><span class="line">        &#123;</span><br><span class="line">            tjd_last = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error = solarsystem(time1, HELIOC, pes, ves))</span><br><span class="line">        &#123;</span><br><span class="line">            tjd_last = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        tjd_last = tjd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *tdb = time1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bary_earthp[i] = peb[i];</span><br><span class="line">        bary_earthv[i] = veb[i];</span><br><span class="line">        helio_earthp[i] = pes[i];</span><br><span class="line">        helio_earthv[i] = ves[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bary_to_geo</span><span class="params">(<span class="keyword">double</span> *pos, <span class="keyword">double</span> *earthvector, <span class="keyword">double</span> *pos2, <span class="keyword">double</span> *lighttime)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum_of_squares;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        pos2[j] = pos[j] - earthvector[j];</span><br><span class="line"></span><br><span class="line">    sum_of_squares = <span class="built_in">pow</span>(pos2[<span class="number">0</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos2[<span class="number">1</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos2[<span class="number">2</span>], <span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    *lighttime = <span class="built_in">sqrt</span>(sum_of_squares) / C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">sun_field</span><span class="params">(<span class="keyword">double</span> *pos, <span class="keyword">double</span> *earthvector, <span class="keyword">double</span> *pos2)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> f = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> p1mag, pemag, cosd, sind, b, bm, pqmag, zfinl, zinit,</span><br><span class="line">        xifinl, xiinit, delphi, delphp, delp, p1hat[<span class="number">3</span>], pehat[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> c = (C * MAU) / <span class="number">86400.0</span>;</span><br><span class="line"></span><br><span class="line">    p1mag = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[<span class="number">0</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos[<span class="number">1</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos[<span class="number">2</span>], <span class="number">2.0</span>));</span><br><span class="line">    pemag = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(earthvector[<span class="number">0</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(earthvector[<span class="number">1</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(earthvector[<span class="number">2</span>], <span class="number">2.0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1hat[j] = pos[j] / p1mag;</span><br><span class="line">        pehat[j] = earthvector[j] / pemag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cosd = -pehat[<span class="number">0</span>] * p1hat[<span class="number">0</span>] - pehat[<span class="number">1</span>] * p1hat[<span class="number">1</span>] - pehat[<span class="number">2</span>] * p1hat[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(cosd) &gt; <span class="number">0.9999999999</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            pos2[j] = pos[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sind = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - <span class="built_in">pow</span>(cosd, <span class="number">2.0</span>));</span><br><span class="line"></span><br><span class="line">        b = pemag * sind;</span><br><span class="line">        bm = b * MAU;</span><br><span class="line"></span><br><span class="line">        pqmag = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p1mag, <span class="number">2.0</span>) + <span class="built_in">pow</span>(pemag, <span class="number">2.0</span>) - <span class="number">2.0</span> * p1mag * pemag * cosd);</span><br><span class="line"></span><br><span class="line">        zfinl = pemag * cosd;</span><br><span class="line">        zinit = -p1mag + zfinl;</span><br><span class="line">        xifinl = zfinl / b;</span><br><span class="line">        xiinit = zinit / b;</span><br><span class="line"></span><br><span class="line">        delphi = <span class="number">2.0</span> * GS / (bm * c * c) * (xifinl / <span class="built_in">sqrt</span>(<span class="number">1.0</span> + <span class="built_in">pow</span>(xifinl, <span class="number">2.0</span>)) - xiinit / <span class="built_in">sqrt</span>(<span class="number">1.0</span> + <span class="built_in">pow</span>(xiinit, <span class="number">2.0</span>)));</span><br><span class="line"></span><br><span class="line">        delphp = delphi / (<span class="number">1.0</span> + (pemag / pqmag));</span><br><span class="line"></span><br><span class="line">        f = delphp * p1mag / sind;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            delp = f * (cosd * p1hat[j] + pehat[j]);</span><br><span class="line">            pos2[j] = pos[j] + delp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">aberration</span><span class="params">(<span class="keyword">double</span> *pos, <span class="keyword">double</span> *ve, <span class="keyword">double</span> lighttime, <span class="keyword">double</span> *pos2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p1mag, vemag, beta, dot, cosd, gammai, p, q, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lighttime == <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p1mag = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(pos[<span class="number">0</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos[<span class="number">1</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(pos[<span class="number">2</span>], <span class="number">2.0</span>));</span><br><span class="line">        lighttime = p1mag / C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p1mag = lighttime * C;</span><br><span class="line"></span><br><span class="line">    vemag = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(ve[<span class="number">0</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(ve[<span class="number">1</span>], <span class="number">2.0</span>) + <span class="built_in">pow</span>(ve[<span class="number">2</span>], <span class="number">2.0</span>));</span><br><span class="line">    beta = vemag / C;</span><br><span class="line">    dot = pos[<span class="number">0</span>] * ve[<span class="number">0</span>] + pos[<span class="number">1</span>] * ve[<span class="number">1</span>] + pos[<span class="number">2</span>] * ve[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    cosd = dot / (p1mag * vemag);</span><br><span class="line">    gammai = <span class="built_in">sqrt</span>(<span class="number">1.0</span> - <span class="built_in">pow</span>(beta, <span class="number">2.0</span>));</span><br><span class="line">    p = beta * cosd;</span><br><span class="line">    q = (<span class="number">1.0</span> + p / (<span class="number">1.0</span> + gammai)) * lighttime;</span><br><span class="line">    r = <span class="number">1.0</span> + p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        pos2[j] = (gammai * pos[j] + q * ve[j]) / r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">nutate</span><span class="params">(<span class="keyword">double</span> tjd, <span class="keyword">short</span> <span class="keyword">int</span> fn, <span class="keyword">double</span> *pos, <span class="keyword">double</span> *pos2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> cobm, sobm, cobt, sobt, cpsi, spsi, xx, yx, zx, xy, yy, zy, xz, yz, zz, oblm, oblt, eqeq, psi, eps;</span><br><span class="line"></span><br><span class="line">    earthtilt(tjd, &amp;oblm, &amp;oblt, &amp;eqeq, &amp;psi, &amp;eps);</span><br><span class="line"></span><br><span class="line">    cobm = <span class="built_in">cos</span>(oblm * DEG2RAD);</span><br><span class="line">    sobm = <span class="built_in">sin</span>(oblm * DEG2RAD);</span><br><span class="line">    cobt = <span class="built_in">cos</span>(oblt * DEG2RAD);</span><br><span class="line">    sobt = <span class="built_in">sin</span>(oblt * DEG2RAD);</span><br><span class="line">    cpsi = <span class="built_in">cos</span>(psi / RAD2SEC);</span><br><span class="line">    spsi = <span class="built_in">sin</span>(psi / RAD2SEC);</span><br><span class="line"></span><br><span class="line">    xx = cpsi;</span><br><span class="line">    yx = -spsi * cobm;</span><br><span class="line">    zx = -spsi * sobm;</span><br><span class="line">    xy = spsi * cobt;</span><br><span class="line">    yy = cpsi * cobm * cobt + sobm * sobt;</span><br><span class="line">    zy = cpsi * sobm * cobt - cobm * sobt;</span><br><span class="line">    xz = spsi * sobt;</span><br><span class="line">    yz = cpsi * cobm * sobt - sobm * cobt;</span><br><span class="line">    zz = cpsi * sobm * sobt + cobm * cobt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fn)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        pos2[<span class="number">0</span>] = xx * pos[<span class="number">0</span>] + yx * pos[<span class="number">1</span>] + zx * pos[<span class="number">2</span>];</span><br><span class="line">        pos2[<span class="number">1</span>] = xy * pos[<span class="number">0</span>] + yy * pos[<span class="number">1</span>] + zy * pos[<span class="number">2</span>];</span><br><span class="line">        pos2[<span class="number">2</span>] = xz * pos[<span class="number">0</span>] + yz * pos[<span class="number">1</span>] + zz * pos[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        pos2[<span class="number">0</span>] = xx * pos[<span class="number">0</span>] + xy * pos[<span class="number">1</span>] + xz * pos[<span class="number">2</span>];</span><br><span class="line">        pos2[<span class="number">1</span>] = yx * pos[<span class="number">0</span>] + yy * pos[<span class="number">1</span>] + yz * pos[<span class="number">2</span>];</span><br><span class="line">        pos2[<span class="number">2</span>] = zx * pos[<span class="number">0</span>] + zy * pos[<span class="number">1</span>] + zz * pos[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="keyword">int</span> <span class="title">app_star</span><span class="params">(<span class="keyword">double</span> tjd, cat_entry *star, <span class="keyword">double</span> *ra, <span class="keyword">double</span> *dec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> tdb, time2, peb[<span class="number">3</span>], veb[<span class="number">3</span>], pes[<span class="number">3</span>], ves[<span class="number">3</span>], pos1[<span class="number">3</span>], pos2[<span class="number">3</span>],</span><br><span class="line">        pos3[<span class="number">3</span>], pos4[<span class="number">3</span>], pos5[<span class="number">3</span>], pos6[<span class="number">3</span>], pos7[<span class="number">3</span>], vel1[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error = get_earth(tjd, &amp;tdb, peb, veb, pes, ves))</span><br><span class="line">    &#123;</span><br><span class="line">        *ra = <span class="number">0.0</span>;</span><br><span class="line">        *dec = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    starvectors(star, pos1, vel1);</span><br><span class="line">    proper_motion(T0, pos1, vel1, tdb, pos2);</span><br><span class="line"></span><br><span class="line">    bary_to_geo(pos2, peb, pos3, &amp;time2);</span><br><span class="line">    sun_field(pos3, pes, pos4);</span><br><span class="line">    aberration(pos4, veb, time2, pos5);</span><br><span class="line">    precession(T0, pos5, tdb, pos6);</span><br><span class="line">    nutate(tdb, FN0, pos6, pos7);</span><br><span class="line"></span><br><span class="line">    vector2radec(pos7, ra, dec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spin</span><span class="params">(<span class="keyword">double</span> st, <span class="keyword">double</span> *pos1, <span class="keyword">double</span> *pos2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> str, cosst, sinst, xx, yx, xy, yy;</span><br><span class="line"></span><br><span class="line">    str = st * <span class="number">15.0</span> * DEG2RAD;</span><br><span class="line">    cosst = <span class="built_in">cos</span>(str);</span><br><span class="line">    sinst = <span class="built_in">sin</span>(str);</span><br><span class="line"></span><br><span class="line">    xx = cosst;</span><br><span class="line">    yx = -sinst;</span><br><span class="line">    xy = sinst;</span><br><span class="line">    yy = cosst;</span><br><span class="line"></span><br><span class="line">    pos2[<span class="number">0</span>] = xx * pos1[<span class="number">0</span>] + yx * pos1[<span class="number">1</span>];</span><br><span class="line">    pos2[<span class="number">1</span>] = xy * pos1[<span class="number">0</span>] + yy * pos1[<span class="number">1</span>];</span><br><span class="line">    pos2[<span class="number">2</span>] = pos1[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pnsw</span><span class="params">(<span class="keyword">double</span> gast, <span class="keyword">double</span> *vece, <span class="keyword">double</span> *vecs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> dummy, v1[<span class="number">3</span>], v2[<span class="number">3</span>], v3[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        v1[j] = vece[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gast == <span class="number">0.0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">            v2[j] = v1[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        spin(gast, v1, v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">        vecs[j] = v2[j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sidereal_time</span><span class="params">(<span class="keyword">double</span> jd_high, <span class="keyword">double</span> ee, <span class="keyword">double</span> *gst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> t_hi, t_lo, t, t2, t3, st;</span><br><span class="line"></span><br><span class="line">    t_hi = (jd_high - T0) / <span class="number">36525.0</span>;</span><br><span class="line">    t_lo = <span class="number">0</span>;</span><br><span class="line">    t = t_hi;</span><br><span class="line">    t2 = t * t;</span><br><span class="line">    t3 = t2 * t;</span><br><span class="line"></span><br><span class="line">    st = ee - <span class="number">6.2e-6</span> * t3 + <span class="number">0.093104</span> * t2 + <span class="number">67310.54841</span> + <span class="number">8640184.812866</span> * t_lo + <span class="number">3155760000.0</span> * t_lo + <span class="number">8640184.812866</span> * t_hi + <span class="number">3155760000.0</span> * t_hi;</span><br><span class="line"></span><br><span class="line">    *gst = <span class="built_in">fmod</span>((st / <span class="number">3600.0</span>), <span class="number">24.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*gst &lt; <span class="number">0.0</span>)</span><br><span class="line">        *gst += <span class="number">24.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equ2hor</span><span class="params">(<span class="keyword">double</span> tjd, site_info *location, <span class="keyword">double</span> ra, <span class="keyword">double</span> dec, <span class="keyword">double</span> *zd, <span class="keyword">double</span> *az, <span class="keyword">double</span> *rar, <span class="keyword">double</span> *decr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ujd, dummy, secdiff, tdb, mobl, tobl, ee, dpsi, deps, gast,</span><br><span class="line">        sinlat, coslat, sinlon, coslon, sindc, cosdc, sinra, cosra,</span><br><span class="line">        uze[<span class="number">3</span>], une[<span class="number">3</span>], uwe[<span class="number">3</span>], uz[<span class="number">3</span>], un[<span class="number">3</span>], uw[<span class="number">3</span>], p[<span class="number">3</span>], pz, pn, pw,</span><br><span class="line">        proj, zd0, zd1, refr, cosr, prlen, rlen, pr[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    ujd = tjd;</span><br><span class="line"></span><br><span class="line">    tdb2tdt(tjd, &amp;dummy, &amp;secdiff);</span><br><span class="line">    tdb = tjd + secdiff / <span class="number">86400.0</span>;</span><br><span class="line"></span><br><span class="line">    earthtilt(tdb, &amp;mobl, &amp;tobl, &amp;ee, &amp;dpsi, &amp;deps);</span><br><span class="line"></span><br><span class="line">    sidereal_time(ujd, ee, &amp;gast);</span><br><span class="line">    *rar = ra;</span><br><span class="line">    *decr = dec;</span><br><span class="line"></span><br><span class="line">    sinlat = <span class="built_in">sin</span>(location-&gt;latitude * DEG2RAD);</span><br><span class="line">    coslat = <span class="built_in">cos</span>(location-&gt;latitude * DEG2RAD);</span><br><span class="line">    sinlon = <span class="built_in">sin</span>(location-&gt;longitude * DEG2RAD);</span><br><span class="line">    coslon = <span class="built_in">cos</span>(location-&gt;longitude * DEG2RAD);</span><br><span class="line">    sindc = <span class="built_in">sin</span>(dec * DEG2RAD);</span><br><span class="line">    cosdc = <span class="built_in">cos</span>(dec * DEG2RAD);</span><br><span class="line">    sinra = <span class="built_in">sin</span>(ra * <span class="number">15.0</span> * DEG2RAD);</span><br><span class="line">    cosra = <span class="built_in">cos</span>(ra * <span class="number">15.0</span> * DEG2RAD);</span><br><span class="line"></span><br><span class="line">    uze[<span class="number">0</span>] = coslat * coslon;</span><br><span class="line">    uze[<span class="number">1</span>] = coslat * sinlon;</span><br><span class="line">    uze[<span class="number">2</span>] = sinlat;</span><br><span class="line">    une[<span class="number">0</span>] = -sinlat * coslon;</span><br><span class="line">    une[<span class="number">1</span>] = -sinlat * sinlon;</span><br><span class="line">    une[<span class="number">2</span>] = coslat;</span><br><span class="line"></span><br><span class="line">    uwe[<span class="number">0</span>] = sinlon;</span><br><span class="line">    uwe[<span class="number">1</span>] = -coslon;</span><br><span class="line">    uwe[<span class="number">2</span>] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    pnsw(gast, uze, uz);</span><br><span class="line">    pnsw(gast, une, un);</span><br><span class="line">    pnsw(gast, uwe, uw);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = cosdc * cosra;</span><br><span class="line">    p[<span class="number">1</span>] = cosdc * sinra;</span><br><span class="line">    p[<span class="number">2</span>] = sindc;</span><br><span class="line"></span><br><span class="line">    pz = p[<span class="number">0</span>] * uz[<span class="number">0</span>] + p[<span class="number">1</span>] * uz[<span class="number">1</span>] + p[<span class="number">2</span>] * uz[<span class="number">2</span>];</span><br><span class="line">    pn = p[<span class="number">0</span>] * un[<span class="number">0</span>] + p[<span class="number">1</span>] * un[<span class="number">1</span>] + p[<span class="number">2</span>] * un[<span class="number">2</span>];</span><br><span class="line">    pw = p[<span class="number">0</span>] * uw[<span class="number">0</span>] + p[<span class="number">1</span>] * uw[<span class="number">1</span>] + p[<span class="number">2</span>] * uw[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    proj = <span class="built_in">sqrt</span>(pn * pn + pw * pw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (proj &gt; <span class="number">0.0</span>)</span><br><span class="line">        *az = -<span class="built_in">atan2</span>(pw, pn) * RAD2DEG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*az &lt; <span class="number">0.0</span>)</span><br><span class="line">        *az += <span class="number">360.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*az &gt;= <span class="number">360.0</span>)</span><br><span class="line">        *az -= <span class="number">360.0</span>;</span><br><span class="line"></span><br><span class="line">    *zd = <span class="built_in">atan2</span>(proj, pz) * RAD2DEG;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">julian_date</span><span class="params">(<span class="keyword">short</span> <span class="keyword">int</span> year, <span class="keyword">short</span> <span class="keyword">int</span> month, <span class="keyword">short</span> <span class="keyword">int</span> day, <span class="keyword">double</span> hour)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> jd12h = (<span class="keyword">long</span>)day - <span class="number">32075L</span> + <span class="number">1461L</span> * ((<span class="keyword">long</span>)year + <span class="number">4800L</span> + ((<span class="keyword">long</span>)month - <span class="number">14L</span>) / <span class="number">12L</span>) / <span class="number">4L</span> + <span class="number">367L</span> * ((<span class="keyword">long</span>)month - <span class="number">2L</span> - ((<span class="keyword">long</span>)month - <span class="number">14L</span>) / <span class="number">12L</span> * <span class="number">12L</span>) / <span class="number">12L</span> - <span class="number">3L</span> * (((<span class="keyword">long</span>)year + <span class="number">4900L</span> + ((<span class="keyword">long</span>)month - <span class="number">14L</span>) / <span class="number">12L</span>) / <span class="number">100L</span>) / <span class="number">4L</span>;</span><br><span class="line">    <span class="keyword">double</span> tjd = (<span class="keyword">double</span>)jd12h - <span class="number">0.5</span> + hour / <span class="number">24.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (tjd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// convert(hip_ra, hip_dec, hip_promora, hip_promodec, hip_parallax, fk5_ra, fk5_dec);</span></span><br><span class="line">    cat_entry hip = &#123;<span class="number">113368</span>, <span class="number">6.011119421</span> / TWOPI * <span class="number">360</span>, <span class="number">-0.516998583</span> / TWOPI * <span class="number">360</span>, <span class="number">328.95</span>, <span class="number">-164.67</span>, <span class="number">129.81</span>, <span class="number">0</span>&#125;; <span class="comment">// &quot;hi&quot;, &quot;beiluoshimen&quot;</span></span><br><span class="line">    <span class="comment">// cat_entry hip = &#123;&quot;ho&quot;, &quot;niulang&quot;, 97649, 5.195749333 / TWOPI * 360, 0.15476506 / TWOPI * 360, 536.23, 385.29, 194.95, 0&#125;;</span></span><br><span class="line">    <span class="comment">// cat_entry hip = &#123;&quot;hi&quot;, &quot;tianhezuo&quot;, 109268, 5.79550224 / TWOPI * 360, -0.819617367 / TWOPI * 360, 126.69, -147.47, 32.29, 0&#125;;</span></span><br><span class="line">    cat_entry fk5;</span><br><span class="line">    site_info loc = &#123;<span class="number">32.08</span>, <span class="number">118.8</span>&#125;; <span class="comment">// 温度10摄氏度 高度10米 大气压1013毫巴=1013百帕</span></span><br><span class="line">    transform_hip(&amp;hip, &amp;fk5);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fk5.ra &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fk5.dec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> now;</span><br><span class="line">    tm *utc;</span><br><span class="line">    <span class="keyword">double</span> tjd, ra, dec, zd, az, rar, decr, rah;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        now = time(<span class="number">0</span>);</span><br><span class="line">        utc = gmtime(&amp;now);</span><br><span class="line">        tjd = julian_date(<span class="number">1900</span> + utc-&gt;tm_year, <span class="number">1</span> + utc-&gt;tm_mon, utc-&gt;tm_mday, utc-&gt;tm_hour + utc-&gt;tm_min / <span class="number">60.0</span> + utc-&gt;tm_sec / <span class="number">3600.0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>) &lt;&lt; tjd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// double tjd = 2459921.90082;</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; tjd &quot;</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>) &lt;&lt; tjd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        app_star(tjd, &amp;fk5, &amp;ra, &amp;dec);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ra &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; dec &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        equ2hor(tjd, &amp;loc, ra, dec, &amp;zd, &amp;az, &amp;rar, &amp;decr);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">90</span> - zd &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; az &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; zd 高度 : &quot;</span> &lt;&lt; <span class="keyword">int</span>(<span class="number">90</span> - zd) &lt;&lt; <span class="string">&quot; ram: &quot;</span> &lt;&lt; <span class="keyword">int</span>((<span class="number">90</span> - zd - <span class="keyword">int</span>(<span class="number">90</span> - zd)) * <span class="number">60</span>) &lt;&lt; <span class="string">&quot; ras: &quot;</span> &lt;&lt; <span class="number">60</span> * ((<span class="number">90</span> - zd - <span class="keyword">int</span>(<span class="number">90</span> - zd)) * <span class="number">60</span> - <span class="keyword">int</span>((<span class="number">90</span> - zd - <span class="keyword">int</span>(<span class="number">90</span> - zd)) * <span class="number">60</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; az 方位 : &quot;</span> &lt;&lt; <span class="keyword">int</span>(az) &lt;&lt; <span class="string">&quot; ram: &quot;</span> &lt;&lt; <span class="keyword">int</span>((az - <span class="keyword">int</span>(az)) * <span class="number">60</span>) &lt;&lt; <span class="string">&quot; ras: &quot;</span> &lt;&lt; <span class="number">60</span> * ((az - <span class="keyword">int</span>(az)) * <span class="number">60</span> - <span class="keyword">int</span>((az - <span class="keyword">int</span>(az)) * <span class="number">60</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// double tdb,</span></span><br><span class="line">    <span class="comment">//     time2, peb[3], veb[3], pes[3], ves[3], pos1[3], pos2[3], pos3[3], pos4[3], pos5[3], pos6[3], pos7[3], vel1[3];</span></span><br><span class="line"></span><br><span class="line">    rah = ra;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot; ra: &quot; &lt;&lt; fk5_ra;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; rah: &quot;</span> &lt;&lt; <span class="keyword">int</span>(rah) &lt;&lt; <span class="string">&quot; ram: &quot;</span> &lt;&lt; <span class="keyword">int</span>((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span>) &lt;&lt; <span class="string">&quot; ras: &quot;</span> &lt;&lt; <span class="number">60</span> * ((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span> - <span class="keyword">int</span>((rah - <span class="keyword">int</span>(rah)) * <span class="number">60</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; fk5_dec &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">double</span> dech = dec;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; dech: &quot;</span> &lt;&lt; (dech &lt; <span class="number">0</span> ? <span class="string">&quot;-&quot;</span> : <span class="string">&quot;&quot;</span>) &lt;&lt; <span class="built_in">abs</span>(<span class="keyword">int</span>(dech)) &lt;&lt; <span class="string">&quot; ram: &quot;</span> &lt;&lt; <span class="built_in">abs</span>(<span class="keyword">int</span>((dech - <span class="keyword">int</span>(dech)) * <span class="number">60</span>)) &lt;&lt; <span class="string">&quot; ras: &quot;</span> &lt;&lt; <span class="built_in">abs</span>(<span class="number">60</span> * ((dech - <span class="keyword">int</span>(dech)) * <span class="number">60</span> - <span class="keyword">int</span>((dech - <span class="keyword">int</span>(dech)) * <span class="number">60</span>))) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冲毕业第二、三周记录</title>
      <link href="2022/12/06/blog67-study2/"/>
      <url>2022/12/06/blog67-study2/</url>
      
        <content type="html"><![CDATA[<p>中文网站上介绍星图绘制的文章挺少的，知乎这个系列介绍的挺好的</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221123135230526.png" alt="image-20221123135230526"></p><p><a href="https://zhuanlan.zhihu.com/p/82496762">https://zhuanlan.zhihu.com/p/82496762</a></p><p>下载Hipparcos Catalog，用python进行简单处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">user_cols = [<span class="string">&#x27;hip&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;ra&#x27;</span>, <span class="string">&#x27;de&#x27;</span>, <span class="string">&#x27;plx&#x27;</span>, <span class="string">&#x27;pmra&#x27;</span>, <span class="string">&#x27;pmde&#x27;</span>, <span class="string">&#x27;era&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;ede&#x27;</span>, <span class="string">&#x27;eplx&#x27;</span>, <span class="string">&#x27;epmra&#x27;</span>, <span class="string">&#x27;epmde&#x27;</span>, <span class="string">&#x27;ntr&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;var&#x27;</span>, <span class="string">&#x27;ic&#x27;</span>, <span class="string">&#x27;hpmag&#x27;</span>, <span class="string">&#x27;ehpmag&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df = pd.read_table(<span class="string">&quot;hip2.dat&quot;</span>, sep=<span class="string">&#x27;\s+&#x27;</span>, header=<span class="literal">None</span>,</span><br><span class="line">                   engine=<span class="string">&#x27;python&#x27;</span>, index_col=<span class="number">0</span>, usecols=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">21</span>)), names=user_cols)</span><br><span class="line"></span><br><span class="line">print(df.shape)</span><br><span class="line">print(df.head())</span><br><span class="line">df1 = df[df.hpmag &lt;= <span class="number">6</span>]</span><br><span class="line">print(df1.shape)</span><br><span class="line">print(df1.head())</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(117955, 20)</span><br><span class="line">     a2  a3  a4        ra        de    plx    pmra  pmde   era   ede  eplx  epmra  epmde  ntr    f2  f1  var  ic   hpmag  ehpmag</span><br><span class="line">hip</span><br><span class="line">1     5   0   1  0.000016  0.019007   4.55   -4.55 -1.19  1.29  0.66  1.33   1.25   0.75   90  0.91   0  0.0   0  9.2043  0.0020</span><br><span class="line">2    75   4   1  0.000066 -0.340319  20.85  182.88 -1.31  0.95  0.53  1.13   1.22   0.66  121  0.06   0  0.0   0  9.4017  0.0017</span><br><span class="line">3     5   0   1  0.000087  0.678222   2.26    4.27 -3.43  0.31  0.21  0.36   0.34   0.27  129  1.56   0  0.0   0  6.6081  0.0006</span><br><span class="line">4     5   0   1  0.000146 -0.905713   7.45   62.64  0.19  0.40  0.47  0.77   0.51   0.51  205 -1.50   0  0.0   0  8.1498  0.0011</span><br><span class="line">5     5   0   1  0.000174 -0.708451   3.88    1.89  8.06  0.55  0.50  0.95   0.58   0.64  163  0.36   0  0.0   0  8.7077  0.0018</span><br><span class="line">(4559, 20)</span><br><span class="line">     a2  a3  a4        ra        de    plx   pmra    pmde   era   ede  eplx  epmra  epmde  ntr    f2  f1  var  ic   hpmag  ehpmag</span><br><span class="line">hip</span><br><span class="line">88    5   0   1  0.004698 -0.851893   5.50 -18.36   -5.82  0.26  0.29  0.48   0.46   0.38  157  4.38   0  0.0   0  5.8690  0.0006</span><br><span class="line">107   5   0   1  0.005826 -0.878553   6.01   7.88   11.40  0.21  0.20  0.32   0.25   0.24  170  1.00   0  0.0   0  5.6243  0.0012</span><br><span class="line">122   5   0   1  0.006970 -1.345043  15.02 -57.30 -177.06  0.16  0.14  0.18   0.19   0.15  142 -0.13   1  0.0   0  4.9354  0.0006</span><br><span class="line">124   5   0   1  0.007055  1.068540   1.06  -3.14   -0.74  0.20  0.19  0.27   0.26   0.21  153  1.28   0  0.0   0  5.6725  0.0006</span><br><span class="line">145   5   0   1  0.007959 -0.052839   7.18  19.08   -9.66  0.28  0.17  0.30   0.32   0.16  100  1.86   0  0.0   0  5.0831  0.0006</span><br></pre></td></tr></table></figure><p>完整处理为一个csv文件</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">user_cols = [<span class="string">&#x27;hip&#x27;</span>, <span class="string">&#x27;a2&#x27;</span>, <span class="string">&#x27;a3&#x27;</span>, <span class="string">&#x27;a4&#x27;</span>, <span class="string">&#x27;ra&#x27;</span>, <span class="string">&#x27;de&#x27;</span>, <span class="string">&#x27;plx&#x27;</span>, <span class="string">&#x27;pmra&#x27;</span>, <span class="string">&#x27;pmde&#x27;</span>, <span class="string">&#x27;era&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;ede&#x27;</span>, <span class="string">&#x27;eplx&#x27;</span>, <span class="string">&#x27;epmra&#x27;</span>, <span class="string">&#x27;epmde&#x27;</span>, <span class="string">&#x27;ntr&#x27;</span>, <span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;var&#x27;</span>, <span class="string">&#x27;ic&#x27;</span>, <span class="string">&#x27;hpmag&#x27;</span>, <span class="string">&#x27;ehpmag&#x27;</span>]</span><br><span class="line"></span><br><span class="line">df = pd.read_table(<span class="string">&quot;hip2.dat&quot;</span>, sep=<span class="string">&#x27;\s+&#x27;</span>, header=<span class="literal">None</span>,</span><br><span class="line">                   engine=<span class="string">&#x27;python&#x27;</span>, index_col=<span class="number">0</span>, usecols=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">21</span>)), names=user_cols)</span><br><span class="line"></span><br><span class="line">print(df.shape)</span><br><span class="line">print(df.head())</span><br><span class="line"></span><br><span class="line">df1 = df[df.hpmag &lt;= <span class="number">6</span>]</span><br><span class="line">print(df1.shape)</span><br><span class="line"><span class="comment"># print(df1.head())</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df2 = df1[df1.a4 == <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">tmp = df2[<span class="string">&#x27;ra&#x27;</span>] * <span class="number">180</span> / math.pi</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_d&#x27;</span>, tmp)</span><br><span class="line">tmp = df2[<span class="string">&#x27;ra_d&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_dh&#x27;</span>, tmp)</span><br><span class="line">tmp = ((df2[<span class="string">&#x27;ra_d&#x27;</span>] - df2[<span class="string">&#x27;ra_dh&#x27;</span>]) * <span class="number">60</span>).astype(<span class="built_in">int</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_dm&#x27;</span>, tmp)</span><br><span class="line">tmp = (((df2[<span class="string">&#x27;ra_d&#x27;</span>] - df2[<span class="string">&#x27;ra_dh&#x27;</span>]) * <span class="number">60</span>-df2[<span class="string">&#x27;ra_dm&#x27;</span>])*<span class="number">60</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_ds&#x27;</span>, tmp)</span><br><span class="line"></span><br><span class="line">tmp = df2[<span class="string">&#x27;ra&#x27;</span>] * <span class="number">24</span> / <span class="number">2</span> / math.pi</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_t&#x27;</span>, tmp)</span><br><span class="line">tmp = df2[<span class="string">&#x27;ra_t&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_th&#x27;</span>, tmp)</span><br><span class="line">tmp = ((df2[<span class="string">&#x27;ra_t&#x27;</span>] - df2[<span class="string">&#x27;ra_th&#x27;</span>]) * <span class="number">60</span>).astype(<span class="built_in">int</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_tm&#x27;</span>, tmp)</span><br><span class="line">tmp = (((df2[<span class="string">&#x27;ra_t&#x27;</span>] - df2[<span class="string">&#x27;ra_th&#x27;</span>]) * <span class="number">60</span>-df2[<span class="string">&#x27;ra_tm&#x27;</span>])*<span class="number">60</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;ra_ts&#x27;</span>, tmp)</span><br><span class="line"></span><br><span class="line">tmp = df2[<span class="string">&#x27;de&#x27;</span>] * <span class="number">180</span> / math.pi</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;de_d&#x27;</span>, tmp)</span><br><span class="line">tmp = df2[<span class="string">&#x27;de_d&#x27;</span>].astype(<span class="built_in">int</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;de_dh&#x27;</span>, tmp)</span><br><span class="line">tmp = <span class="built_in">abs</span>((df2[<span class="string">&#x27;de_d&#x27;</span>] - df2[<span class="string">&#x27;de_dh&#x27;</span>]) * <span class="number">60</span>).astype(<span class="built_in">int</span>)</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;de_dm&#x27;</span>, tmp)</span><br><span class="line">tmp = <span class="built_in">abs</span>(((<span class="built_in">abs</span>(df2[<span class="string">&#x27;de_d&#x27;</span>] - df2[<span class="string">&#x27;de_dh&#x27;</span>]) * <span class="number">60</span>-<span class="built_in">abs</span>(df2[<span class="string">&#x27;de_dm&#x27;</span>]))*<span class="number">60</span>))</span><br><span class="line">df2.insert(df2.shape[<span class="number">1</span>], <span class="string">&#x27;de_ds&#x27;</span>, tmp)</span><br><span class="line"></span><br><span class="line">print(df2.shape)</span><br><span class="line">print(df2.head())</span><br><span class="line"></span><br><span class="line">df2.to_csv(<span class="string">&quot;df2.csv&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221123175438847.png" alt="image-20221123175438847"></p><p>生成4006个星等 小于等于6 的 单星。</p><p>研究换算公式</p><p>坐标系ICRS与ITRS相互转换，时间系统及转换 <a href="https://blog.csdn.net/wokaowokaowokao12345/article/details/127211085">https://blog.csdn.net/wokaowokaowokao12345/article/details/127211085</a></p><p>研究sofa</p><p><a href="https://zhuanlan.zhihu.com/p/226482319">https://zhuanlan.zhihu.com/p/226482319</a></p><p><a href="http://www.iausofa.org/tandc.html">http://www.iausofa.org/tandc.html</a></p><p><a href="http://www.iausofa.org/2021_0512_C.html">http://www.iausofa.org/2021_0512_C.html</a></p><hr><p>处理星表文件 stars_0_0v0_8.cat，136KB -&gt;139524位 </p><p>139524 =32 + 20 <em> 4 + 4979 </em> 28 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221125114703130.png" alt="image-20221125114703130"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221125142052077.png" alt="image-20221125142052077"></p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[output]</span> = <span class="title">myFunc</span><span class="params">(A, start, num)</span></span></span><br><span class="line">beishu = <span class="number">1</span>;</span><br><span class="line">output = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : num</span><br><span class="line">  output = output + A(start + <span class="built_in">i</span> - <span class="number">1</span>) * beishu;</span><br><span class="line">  beishu = beishu * <span class="number">256</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clear all; close all;</span><br><span class="line">fileID = fopen(<span class="string">&#x27;stars_0_0v0_8.cat&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">A = fread(fileID,<span class="string">&#x27;ubit8&#x27;</span>); <span class="comment">% bytes 139524 = 32 + 20 * 4 + 4979 * 28;</span></span><br><span class="line"></span><br><span class="line">FileHeaderRecord = A(<span class="number">1</span>:<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">magic</span> = FileHeaderRecord(<span class="number">1</span>:<span class="number">4</span>);</span><br><span class="line">datatype = myFunc(A, <span class="number">5</span>, <span class="number">4</span>);</span><br><span class="line">MajorVersion = myFunc(A, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">MinorVersion = myFunc(A, <span class="number">13</span>, <span class="number">4</span>);</span><br><span class="line">Level = myFunc(A, <span class="number">17</span>, <span class="number">4</span>);</span><br><span class="line">MagnitudeMinimum = myFunc(A, <span class="number">21</span>, <span class="number">4</span>);</span><br><span class="line">MagnitudeMinimum = MagnitudeMinimum - <span class="number">4294967296</span>;</span><br><span class="line">MagnitudeRange = myFunc(A, <span class="number">25</span>, <span class="number">4</span>);</span><br><span class="line">MagnitudeStep = myFunc(A, <span class="number">29</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">n=<span class="number">1</span>:<span class="number">20</span>;</span><br><span class="line">num(n) = myFunc(A, <span class="number">29</span>+n*<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">sum = sum(num);</span><br><span class="line"></span><br><span class="line">k = <span class="number">1</span>:<span class="number">4979</span>;</span><br><span class="line">hip(k) = myFunc(A, <span class="number">85</span> + k *<span class="number">28</span>, <span class="number">3</span>);</span><br><span class="line">component_ids(k) = A(<span class="number">88</span> + k *<span class="number">28</span>);</span><br><span class="line">x0(k)= myFunc(A, <span class="number">89</span> + k *<span class="number">28</span>, <span class="number">4</span>);</span><br><span class="line">x0(x0(k) &gt; intmax) = x0(x0(k) &gt; intmax) - <span class="number">4294967296</span>;</span><br><span class="line">x1(k)= myFunc(A, <span class="number">93</span> + k *<span class="number">28</span>, <span class="number">4</span>);</span><br><span class="line">x1(x1(k) &gt; intmax) = x1(x1(k) &gt; intmax) - <span class="number">4294967296</span>;</span><br><span class="line">b_v(k)= A(<span class="number">97</span> + k *<span class="number">28</span>);</span><br><span class="line">mag(k)= A(<span class="number">98</span>+ k *<span class="number">28</span>);</span><br><span class="line">mag_<span class="built_in">true</span>(k) = mag(k)*<span class="number">0.05</span><span class="number">-2</span>;</span><br><span class="line">sp_int(k) = myFunc(A, <span class="number">99</span>+ k *<span class="number">28</span>, <span class="number">2</span>);</span><br><span class="line">dx0(k) = myFunc(A, <span class="number">101</span>+ k *<span class="number">28</span>, <span class="number">4</span>);</span><br><span class="line">dx1(k) = myFunc(A, <span class="number">105</span>+ k *<span class="number">28</span>, <span class="number">4</span>);</span><br><span class="line">plx(k) = myFunc(A, <span class="number">109</span>+ k *<span class="number">28</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x00 = x0 ./MagnitudeMinimum;</span><br><span class="line">x11 = x1 ./MagnitudeMinimum;</span><br><span class="line"></span><br><span class="line">hebing = [hip.&#x27; component_ids.&#x27; x0.&#x27; x1.&#x27; b_v.&#x27; mag.&#x27; mag_true.&#x27; sp_int.&#x27; dx0.&#x27; dx1.&#x27; plx.&#x27; x00.&#x27; x11.&#x27;];</span><br><span class="line"><span class="comment">% xlswrite(&#x27;test.xlsx&#x27;,hebing);</span></span><br><span class="line"></span><br><span class="line">fclose(fileID);</span><br></pre></td></tr></table></figure><p>20个zone的星数为</p><p>184    174    317    235    209    254    201    210    311    341    179    158    298    383    290    206    165    346    293    225</p><p>总和为4979</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221125230432393.png" alt="image-20221125230432393"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221125153158442.png" alt="image-20221125153158442"></p><p>验证了hip 和星图和星等。</p><hr><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\gui\SkyGui.cpp</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void InfoPanel::setTextFromObjects(const QList&lt; StelObjectP &gt;&amp; selected) &#123;</span><br><span class="line"></span><br><span class="line">  138,28: QString s &#x3D; selected[0]-&gt;getInfoString(core, infoTextFilters);</span><br></pre></td></tr></table></figure><p>StarWrapper.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">StarWrapper1::getInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *core, <span class="keyword">const</span> InfoStringGroup&amp; flags)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">oss &lt;&lt; getCommonInfoString(core, flags);</span><br></pre></td></tr></table></figure><p>调用StelObject.cpp的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QString StelObject::getCommonInfoString(const StelCore *core, const InfoStringGroup&amp; flags) const &#123;</span><br></pre></td></tr></table></figure><p>StelCore *core = StelApp::getInstance().getCore();</p><p>QFlags<StelObject::InfoStringGroupFlags>(Name|CatalogNumber|Magnitude|RaDecJ2000|RaDecOfDate|AltAzi|Distance|Elongation|Size|Velocity|ProperMotion|Extra|HourAngle|AbsoluteMagnitude|GalacticCoord|SupergalacticCoord|OtherCoord|ObjectType|EclipticCoordJ2000|EclipticCoordOfDate|IAUConstellation|SiderealTime|RTSTime|SolarLunarPosition)</p><p>在wrapper中的getAltAzPosApparent(core) 可以得到， s-&gt;getHip()也能得到 那么select 到底是怎么关联过来的呢</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221126191150684.png" alt="image-20221126191150684"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StelUtils::rectToSphe(&amp;az, &amp;alt, getAltAzPosGeometric(core));</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (flags &amp; AltAzi) &#123;</span><br><span class="line">        <span class="comment">// calculate alt az</span></span><br><span class="line">        <span class="keyword">double</span> az, alt;</span><br><span class="line">        StelUtils::rectToSphe(&amp;az, &amp;alt, getAltAzPosGeometric(core));</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot; 0 &quot;</span> &lt;&lt; az &lt;&lt; alt;</span><br><span class="line">        <span class="keyword">double</span> direction = <span class="number">3.</span>; <span class="comment">// N is zero, E is 90 degrees</span></span><br><span class="line">        <span class="keyword">if</span> (useSouthAzimuth)</span><br><span class="line">            direction = <span class="number">2.</span>;</span><br><span class="line">        az = direction * M_PI - az;</span><br><span class="line">        <span class="keyword">if</span> (az &gt; M_PI * <span class="number">2</span>)</span><br><span class="line">            az -= M_PI * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (withAtmosphere &amp;&amp; (alt_app &gt; <span class="number">-2.0</span> * M_PI / <span class="number">180.0</span>)) &#123; <span class="comment">// Don&#x27;t show refracted altitude much below horizon where model is meaningless.</span></span><br><span class="line">            <span class="keyword">if</span> (withDecimalDegree) &#123;</span><br><span class="line">                firstCoordinate  = StelUtils::radToDecDegStr(az);</span><br><span class="line">                secondCoordinate = StelUtils::radToDecDegStr(alt_app);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                firstCoordinate  = StelUtils::radToDmsStr(az, <span class="literal">true</span>);</span><br><span class="line">                secondCoordinate = StelUtils::radToDmsStr(alt_app, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (withDecimalDegree) &#123;</span><br><span class="line">                firstCoordinate  = StelUtils::radToDecDegStr(az);</span><br><span class="line">                secondCoordinate = StelUtils::radToDecDegStr(alt);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                firstCoordinate  = StelUtils::radToDmsStr(az, <span class="literal">true</span>);</span><br><span class="line">                secondCoordinate = StelUtils::radToDmsStr(alt, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TRANSLATORS: Azimuth/Altitude</span></span><br><span class="line">        <span class="keyword">const</span> QString AzAlt = (withDesignations ? <span class="string">&quot;A/a&quot;</span> : qc_(<span class="string">&quot;Az./Alt.&quot;</span>, <span class="string">&quot;celestial coordinate system&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (withTables)</span><br><span class="line">            res += QString(<span class="string">&quot;&lt;tr&gt;&lt;td&gt;%1:&lt;/td&gt;&lt;td style=&#x27;text-align:right;&#x27;&gt;%2/&lt;/td&gt;&lt;td style=&#x27;text-align:right;&#x27;&gt;%3&lt;/td&gt;&lt;td&gt;%4&lt;/td&gt;&lt;/tr&gt;&quot;</span>).arg(AzAlt, firstCoordinate, secondCoordinate, apparent);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            res += QString(<span class="string">&quot;%1: %2/%3 %4&lt;br/&gt;&quot;</span>).arg(AzAlt, firstCoordinate, secondCoordinate, apparent);</span><br><span class="line">        res += getExtraInfoStrings(AltAzi).join(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//        qDebug() &lt;&lt; &quot; 1 &quot; &lt;&lt; res; // 高度方位</span></span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot; 1 &quot;</span> &lt;&lt; QString(<span class="string">&quot;%1: %2/%3 %4&lt;br/&gt;&quot;</span>).arg(AzAlt, firstCoordinate, secondCoordinate, apparent);</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot; 2 &quot;</span> &lt;&lt; az &lt;&lt; alt;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><p>在SkyGui.cpp中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">        StelCore *core = StelApp::getInstance().getCore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        qDebug() &lt;&lt; &quot;getAltAzPosGeometric &quot;  &lt;&lt; selected[0]-&gt;getInfoString(core);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> az, alt;</span><br><span class="line">        StelUtils::rectToSphe(&amp;az, &amp;alt, selected[<span class="number">0</span>]-&gt;getAltAzPosGeometric(core));</span><br><span class="line">        <span class="keyword">double</span> direction = <span class="number">3.</span>; <span class="comment">// N is zero, E is 90 degrees</span></span><br><span class="line">        az = direction * M_PI - az;</span><br><span class="line">        <span class="keyword">if</span> (az &gt; M_PI * <span class="number">2</span>)</span><br><span class="line">            az -= M_PI * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> az_app, alt_app;</span><br><span class="line">        StelUtils::rectToSphe(&amp;az_app, &amp;alt_app, selected[<span class="number">0</span>]-&gt;getAltAzPosApparent(core));</span><br><span class="line">        QString res, firstCoordinate, secondCoordinate;</span><br><span class="line"></span><br><span class="line">        firstCoordinate  = StelUtils::radToDmsStr(az, <span class="literal">true</span>);</span><br><span class="line">        secondCoordinate = StelUtils::radToDmsStr(alt, <span class="literal">true</span>);</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot;AzAlt &quot;</span> &lt;&lt; firstCoordinate &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; secondCoordinate &lt;&lt; <span class="string">&quot; &quot;</span>  &lt;&lt; alt_app &lt;&lt; (alt_app &gt; <span class="number">-2.0</span> * M_PI / <span class="number">180.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以显示选中星体的信息。</p><p><strong>getAltAzPosGeometric</strong></p><hr><hr><p><strong>研究 Star1</strong> </p><p>在 C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\util\ConvertCatToNative.C 文件中 </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  PerformConversion(argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerformConversion</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname_in,<span class="keyword">const</span> <span class="keyword">char</span> *fname_out)</span> </span>&#123;</span><br><span class="line">    Convert&lt;Star1&gt;(f_in,f_out,from_be,nr_of_stars);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Convert</span><span class="params">(FILE *f_in,FILE *f_out,<span class="keyword">bool</span> from_be,<span class="keyword">unsigned</span> <span class="keyword">int</span> nr_of_stars)</span> </span>&#123;</span><br><span class="line">    s.repack(from_be);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Star1::repack</span><span class="params">(<span class="keyword">bool</span> from_be)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> _hip  = UnpackBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>, <span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _cids = UnpackUBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">24</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> _x0  = UnpackBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">32</span>,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> _x1  = UnpackBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">64</span>,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _b_v = UnpackUBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>, <span class="number">96</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _mag = UnpackUBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">104</span>, <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> _sp_int = UnpackUBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">112</span>,<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> _dx0 = UnpackBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">128</span>,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> _dx1 = UnpackBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">160</span>,<span class="number">32</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> _plx = UnpackBits(from_be,(<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="keyword">this</span>,<span class="number">192</span>,<span class="number">32</span>);</span><br><span class="line">  hip = _hip;</span><br><span class="line">  component_ids = _cids;</span><br><span class="line">  x0 = _x0;</span><br><span class="line">  x1 = _x1;</span><br><span class="line">  b_v = _b_v;</span><br><span class="line">  mag = _mag;</span><br><span class="line">  sp_int = _sp_int;</span><br><span class="line">  dx0 = _dx0;</span><br><span class="line">  dx1 = _dx1;</span><br><span class="line">  plx = _plx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Star1</span> &#123;</span> <span class="comment">// 28 byte</span></span><br><span class="line">  <span class="keyword">int</span> hip:<span class="number">24</span>;                  <span class="comment">// 17 bits needed</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> component_ids; <span class="comment">//  5 bits needed</span></span><br><span class="line">  Int32 x0;                    <span class="comment">// 32 bits needed</span></span><br><span class="line">  Int32 x1;                    <span class="comment">// 32 bits needed</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> b_v;           <span class="comment">//  7 bits needed</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> mag;           <span class="comment">//  8 bits needed</span></span><br><span class="line">  Uint16 sp_int;               <span class="comment">// 14 bits needed</span></span><br><span class="line">  Int32 dx0,dx1,plx;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">repack</span><span class="params">(<span class="keyword">bool</span> from_be)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p> 研究s-&gt;getHip() , 哪里的s呢</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">StarWrapper1::getInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *core, <span class="keyword">const</span> InfoStringGroup&amp; flags)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    <span class="keyword">const</span> QString varType </span>= StarMgr::getGcvsVariabilityType(s-&gt;getHip());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StelObject</span> :</span> <span class="keyword">public</span> StelRegionObject</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWrapperBase</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">StarWrapperBase(<span class="keyword">void</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~StarWrapperBase(<span class="keyword">void</span>) Q_DECL_OVERRIDE &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getType</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> STAR_TYPE;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="title">QString</span>  <span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> N_(<span class="string">&quot;star&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getObjectTypeI18n</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> q_(getObjectType()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getEnglishName</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> QString();&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getNameI18n</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *core, <span class="keyword">const</span> InfoStringGroup&amp; flags)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getBV</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Star</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">StarWrapper</span> :</span> <span class="keyword">public</span> StarWrapperBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">StarWrapper(<span class="keyword">const</span> SpecialZoneArray&lt;Star&gt; *<span class="built_in">array</span>,</span><br><span class="line"><span class="keyword">const</span> SpecialZoneData&lt;Star&gt; *zone,</span><br><span class="line"><span class="keyword">const</span> Star *star) : a(<span class="built_in">array</span>), z(zone), s(star) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3d <span class="title">getJ2000EquatorialPos</span><span class="params">(<span class="keyword">const</span> StelCore* core)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3f <span class="title">getInfoColor</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getVMagnitude</span><span class="params">(<span class="keyword">const</span> StelCore* core)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">float</span> <span class="title">getBV</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span>  Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> s-&gt;getBV();&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getEnglishName</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> QString();&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getNameI18n</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE </span>&#123;<span class="keyword">return</span> s-&gt;getNameI18n();&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">const</span> SpecialZoneArray&lt;Star&gt; *<span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> SpecialZoneData&lt;Star&gt; *<span class="keyword">const</span> z;</span><br><span class="line"><span class="keyword">const</span> Star *<span class="keyword">const</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWrapper1</span> :</span> <span class="keyword">public</span> StarWrapper&lt;Star1&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">StarWrapper1(<span class="keyword">const</span> SpecialZoneArray&lt;Star1&gt; *<span class="built_in">array</span>,</span><br><span class="line"><span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *zone,</span><br><span class="line"><span class="keyword">const</span> Star1 *star) : StarWrapper&lt;Star1&gt;(<span class="built_in">array</span>,zone,star) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! StarWrapper1 supports the following InfoStringGroup flags: &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; Name</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; CatalogNumber</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; Magnitude</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; RaDecJ2000</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; RaDec</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; AltAzi</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; Extra (spectral type, parallax)</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; Distance</span></span><br><span class="line"><span class="comment">//! &lt;li&gt; PlainText &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">//! @param core the StelCore object.</span></span><br><span class="line"><span class="comment">//! @param flags a set of InfoStringGroup items to include in the return value.</span></span><br><span class="line"><span class="comment">//! @return a QString containing an HMTL encoded description of the StarWrapper1.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *core, <span class="keyword">const</span> InfoStringGroup&amp; flags)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"><span class="comment">//! In addition to the entries from StelObject::getInfoMap(), StarWrapper1 objects provide</span></span><br><span class="line"><span class="comment">//! - variable-star (no|eruptive|pulsating|rotating|cataclysmic|eclipsing-binary)</span></span><br><span class="line"><span class="comment">//! - star-type (star|double-star)</span></span><br><span class="line"><span class="comment">//! - bV : B-V Color Index</span></span><br><span class="line"><span class="comment">//! A few tags are only present if data known, or for variable or double stars from the WDS catalog</span></span><br><span class="line"><span class="comment">//! - absolute-mag</span></span><br><span class="line"><span class="comment">//! - distance-ly</span></span><br><span class="line"><span class="comment">//! - parallax</span></span><br><span class="line"><span class="comment">//! - spectral-class</span></span><br><span class="line"><span class="comment">//! - period (days)</span></span><br><span class="line"><span class="comment">//! - wds-year (year of validity of wds... fields)</span></span><br><span class="line"><span class="comment">//! - wds-position-angle</span></span><br><span class="line"><span class="comment">//! - wds-separation (arcseconds; 0 for spectroscopic binaries)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QVariantMap <span class="title">getInfoMap</span><span class="params">(<span class="keyword">const</span> StelCore *core)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getEnglishName</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getID</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getObjectType</span><span class="params">()</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> QString <span class="title">getObjectTypeI18n</span><span class="params">()</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>按键按下之后发生的事</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StelMovementMgr::handleMouseClicks</span><span class="params">(QMouseEvent* event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> Qt::LeftButton :</span><br><span class="line">    objectMgr-&gt;findAndSelect(core, event-&gt;x(), event-&gt;y(), event-&gt;modifiers().testFlag(Qt::ControlModifier) ? StelModule::AddToSelection : StelModule::ReplaceSelection);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StelObjectMgr::findAndSelect</span><span class="params">(<span class="keyword">const</span> StelCore* core, <span class="keyword">int</span> x, <span class="keyword">int</span> y, StelModule::StelModuleSelectAction action)</span> </span>&#123;</span><br><span class="line">    StelObjectP tempselect = cleverFind(core, x, y);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">StelObjectP <span class="title">StelObjectMgr::cleverFind</span><span class="params">(<span class="keyword">const</span> StelCore* core, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cleverFind(core, v2000);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">StelObjectP <span class="title">StelObjectMgr::cleverFind</span><span class="params">(<span class="keyword">const</span> StelCore* core, <span class="keyword">const</span> Vec3d&amp; v)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>* m : objectsModules) &#123; <span class="comment">// StelObjectMgr.cpp</span></span><br><span class="line">        candidates += m-&gt;searchAround(v, fov_around, core); <span class="comment">// 点一下</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\modules\StarMgr.cpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QList&lt;StelObjectP &gt; <span class="title">StarMgr::searchAround</span><span class="params">(<span class="keyword">const</span> Vec3d&amp; vv, <span class="keyword">double</span> limFov, <span class="keyword">const</span> StelCore* core)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        <span class="title">for</span> <span class="params">(GeodesicSearchBorderIterator it1(*geodesic_search_result, z-&gt;level); (zone = it1.next()) &gt;= <span class="number">0</span>;)</span> </span></span><br><span class="line">            qDebug() &lt;&lt; &quot; 1111 eee &quot; &lt;&lt; eee++;</span><br><span class="line">            z-&gt;searchAround(core, zone, v, f, result);</span><br></pre></td></tr></table></figure><p>qDebug() &lt;&lt; “ 2222 now2 “ &lt;&lt; bbb++; // 2531次<br>        return s-&gt;createStelObject(a, z);</p><p>//            qDebug() &lt;&lt; “ 2222 now “ &lt;&lt; aaa++; //24920次<br>            StelObjectP so = s-&gt;createStelObject(a, z);</p><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\modules\ZoneArray.cpp的result.push_back(s-&gt;createStelObject(this, z)); // 调用27多次 点击也是这里调用</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> SpecialZoneArray&lt;Star&gt;::searchAround(<span class="keyword">const</span> StelCore* core, <span class="keyword">int</span> index, <span class="keyword">const</span> Vec3d &amp;v, <span class="keyword">double</span> cosLimFov, QList&lt;StelObjectP &gt; &amp;result) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> Star* s=z-&gt;getStars();s&lt;z-&gt;getStars()+z-&gt;size;++s)</span><br><span class="line">    result.push_back(s-&gt;createStelObject(<span class="keyword">this</span>, z));</span><br></pre></td></tr></table></figure><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\modules\StarWrapper.cpp中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">StelObjectP <span class="title">Star1::createStelObject</span><span class="params">(<span class="keyword">const</span> SpecialZoneArray&lt;Star1&gt; *a, <span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *z)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"><span class="keyword">return</span> <span class="title">StelObjectP</span><span class="params">(<span class="keyword">new</span> StarWrapper1(a,z,<span class="keyword">this</span>), <span class="literal">true</span>)</span></span>; <span class="comment">//27479次</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWrapper1</span> :</span> <span class="keyword">public</span> StarWrapper&lt;Star1&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    StarWrapper1(<span class="keyword">const</span> SpecialZoneArray&lt;Star1&gt; *<span class="built_in">array</span>,</span><br><span class="line">                 <span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *zone,</span><br><span class="line">                 <span class="keyword">const</span> Star1 *star) : StarWrapper&lt;Star1&gt;(<span class="built_in">array</span>, zone, star) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Star</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWrapper</span> :</span> <span class="keyword">public</span> StarWrapperBase &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    StarWrapper(<span class="keyword">const</span> SpecialZoneArray&lt;Star&gt; *<span class="built_in">array</span>,</span><br><span class="line">                <span class="keyword">const</span> SpecialZoneData&lt;Star&gt; *zone,</span><br><span class="line">                <span class="keyword">const</span> Star *star) : a(<span class="built_in">array</span>), z(zone), s(star) &#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StarWrapper.s .a .z</span><br></pre></td></tr></table></figure><hr><p>研究如何算j2000的赤经赤纬</p><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\StelObject.cpp文件中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QString <span class="title">StelObject::getCommonInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *core, <span class="keyword">const</span> InfoStringGroup&amp; flags)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; RaDecJ2000) &#123;</span><br><span class="line">        <span class="keyword">double</span> dec_j2000, ra_j2000;</span><br><span class="line">        StelUtils::rectToSphe(&amp;ra_j2000, &amp;dec_j2000, getJ2000EquatorialPos(core));</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot; getJ2000EquatorialPos222 &quot;</span> &lt;&lt; getJ2000EquatorialPos(core);</span><br><span class="line">        <span class="keyword">if</span> (withDecimalDegree) &#123;</span><br><span class="line">            firstCoordinate  = StelUtils::radToDecDegStr(ra_j2000, <span class="number">5</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            secondCoordinate = StelUtils::radToDecDegStr(dec_j2000);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            firstCoordinate  = StelUtils::radToHmsStr(ra_j2000, <span class="literal">true</span>);</span><br><span class="line">            secondCoordinate = StelUtils::radToDmsStr(dec_j2000, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>getJ2000EquatorialPos调用</p><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\modules\StarWrapper.hpp中的</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Star</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StarWrapper</span> :</span> <span class="keyword">public</span> StarWrapperBase</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">StarWrapper(<span class="keyword">const</span> SpecialZoneArray&lt;Star&gt; *<span class="built_in">array</span>, <span class="keyword">const</span> SpecialZoneData&lt;Star&gt; *zone, <span class="keyword">const</span> Star *star) : a(<span class="built_in">array</span>), z(zone), s(star) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> Vec3d <span class="title">getJ2000EquatorialPos</span><span class="params">(<span class="keyword">const</span> StelCore* core)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span></span><br><span class="line">        s-&gt;getJ2000Pos(z, (M_PI / 180.) * (0.0001 / 3600.) * ((core-&gt;getJDE() - d2000) / 365.25) / a-&gt;star_position_scale, v);</span><br></pre></td></tr></table></figure><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\modules\Star.hpp</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Star1</span> &#123;</span> <span class="comment">// 28 byte</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getJ2000Pos</span><span class="params">(<span class="keyword">const</span> ZoneData *z,<span class="keyword">float</span> movementFactor, Vec3f&amp; pos)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">pos = z-&gt;axis0;</span><br><span class="line">pos*=(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(getX0())+movementFactor*getDx0());</span><br><span class="line">pos+=(<span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(getX1())+movementFactor*getDx1())*z-&gt;axis1;</span><br><span class="line">pos+=z-&gt;center;</span><br></pre></td></tr></table></figure><hr><p>C:\Users\hp\Desktop\stellarium-0.22.2\stellarium-0.22.2\src\core\StelGeodesicGrid.cpp中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StelGeodesicGrid::StelGeodesicGrid(<span class="keyword">const</span> <span class="keyword">int</span> lev) : maxLevel(lev &lt; <span class="number">0</span> ? <span class="number">0</span> : lev)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">    initTriangle(<span class="number">0</span>, i, icosahedron_corners[corners[<span class="number">0</span>]], icosahedron_corners[corners[<span class="number">1</span>]], icosahedron_corners[corners[<span class="number">2</span>]]); <span class="comment">// 20次</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> icosahedron_G = <span class="number">0.5f</span> * (<span class="number">1.0f</span> + <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">5.0f</span>));</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> icosahedron_b = <span class="number">1.0f</span> / <span class="built_in">std</span>::<span class="built_in">sqrt</span>(<span class="number">1.0f</span> + icosahedron_G*icosahedron_G);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> icosahedron_a = icosahedron_b * icosahedron_G;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> Vec3f icosahedron_corners[<span class="number">12</span>] = &#123;</span><br><span class="line">    Vec3f( icosahedron_a, -icosahedron_b,            <span class="number">0.0</span>),</span><br><span class="line">    Vec3f( icosahedron_a,  icosahedron_b,            <span class="number">0.0</span>),</span><br><span class="line">    Vec3f(-icosahedron_a,  icosahedron_b,            <span class="number">0.0</span>),</span><br><span class="line">    Vec3f(-icosahedron_a, -icosahedron_b,            <span class="number">0.0</span>),</span><br><span class="line">    Vec3f(           <span class="number">0.0</span>,  icosahedron_a, -icosahedron_b),</span><br><span class="line">    Vec3f(           <span class="number">0.0</span>,  icosahedron_a,  icosahedron_b),</span><br><span class="line">    Vec3f(           <span class="number">0.0</span>, -icosahedron_a,  icosahedron_b),</span><br><span class="line">    Vec3f(           <span class="number">0.0</span>, -icosahedron_a, -icosahedron_b),</span><br><span class="line">    Vec3f(-icosahedron_b,            <span class="number">0.0</span>,  icosahedron_a),</span><br><span class="line">    Vec3f( icosahedron_b,            <span class="number">0.0</span>,  icosahedron_a),</span><br><span class="line">    Vec3f( icosahedron_b,            <span class="number">0.0</span>, -icosahedron_a),</span><br><span class="line">    Vec3f(-icosahedron_b,            <span class="number">0.0</span>, -icosahedron_a)</span><br><span class="line">        </span><br><span class="line"><span class="number">0</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">1</span> [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">2</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">3</span> [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">4</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">5</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">6</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">7</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">8</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">9</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">10</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">11</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line">        </span><br><span class="line"><span class="number">0</span> [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">1</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">2</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">3</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">4</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">5</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span></span><br><span class="line"><span class="number">6</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">7</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">8</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">9</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">10</span> [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">11</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">12</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">13</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">14</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">15</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">16</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">17</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span></span><br><span class="line"><span class="number">18</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span></span><br><span class="line"><span class="number">19</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br></pre></td></tr></table></figure><p>正二十面体(Regular icosahedron ) 是由20个等边三角形所组成的正多面体，共有12个顶点，30条棱，20个面。为五个柏拉图多面体之一。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StelApp::getInstance().getCore()-&gt;getGeodesicGrid(maxGeodesicGridLevel)-&gt;visitTriangles(maxGeodesicGridLevel, initTriangleFunc, <span class="keyword">this</span>); <span class="comment">// 1次</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StelGeodesicGrid::visitTriangles</span><span class="params">(<span class="keyword">int</span> maxVisitLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      VisitFunc *func,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">void</span> *context)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 1次</span></span><br><span class="line">    <span class="keyword">if</span> (func &amp;&amp; maxVisitLevel &gt;= <span class="number">0</span>) &#123;  <span class="comment">// 1次</span></span><br><span class="line">        <span class="keyword">if</span> (maxVisitLevel &gt; maxLevel) maxVisitLevel = maxLevel;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123; <span class="comment">// 20次</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> corners = icosahedron_triangles[i].corners;</span><br><span class="line">            visitTriangles(<span class="number">0</span>, i,</span><br><span class="line">                           icosahedron_corners[corners[<span class="number">0</span>]],</span><br><span class="line">                           icosahedron_corners[corners[<span class="number">1</span>]],</span><br><span class="line">                           icosahedron_corners[corners[<span class="number">2</span>]],</span><br><span class="line">                           maxVisitLevel, func, context);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StelGeodesicGrid::visitTriangles</span><span class="params">(<span class="keyword">int</span> lev, <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> Vec3f &amp;c0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> Vec3f &amp;c1,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> Vec3f &amp;c2,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> maxVisitLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      VisitFunc *func,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">void</span> *context)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">&quot; initTriangle maxVisitLevel222 &quot;</span> &lt;&lt; lev &lt;&lt; index &lt;&lt; maxVisitLevel &lt;&lt; maxLevel;</span><br><span class="line">    (*func)(lev, index, c0, c1, c2, context); <span class="comment">// 20 * 调用一次</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Triangle &amp;<span class="title">t</span><span class="params">(triangles[lev][index])</span></span>;</span><br><span class="line">    lev++;</span><br><span class="line">    <span class="keyword">if</span> (lev &lt;= maxVisitLevel) &#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">&quot; initTriangle maxVisitLevel333 &quot;</span>  &lt;&lt; maxLevel;</span><br><span class="line">        index *= <span class="number">4</span>;</span><br><span class="line">        visitTriangles(lev, index + <span class="number">0</span>, c0, t.e2, t.e1, maxVisitLevel, func, context);</span><br><span class="line">        visitTriangles(lev, index + <span class="number">1</span>, t.e2, c1, t.e0, maxVisitLevel, func, context);</span><br><span class="line">        visitTriangles(lev, index + <span class="number">2</span>, t.e1, t.e0, c2, maxVisitLevel, func, context);</span><br><span class="line">        visitTriangles(lev, index + <span class="number">3</span>, t.e0, t.e1, t.e2, maxVisitLevel, func, context);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initTriangleFunc</span><span class="params">(<span class="keyword">int</span> lev, <span class="keyword">int</span> index, <span class="keyword">const</span> Vec3f &amp;c0, <span class="keyword">const</span> Vec3f &amp;c1, <span class="keyword">const</span> Vec3f &amp;c2, <span class="keyword">void</span> *context)</span> </span>&#123;  <span class="comment">// 100次调用</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StarMgr::initTriangle(<span class="keyword">int</span> lev, <span class="keyword">int</span> index, <span class="keyword">const</span> Vec3f &amp;c0, <span class="keyword">const</span> Vec3f &amp;c1, <span class="keyword">const</span> Vec3f &amp;c2) &#123; <span class="comment">// 100次调用</span></span><br></pre></td></tr></table></figure><p>有2层level ，第一层的index为20 第二层为80；</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">3</span> [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">5</span> <span class="number">0</span> <span class="number">1</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">4</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">7</span> <span class="number">1</span> <span class="number">5</span> [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">6</span> [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">9</span> <span class="number">1</span> <span class="number">7</span> [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">10</span> <span class="number">0</span> <span class="number">2</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">11</span> <span class="number">1</span> <span class="number">8</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">12</span> <span class="number">1</span> <span class="number">9</span> [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">13</span> <span class="number">1</span> <span class="number">10</span> [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">14</span> <span class="number">1</span> <span class="number">11</span> [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">15</span> <span class="number">0</span> <span class="number">3</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">16</span> <span class="number">1</span> <span class="number">12</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">17</span> <span class="number">1</span> <span class="number">13</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">18</span> <span class="number">1</span> <span class="number">14</span> [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">19</span> <span class="number">1</span> <span class="number">15</span> [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">20</span> <span class="number">0</span> <span class="number">4</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">21</span> <span class="number">1</span> <span class="number">16</span> [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">22</span> <span class="number">1</span> <span class="number">17</span> [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">23</span> <span class="number">1</span> <span class="number">18</span> [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">24</span> <span class="number">1</span> <span class="number">19</span> [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">25</span> <span class="number">0</span> <span class="number">5</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">26</span> <span class="number">1</span> <span class="number">20</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">27</span> <span class="number">1</span> <span class="number">21</span> [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">28</span> <span class="number">1</span> <span class="number">22</span> [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">29</span> <span class="number">1</span> <span class="number">23</span> [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">30</span> <span class="number">0</span> <span class="number">6</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">31</span> <span class="number">1</span> <span class="number">24</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">32</span> <span class="number">1</span> <span class="number">25</span> [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">33</span> <span class="number">1</span> <span class="number">26</span> [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">34</span> <span class="number">1</span> <span class="number">27</span> [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">35</span> <span class="number">0</span> <span class="number">7</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">36</span> <span class="number">1</span> <span class="number">28</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">0.525731</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">37</span> <span class="number">1</span> <span class="number">29</span> [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">38</span> <span class="number">1</span> <span class="number">30</span> [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">39</span> <span class="number">1</span> <span class="number">31</span> [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">40</span> <span class="number">0</span> <span class="number">8</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">41</span> <span class="number">1</span> <span class="number">32</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">42</span> <span class="number">1</span> <span class="number">33</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">43</span> <span class="number">1</span> <span class="number">34</span> [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">44</span> <span class="number">1</span> <span class="number">35</span> [<span class="number">0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line"><span class="number">45</span> <span class="number">0</span> <span class="number">9</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">46</span> <span class="number">1</span> <span class="number">36</span> [<span class="number">0</span>, <span class="number">-0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">47</span> <span class="number">1</span> <span class="number">37</span> [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">48</span> <span class="number">1</span> <span class="number">38</span> [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">49</span> <span class="number">1</span> <span class="number">39</span> [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.309017</span>, <span class="number">-0.5</span>, <span class="number">-0.809017</span>] [<span class="number">-0.5</span>, <span class="number">-0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">50</span> <span class="number">0</span> <span class="number">10</span> [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">51</span> <span class="number">1</span> <span class="number">40</span> [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">52</span> <span class="number">1</span> <span class="number">41</span> [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">53</span> <span class="number">1</span> <span class="number">42</span> [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">54</span> <span class="number">1</span> <span class="number">43</span> [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">55</span> <span class="number">0</span> <span class="number">11</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">56</span> <span class="number">1</span> <span class="number">44</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">57</span> <span class="number">1</span> <span class="number">45</span> [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>] [<span class="number">-0.850651</span>, <span class="number">-0.525731</span>, <span class="number">0</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">58</span> <span class="number">1</span> <span class="number">46</span> [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>]</span><br><span class="line"><span class="number">59</span> <span class="number">1</span> <span class="number">47</span> [<span class="number">-0.809017</span>, <span class="number">-0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">60</span> <span class="number">0</span> <span class="number">12</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">61</span> <span class="number">1</span> <span class="number">48</span> [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">62</span> <span class="number">1</span> <span class="number">49</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">63</span> <span class="number">1</span> <span class="number">50</span> [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>]</span><br><span class="line"><span class="number">64</span> <span class="number">1</span> <span class="number">51</span> [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>]</span><br><span class="line"><span class="number">65</span> <span class="number">0</span> <span class="number">13</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">66</span> <span class="number">1</span> <span class="number">52</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">67</span> <span class="number">1</span> <span class="number">53</span> [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">68</span> <span class="number">1</span> <span class="number">54</span> [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">69</span> <span class="number">1</span> <span class="number">55</span> [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">70</span> <span class="number">0</span> <span class="number">14</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">71</span> <span class="number">1</span> <span class="number">56</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">72</span> <span class="number">1</span> <span class="number">57</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">73</span> <span class="number">1</span> <span class="number">58</span> [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">74</span> <span class="number">1</span> <span class="number">59</span> [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">75</span> <span class="number">0</span> <span class="number">15</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">76</span> <span class="number">1</span> <span class="number">60</span> [<span class="number">-0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">77</span> <span class="number">1</span> <span class="number">61</span> [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">78</span> <span class="number">1</span> <span class="number">62</span> [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">79</span> <span class="number">1</span> <span class="number">63</span> [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">-0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">-0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">80</span> <span class="number">0</span> <span class="number">16</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">81</span> <span class="number">1</span> <span class="number">64</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>]</span><br><span class="line"><span class="number">82</span> <span class="number">1</span> <span class="number">65</span> [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>]</span><br><span class="line"><span class="number">83</span> <span class="number">1</span> <span class="number">66</span> [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">-0.850651</span>]</span><br><span class="line"><span class="number">84</span> <span class="number">1</span> <span class="number">67</span> [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">-0.5</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">-0.809017</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">85</span> <span class="number">0</span> <span class="number">17</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">86</span> <span class="number">1</span> <span class="number">68</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">-0.525731</span>] [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>]</span><br><span class="line"><span class="number">87</span> <span class="number">1</span> <span class="number">69</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">88</span> <span class="number">1</span> <span class="number">70</span> [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">89</span> <span class="number">1</span> <span class="number">71</span> [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">-0.309017</span>] [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">90</span> <span class="number">0</span> <span class="number">18</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">91</span> <span class="number">1</span> <span class="number">72</span> [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>]</span><br><span class="line"><span class="number">92</span> <span class="number">1</span> <span class="number">73</span> [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="number">93</span> <span class="number">1</span> <span class="number">74</span> [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.850651</span>, <span class="number">0.525731</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">94</span> <span class="number">1</span> <span class="number">75</span> [<span class="number">0.809017</span>, <span class="number">0.309017</span>, <span class="number">0.5</span>] [<span class="number">0.5</span>, <span class="number">0.809017</span>, <span class="number">0.309017</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">95</span> <span class="number">0</span> <span class="number">19</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">96</span> <span class="number">1</span> <span class="number">76</span> [<span class="number">-0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">97</span> <span class="number">1</span> <span class="number">77</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>] [<span class="number">0.525731</span>, <span class="number">0</span>, <span class="number">0.850651</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>]</span><br><span class="line"><span class="number">98</span> <span class="number">1</span> <span class="number">78</span> [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">0</span>, <span class="number">0.850651</span>, <span class="number">0.525731</span>]</span><br><span class="line"><span class="number">99</span> <span class="number">1</span> <span class="number">79</span> [<span class="number">0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">-0.309017</span>, <span class="number">0.5</span>, <span class="number">0.809017</span>] [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>自己研究了两周还是没结果，很失落，写不出第二周的总结，因为第二周没有收获。第三周末尾和一位天文学专业的同学请教了，才发现自己这2周方向都错了，顶多算是对c++代码的一次学习。</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冲毕业第一周记录</title>
      <link href="2022/11/22/blog66-study1/"/>
      <url>2022/11/22/blog66-study1/</url>
      
        <content type="html"><![CDATA[<p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221122152053959.png" alt="image-20221122152053959"></p><p>秋招开始前卡在一个问题：漫天分布的星点如何筛选，使得筛选星均匀遍布在天球上，以便望远镜可以进行全天球的均匀校正。</p><p>一篇螺旋基准点的文章提供了思路，在各基准点周围找星点，但生成的基准点是固定的位置，就连初始点和旋转角都没有改变，我一直觉得不合适，我在想是否有点匹配方法才是更为合适的解决方法。</p><hr><p>从一个好友那得到我想研究的问题可能是点云配准问题。比如经典的icp方法。</p><p>做了个pcl实验</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221114195929901.png" alt="image-20221114195929901"></p><p>处理了bug，跑起了实验</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221114201720714.png" alt="image-20221114201720714"></p><p>看了icp原理 <a href="https://zhuanlan.zhihu.com/p/107218828">https://zhuanlan.zhihu.com/p/107218828</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221115142324782.png" alt="image-20221115142324782"></p><p>跑起了icp经典实验，但是发现若初始位置偏差较大，配准效果较差，就像第一张图一样，所以作罢，寻找其他方法。</p><p>一方面是寻找更佳的配准方法，另一方面是用粒子群算法寻找全局最优。</p><p>更佳的配准方法看到一个博文  <a href="https://www.cnblogs.com/shushen/p/11676486.html">https://www.cnblogs.com/shushen/p/11676486.html</a> 其中出现了很多配准方法 以及二维点云实验结果 让我很想试试其他方法</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221115220517251.png" alt="image-20221115220517251"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221122154530701.png" alt="image-20221122154530701"></p><p>在搜索rpm方法的时候，找到了一个配准的宝藏网站</p><p>维基 介绍 <a href="https://en.wikipedia.org/wiki/Point-set_registration">https://en.wikipedia.org/wiki/Point-set_registration</a></p><p>github 合集 <a href="https://github.com/gwang-cv/Point-Set-Matching-Registration-Material#mismatch-removalcorrespondence-pruning-methods">https://github.com/gwang-cv/Point-Set-Matching-Registration-Material#mismatch-removalcorrespondence-pruning-methods</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20221115234203726.png" alt="image-20221115234203726"></p><p>做TPS-RPM实验研究不清楚，是进阶版的非刚性变换版本，基础rpm没整起来</p><p><strong>Gold S, Rangarajan A, Lu C P, et al. New algorithms for 2D and 3D point matching: pose estimation and correspondence[J]. Pattern recognition, 1998, 31(8): 1019-1031.</strong> 基础的RPM</p><p><strong>Chui H, Rangarajan A. A new point matching algorithm for non-rigid registration[J]. Computer Vision and Image Understanding, 2003, 89(2-3): 114-141.</strong> 进阶TPS-RPM</p><p><strong><a href="https://www.cise.ufl.edu/~anand/students/chui/tps-rpm.html">https://www.cise.ufl.edu/~anand/students/chui/tps-rpm.html</a></strong> TPS代码</p><hr><p>二维点云配准算法 二维点云ICP <a href="https://blog.csdn.net/weixin_42156097/article/details/106379613">https://blog.csdn.net/weixin_42156097/article/details/106379613</a></p><p>二维点云ICP的C++实现 <a href="https://blog.csdn.net/weixin_42156097/article/details/106827472">https://blog.csdn.net/weixin_42156097/article/details/106827472</a></p><hr><p>粒子群算法！看b站研究了点，做了个实验</p><hr><p>有几篇类似文章，可以参考算法描述</p><p><strong>《陈斯祺, 张海洋, 赵长明, 等. 基于天牛须改进粒子群算法的点云配准方法[J]. 激光技术, 2020, 44(6): 678-683.》</strong></p><p>为了提高激光点云配准精度与配准速度,采用了基于天牛须算法改进的粒子群算法,以点云分布熵为寻优目 标,寻找最优空间变换矩阵的点云粗配准,为点云精配准提供良好的初始条件。 结果表明,点云分布熵较传统的均值平 方差评价方式有更快的计算速度,基于天牛须算法改进的粒子群算法具有全局搜索能力强、计算速度快等特点,与传统 点云粗配准方法相比,该方法配准速度提升了近 25% ;在点云数据量大的条件下,表现出较快的配准速度。 这一方法对 如何提高激光点云配准速度具有参考意义。</p><p><strong>《马卫. 基于布谷鸟优化的三维点云配准算法[J]. 计算机应用与软件, 2020, 37(12): 216-223.》</strong></p><p><a href="http://www.shcas.net/jsjyup/pdf/2020/12/%E5%9F%BA%E4%BA%8E%E5%B8%83%E8%B0%B7%E9%B8%9F%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91%E9%85%8D%E5%87%86%E7%AE%97%E6%B3%95.pdf">http://www.shcas.net/jsjyup/pdf/2020/12/%E5%9F%BA%E4%BA%8E%E5%B8%83%E8%B0%B7%E9%B8%9F%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%89%E7%BB%B4%E7%82%B9%E4%BA%91%E9%85%8D%E5%87%86%E7%AE%97%E6%B3%95.pdf</a></p><p><strong>《一种基于改进粒子群算法的点云配准方法》</strong>专利</p><p><strong>《王尔申, 孙彩苗, 黄煜峰, 等. 改进粒子群优化的卫星导航选星算法[J]. 北京航空航天大学学报, 2021.》</strong></p><hr><p>最后总结，其实没必要研究复杂的配准方法。<strong>只需要结合以前看的螺旋基准点搜索点方法即可，再加以粒子群算法进行最优搜索即可。</strong> <strong>可能最近点搜索可以结合icp 和 kd-tree方法（目标函数不是mse 应该是分布熵）。</strong></p><p>上周周赛做完缓到今天周二……</p>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状压总结</title>
      <link href="2022/08/25/blog65-stateCompressionDP/"/>
      <url>2022/08/25/blog65-stateCompressionDP/</url>
      
        <content type="html"><![CDATA[<h2 id="LC464-单词拆分-II"><a href="#LC464-单词拆分-II" class="headerlink" title="LC464. 单词拆分 II"></a>LC464. <a href="https://leetcode.cn/problems/word-break-ii/">单词拆分 II</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; memo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">backtracking</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> start, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">set</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == s.size())</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo.count(start))</span><br><span class="line">        <span class="keyword">return</span> memo[start];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;                    start = &quot;</span> &lt;&lt; start &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len + start &lt;= s.size(); len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = s.substr(start, len);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>.count(str))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; next = backtracking(s, start + len, <span class="built_in">set</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ss : next)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;   ss =  &quot;</span> &lt;&lt; ss &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span> (ss == <span class="string">&quot;&quot;</span>)</span><br><span class="line">                    ret.push_back(str);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ret.push_back(str + <span class="string">&quot; &quot;</span> + ss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[start] = ret;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;  start &quot;</span> &lt;&lt; start &lt;&lt; <span class="string">&quot; memo[start] &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; memo[start].size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; memo[start][i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;catsanddog&quot;</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordDict = &#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;cats&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;sand&quot;</span>, <span class="string">&quot;dog&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line">        <span class="built_in">set</span>(wordDict.begin(), wordDict.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans = backtracking(s, <span class="number">0</span>, <span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LC464. 我能赢吗</p><p>记忆化搜索+状态压缩</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> maxChoosableInteger, <span class="keyword">int</span> usedNum, <span class="keyword">int</span> desiredTotal, <span class="keyword">int</span> currSum, <span class="keyword">bool</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!memo[usedNum])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxChoosableInteger; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (((usedNum &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123; <span class="comment">// 若此数没被选择 就继续</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; usedNum &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;12&gt;(usedNum) &lt;&lt; <span class="string">&quot; currSum &quot;</span> &lt;&lt; currSum</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; i &quot;</span> &lt;&lt; i &lt;&lt; (flag ? <span class="string">&quot; me  &quot;</span> : <span class="string">&quot; you &quot;</span>) &lt;&lt; <span class="built_in">bitset</span>&lt;12&gt;(usedNum | (<span class="number">1</span> &lt;&lt; i)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> + currSum &gt;= desiredTotal || !dfs(maxChoosableInteger, usedNum | (<span class="number">1</span> &lt;&lt; i), desiredTotal, currSum + i + <span class="number">1</span>, !flag))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; win &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    ret = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; usedNum &quot;</span> &lt;&lt; <span class="built_in">bitset</span>&lt;12&gt;(usedNum) &lt;&lt; <span class="string">&quot; ret &quot;</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        memo[usedNum] = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[usedNum];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxChoosableInteger = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> desiredTotal = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">if</span> (desiredTotal &lt; maxChoosableInteger)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (maxChoosableInteger * (maxChoosableInteger + <span class="number">1</span>) &lt; <span class="number">2</span> * desiredTotal)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dfs(maxChoosableInteger, <span class="number">0</span>, desiredTotal, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220825172848204.png" alt="image-20220825172848204"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() : val(<span class="number">0</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x, ListNode next) : val(x), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LC1349</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxStudents</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;seats)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = seats.size();</span><br><span class="line">        <span class="keyword">int</span> n = seats[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; n)); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= m; row++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++)</span><br><span class="line">            &#123;                    <span class="comment">//遍历 2^n 个状态</span></span><br><span class="line">                <span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">bs</span><span class="params">(s)</span></span>; <span class="comment">//记录对应状态的bit位</span></span><br><span class="line">                <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((bs[j] &amp;&amp; seats[row - <span class="number">1</span>][j] == <span class="string">&#x27;#&#x27;</span>) || (j &lt; n - <span class="number">1</span> &amp;&amp; bs[j] &amp;&amp; bs[j + <span class="number">1</span>]))</span><br><span class="line">                    &#123; <span class="comment">//不能坐在坏椅子上也不能在同一行相邻坐</span></span><br><span class="line">                        ok = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!ok)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[row][s] = <span class="number">-1</span>; <span class="comment">//说明坐在坏椅子上或相邻坐了，该状态舍弃</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> last = <span class="number">0</span>; last &lt; (<span class="number">1</span> &lt;&lt; n); last++)</span><br><span class="line">                &#123;                                <span class="comment">//找到一种当前行的可行状态后，遍历上一行的所有状态</span></span><br><span class="line">                    <span class="keyword">if</span> (dp[row - <span class="number">1</span>][last] == <span class="number">-1</span>) <span class="comment">//上一行的状态被舍弃了，那就直接下一个状态</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="function"><span class="built_in">bitset</span>&lt;8&gt; <span class="title">lbs</span><span class="params">(last)</span></span>;</span><br><span class="line">                    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (lbs[j] &amp;&amp; ((j &gt; <span class="number">0</span> &amp;&amp; bs[j - <span class="number">1</span>]) || (j &lt; n - <span class="number">1</span> &amp;&amp; bs[j + <span class="number">1</span>])))</span><br><span class="line">                        &#123;                 <span class="comment">//如果找到的这个上一行状态的j位置坐了人，</span></span><br><span class="line">                            flag = <span class="literal">false</span>; <span class="comment">//下一行的j+1位置或j-1位置也坐了人，那么该状态不合法，舍弃</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (flag)</span><br><span class="line">                    &#123;                                                                      <span class="comment">// flag为真说明这个last状态的每个位置都合法</span></span><br><span class="line">                        dp[row][s] = max(dp[row][s], dp[row - <span class="number">1</span>][last] + (<span class="keyword">int</span>)bs.count()); <span class="comment">//转移方程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">        &#123; <span class="comment">//在最后一行的所有状态中找出最大的</span></span><br><span class="line">            <span class="keyword">if</span> (dp[m][i] &gt; res)</span><br><span class="line">            &#123;</span><br><span class="line">                res = dp[m][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度M*2^(2N)</p><p>空间复杂度M*2^(N)</p><p>华为0824</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;int&gt;&gt; seats = &#123;&#123;1, 0, 0, 0, 0, 1&#125;, &#123;0, 0, 0, 0, 0, 0&#125;, &#123;0, 1, 0, 0, 0, 1&#125;, &#123;0, 0, 0, 0, 0, 0&#125;&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; seats = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = seats.size();</span><br><span class="line">    <span class="keyword">int</span> n = seats[<span class="number">0</span>].size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span> &lt;&lt; n)); <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= m; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> state = <span class="number">0</span>; state &lt; (<span class="number">1</span> &lt;&lt; n); state++)</span><br><span class="line">        &#123;                         <span class="comment">//遍历 2^n 个状态</span></span><br><span class="line">            <span class="function"><span class="built_in">bitset</span>&lt;20&gt; <span class="title">bs</span><span class="params">(state)</span></span>; <span class="comment">//记录对应状态的bit位</span></span><br><span class="line">            <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((seats[row - <span class="number">1</span>][j] == <span class="number">1</span>) &amp;&amp; (bs[j] == <span class="number">0</span>) || (j &lt; n - <span class="number">1</span> &amp;&amp; bs[j] &amp;&amp; bs[j + <span class="number">1</span>])) <span class="comment">//状态一定要是1 也不能在同一行相邻坐</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ok)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[row][state] = <span class="number">-1</span>; <span class="comment">//说明该状态不包含原有位置，该状态舍弃</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lastState = <span class="number">0</span>; lastState &lt; (<span class="number">1</span> &lt;&lt; n); lastState++)</span><br><span class="line">            &#123;                                     <span class="comment">//找到一种当前行的可行状态后，遍历上一行的所有状态</span></span><br><span class="line">                <span class="keyword">if</span> (dp[row - <span class="number">1</span>][lastState] == <span class="number">-1</span>) <span class="comment">//上一行的状态被舍弃了，那就直接下一个状态</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function"><span class="built_in">bitset</span>&lt;20&gt; <span class="title">lbs</span><span class="params">(lastState)</span></span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lbs[j] &amp;&amp; bs[j])</span><br><span class="line">                    &#123; <span class="comment">//如果找到的这个上一行状态的j位置坐了人，，那么该状态不合法，舍弃</span></span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag)</span><br><span class="line">                    dp[row][state] = max(dp[row][state], dp[row - <span class="number">1</span>][lastState] + (<span class="keyword">int</span>)bs.count()); <span class="comment">//转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++)</span><br><span class="line">    &#123; <span class="comment">//在最后一行的所有状态中找出最大的</span></span><br><span class="line">        <span class="keyword">if</span> (dp[m][i] &gt; res)</span><br><span class="line">        &#123;</span><br><span class="line">            res = dp[m][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (seats[i][j] == <span class="number">1</span>)</span><br><span class="line">                total++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res - total;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试记录</title>
      <link href="2022/08/23/blog61-interviewRecord/"/>
      <url>2022/08/23/blog61-interviewRecord/</url>
      
        <content type="html"><![CDATA[<p>2022.8.2 15:00 </p><p>1、接雨水问题</p><p>2、进程间通信有哪些方式 7种（匿名管道、有名管道、信号、信号量、共享内存、消息队列、socket）</p><p>3、程序、进程、线程有什么区别（背的不好，有点瞎编，面试官皱眉了）</p><ul><li><code>定义</code><br><strong>程序</strong>是含有代码和数据的文件，存储在磁盘中，也就是说程序是静态的代码。<br><strong>进程</strong> 运行可执行文件后，会被装载到内存中，运行的程序就是进程。<br><strong>线程</strong>是进程的子任务，可以理解为轻量级的进程。</li><li><code>根本区别</code> 进程是操作系统<strong>资源分配</strong>的基本单位，而线程是<strong>CPU调度和程序执行</strong>的基本单位</li><li><code>包含关系</code>  一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li></ul><ul><li><code>资源</code> 每个进程都有独立的代码和数据空间（程序上下文），进程间切换开销大；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</li><li><code>内存分配</code>  进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li><li><code>共享</code><br>进程间信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因为必须采用一些进程间通信（IPC）方式，在进程间进行信息交换。<br>线程之间能够方便，快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。不过，要避免出现多个线程同时修改同一份信息的情况，这就需要使用到线程同步（同步就是协同步调，按预定的先后次序进行运行）技术（临界区、互斥量mutex、信号量semaphore、实物对象events）。</li></ul><ul><li><p><code>创建</code> 调用fork()来创建进程的代价相对较高，即便使用copy-on-write技术，仍然需要复制<strong>内存页表</strong>（page table）和<strong>文件描述符表</strong>（file descriptor table)之类的进程属性，这意味着fork()调用在时间上的开销依然不菲。创建线程比创建进程通常要快十倍甚至更多。线程的创建之所以快，是因为所需复制的诸多属性，在线程间本来就是<strong>共享</strong>的，无需采用写时复制（copy-on-write）来复制内存页，也无需复制页表。</p></li><li><p><code>执行过程</code> 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p></li><li><p><code>通信</code> 进程间通信用IPC，线程间通信直接读写数据段（但需要一些同步和互斥的方法）。</p></li><li><p><code>影响关系</code> 一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p></li></ul><hr><p>4、HTTP状态码（504 404 301）是什么意思，（就简答重定向、成功、客户端、服务器错误，没具体背，他问我4打头都是客户端报错吗，3打头都是重定向吗）</p><div class="table-container"><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">分类描述</th></tr></thead><tbody><tr><td style="text-align:left">1**</td><td style="text-align:left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td style="text-align:left">2**</td><td style="text-align:left">成功，操作被成功接收并处理</td></tr><tr><td style="text-align:left">3**</td><td style="text-align:left">重定向，需要进一步的操作以完成请求</td></tr><tr><td style="text-align:left">4**</td><td style="text-align:left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td style="text-align:left">5**</td><td style="text-align:left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table></div><p>200 OK 请求成功。一般用于GET与POST请求。</p><p>301 永久移动 Moved Permanently。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p><p>302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</p><p>304  Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p><p>400  Bad Request 客户端请求的语法错误，服务器无法理解</p><p>401  Unauthorized 请求要求用户的身份认证</p><p>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求</p><p>404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p><p>504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</p><hr><p>5、HTTP的header里面包含哪些key，分别是什么意思（以为问post get，面试官知道我不会直接过了</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220803155421787.png" alt="image-20220803155421787"></p><p>灰体都是key</p><hr><p>6、写sql，班级里 姓名重复的人的数量（不会</p><p>7、（a,b）联合索引 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; ? and c &#x3D; ?,</span><br><span class="line"></span><br><span class="line">b &#x3D; ? and c &#x3D; ?</span><br><span class="line"></span><br><span class="line">a &#x3D; ? and b &#x3D; ?</span><br></pre></td></tr></table></figure><p>不会</p><p>8、设计一个登录模块，考虑注意哪些安全问题，怎么避免（不会</p><p>我问能不能给建议和评价，他问你自己觉得怎么样</p><p>（后端肯定是需要数据库的）</p><p>网页登录和手机登录的问题 缓存存在哪，换了网络和地点网页还能登上吗 扫码登录怎么解决。。</p><p>2022.8.3 17:00</p><p>1、自我介绍学习能力强，举例</p><p>2、实习经历里的公司选择</p><p>3、实习收获</p><p>4、Flutter、qt学习看法，偏向C++还是js，（其实米哈游也在招前端</p><p>10min</p><p>5、指针和引用的区别，本质区别，定义 描述 使用，什么场景下用引用 什么场景下用指针，什么场景下只能用指针、什么场景下只能用引用。</p><blockquote><p>指针是一个存放内存地址的整数，是一个实体，这个整数表示的是被指向的变量的地址。</p><p>引用其实就是变量的别名，一定要有本体</p></blockquote><p>都是地址的概念</p><ul><li>程序为指针变量分配内存区域，而引用不需要分配内存区域；</li><li>指针在声明时可以暂时不<strong>初始化</strong>，pointer = nullptr，引用永远都不会为<strong>空</strong>，它得代表某个对象，引用在创建的同时必须被初始化</li><li>指针的值在初始化后<strong>可以被重新赋值</strong>，即指向其它的存储单元，而引用在进行初始化后就不会再改变了，从一而终。</li><li>”sizeof(运算符)引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；指针和引用的自增(++)运算意义不一样；指针有多级，引用没有。可以有const指针，但是没有const引用；</li></ul><p>使用场景：</p><p>指针：存在不指向任何对象的可能，改变指针的指向</p><p>引用：引用的主要功能就是作为函数的参数和返回值，当你需要指向某个东西，而且一定专一，绝不会让其指向其它东西，例如有些函数参数为了避免拷贝可以使用引用。重载某个操作符。有些函数参数为了避免拷贝可以使用引用，或者实现一个操作符，指针可以毫无约束的操作内存中的任何东西，功能十分强大，但是也很危险，所以可以在恰当的时机使用引用。</p><p>6、NULL和nullptr的区别</p><p>7、vector push_back()的复杂度</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220807153912590.png" alt="image-20220807153912590"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220807154212477.png" alt="image-20220807154212477"></p><p>8、虚函数、模板函数，虚函数机制，虚函数表，虚表指针。</p><p>9、计算机基础，锁的用处，有哪些锁。锁的类型，悲观锁和乐观锁的区别。</p><p>10、线程和进程的区别，进程是资源分配的最小单元 怎么理解，线程是CPU调度的最小单元。</p><p>理解 举例 <a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html">http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html</a> （进程、线程、共享内存、互斥锁、信号量的解释）</p><p>11、TCP三次握手四次挥手，举例。</p><p>12、TCP状态</p><p>13、DNS</p><p>14、哈夫曼树拿来做什么（前缀编码）</p><p>19min</p><p>完全背包硬币凑数 13min</p><p>8min反问</p><hr><p>2022.8.3 15:00</p><p>1、项目的TCP/UDP</p><p>2、socket通信的特点、实现机制</p><p>3、了解linux内核吗、进程线程内存管理</p><p>4、上下文切换会有哪些东西</p><hr><p>大疆08.07笔试</p><p>1、<strong>static</strong></p><p><strong>生存周期</strong>: 变量从定义到销毁的时间范围。<strong>静态数据存放在全局数据区</strong>(不会导致堆栈溢出)的变量的生存周期存在于整个程序运行期间，而局部变量存放在栈中的数据则随着函数等的作用域结束导致出栈而销毁。</p><p><strong>作用域</strong>: 变量的可见代码域（块作用域，函数作用域，类作用域，程序全局作用域）。</p><ul><li><p>局部变量m存放在栈中，当test函数结束，m将被销毁；静态变量i不存放在栈中，而是存放于程序的全局变量区域，因此随着函数test的结束，它并不随着出栈操作而被销毁，它的生存周期存在于程序的整个运行期。static局部变量只被初始化一次，下一次依据上一次结果值；</p></li><li><p>再举一个全局声明的例子。在文件A 中定义静态变量j：<br>int n=3; //默认为extern<br>static int j=5;  //声明为static<br>全局变量和静态变量j都存放于程序的全局数据区域，它们的生存周期都是程序的整个运行期，但是n的作用域为全局作用域，可以通过extern在其他文件中使用，而j只能在文件A中使用，例如在文件B中：<br>extern int n;  //ok</p><p>extern int j;  //error: j在文件B中不可见</p></li></ul><p><strong>static全局变量与普通的全局变量有什么区别</strong> </p><p>这两者的区别在于<u>非静态全局变量</u>的作用域是<u>整个源程序</u>， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而<u>静态全局变量则限制了其作用域</u>， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。 </p><p>static全局变量只初始化一次，防止在其他文件单元中被引用; 　（静态数据不初始化会被自动初始化为0）</p><p><strong>static局部变量和普通局部变量有什么区别 ？</strong></p><p>把局部变量改变为<a href="https://so.csdn.net/so/search?q=静态变量&amp;spm=1001.2101.3001.7020">静态变量</a>后是改变了它的存储方式即改变了它的<strong>生存期</strong>。把全局变量改变为静态变量后是改变了它的<strong>作用域</strong>，限制了它的使用范围。 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</p><p>static局部变量只被初始化一次，下一次依据上一次结果值； 其他文件可以定义同名函数，不会冲突。</p><p><strong>static函数与普通函数有什么区别？</strong></p><p>static函数与普通函数<strong>作用域</strong>不同,仅在本文件。只在当前源文件中使用的函数应该说明为<strong>内部函数</strong>(static修饰的函数)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.</p><p>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。其它文件中可以定义相同名字的函数，不会发生冲突；</p><p><strong>静态数据成员</strong></p><p>非静态数据成员，每个类对象都有自己的拷贝。静态数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问，值可以更新。节省存储空间。需要改的时候改的很快。没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性； </p><p>静态数据成员初始化与一般数据成员初始化不同。</p><p>静态数据成员初始化的格式为： </p><p>＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞ </p><p>类的静态数据成员有两种访问形式： </p><p>＜类对象名＞.＜静态数据成员名＞ 或 ＜类类型名＞::＜静态数据成员名＞ </p><p><strong>静态成员函数</strong> </p><p>它为类的全部服务而不是为某一个类的具体对象服务。静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，静态成员函数<strong>无法访问属于类对象的非静态数据成员</strong>，也无法访问<strong>非静态成员函数，它只能调用其余的静态成员函数</strong>。 必须定义在类体内部！</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">C程序一直由下列部分组成：</span><br><span class="line"><span class="number">1</span>）正文段（代码段）——CPU执行的机器指令部分；一个程序只有一个副本；只读，防止程序由于意外事故而修改自身指令；    </span><br><span class="line"><span class="number">2</span>）初始化数据段（数据段）——在程序中所有赋了初值的全局变量，存放在这里。    </span><br><span class="line"><span class="number">3</span>）非初始化数据段（bss段）——在程序中没有初始化的全局变量；内核将此段初始化为<span class="number">0</span>。（这就是为什么全局内置类型变量会初始化，而局部变量就为未初始化的未知值）     </span><br><span class="line"><span class="number">4</span>）栈——增长方向：自顶向下增长；自动变量以及每次函数调用时所需要保存的信息（返回地址；环境信息）。      </span><br><span class="line"><span class="number">5</span>）堆——动态存储部分。</span><br></pre></td></tr></table></figure><p>程序在内存中申请了代码段，全局数据段（初始化和未初始化），栈和堆：程序代码放于代码段，全局变量和静态变量存放在全局数据段中，一直存在直到程序结束，而局部变量都放于临时的栈中，随着作用域的结束随着出栈操作而销毁。malloc和new出来的内存不属于上面提到的程序申请的内存中，而是在系统中申请到的内存，所以如果在程序中没有明确free和delete的话，程序结束后该内存仍不会被释放，造成内存泄漏。</p><p>2、reinterpret_cast</p><p>reinterpret_cast运算符是用来处理无关类型之间的转换；它会产生一个新的值，这个值会有与原始参数（expressoin）有完全相同的比特位。可以将int *转为long long 同是8bits</p><ul><li><strong>从指针类型到一个足够大的整数类型</strong></li><li>从整数类型或者枚举类型到指针类型</li><li>从一个指向函数的指针到另一个不同类型的指向函数的指针</li><li>从一个指向对象的指针到另一个不同类型的指向对象的指针</li><li>从一个指向类函数成员的指针到另一个指向不同类型的函数成员的指针</li><li>从一个指向类数据成员的指针到另一个指向不同类型的数据成员的指针</li></ul><p>还有</p><ul><li><p><strong>static_cast&lt;类型说明符&gt;(表达式）</strong>用于进行比较“自然”和低风险的转换，如整型和浮点型、字符型之间的互相转换</p></li><li><p><strong>dynamic_cast&lt;类型说明符&gt;(表达式）</strong>专门用于将多态基类的指针或引用强制转换为派生类的指针或引用 </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base* pBase = <span class="keyword">new</span> Derived(); <span class="comment">// 转为基类</span></span><br><span class="line">pBase-&gt;print();  <span class="comment">// 虚函数 在运行时的类型来决定运行结果 Derived print!</span></span><br><span class="line">pBase-&gt;work();   <span class="comment">// 普通成员函数 编译期间决定 Base do work...</span></span><br><span class="line"></span><br><span class="line">Derived* pDerived = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(pBase);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>const_cast&lt;类型说明符&gt;(表达式）</strong> 去掉const性质（没有真正去除），将 常量转换成非常量，如果原对象本身是常量，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> constant = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* const_p = &amp;constant;</span><br><span class="line"><span class="keyword">int</span>* modifier = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(const_p);</span><br><span class="line">*modifier = <span class="number">7</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">constant: 21</span></span><br><span class="line"><span class="comment">*const_p: 7</span></span><br><span class="line"><span class="comment">*modifier: 7</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li></ul><p>3、智能指针</p><ul><li>shared_ptr 允许多指针指向同一个对象：允许拷贝和移动构造函数。</li><li>unique_ptr 独占所指向的对象：不允许拷贝和赋值构造函数。</li><li>weak_ptr 伴随类“允许默认、拷贝构造函数。</li></ul><p>4、C++11 auto关键字</p><p>4、类、函数模板 全特化、偏特化</p><p>5、右值引用</p><p>6、线性数据结构：线性表 栈 队列 双端队列 数组 串  ，非线性：树 图</p><p>7、排序过程正确的有</p><p>8、缩窄转换</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220808204639298.png" alt="image-20220808204639298"></p><p>9、STL迭代器</p><p>queue、stack没有迭代器，对于根据定义不允许顺序或随机访问的数据结构，迭代器没有任何意义。这就是<strong>堆栈和队列</strong>没有迭代器的原因，另一方面，<strong>向量和列表</strong>允许对元素进行顺序和/或随机访问，因此迭代器对于导航这些数据结构是有意义的。</p><p>10、在C++程序中调用被C 编译器编译后的函数，为什么要加extern “C”  <strong>实现 C++ 与 C 的混合编程。 解决名字匹配问题</strong></p><p>extern “C”是连接声明。被extern “C”修饰的变量和函数是按照C语言方式编译和连接的。作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：void foo( int x, int y );该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现<strong>函数重载</strong>的。</p><p>2022.8.12 10:00  </p><p>1、反转链表②</p><p>链表出现野指针问题，野指针不可为next赋值，释放指针。30min</p><p>2、vector的遍历 使用for循环和迭代器的优劣 34min</p><p>for需要知道集合或数组的大小，而且需要是有序的，不然无法遍历；</p><p>iterator都不需要知道集合或数组的大小，他们都是得到集合内的每个元素然后进行处理</p><p>iterator是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的大小的情况下进行的，当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！</p><p><a href="https://blog.51cto.com/shijianfeng/4896110">https://blog.51cto.com/shijianfeng/4896110</a></p><p>当容器中的一个元素被删除时，指向该元素后续的迭代器变得无效。上面的代码中，只要执行了erase(it),那么it就会变得无效，那么执行it++就肯定会出错。</p><ol><li><p>对于节点式容器(map, list, set)元素的删除，插入操作会导致指向该元素的迭代器失效，其他元素迭代器不受影响</p></li><li><p>对于顺序式容器(vector，string，deque)元素的删除、插入操作会导致指向该元素以及后面的元素的迭代器失效</p></li></ol><p>3、两个线程之间的同步 40min</p><p>条件变量+锁</p><p>4、项目</p><p>2022.8.12 16:00 </p><p>商业架构部 广告投放 商业相关 检索架构c++</p><p>1、2min13s 输入网址 请求发起到结束流程：DNS检查浏览器缓存、系统缓存hosts缓存，本地域名服务器，根域名服务器，顶级域名服务器，权威域名服务器。</p><p>2、http的header都有什么</p><ol><li><p>General通用信息</p><p>请求url地址， 请求方法， 状态码</p></li><li><p>请求头Request Headers</p><ul><li>User-Agent : 客户端信息</li><li>cookie : 浏览器端cookie</li><li>Origin : 目标地址</li><li>Referer : 包含一个URL，用户从该URL代表的页面出发访问当前请求的页面</li><li>Host : 客户端地址</li></ul></li><li><p>Response Headers 响应头</p><ul><li>Cache-Control 缓存哪种类型</li><li>Content-Language 响应体的语言</li></ul></li></ol><p>3、xss攻击原理</p><p>跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。</p><p>XSS的重点不在于跨站点，而在于脚本的执行。 XSS的原理是： 恶意攻击者在web页面中会插入一些恶意的script代码。 当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。</p><p>Sql 注入攻击是通过将恶意的 Sql 查询或添加语句插入到应用的输入参数中，再在后台 Sql 服务器上解析执行进行的攻击，它目前黑客对数据库进行攻击的最常用手段之一。</p><p>4、进程，线程</p><p>IPC7种方式</p><p>信号怎么给另一个程序发送信号</p><p>5、C++编译流程</p><p>6、一般用什么编译、g++编译选项</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">-D&#123;=|#&#125; 定义宏 define macro</span><br></pre></td></tr></table></figure><p>-O0 不进行优化处理。</p><p>-O 或 -O1 优化生成代码。</p><p>-O2 进一步优化。</p><p>-O3 比 -O2 更进一步优化，包括 inline 函数。</p><p>7、CPU cache 结构、如何提升代码的cache命中率</p><p>代码优化目标是提升 CPU 缓存的命中率</p><p>19min 算法题 五子棋 二维数组表示棋盘 </p><p>53min完成 </p><p>并发度比较高，提交场景下，贴吧发帖并发度高，提交多，mysql数据库性能没那么强；</p><p>2022.8.16 14:30</p><p>2min C++智能指针、什么工具排查内存泄漏</p><p>Valgrind具是一个用于调试和分析Linux程序的GPL系统。使用Valgrind的工套件，您可以自动检测许多内存管理和线程错误，使程序更稳定。还可以执行详细的分析以帮助加速程序的执行。下面我们介绍Valgrind工具集中的内存检测工具Memcheck的用法，以提高内存错误的查找效率。</p><p>2022.08.24 zk二面</p><p>1、抽象类怎么定义的，从软件工程角度讲，c++引入抽象类的作用是什么</p><p>2、定义了一个int类的指针，定义为0，然后又去访问它，编译的时候有没有问题</p><p>3、操作系统引入虚拟地址空间的作用</p><p>2022.09.02 10：00</p><p>1、hexo博客后端是什么</p><p>是nodejs</p><p>2、web服务器项目 高性能高并发是怎么体现出来的</p><p>3、select/poll/epoll区别</p><p>4、http报文格式</p><p>request</p><p>5、301 和 302 区别</p><p>6、线程池、核心线程 非核心线程</p><p>7、B树和B+树区别</p><p>8、快排思想</p><p>9、linux运维了解吗</p><p>10、服务器性能指令、cpu memory指标 df</p><ul><li><p>top：查看内存/显示系统当前进程信息</p></li><li><p>df -h：查看磁盘储存状况</p></li><li><p>iotop：查看IO读写（yum install iotop安装）</p></li><li><p>iotop -o：直接查看比较高的磁盘读写程序</p></li><li><p>netstat -tunlp | grep 端口号：查看端口号占用情况（1）</p></li><li><p>lsof -i:端口号：查看端口号占用情况（2）</p></li><li><p>uptime：查看报告系统运行时长及平均负载</p></li><li><p>ps aux：查看进程</p></li></ul><p>11、sql索引失效的情况</p><p>12、读未提交有什么问题</p><p>13、BIO和NIO</p><p>2022.09.03 17:00 </p><p>1、c11你认为最大的更新是什么</p><p><strong>类对象</strong>，在默认情况下，将一个对象赋给同类型的另外一个对象时，C++将源对象的每个数据成员复制到目标对象中相应的数据成员中</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    t1.a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Test t2;</span><br><span class="line">    t2.a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t1:&quot;</span> &lt;&lt; &amp;t1 &lt;&lt; <span class="string">&quot; a = 10 &quot;</span> &lt;&lt; t1.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t2:&quot;</span> &lt;&lt; &amp;t2 &lt;&lt; <span class="string">&quot; a = 5 &quot;</span> &lt;&lt; t2.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    t2 = t1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t1:&quot;</span> &lt;&lt; &amp;t1 &lt;&lt; <span class="string">&quot; &amp;t1:0x61fe1c a = 10 &quot;</span> &lt;&lt; t1.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t2:&quot;</span> &lt;&lt; &amp;t2 &lt;&lt; <span class="string">&quot; &amp;t2:0x61fe18 a = 10 &quot;</span> &lt;&lt; t2.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    t1.a = <span class="number">111</span>;</span><br><span class="line">    t2.a = <span class="number">222</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t1:&quot;</span> &lt;&lt; &amp;t1 &lt;&lt; <span class="string">&quot; &amp;t1:0x61fe1c a = 111 &quot;</span> &lt;&lt; t1.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t2:&quot;</span> &lt;&lt; &amp;t2 &lt;&lt; <span class="string">&quot; &amp;t2:0x61fe18 a = 222 &quot;</span> &lt;&lt; t2.a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类指针</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    Test()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Test *t1 = <span class="keyword">new</span> Test();</span><br><span class="line">    t1-&gt;a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    Test *t2 = <span class="keyword">new</span> Test();</span><br><span class="line">    t2-&gt;a = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t1:&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot; a = 10 &quot;</span> &lt;&lt; t1-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t2:&quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot; a = 5 &quot;</span> &lt;&lt; t2-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    t2 = t1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t1:&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot; &amp;t1:0xfd3f20 a = 10 &quot;</span> &lt;&lt; t1-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t2:&quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot; &amp;t2:0xfd3f20 a = 10 &quot;</span> &lt;&lt; t2-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    t1-&gt;a = <span class="number">111</span>;</span><br><span class="line">    t2-&gt;a = <span class="number">222</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t1:&quot;</span> &lt;&lt; t1 &lt;&lt; <span class="string">&quot; &amp;t1:0xfd3f20 a = 222 &quot;</span> &lt;&lt; t1-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;&amp;t2:&quot;</span> &lt;&lt; t2 &lt;&lt; <span class="string">&quot; &amp;t2:0xfd3f20 a = 222 &quot;</span> &lt;&lt; t2-&gt;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类对象和类指针区别：</p><ul><li><p>定义对象实例时，分配了内存，指针变量则未分配类对象所需内存。</p></li><li><p>指针变量是间接访问，但可实现多态（通过父类指针可调用子类对象），并且没有调用构造函数。<br>直接声明可直接访问，但不能实现多态，声明即调用了构造函数（已分配了内存）。</p></li><li><p>类的对象:用的是内存栈,是个局部的临时变量.<br>类的指针:用的是内存堆,是个永久变量,除非你释放它.  </p></li><li><p>类指针的优点：<br>第一实现多态。<br>第二，在函数调用，传指针参数。不管你的对象或结构参数多么庞大，你用指针，传过去的就是4个字节。如果用对象，参数传递占用的资源就太大了</p></li><li><p><strong>当类是有虚函数的基类,Func是它的一个虚函数,则调用Func时:<br>类的对象:调用的是它自己的Func;<br>类的指针:调用的是分配给它空间时那种类的Func;</strong> </p></li></ul><p>通过基类对象的指针（或引用）访问“同名虚函数”——&gt;动态联编</p><p>通过派生类对象访问同名函数——&gt;静态联编</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;animal sleep&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;animal breathe&quot;</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">fish</span>:</span><span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">breathe</span><span class="params">()</span></span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;fish bubble&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       fish fh;</span><br><span class="line">       animal *pAn=&amp;fh; <span class="comment">// 隐式类型转换</span></span><br><span class="line">       pAn-&gt;breathe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别于这个</p><p>编译的角度<br>C++编译器在编译的时候，要确定每个对象调用的函数（要求此函数是非虚函数）的地址，这称为<strong>早期绑定</strong>（early binding），当我们将fish类的对象fh的地址赋给pAn时，C++编译器进行了<strong>类型转换</strong>，此时C++编译器认为变量pAn保存的就是animal对象的地址。当在main()函数中执行pAn-&gt;breathe()时，调用的当然就是animal对象的breathe函数。</p><p>2、手写体现多态的例子</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; a &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; b &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; aa &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; bb &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;run();  <span class="comment">// 多态执行aa</span></span><br><span class="line">    a-&gt;run2(); <span class="comment">// b 执行基类函数；若基类没函数 仍然调用基类函数 因此报错；</span></span><br><span class="line">    A a2 = B();</span><br><span class="line">    a2.run(); <span class="comment">// a 执行基类函数</span></span><br><span class="line">    a2.run2(); <span class="comment">// b 执行基类函数</span></span><br><span class="line">    B a3 = B();</span><br><span class="line">    a3.run();  <span class="comment">// aa</span></span><br><span class="line">    a3.run2(); <span class="comment">// bb</span></span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数隐藏</strong>和函数覆盖只会发生在基类和派生类之间。</p><p>函数隐藏是指派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，这种情况就是函数的隐藏。<br>所谓隐藏是指使用常规的调用方法，派生类对象访问这个函数时，会优先访问派生类中的这个函数，基类中的这个函数对派生类对象来说是隐藏起来的。 但是隐藏并不意味这不存在或完全不可访问。通过 d-&gt;Base::func()访问基类中被隐藏的函数。</p><p>函数覆盖特指由基类中定义的虚函数引发的一种多态现象。在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。</p><p><strong>基类指针指向派生类对象</strong></p><p><strong>一、 函数在基类和派生类中都存在</strong></p><p>这时通过“指向派生类对象的基类指针”调用成员函数，调用的是基类的成员函数。</p><p><strong>二、函数在基类中不存在，在派生类中存在</strong></p><p>由于调用的还是基类中的成员函数，试图通过基类指针调用派生类才有的成员函数，则编译器会报错。</p><p><strong>三、 将基类指针强制转换为派生类指针</strong></p><p>这种是向下的强制<a href="https://so.csdn.net/so/search?q=类型转换&amp;spm=1001.2101.3001.7020">类型转换</a>，转换之后“指向派生类的基类指针”就可以访问派生类的成员函数。但是这种强制转换操作是一种<strong>潜在的危险操作</strong>。</p><p><strong>四、基类中存在虚函数的情况</strong></p><p>3、手写链表模板类</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// linklist.h</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T t;</span><br><span class="line">Node&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">LinkList();</span><br><span class="line">~LinkList();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(T &amp;t, <span class="keyword">int</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos, T &amp;t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> pos, T &amp;t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLen</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Node&lt;T&gt; *header;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::LinkList()</span><br><span class="line">&#123;</span><br><span class="line">header = <span class="keyword">new</span> Node &lt; T &gt; ;</span><br><span class="line">header-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">LinkList&lt;T&gt;::~LinkList()</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt; *tmp = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (header) &#123;</span><br><span class="line">tmp = header-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> header;</span><br><span class="line">header = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;T&gt;::clear()</span><br><span class="line">&#123;</span><br><span class="line">~LinkList();</span><br><span class="line">LinkList();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;T&gt;::insert(T &amp;t, <span class="keyword">int</span> pos)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt; *cur = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对pos的容错处理</span></span><br><span class="line"><span class="keyword">if</span> (pos &gt;= length) &#123;</span><br><span class="line">pos = length;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">cur = header;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i) &#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 把上层应用的t结点缓存到容器中</span></span><br><span class="line">Node&lt;T&gt; *node = <span class="keyword">new</span> Node &lt; T &gt; ;</span><br><span class="line">node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">node-&gt;t = t; <span class="comment">// 把t缓存到容器中</span></span><br><span class="line"> </span><br><span class="line">node-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = node;</span><br><span class="line"> </span><br><span class="line">++length;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;T&gt;::get(<span class="keyword">int</span> pos, T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt; *cur = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (pos &gt;= length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">cur = header;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i) &#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">t = cur-&gt;next-&gt;t; <span class="comment">// 把pos位置的结点赋值给t</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;T&gt;::del(<span class="keyword">int</span> pos, T &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">Node&lt;T&gt; *cur = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (pos &gt;= length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">cur = header;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i) &#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">Node&lt;T&gt; *ret = <span class="literal">NULL</span>;</span><br><span class="line">ret = cur-&gt;next;</span><br><span class="line">t = ret-&gt;t; <span class="comment">// 把缓存的结点给上层应用t</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line">cur-&gt;next = ret-&gt;next;</span><br><span class="line">--length;</span><br><span class="line"><span class="keyword">delete</span> ret; <span class="comment">// 注意释放内存，因为insert的时候new Node&lt;T&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> LinkList&lt;T&gt;::getLen()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> work </category>
          
      </categories>
      
      
        <tags>
            
            <tag> work </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++11新特性</title>
      <link href="2022/08/18/blog64-smartptr/"/>
      <url>2022/08/18/blog64-smartptr/</url>
      
        <content type="html"><![CDATA[<h2 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h2><p>将其它类型转换为当前类类型需要借助转换构造函数（Conversion constructor）</p><h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。</p><ol><li>​    Student stu2 = stu1;  //调用拷贝构造函数</li><li>​    Student stu3(stu1);  //调用拷贝构造函数</li></ol><p>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。</p><h3 id="为什么是-const-引用呢？"><a href="#为什么是-const-引用呢？" class="headerlink" title="为什么是 const 引用呢？"></a>为什么是 const 引用呢？</h3><p>添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。</p><h2 id="拷贝赋值构造函数"><a href="#拷贝赋值构造函数" class="headerlink" title="拷贝赋值构造函数"></a>拷贝赋值构造函数</h2><h2 id="移动构造"><a href="#移动构造" class="headerlink" title="移动构造"></a>移动构造</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = get_demo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</span></span><br><span class="line"><span class="comment">// 2 执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</span></span><br><span class="line"><span class="comment">// 3 执行 a = get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</span></span><br><span class="line"><span class="comment">// 4 程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</span></span><br></pre></td></tr></table></figure><p>目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p><p>-fno-elide-constructors</p><p><strong>利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作</strong></p><p><strong>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</strong></p><p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数<strong>使用右值引用</strong>形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是<strong>浅拷贝</strong>的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p><ol><li>​    demo(demo &amp;&amp;d):num(d.num){</li><li>​        d.num = NULL;</li><li>​        cout&lt;&lt;”move construct!”&lt;&lt;endl;</li><li>​    }</li></ol><p>当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 <strong>2 次</strong>拷贝操作，都转由<strong>移动构造</strong>函数完成。</p><p>当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会<strong>优先</strong>调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220819003402549.png" alt="image-20220819003402549"></p><hr><p><a href="https://zhuanlan.zhihu.com/p/335994370">https://zhuanlan.zhihu.com/p/335994370</a></p><p><strong>左值</strong>：左值可以取地址，位于等号左边，具有名字的.包括</p><ul><li>变量名</li><li>返回左值引用的函数调用</li><li>int a = 0; int b = a; </li><li>前置自增。</li><li>赋值运算或复合赋值运算 ( i = 9) = 100; ( i += 10 ) = 1000;</li><li>解引用</li></ul><p><strong>右值</strong>：右值只能在等号右边，不能取地址，不具有名字。</p><ol><li><p>纯右值</p><ul><li>字面值</li><li>返回非引用类型的函数调用</li><li>后置自增</li><li>算术表达式/比较表达式/逻辑表达式</li></ul></li><li><p>将亡值（c11新引入的 与右值引用（移动语义）相关的值类型） 将亡值用来触发移动构造或移动赋值构造，并进行资源转移，之后值将调用析构函数</p></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A a = A();</span><br></pre></td></tr></table></figure><ul><li>同样的，a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li><li>A()是个临时值，没法通过 &amp; 取地址，位于等号右边，所以A()是个右值。</li></ul><p><strong>左值引用</strong>是对左值的引用；<strong>右值引用</strong>是对右值的引用。</p><p><strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。</strong></p><p><strong>const左值引用</strong>是可以指向右值的，<strong>const左值引用不会修改指向值，因此可以指向右值。但是引用又需要修改变量值，因此引出右值引用。</strong></p><p><strong>右值引用</strong>，右值引用的标志是&amp;&amp;，可以指向右值，不能指向左值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_left = a; <span class="comment">// 编译不过，右值引用不可以指向左值</span></span><br><span class="line"></span><br><span class="line">ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br></pre></td></tr></table></figure><h3 id="右值引用有办法指向左值吗？std-move"><a href="#右值引用有办法指向左值吗？std-move" class="headerlink" title="右值引用有办法指向左值吗？std::move"></a><strong>右值引用有办法指向左值吗？</strong>std::move</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="built_in">std</span>::move(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br></pre></td></tr></table></figure><p>看上去是左值a通过std::move移动到了右值ref_a_right中，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code></p><p>同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="number">5</span>;</span><br><span class="line">ref_a = <span class="number">6</span>; </span><br><span class="line"> </span><br><span class="line">等同于以下代码：</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="built_in">std</span>::move(temp);</span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><strong>被声明出来的左、右值引用都是左值</strong>，std::move会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以move返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：<strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p><p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>没有什么区别，等号左边就是左值，右边就是右值。</p><hr><p>最后，从上述分析中我们得到如下结论：</p><ol><li><strong>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</strong>左值引用和右值引用都是左值。</li><li><strong>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li><li><strong>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</strong>const右值可以修改。</li></ol><h3 id="3-右值引用和std-move的应用场景"><a href="#3-右值引用和std-move的应用场景" class="headerlink" title="3. 右值引用和std::move的应用场景"></a><strong>3. 右值引用和std::move的应用场景</strong></h3><p>在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。 在没有右值引用之前，一个简单的数组类通常实现如下，有<code>构造函数</code>、<code>拷贝构造函数</code>、<code>赋值运算符重载</code>、<code>析构函数</code>等。深拷贝/浅拷贝在此不做讲解。</p><p>在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a><strong>完美转发 std::forward</strong></h3><p>与move相比，forward更强大，move只能转出来右值，forward都可以。</p><blockquote><p>std::forward(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>&amp;&amp; ref_r)</span> </span>&#123;</span><br><span class="line">    ref_r = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A、B的入参是右值引用</span></span><br><span class="line"><span class="comment">// 有名字的右值引用是左值，因此ref_r是左值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span>&amp;&amp; ref_r)</span> </span>&#123;</span><br><span class="line">    B(ref_r);  <span class="comment">// 错误，B的入参是右值引用，需要接右值，ref_r是左值，编译失败</span></span><br><span class="line">     </span><br><span class="line">    B(<span class="built_in">std</span>::move(ref_r)); <span class="comment">// ok，std::move把左值转为右值，编译通过</span></span><br><span class="line">    B(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(ref_r));  <span class="comment">// ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    A(<span class="built_in">std</span>::move(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左值引用和右值引用功能差异"><a href="#左值引用和右值引用功能差异" class="headerlink" title="左值引用和右值引用功能差异"></a>左值引用和右值引用功能差异</h3><ol><li><p>左值引用避免对象拷贝：函数传参和函数返回值。</p><p>T&amp; f()：返回类的引用可以作为左值，并且返回的类类型引用可以直接调用成员函数来修改，返回的类类型不会调用复制构造函数。</p></li><li><p>右值引用：实现移动语义和完美转发。</p><p>移动语义：</p><ul><li>对象赋值的时候，避免资源的重新分配。</li><li>移动构造以及移动拷贝构造</li><li>stl应用 alist.push_back(A()) 用了移动构造</li><li>std::unique_ptr</li></ul><p>实现完美转发：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">revoke</span><span class="params">(T &amp;&amp;t)</span> </span>&#123;</span><br><span class="line">    func(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数模板可以将自己的参数完美地转发给内部调用的其他函数。</li><li>完美指不仅能转发参数的值，还能保证被转发的参数的左右值属性不变。</li><li>借用万能引用，通过引用的方式接收左右值。</li><li>引用折叠规则，参数为左值或者左值引用T&amp;&amp;会转化为int &amp;，右值或右值引用转为int &amp;&amp;</li><li>std::forwad<T>(v) T为左值引用，v将转为T类型的左值；T为右值引用，V将转为T类型的右值。forward作用是解引用。</li></ul><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220819101639616.png" alt="image-20220819101639616"></p></li></ol><hr><p><a href="https://www.bilibili.com/video/BV1bG411n79V?spm_id_from=333.880.my_history.page.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8">https://www.bilibili.com/video/BV1bG411n79V?spm_id_from=333.880.my_history.page.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8</a></p><hr><p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaike.baidu.com%2Flink%3Furl%3DEYX-dODwSQw-1pxK8PiUviIBypeiZemhztsktVj85DByLHqTUiAvzFdorWB9HqEUvztZX_uecf7ZIQaUBWr_A3FPzlQYuz-9MFJQthsrXvr5OYQkXnGVwjTjMxjRy6VM">core dump</a>(核心转储/吐核)：是操作系统在进程收到某些信号而终止运行时，将此时进程地址空间的内容以及有关进程状态的其他信息写出的一个磁盘文件。这种信息往往用于调试。<br>C/C++程序常见coredump总结：</p><p>无效指针引起的程序coredump,大致可以分为4种原因引起异常。<br> (1)对空指针进行了操作。<br> (2)对一个未初始化的指针进行了操作。<br> (3)对一个已经调用了delete释放了内存的指针再次调用了delete去重复释放。<br> (4)多线程访问全局变量，导致内存值异常。</p><p>注:</p><ol><li>存放Coredump的目录即进程的当前目录。(1)/proc/sys /kernel/core_uses_pid可以控制core文件的文件名中是否添加pid作为扩展。(2)proc/sys/kernel/core_pattern可以控制core文件保存位置和文件名格式。</li><li>core文件的生成开关和大小限制：<code>ulimit</code>。</li><li>用gdb查看core文件：<code>gdb [exec file] [core file]</code>。</li></ol><hr><h2 id="指针管理的困境"><a href="#指针管理的困境" class="headerlink" title="指针管理的困境"></a>指针管理的困境</h2><ol><li>资源释放了，指针没有置空：<ul><li>野指针：如果未来接着使用这个内存，会判断存在。指针没初始化，不确定指向哪。未初始化的指针被称为野指针，可能是null，也可能指向合法内存（野）。</li><li>指针悬挂：多个指针指向同一个资源，其中一个指针将资源删除且置空了，但其他指针不知道，还在使用。指针所指的内存空间已经删除，指针指向空间就不确定了。当指针所指向的对象被释放，但是该指针没有任何改变，以至于其仍然指向已经被回收的内存地址，这种情况下该指针被称为悬挂指针；</li><li>踩内存：访问了不应该访问的内存</li></ul></li><li>没有释放内存导致内存泄漏</li><li>重复释放资源引发coredump</li></ol><p>怎么解决：RAII</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="2022/08/08/blog62-sort/"/>
      <url>2022/08/08/blog62-sort/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1656597367-EDjKrb-%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.png" alt="十大经典排序算法.png"></p><h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><p>从前往后 两两交换，最大的浮到最后</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                swap(arr[j], arr[j + <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><p>找到最小 和位置0换，找到次小，和位置1换</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> min = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.size(); j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                                min = j;</span><br><span class="line">                <span class="built_in">std</span>::swap(arr[i], arr[min]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、插入排序"><a href="#3、插入排序" class="headerlink" title="3、插入排序"></a>3、插入排序</h2><p>一把牌，后面没排序的，一张张换到前面来。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> key=arr[i];</span><br><span class="line">                <span class="keyword">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>]=key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、希尔排序"><a href="#4、希尔排序" class="headerlink" title="4、希尔排序"></a>4、希尔排序</h2><p>希尔排序是基于插入排序.</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。D=1时退化成插入排序。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> D = nums.size() / <span class="number">2</span>; D &gt; <span class="number">0</span>; D /= <span class="number">2</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = D; i &lt; nums.size(); i++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j = i ;</span><br><span class="line">            <span class="keyword">for</span> ( ; j &gt;= D &amp;&amp; nums[j-D] &gt;key; j -= D ) &#123;</span><br><span class="line">                nums[j] = nums[j-D];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = key;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h2><p>1和2先排序，3和4排序，1234排序</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(nums, left, mid);</span><br><span class="line">    mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j]) &#123;</span><br><span class="line">            tmp[cnt++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[cnt++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        tmp[cnt++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">        tmp[cnt++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        nums[i + left] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i, <span class="keyword">int</span> end)</span> </span>&#123; <span class="comment">// 和子比 大子往上 一步步循环往下</span></span><br><span class="line">    <span class="keyword">for</span> ( ; i * <span class="number">2</span> + <span class="number">1</span> &lt;= end; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> leftSon = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSon = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> large = i;</span><br><span class="line">        <span class="keyword">if</span> ( leftSon &lt;= end &amp;&amp; nums[leftSon] &gt; nums[i] ) large = leftSon;</span><br><span class="line">        <span class="keyword">if</span> ( rightSon &lt;= end &amp;&amp; nums[rightSon] &gt; nums[large] ) large = rightSon;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( large != i ) &#123;</span><br><span class="line">            swap( nums[i], nums[large] );</span><br><span class="line">            i = large;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = (len - <span class="number">1</span>) / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; i-- ) <span class="comment">// 从最后一个父节点（独生子也行）开始往回</span></span><br><span class="line">        maxHeapify(nums, i, len - <span class="number">1</span>); <span class="comment">// 最大值在最上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i-- ) &#123;</span><br><span class="line">        swap( nums[i], nums[<span class="number">0</span>] );</span><br><span class="line">        len -= <span class="number">1</span>;</span><br><span class="line">        maxHeapify(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    quickSort( nums, <span class="number">0</span>, nums.size() - <span class="number">1</span> );</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( left &lt; right ) &#123;</span><br><span class="line">        <span class="keyword">int</span> randVal = rand() % ( right - left + <span class="number">1</span> ) + left;</span><br><span class="line">        swap( nums[randVal], nums[right] );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = nums[right];</span><br><span class="line">        <span class="keyword">int</span> i = left - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = left; j &lt; right; j++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[j] &lt; pivot ) &#123; <span class="comment">//j遇小则换</span></span><br><span class="line">                i = i + <span class="number">1</span>;</span><br><span class="line">                swap( nums[j], nums[i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap( nums[right], nums[i+<span class="number">1</span>] );</span><br><span class="line">        <span class="keyword">int</span> pos = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        quickSort(nums, left, pos - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, pos + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL基础记录</title>
      <link href="2022/08/02/blog60-mysql/"/>
      <url>2022/08/02/blog60-mysql/</url>
      
        <content type="html"><![CDATA[<p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。  </p><h2 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h2><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>上述就是事务的四大特性，简称ACID。</p><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><ul><li>赃读：一个事务读到另外一个事务还没有提交的数据。  </li><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读  </li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。  </li></ul><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220802101439343.png" alt="image-20220802101439343"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++构造析构顺序问题</title>
      <link href="2022/07/30/blog59-baseDerived/"/>
      <url>2022/07/30/blog59-baseDerived/</url>
      
        <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>先构造父类，再构造子类，其中父类的构造顺序是从左到右。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Construct A</span><br><span class="line">Construct C</span><br><span class="line">Construct B</span><br><span class="line">Destruct B</span><br><span class="line">Destruct C</span><br><span class="line">Destruct A</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/abc1.png" alt="类图"></p><hr><h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><p>现在ABC之间<strong>不再是继承关系</strong>，而是<strong>组合关系</strong>。B类中有A和C两个类型的变量。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Notice</span></span><br><span class="line">B(): a(A()), c(C()) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">C c;</span><br><span class="line">A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列表初始化是先于构造函数的调用的，而且列表初始化是与初始化顺序无关，只与数据成员定义的顺序有关</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Construct C</span><br><span class="line">Construct A</span><br><span class="line">Construct B</span><br><span class="line">Destruct B</span><br><span class="line">Destruct A</span><br><span class="line">Destruct C</span><br></pre></td></tr></table></figure><h2 id="继承与列表初始化"><a href="#继承与列表初始化" class="headerlink" title="继承与列表初始化"></a>继承与列表初始化</h2><p>下面的例子中B类继承了A和C，然后又拥有一个A和C类型的成员变量，虽然不符合设计模式，但是就将就看了。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Notice: List initialize</span></span><br><span class="line">B(): a(A()), c(C()) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">C c;</span><br><span class="line">A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类在<strong>构造</strong>的时候会先从左到右调用父类的构造函数，然后根据类中<strong>数据成员</strong>的定义依次构造</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Construct A</span><br><span class="line">Construct C</span><br><span class="line">Construct C</span><br><span class="line">Construct A</span><br><span class="line">Construct B</span><br><span class="line">Destruct B</span><br><span class="line">Destruct A</span><br><span class="line">Destruct C</span><br><span class="line">Destruct C</span><br><span class="line">Destruct A</span><br></pre></td></tr></table></figure><h2 id="虚拟继承，继承，与列表初始化"><a href="#虚拟继承，继承，与列表初始化" class="headerlink" title="虚拟继承，继承，与列表初始化"></a>虚拟继承，继承，与列表初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~A()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct A&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~C()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct C&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Notice: C is a virtual public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A, <span class="keyword">public</span> <span class="keyword">virtual</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(): a(A()), c(C()) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Construct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">~B()&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Destruct B&quot;</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">C c;</span><br><span class="line">A a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行<strong>虚拟继承</strong>的父类的构造函数，然后从左到右执行普通<strong>继承</strong>的父类的构造函数，然后按照定义的顺序执行<strong>数据成员</strong>的初始化，最后是<strong>自身的构造函数</strong>的调用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Construct C</span><br><span class="line">Construct A</span><br><span class="line">Construct C</span><br><span class="line">Construct A</span><br><span class="line">Construct B</span><br><span class="line">Destruct B</span><br><span class="line">Destruct A</span><br><span class="line">Destruct C</span><br><span class="line">Destruct A</span><br><span class="line">Destruct C</span><br></pre></td></tr></table></figure><hr><p>一个例子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Base() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VBase1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VBase1() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is VBase1&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VBase2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  VBase2() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is VBase2&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> :</span> <span class="keyword">public</span> Base, <span class="keyword">virtual</span> <span class="keyword">public</span> VBase1, <span class="keyword">virtual</span> <span class="keyword">public</span> VBase2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is A &quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is B&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is C&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  E() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is E &quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  D() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; this is D&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  C c;</span><br><span class="line">  E e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  D d = D();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20190815113449656.png" alt="在这里插入图片描述"></p><p>执行虚基类的构造函数（不管是几重继承），执行的顺序是虚基类继承的顺序</p><p>B比Base优先；</p><hr><p>再来一个例子</p><p><a href="https://blog.csdn.net/qq_45532226/article/details/105278043">https://blog.csdn.net/qq_45532226/article/details/105278043</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;X &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Y() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Y &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Z() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Z &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  B() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B, <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  C() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;C &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  D() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;D &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">public</span> C, <span class="keyword">virtual</span> <span class="keyword">public</span> D, <span class="keyword">virtual</span> <span class="keyword">public</span> Z &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  X objX;</span><br><span class="line">  Y objY;</span><br><span class="line">  E() &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;E &quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  E obj;</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B A.    B A.</p><p> C         D.       Z.</p><p>​        (XY)E</p><p>A B！ D Z   B C   X Y E</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数指针/数组指针</title>
      <link href="2022/07/28/blog58-funcPtr/"/>
      <url>2022/07/28/blog58-funcPtr/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/lixd1210/article/details/104847089">https://blog.csdn.net/lixd1210/article/details/104847089</a></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> x)</span></span>;   <span class="comment">/*声明一个函数*/</span></span><br><span class="line"><span class="keyword">int</span> (*p) (<span class="keyword">int</span> x);  <span class="comment">/*定义一个函数指针*/</span></span><br><span class="line">p = Func;          <span class="comment">/*将Func函数的首地址赋给指针变量p*/</span></span><br></pre></td></tr></table></figure><hr><p>方式1</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func(int, int)&quot;</span> &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1 :声明一种函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(MY_FUNC)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">MY_FUNC *fp = <span class="literal">NULL</span>;</span><br><span class="line">fp = func;</span><br><span class="line">fp(<span class="number">15</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>方式2：函数指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式2 :声明一种函数类型的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*MY_FUNC_P)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.方式2举例</span></span><br><span class="line">MY_FUNC_P fp1 = <span class="literal">NULL</span>;</span><br><span class="line">fp1 = func;</span><br><span class="line">fp1(<span class="number">25</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>方式3</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式3 :直接通过指针类型创建，不需用typedef预定义。</span></span><br><span class="line"><span class="keyword">int</span> (*fp3)(<span class="keyword">int</span>, <span class="keyword">int</span>) = <span class="literal">NULL</span>;</span><br><span class="line">fp3 = func;</span><br><span class="line">fp3(<span class="number">27</span>, <span class="number">89</span>);</span><br></pre></td></tr></table></figure></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">下列对函数指针声明描述正确的是</span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">fptr</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">fptr</span><span class="params">(<span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*fptr)(<span class="keyword">int</span>*); <span class="comment">//是</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fptr)</span><span class="params">(<span class="keyword">int</span>*)</span></span>; <span class="comment">//是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*fptr)(<span class="keyword">int</span>*); <span class="comment">//是</span></span><br></pre></td></tr></table></figure></h2><p><strong>数组指针</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">888</span>, <span class="number">252</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*p)[n]; <span class="comment">// 数组指针（也称行指针）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*a)[<span class="number">10</span>] = &amp;arr; <span class="comment">// a指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;b)[<span class="number">10</span>] = arr; <span class="comment">// b引用一个含有10个证书的数组</span></span><br></pre></td></tr></table></figure><p>指针数组</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[n];</span><br></pre></td></tr></table></figure></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如要表示数组中i行j列一个元素：</span></span><br><span class="line">*(p[i]+j)</span><br><span class="line">*(*(p+i)+j)</span><br><span class="line">(*(p+i))[j]</span><br><span class="line">p[i][j]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> p1[<span class="number">3</span>]; <span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">int</span> *p2[<span class="number">3</span>];     <span class="comment">// 指针数组，数组里的元素是指针类型，是一个由返回整型数据的指针所组成的数组</span></span><br><span class="line"><span class="keyword">int</span>(*p3)[<span class="number">3</span>]; <span class="comment">// 数组指针 指向了一个数组，数组有3个指针元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p4</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// p4是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">p5</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// p5是一个函数，返回一个指针，所以是指针函数。</span></span><br><span class="line"><span class="keyword">int</span> (*p6)(<span class="keyword">int</span>); <span class="comment">// p6是一个函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*p7)(<span class="keyword">int</span>)[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(*p9(<span class="keyword">int</span>))[<span class="number">3</span>]; <span class="comment">// = int* A[3] A是个指针数组 , A调用 (*p(int))指针函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(*(*p10)(<span class="keyword">int</span>))[<span class="number">3</span>]; <span class="comment">// p 是一个函数指针，这个函数接收一个int 参数，返回一个指针，指向数组，数组有3个元素，元素是 int *</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(*p11(<span class="keyword">int</span>))[<span class="number">3</span>];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sizeof总结</title>
      <link href="2022/07/26/blog57-sizeof/"/>
      <url>2022/07/26/blog57-sizeof/</url>
      
        <content type="html"><![CDATA[<p>sizeof运算符返回一条表达式（表达式结果类型的大小）或一个类型名字所占的字节数。</p><p>32位系统指针是4字节，64位系统指针是8字节</p><hr><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>没有成员的结构体占用的空间是多少个字节？</p><pre><code> 答案是：1个字节。 这就是实例化的原因（空类同样可以被实例化），每个实例在内存中都有一个独一无二的地址，为了达到这个目的，编译器往往会给一个空类或空结构体（C++中结构体也可看为类）隐含的加一个字节，这样空类或空结构体在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。</code></pre><p>sizeof求结构体大小的问题</p><p><a href="https://www.bilibili.com/video/BV1be411x7ah?share_source=copy_web&amp;vd_source=17cdeb76122f8dc86347b37ac29fd89d">https://www.bilibili.com/video/BV1be411x7ah?share_source=copy_web&amp;vd_source=17cdeb76122f8dc86347b37ac29fd89d</a> 看懂了</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220726142031151.png" alt="image-20220726142031151"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220726142349090.png" alt="image-20220726142349090"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu1</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">     <span class="keyword">int</span> i;  <span class="comment">// 对齐单位是：4，[0]~[3]</span></span><br><span class="line">     <span class="keyword">char</span> c;  <span class="comment">// 对齐单位是：1，[4]~[5]</span></span><br><span class="line">     <span class="keyword">int</span> j;  <span class="comment">// 对齐单位是：4，[8]~[11]</span></span><br><span class="line">&#125;; <span class="comment">//总长度应为对齐单位(4)的倍数:12</span></span><br></pre></td></tr></table></figure><p>4 + 4 + 4 = 12 </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu1</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> *i;  <span class="comment">// 对齐单位是：8，[0]~[7]</span></span><br><span class="line">  <span class="keyword">int</span> j;   <span class="comment">// 对齐单位是：4，[8]~[11]</span></span><br><span class="line">  <span class="keyword">short</span> c; <span class="comment">// 对齐单位是：2，[12]~[13]</span></span><br><span class="line">&#125;;<span class="comment">//总长度应为对齐单位(4)的倍数:16</span></span><br></pre></td></tr></table></figure><p>12-&gt;16</p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>   <span class="title">s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span>   x: <span class="number">3</span>; </span><br><span class="line">   <span class="keyword">int</span>   y: <span class="number">4</span>; </span><br><span class="line">   <span class="keyword">int</span>   z: <span class="number">5</span>; <span class="comment">// 对齐单位是：4，[0]~[3]</span></span><br><span class="line">   <span class="keyword">double</span>   a; <span class="comment">// 对齐单位是：8，[8]~[15]</span></span><br><span class="line">&#125; <span class="comment">//总长度应为对齐单位(8)的倍数:16</span></span><br></pre></td></tr></table></figure><p>C语言的语法：位域。需要看清楚该结构体中是位操作，三个变量共占用一个int类型的大小，int类型占用4个字节，double占用8个字节。为了实现内存对齐，int类型需要填充4个字节的长度。前面补4位，4+4+8=16  </p><p>答案16字节</p><hr><p><strong>结构体嵌套</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student4</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;        <span class="comment">//对齐单位是：4，[0]~[3]</span></span><br><span class="line"><span class="keyword">double</span> weight; <span class="comment">//对齐单位是：8，[8]~[15]</span></span><br><span class="line"><span class="keyword">float</span> height;  <span class="comment">//[16]~[19]</span></span><br><span class="line">&#125;Stu4;                 <span class="comment">//总长度应为对齐单位(8)的倍数:24</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结构体作为成员：如果一个结构体中同时包含结构体成员，则结构体成员要<strong>从其内部最大元素大小的整数倍地址</strong>开始存储（如struct  a中有struct b，而b中有char,int,double等元素，那么b应该从8(double类型的大小）的整数倍开始存储。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体内嵌结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student5</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;        <span class="comment">//对齐单位是：4，[0]~[3]</span></span><br><span class="line"><span class="keyword">double</span> score;  <span class="comment">//对齐单位是：8，[8]~[15]</span></span><br><span class="line"><span class="keyword">short</span> grade;   <span class="comment">//[16]~[17]</span></span><br><span class="line">Stu4 aa;       <span class="comment">//对齐单位是：8，[24]~[47]</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">2</span>];  <span class="comment">//[48]~[49]</span></span><br><span class="line">&#125;Stu5;             <span class="comment">//总长度应为对齐单位(8)的倍数:56</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220726145422755.png" alt="image-20220726145422755"></p><p>2-&gt;4 + 1-&gt;4 + 4 + 4 = 16</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu5</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">      <span class="keyword">char</span> i;   <span class="comment">//对齐单位是：1，[0]~[1]</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span>   </span></span><br><span class="line"><span class="class">      &#123;</span>  </span><br><span class="line">           <span class="keyword">char</span> c;  <span class="comment">//对齐单位是：1，[0]~[1]</span></span><br><span class="line">           <span class="keyword">int</span> j;  <span class="comment">//对齐单位是：4，[4]~[8]</span></span><br><span class="line">      &#125; ss;   <span class="comment">//对齐单位是：4，长度8 [4]~[11]</span></span><br><span class="line">      <span class="keyword">char</span> a;   <span class="comment">//对齐单位是：1，[12]~[13]</span></span><br><span class="line">      <span class="keyword">char</span> b;  </span><br><span class="line">      <span class="keyword">char</span> d;  </span><br><span class="line">      <span class="keyword">char</span> e;  </span><br><span class="line">      <span class="keyword">char</span> f;   <span class="comment">//对齐单位是：1，[16]~[17]</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>1-&gt;4 + 1-&gt;4 + 4 + 5  = 17-&gt; 20 </p><hr><h2 id="联合体-共用体"><a href="#联合体-共用体" class="headerlink" title="联合体/共用体"></a>联合体/共用体</h2><p><a href="https://codeantenna.com/a/V2wGOueu0U">https://codeantenna.com/a/V2wGOueu0U</a></p><p>长度为联合中元类型（如数组，取其类型的数据长度）最大的变量长度(对齐单位)的整数倍，且要大于等于其最大成员所占的存储空间。<strong>大于等于各种成员总长度，且为对齐单位的整数倍。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//联合体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a;         <span class="comment">//对齐单位：4，总长度：4</span></span><br><span class="line"><span class="keyword">double</span> d;      <span class="comment">//对齐单位：8，总长度：8</span></span><br><span class="line">&#125;Foo1;       <span class="comment">//对齐单位：8，最大存储长度8，因此联合体的长度应为对齐单位的倍数：8</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//联合体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];    <span class="comment">//对齐单位：1，总长度：10</span></span><br><span class="line"><span class="keyword">int</span> a;         <span class="comment">//对齐单位：4，总长度：4</span></span><br><span class="line">&#125;Foo1;                 <span class="comment">//对齐单位：8，最大存储长度10，因此联合体的长度应为对齐单位4的倍数：12</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//联合体</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];    <span class="comment">//对齐单位：1，总长度：10</span></span><br><span class="line"><span class="keyword">int</span> a;         <span class="comment">//对齐单位：4，总长度：4</span></span><br><span class="line"><span class="keyword">double</span> d;      <span class="comment">//对齐单位：8，总长度：8</span></span><br><span class="line">&#125;Foo1;                 <span class="comment">//对齐单位：8，最大存储长度10，因此联合体的长度应为对齐单位8的倍数：16</span></span><br></pre></td></tr></table></figure><p>2、联合体内嵌结构体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student4</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;        <span class="comment">//对齐单位是：4，[0]~[3]</span></span><br><span class="line"><span class="keyword">double</span> weight; <span class="comment">//对齐单位是：8，[8]~[15]</span></span><br><span class="line"><span class="keyword">float</span> height;  <span class="comment">//[16]~[19]</span></span><br><span class="line">&#125;Stu4;                 <span class="comment">//总长度应为对齐单位(8)的倍数:24</span></span><br><span class="line"><span class="comment">//联合体包含结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">foo2</span>&#123;</span></span><br><span class="line">Stu4 bb;       <span class="comment">//对齐单位：8，总长度：24</span></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];    <span class="comment">//对齐单位：1，总长度：10</span></span><br><span class="line"><span class="keyword">int</span> a;         <span class="comment">//对齐单位：4，总长度：4</span></span><br><span class="line"><span class="keyword">double</span> d;      <span class="comment">//对齐单位：8，总长度：8</span></span><br><span class="line">&#125;Foo2;             <span class="comment">//对齐单位：8，长度应为对齐单位的倍数：24</span></span><br></pre></td></tr></table></figure><p>​    3、结构体内嵌联合体</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体包含联合体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student6</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> num[<span class="number">10</span>];  <span class="comment">//对齐单位：1，[0]~[9]</span></span><br><span class="line"><span class="keyword">int</span> no[<span class="number">10</span>];    <span class="comment">//对齐单位：4，[12]~[51]</span></span><br><span class="line">Foo2 cc;       <span class="comment">//对齐单位：8，[56]~[79]</span></span><br><span class="line"><span class="keyword">char</span> a;        <span class="comment">//对齐单位：1，[80]</span></span><br><span class="line"><span class="keyword">double</span> a1;     <span class="comment">//对齐单位：8，[88]~[95]</span></span><br><span class="line"><span class="keyword">int</span> a2;        <span class="comment">//对齐单位：4，[96]~[99]</span></span><br><span class="line">&#125;Stu6;             <span class="comment">//对齐单位：8，长度应为对齐单位的倍数：104</span></span><br></pre></td></tr></table></figure><h2 id="枚举enum"><a href="#枚举enum" class="headerlink" title="枚举enum"></a>枚举enum</h2><p>​    1、enum只是定义了一个常量集合，里面没有“元素”，而枚举类型是当做int来存储的，所以枚举类型的sizeof值都为4。</p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    saturday,</span><br><span class="line"></span><br><span class="line">    sunday = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    monday,</span><br><span class="line"></span><br><span class="line">    tuesday,</span><br><span class="line"></span><br><span class="line">    wednesday,</span><br><span class="line"></span><br><span class="line">    thursday,</span><br><span class="line"></span><br><span class="line">    friday</span><br><span class="line"></span><br><span class="line">&#125; workday; <span class="comment">//变量workday的类型为枚举型enum DAY</span></span><br></pre></td></tr></table></figure></h2><hr><h2 id="char数组"><a href="#char数组" class="headerlink" title="char数组"></a>char数组</h2><p>sizeof不是函数，仅仅是一个操作符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">char</span> char1[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> char2[<span class="number">9</span>] = &#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">  <span class="keyword">char</span> *char3 = (<span class="keyword">char</span> *)<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  <span class="built_in">string</span> char4 = <span class="string">&quot;this is a string.this is a string.this is a string.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char1[] = &#123;&#x27;a&#x27;,&#x27;b&#x27;&#125;        -&gt; sizeof:&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(char1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char2[9] = &#123;&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125; -&gt; sizeof:&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(char2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char3 \&quot;hello world\&quot;        -&gt; sizeof:&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(char3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char4 string \&quot;this is a string.\&quot;-&gt; sizeof:&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(char4)</span><br><span class="line">       &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char1[10] = &#123;&#x27;a&#x27;,&#x27;b&#x27;&#125;        -&gt; strlen:&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(char1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char2[9] = &#123;&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27;&#125; -&gt; strlen:&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(char2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char3 \&quot;hello world\&quot;        -&gt; strlen:&quot;</span> &lt;&lt; <span class="built_in">strlen</span>(char3) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">//    cout&lt;&lt; &quot;char4 -&gt; strlen:&quot;&lt;&lt;strlen(char4)&lt;&lt;endl;       //编译不通过</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char4 string \&quot;this is a string.\&quot;-&gt; length:&quot;</span> &lt;&lt; char4.length()</span><br><span class="line">       &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;char4 string \&quot;this is a string.\&quot;-&gt; size:&quot;</span> &lt;&lt; char4.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char1[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;        -&gt; <span class="keyword">sizeof</span>:<span class="number">2</span></span><br><span class="line">char2[<span class="number">9</span>] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125; -&gt; <span class="keyword">sizeof</span>:<span class="number">9</span></span><br><span class="line">char3 <span class="string">&quot;hello world&quot;</span>        -&gt; <span class="keyword">sizeof</span>:<span class="number">8</span>  <span class="comment">// 指针！</span></span><br><span class="line">char4 <span class="built_in">string</span> <span class="string">&quot;this is a string.&quot;</span>-&gt; <span class="keyword">sizeof</span>:<span class="number">32</span> <span class="comment">// string 多长都是32</span></span><br><span class="line"></span><br><span class="line">char1[<span class="number">10</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>&#125;        -&gt; <span class="built_in">strlen</span>:<span class="number">2</span></span><br><span class="line">char2[<span class="number">9</span>] = &#123;<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125; -&gt; <span class="built_in">strlen</span>:<span class="number">4</span></span><br><span class="line">char3 <span class="string">&quot;hello world&quot;</span>        -&gt; <span class="built_in">strlen</span>:<span class="number">11</span></span><br><span class="line"></span><br><span class="line">char4 <span class="built_in">string</span> <span class="string">&quot;this is a string.&quot;</span>-&gt; length:<span class="number">51</span></span><br><span class="line">char4 <span class="built_in">string</span> <span class="string">&quot;this is a string.&quot;</span>-&gt; size:<span class="number">51</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>对于<strong>字符数组</strong>：sizeof得到的是字符数组的容量，strlen是的到的字符的长度<br>对于<strong>字符指针</strong>：sizeof得到的是指针的字节数8，strlen得到的是指针指向的字符的个数</p><p>对于<strong>string</strong>：sizeof得到的变量的字符大小32，而length和size得到的是变量中字符串的长度。</p><hr><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> buffer[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> m = <span class="built_in">strlen</span>(buffer); <span class="comment">/*m = 5*/</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(buffer); <span class="comment">/*n = 6*/</span></span><br></pre></td></tr></table></figure><p>以遇到的第一个’\0’为结束标志；n = 6，这是因为字符串以’\0’为结束标志，’\0’也需要占用一个字节，所以sizeof测得的结果为6。</p><p>所以char s[8] = “newcoder”是错的 需要s[9]</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 100  (str的容量为100)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(*str) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1    (*str是一个字符数据)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 7    (字符串str的长度)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">&quot;abcdefg&quot;</span>; <span class="comment">//  </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">&quot;abcde0fg&quot;</span>; <span class="comment">//  (里面是字符&#x27;0&#x27;,不等于&#x27;\0&#x27;)</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">char</span> str3[] = <span class="string">&quot;abcde\0fg&quot;</span>;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str3) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str3) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str4[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str4) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str4) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 7  (数值不确定)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str6[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str6) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 21  (数值不确定)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str7[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str7) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str7) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str8[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str8) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str8) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str9[] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str9) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str9) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">9</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 90</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dji 08.07</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(T)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">sizeof</span>(T); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(T &amp;&amp;)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">sizeof</span>(T); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">int</span> aa[<span class="number">100</span>] = &#123;i&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = aa;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a(i) &lt;&lt; <span class="built_in">endl</span>  <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; a(aa) &lt;&lt; <span class="built_in">endl</span> <span class="comment">// 8</span></span><br><span class="line">         &lt;&lt; a(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b(i) &lt;&lt; <span class="built_in">endl</span>  <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; b(aa) &lt;&lt; <span class="built_in">endl</span> <span class="comment">// 400</span></span><br><span class="line">         &lt;&lt; b(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(i) &lt;&lt; <span class="built_in">endl</span> <span class="comment">// 4</span></span><br><span class="line">         &lt;&lt; <span class="keyword">sizeof</span>(aa) &lt;&lt; <span class="built_in">endl</span> <span class="comment">// 400</span></span><br><span class="line">         &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">char</span> aaa[<span class="number">15</span>]; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(aaa) &lt;&lt; <span class="built_in">endl</span> <span class="comment">// 15</span></span><br><span class="line">         &lt;&lt; f(aaa) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 8</span></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h2><p>计算需要考虑成员变量大小，内存对齐，是否有虚函数，是否有虚继承等</p><ol><li>空类</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of a:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of b:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of c:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>仅有常规函数、无成员变量类</p><p>扩展1：如果在该类型中添加一个构造函数和析构函数，再求sizeof，得到的结果是多少？<br>答案：还是1。调用构造函数和析构函数只需要知道函数的地址即可，而这些地址只与类型相关，而与类型的实例无关， 编译器也不会因为这两个函数而在实例内添加任何额外的信息。<br>注：不管添加的是构造函数还是析构函数还是其它任何类型的函数，都是这个结果。</p></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C() &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello C&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of a:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of b:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of c:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅包含一般成员函数(即没有<a href="https://so.csdn.net/so/search?q=虚函数&amp;spm=1001.2101.3001.7020">虚函数</a>)，不含成员变量时，运行结果和(一)是一样的，系统也只是为对象创建了1个字节的占位符。因此，我们可以得出结论是，一般成员函数不会对类的大小造成影响。</p><ol><li><p>含有一般成员变量类</p><p>普通的继承就是基类的大小+派生类自身的大小。</p></li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> Data1[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Data2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> Data1[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Data2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello C&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> Data1[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Data2;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of a:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 8 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of b:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 16</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of c:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">// 24</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次继承的三个类中含有相同数量，相同类型的一般成员变量(不含静态成员变量)。此种情况下，类对象大小=基类对象大小+自身成员大小。A当中三个字符变量3个字节，一个整形变量4个字节，考虑内存对齐因素(默认为4)，A类对象大小为8。B类对象大小为A类对象大小基础上再加8，C类对象大小在B类对象大小基础上再加8。</p><ol><li>含静态成员变量的类</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello A&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> Data1[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Data2;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Data3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello B&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> Data1[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Data2;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Data3;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">C(<span class="keyword">int</span> x=<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Hello C&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">char</span> Data1[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> Data2;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> Data3;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">C c;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of a:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(a)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of b:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(b)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16 </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;size of c:&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(c)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 24</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，类对象大小没有因为增加了静态成员而变化。因为静态成员是属于类成员共有的，不单独属于任何一个对象，对静态成员的存储不会选择在某个对象空间，而是存在于堆当中，因此不会对对象的大小造成影响。</p><ol><li>虚函数</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  B b;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> b;</span><br><span class="line">  <span class="keyword">double</span> a;</span><br><span class="line">  <span class="keyword">short</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">short</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 24</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8 + 1-&gt;2 + 2 = 12-&gt;16</span></span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了效率问题，编译器(gcc 和 微软)一般会把虚指针放在类的内存空间的最前面的位置，不管虚函数声明的位置。考虑对齐，大小都是 4 +1+1+2 = 8.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; <span class="comment">// 虚基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(C) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类继承了基类的虚指针，所以大小为4。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(ivec) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">3</span>个指针 = <span class="number">24</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网项目记录-第五章项目实战与总结</title>
      <link href="2022/07/17/blog56-nowcoderProject5/"/>
      <url>2022/07/17/blog56-nowcoderProject5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-阻塞-非阻塞、同步-异步-网络IO"><a href="#1-阻塞-非阻塞、同步-异步-网络IO" class="headerlink" title="1.阻塞/非阻塞、同步/异步(网络IO)"></a>1.阻塞/非阻塞、同步/异步(网络IO)</h1><blockquote><p>阻塞/非阻塞、同步/异步(网络IO)  </p></blockquote><p>数据就绪：根据系统IO操作的就绪状态</p><ul><li><p>阻塞</p></li><li><p>非阻塞</p></li></ul><p>数据读写：根据应用程序和内核的交互方式</p><ul><li><p>同步</p></li><li><p>异步</p></li></ul><p>陈硕：在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717233456139.png" alt="image-20220717233456139"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717234840065.png" alt="image-20220717234840065"></p><p>一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和 “数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。</p><p><strong>同步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；<strong>异步</strong>表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。  </p><h1 id="5-2-Unix-Linux上的5种IO模型"><a href="#5-2-Unix-Linux上的5种IO模型" class="headerlink" title="5.2 Unix/Linux上的5种IO模型"></a>5.2 Unix/Linux上的5种IO模型</h1><h3 id="a-阻塞-blocking-（BIO"><a href="#a-阻塞-blocking-（BIO" class="headerlink" title="a.阻塞 blocking  （BIO)"></a>a.阻塞 blocking  （BIO)</h3><p>调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717235855889.png" alt="image-20220717235855889"></p><h3 id="b-非阻塞-non-blocking（NIO）"><a href="#b-非阻塞-non-blocking（NIO）" class="headerlink" title="b.非阻塞 non-blocking（NIO）"></a>b.非阻塞 non-blocking（NIO）</h3><p>非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718000028084.png" alt="image-20220718000028084"></p><h3 id="c-IO复用（IO-multiplexing）"><a href="#c-IO复用（IO-multiplexing）" class="headerlink" title="c.IO复用（IO multiplexing）"></a>c.IO复用（IO multiplexing）</h3><p>Linux 用 select/poll/epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数    据可读或可写时，才真正调用IO操作函数  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718000243045.png" alt="image-20220718000243045"></p><h3 id="d-信号驱动（signal-driven）"><a href="#d-信号驱动（signal-driven）" class="headerlink" title="d.信号驱动（signal-driven）"></a>d.信号驱动（signal-driven）</h3><p>Linux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO 信号，然后处理 IO 事件。  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718000404751.png" alt="image-20220718000404751"></p><p>内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。  </p><h3 id="e-异步（asynchronous）"><a href="#e-异步（asynchronous）" class="headerlink" title="e.异步（asynchronous）"></a>e.异步（asynchronous）</h3><p>Linux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718000534332.png" alt="image-20220718000534332"></p><h1 id="5-3-Web服务器简介及Http协议"><a href="#5-3-Web服务器简介及Http协议" class="headerlink" title="5.3 Web服务器简介及Http协议"></a>5.3 Web服务器简介及Http协议</h1><p>一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返回一个 Error 信息  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718001127832.png" alt="image-20220718001127832"></p><p>通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。  </p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的CS的请求 - 响应协议，它通常运行在TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。</p><p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering TaskForce，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。  </p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>HTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管 TCP/IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP/IP 协议族使用 TCP 作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。  </p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。  </p><p>以下是 HTTP 请求/响应的步骤：</p><ol><li><p>客户端连接到 Web 服务器<br>一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，<a href="http://www.baidu.com。（URL）">http://www.baidu.com。（URL）</a></p></li><li><p>发送 HTTP 请求<br>通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个<strong>请求报文</strong>由<strong>请求行、请求头部、空行和请求数据 4 部分</strong>组成。</p></li><li><p>服务器接受请求并返回 HTTP 响应<br>Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个<strong>响应</strong>由<strong>状态行、响应头部、空行和响应数据 4 部分</strong>组成。</p></li><li><p>释放连接 TCP 连接<br>若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析 HTML 内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应<br>头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据<br>HTML 的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><p>例如：<strong>在浏览器地址栏键入URL</strong>，按下回车之后会经历以下流程：</p><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接;</li><li>浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;</li><li>服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器;</li><li>释放 TCP 连接;</li><li>浏览器将该 HTML 文本并显示内容。</li></ol><p>HTTP 协议是基于 TCP/IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718095202692.png" alt="image-20220718095202692"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718095153165.png" alt="image-20220718095153165"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718095213622.png" alt="image-20220718095213622"></p><h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><p>HTTP/1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：  </p><ol><li>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访问。</li><li>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。</li><li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li><li>PUT：向指定资源位置上传其最新内容。</li><li>DELETE：请求服务器删除 Request-URI 所标识的资源。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</li><li>CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的 HTTP 代理服务器）。  </li></ol><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p><p>状态代码的第一个数字代表当前响应的类型：</p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误  </li></ul><p>虽然 RFC 2616 中已经推荐了描述状态的短语，例如”200 OK”，”404 Not Found”，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718102726568.png" alt="image-20220718102726568"></p><hr><h1 id="5-4-服务器编程基本框架"><a href="#5-4-服务器编程基本框架" class="headerlink" title="5.4 服务器编程基本框架"></a>5.4 服务器编程基本框架</h1><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718103155738.png" alt="image-20220718103155738"></p><div class="table-container"><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>IO处理单元</td><td>处理客户连接，读写网络数据</td></tr><tr><td>逻辑单元</td><td>业务进程或线程</td></tr><tr><td>网络存储单元</td><td>数据库、文件或缓存</td></tr><tr><td>请求队列</td><td>各单元之间的通信方式</td></tr></tbody></table></div><p><strong>I/O 处理单元</strong>是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I/O 处理单元中执行，也可能在逻辑单元中执行，具体在何处执行取决于事件处理模式。</p><p>一个<strong>逻辑单元</strong>通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。</p><p>网络存储单元可以是数据库、缓存和文件，但不是必须的。</p><p><strong>请求队列</strong>是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。请求队列通常被实现为池的一部分。  </p><h3 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h3><p>服务器程序通常需要处理三类事件：<strong>I/O 事件、信号及定时事件</strong>。有两种高效的事件处理模式：Reactor和 Proactor，<strong>同步 I/O 模型</strong>通常用于实现 Reactor 模式，<strong>异步 I/O 模型</strong>通常用于实现 Proactor 模式。  </p><h4 id="Reactor模式-（反应堆）"><a href="#Reactor模式-（反应堆）" class="headerlink" title="Reactor模式  （反应堆）"></a>Reactor模式  （反应堆）</h4><p>要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步 I/O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll内核事件表中注册该 socket 上的写就绪事件。</li><li>当主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。  </li></ol><p>Reactor 模式的工作流程：  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718104011617.png" alt="image-20220718104011617"></p><h4 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h4><p>Proactor 模式将所有 I/O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。使用<strong>异步</strong> I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：</p><ol><li>主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。</li></ol><p>Proactor 模式的工作流程：  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718110332425.png" alt="image-20220718110332425"></p><h2 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h2><p>使用同步 I/O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>使用同步 I/O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：</p><ol><li>主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 上有数据可读。</li><li>当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事件表中注册 socket 上的写就绪事件。</li><li>主线程调用 epoll_wait 等待 socket 可写。</li><li>当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。</li></ol><p>同步 I/O 模拟 Proactor 模式的工作流程：  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718110517234.png" alt="image-20220718110517234"></p><hr><h1 id="5-5线程池"><a href="#5-5线程池" class="headerlink" title="5.5线程池"></a>5.5线程池</h1><p>线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。至于主线程选择哪个子线程来为新任务服务，则有多种方式：  </p><ul><li>主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。</li><li>主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。  </li></ul><p>线程池的一般模型为：  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220718110732722.png" alt="image-20220718110732722"></p><blockquote><p>线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费。  </p></blockquote><ul><li>空间换时间，浪费服务器的硬件资源，换取运行效率。</li><li>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。</li><li>当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。</li><li>当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。  </li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// locker.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程同步机制封装类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    locker() &#123;</span><br><span class="line">        <span class="keyword">if</span>(pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~locker() &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件变量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    cond()&#123;</span><br><span class="line">        <span class="keyword">if</span> (pthread_cond_init(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~cond() &#123;</span><br><span class="line">        pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = pthread_cond_wait(&amp;m_cond, m_mutex);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">timewait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex, struct timespec t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = pthread_cond_timedwait(&amp;m_cond, m_mutex, &amp;t);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_signal(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_broadcast(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    sem() &#123;</span><br><span class="line">        <span class="keyword">if</span>( sem_init( &amp;m_sem, <span class="number">0</span>, <span class="number">0</span> ) != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sem(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">if</span>( sem_init( &amp;m_sem, <span class="number">0</span>, num ) != <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~sem() &#123;</span><br><span class="line">        sem_destroy( &amp;m_sem );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sem_wait( &amp;m_sem ) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加信号量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sem_post( &amp;m_sem ) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// threadpool.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">    threadpool(<span class="keyword">int</span> thread_number = <span class="number">8</span>, <span class="keyword">int</span> max_requests = <span class="number">10000</span>);</span><br><span class="line">    ~threadpool();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T* request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 线程的数量</span></span><br><span class="line">    <span class="keyword">int</span> m_thread_number;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 描述线程池的数组，大小为m_thread_number    </span></span><br><span class="line">    <span class="keyword">pthread_t</span> * m_threads;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求队列中最多允许的、等待处理的请求的数量  </span></span><br><span class="line">    <span class="keyword">int</span> m_max_requests; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求队列</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt; T* &gt; m_workqueue;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保护请求队列的互斥锁</span></span><br><span class="line">    locker m_queuelocker;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有任务需要处理</span></span><br><span class="line">    sem m_queuestat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否结束线程          </span></span><br><span class="line">    <span class="keyword">bool</span> m_stop;                    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::threadpool(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests) : </span><br><span class="line">        m_thread_number(thread_number), m_max_requests(max_requests), </span><br><span class="line">        m_stop(<span class="literal">false</span>), m_threads(<span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_threads = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_thread_number];</span><br><span class="line">    <span class="keyword">if</span>(!m_threads) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建thread_number 个线程，并将他们设置为脱离线程。</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;create the %dth thread\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">if</span>(pthread_create(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span> ) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( pthread_detach( m_threads[i] ) ) &#123;</span><br><span class="line">            <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line">threadpool&lt; T &gt;::~threadpool() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] m_threads;</span><br><span class="line">    m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt; T &gt;::append( T* request )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 操作工作队列时一定要加锁，因为它被所有线程共享。</span></span><br><span class="line">    m_queuelocker.lock();</span><br><span class="line">    <span class="keyword">if</span> ( m_workqueue.size() &gt; m_max_requests ) &#123;</span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.push_back(request);</span><br><span class="line">    m_queuelocker.unlock();</span><br><span class="line">    m_queuestat.post();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">void</span>* threadpool&lt; T &gt;::worker( <span class="keyword">void</span>* arg )</span><br><span class="line">&#123;</span><br><span class="line">    threadpool* pool = ( threadpool* )arg;</span><br><span class="line">    pool-&gt;run();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt; T &gt;::run() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">        m_queuestat.wait();</span><br><span class="line">        m_queuelocker.lock();</span><br><span class="line">        <span class="keyword">if</span> ( m_workqueue.empty() ) &#123;</span><br><span class="line">            m_queuelocker.unlock();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T* request = m_workqueue.front();</span><br><span class="line">        m_workqueue.pop_front();</span><br><span class="line">        m_queuelocker.unlock();</span><br><span class="line">        <span class="keyword">if</span> ( !request ) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        request-&gt;process();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FD 65536   <span class="comment">// 最大的文件描述符个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 10000  <span class="comment">// 监听的最大的事件数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">removefd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>( handler )(<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>( &amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>( sa ) );</span><br><span class="line">    sa.sa_handler = handler;</span><br><span class="line">    sigfillset( &amp;sa.sa_mask );</span><br><span class="line">    assert( sigaction( sig, &amp;sa, <span class="literal">NULL</span> ) != <span class="number">-1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取端口号</span></span><br><span class="line">    <span class="keyword">int</span> port = atoi( argv[<span class="number">1</span>] );</span><br><span class="line">    <span class="comment">// 对SIGPIE信号进行处理</span></span><br><span class="line">    addsig( SIGPIPE, SIG_IGN );</span><br><span class="line"></span><br><span class="line">    threadpool&lt; http_conn &gt;* pool = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;;</span><br><span class="line">    &#125; <span class="keyword">catch</span>( ... ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    http_conn* users = <span class="keyword">new</span> http_conn[ MAX_FD ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = socket( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    address.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>( reuse ) );</span><br><span class="line">    ret = bind( listenfd, ( struct sockaddr* )&amp;address, <span class="keyword">sizeof</span>( address ) );</span><br><span class="line">    ret = listen( listenfd, <span class="number">5</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll对象，和事件数组，添加</span></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="keyword">int</span> epollfd = epoll_create( <span class="number">5</span> );</span><br><span class="line">    <span class="comment">// 添加到epoll对象中</span></span><br><span class="line">    addfd( epollfd, listenfd, <span class="literal">false</span> );</span><br><span class="line">    http_conn::m_epollfd = epollfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> number = epoll_wait( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ( ( number &lt; <span class="number">0</span> ) &amp;&amp; ( errno != EINTR ) ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++ ) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>( sockfd == listenfd ) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>( client_address );</span><br><span class="line">                <span class="keyword">int</span> connfd = accept( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; </span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>( http_conn::m_user_count &gt;= MAX_FD ) &#123;</span><br><span class="line">                    <span class="comment">// 目前 连接数满了， 给客户端写一个服务器正忙的信息</span></span><br><span class="line">                    close(connfd);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将新的客户的数据初始化，放到数组里</span></span><br><span class="line">                users[connfd].init( connfd, client_address);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events &amp; ( EPOLLRDHUP | EPOLLHUP | EPOLLERR ) ) &#123;</span><br><span class="line">                <span class="comment">// 对方异常断开</span></span><br><span class="line">                users[sockfd].close_conn();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">               <span class="comment">// 一次性把所有数据都读完</span></span><br><span class="line">                <span class="keyword">if</span>(users[sockfd].read()) &#123;</span><br><span class="line">                    pool-&gt;append(users + sockfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    users[sockfd].close_conn();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;  <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events &amp; EPOLLOUT ) &#123;</span><br><span class="line">                <span class="comment">// 一次性写完所有数据</span></span><br><span class="line">                <span class="keyword">if</span>( !users[sockfd].write() ) &#123;</span><br><span class="line">                    users[sockfd].close_conn();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close( epollfd );</span><br><span class="line">    close( listenfd );</span><br><span class="line">    <span class="keyword">delete</span> [] users;</span><br><span class="line">    <span class="keyword">delete</span> pool;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http_conn.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTPCONNECTION_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http_conn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> FILENAME_LEN = <span class="number">200</span>;        <span class="comment">// 文件名的最大长度</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;   <span class="comment">// 读缓冲区的大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;  <span class="comment">// 写缓冲区的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// HTTP请求方法，这里只支持GET</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">METHOD</span> &#123;</span>GET = <span class="number">0</span>, POST, HEAD, PUT, DELETE, TRACE, OPTIONS, CONNECT&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        解析客户端请求时，主状态机的状态</span></span><br><span class="line"><span class="comment">        CHECK_STATE_REQUESTLINE:当前正在分析请求行</span></span><br><span class="line"><span class="comment">        CHECK_STATE_HEADER:当前正在分析头部字段</span></span><br><span class="line"><span class="comment">        CHECK_STATE_CONTENT:当前正在解析请求体</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>, CHECK_STATE_HEADER, CHECK_STATE_CONTENT &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        服务器处理HTTP请求的可能结果，报文解析的结果</span></span><br><span class="line"><span class="comment">        NO_REQUEST          :   请求不完整，需要继续读取客户数据</span></span><br><span class="line"><span class="comment">        GET_REQUEST         :   表示获得了一个完成的客户请求</span></span><br><span class="line"><span class="comment">        BAD_REQUEST         :   表示客户请求语法错误</span></span><br><span class="line"><span class="comment">        NO_RESOURCE         :   表示服务器没有资源</span></span><br><span class="line"><span class="comment">        FORBIDDEN_REQUEST   :   表示客户对资源没有足够的访问权限</span></span><br><span class="line"><span class="comment">        FILE_REQUEST        :   文件请求,获取文件成功</span></span><br><span class="line"><span class="comment">        INTERNAL_ERROR      :   表示服务器内部错误</span></span><br><span class="line"><span class="comment">        CLOSED_CONNECTION   :   表示客户端已经关闭连接了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从状态机的三种可能状态，即行的读取状态，分别表示</span></span><br><span class="line">    <span class="comment">// 1.读取到一个完整的行 2.行出错 3.行数据尚且不完整</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_OPEN &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    http_conn()&#123;&#125;</span><br><span class="line">    ~http_conn()&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>; <span class="comment">// 初始化新接受的连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">()</span></span>;  <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>; <span class="comment">// 处理客户端请求</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">// 非阻塞读</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">()</span></span>;<span class="comment">// 非阻塞写</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;    <span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">process_read</span><span class="params">()</span></span>;    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">process_write</span><span class="params">( HTTP_CODE ret )</span></span>;    <span class="comment">// 填充HTTP应答</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这一组函数被process_read调用以分析HTTP请求</span></span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">parse_request_line</span><span class="params">( <span class="keyword">char</span>* text )</span></span>;</span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">( <span class="keyword">char</span>* text )</span></span>;</span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">( <span class="keyword">char</span>* text )</span></span>;</span><br><span class="line">    <span class="function">HTTP_CODE <span class="title">do_request</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">get_line</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_read_buf + m_start_line; &#125;</span><br><span class="line">    <span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一组函数被process_write调用以填充HTTP应答。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unmap</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_response</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_content</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* content )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_content_type</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_status_line</span><span class="params">( <span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span>* title )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_headers</span><span class="params">( <span class="keyword">int</span> content_length )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_content_length</span><span class="params">( <span class="keyword">int</span> content_length )</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_linger</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">add_blank_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;       <span class="comment">// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_user_count;    <span class="comment">// 统计用户的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_sockfd;           <span class="comment">// 该HTTP连接的socket和对方的socket地址</span></span><br><span class="line">    sockaddr_in m_address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> m_read_buf[ READ_BUFFER_SIZE ];    <span class="comment">// 读缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> m_read_idx;                         <span class="comment">// 标识读缓冲区中已经读入的客户端数据的最后一个字节的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span> m_checked_idx;                      <span class="comment">// 当前正在分析的字符在读缓冲区中的位置</span></span><br><span class="line">    <span class="keyword">int</span> m_start_line;                       <span class="comment">// 当前正在解析的行的起始位置</span></span><br><span class="line"></span><br><span class="line">    CHECK_STATE m_check_state;              <span class="comment">// 主状态机当前所处的状态</span></span><br><span class="line">    METHOD m_method;                        <span class="comment">// 请求方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> m_real_file[ FILENAME_LEN ];       <span class="comment">// 客户请求的目标文件的完整路径，其内容等于 doc_root + m_url, doc_root是网站根目录</span></span><br><span class="line">    <span class="keyword">char</span>* m_url;                            <span class="comment">// 客户请求的目标文件的文件名</span></span><br><span class="line">    <span class="keyword">char</span>* m_version;                        <span class="comment">// HTTP协议版本号，我们仅支持HTTP1.1</span></span><br><span class="line">    <span class="keyword">char</span>* m_host;                           <span class="comment">// 主机名</span></span><br><span class="line">    <span class="keyword">int</span> m_content_length;                   <span class="comment">// HTTP请求的消息总长度</span></span><br><span class="line">    <span class="keyword">bool</span> m_linger;                          <span class="comment">// HTTP请求是否要求保持连接</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> m_write_buf[ WRITE_BUFFER_SIZE ];  <span class="comment">// 写缓冲区</span></span><br><span class="line">    <span class="keyword">int</span> m_write_idx;                        <span class="comment">// 写缓冲区中待发送的字节数</span></span><br><span class="line">    <span class="keyword">char</span>* m_file_address;                   <span class="comment">// 客户请求的目标文件被mmap到内存中的起始位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">m_file_stat</span>;</span>                <span class="comment">// 目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获取文件大小等信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">m_iv</span>[2];</span>                   <span class="comment">// 我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示被写内存块的数量。</span></span><br><span class="line">    <span class="keyword">int</span> m_iv_count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bytes_to_send;              <span class="comment">// 将要发送的数据的字节数</span></span><br><span class="line">    <span class="keyword">int</span> bytes_have_send;            <span class="comment">// 已经发送的字节数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http_conn.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HTTP响应的一些状态信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_403_form = <span class="string">&quot;You do not have permission to get file from this server.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* error_500_form = <span class="string">&quot;There was an unusual problem serving the requested file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站的根目录</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* doc_root = <span class="string">&quot;/home/nowcoder/webserver/resources&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = fcntl( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    fcntl( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向epoll中添加需要监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot )</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 防止同一个通信被不同的线程处理</span></span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="comment">// 设置文件描述符非阻塞</span></span><br><span class="line">    setnonblocking(fd);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从epoll中移除监听的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removefd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span> </span>&#123;</span><br><span class="line">    epoll_ctl( epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span> );</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改文件描述符，重置socket上的EPOLLONESHOT事件，以确保下一次可读时，EPOLLIN事件能被触发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> ev)</span> </span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">    epoll_ctl( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的客户数</span></span><br><span class="line"><span class="keyword">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 所有socket上的事件都被注册到同一个epoll内核事件中，所以设置成静态的</span></span><br><span class="line"><span class="keyword">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_sockfd != <span class="number">-1</span>) &#123;</span><br><span class="line">        removefd(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--; <span class="comment">// 关闭一个连接，将客户总数量-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化连接,外部调用初始化套接字地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    setsockopt( m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>( reuse ) );</span><br><span class="line">    addfd( m_epollfd, sockfd, <span class="literal">true</span> );</span><br><span class="line">    m_user_count++;</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;    <span class="comment">// 初始状态为检查请求行</span></span><br><span class="line">    m_linger = <span class="literal">false</span>;       <span class="comment">// 默认不保持链接  Connection : keep-alive保持连接</span></span><br><span class="line"></span><br><span class="line">    m_method = GET;         <span class="comment">// 默认请求方式为GET</span></span><br><span class="line">    m_url = <span class="number">0</span>;              </span><br><span class="line">    m_version = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_checked_idx = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    bzero(m_read_buf, READ_BUFFER_SIZE);</span><br><span class="line">    bzero(m_write_buf, READ_BUFFER_SIZE);</span><br><span class="line">    bzero(m_real_file, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取客户数据，直到无数据可读或者对方关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_read_idx &gt;= READ_BUFFER_SIZE ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 从m_read_buf + m_read_idx索引出开始保存数据，大小是READ_BUFFER_SIZE - m_read_idx</span></span><br><span class="line">        bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, </span><br><span class="line">        READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>( errno == EAGAIN || errno == EWOULDBLOCK ) &#123;</span><br><span class="line">                <span class="comment">// 没有数据</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;   <span class="comment">// 对方关闭连接</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_read_idx += bytes_read;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析一行，判断依据\r\n</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="keyword">for</span> ( ; m_checked_idx &lt; m_read_idx; ++m_checked_idx ) &#123;</span><br><span class="line">        temp = m_read_buf[ m_checked_idx ];</span><br><span class="line">        <span class="keyword">if</span> ( temp == <span class="string">&#x27;\r&#x27;</span> ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ( m_checked_idx + <span class="number">1</span> ) == m_read_idx ) &#123;</span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( m_read_buf[ m_checked_idx + <span class="number">1</span> ] == <span class="string">&#x27;\n&#x27;</span> ) &#123;</span><br><span class="line">                m_read_buf[ m_checked_idx++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[ m_checked_idx++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>( temp == <span class="string">&#x27;\n&#x27;</span> )  &#123;</span><br><span class="line">            <span class="keyword">if</span>( ( m_checked_idx &gt; <span class="number">1</span>) &amp;&amp; ( m_read_buf[ m_checked_idx - <span class="number">1</span> ] == <span class="string">&#x27;\r&#x27;</span> ) ) &#123;</span><br><span class="line">                m_read_buf[ m_checked_idx<span class="number">-1</span> ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                m_read_buf[ m_checked_idx++ ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析HTTP请求行，获得请求方法，目标URL,以及HTTP版本号</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span>* text)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// GET /index.html HTTP/1.1</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>); <span class="comment">// 判断第二个参数中的字符哪个在text中最先出现</span></span><br><span class="line">    <span class="keyword">if</span> (! m_url) &#123; </span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// GET\0/index.html HTTP/1.1</span></span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">// 置位空字符，字符串结束符</span></span><br><span class="line">    <span class="keyword">char</span>* method = text;</span><br><span class="line">    <span class="keyword">if</span> ( strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span> ) &#123; <span class="comment">// 忽略大小写比较</span></span><br><span class="line">        m_method = GET;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// /index.html HTTP/1.1</span></span><br><span class="line">    <span class="comment">// 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。</span></span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>( m_url, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">    <span class="keyword">if</span> (!m_version) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp( m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * http://192.168.110.129:10000/index.html</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (strncasecmp(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span> ) &#123;   </span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        <span class="comment">// 在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。</span></span><br><span class="line">        m_url = <span class="built_in">strchr</span>( m_url, <span class="string">&#x27;/&#x27;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    m_check_state = CHECK_STATE_HEADER; <span class="comment">// 检查状态变成检查头</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析HTTP请求的一个头部信息</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span>* text)</span> </span>&#123;   </span><br><span class="line">    <span class="comment">// 遇到空行，表示头部字段解析完毕</span></span><br><span class="line">    <span class="keyword">if</span>( text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span> ) &#123;</span><br><span class="line">        <span class="comment">// 如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，</span></span><br><span class="line">        <span class="comment">// 状态机转移到CHECK_STATE_CONTENT状态</span></span><br><span class="line">        <span class="keyword">if</span> ( m_content_length != <span class="number">0</span> ) &#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则说明我们已经得到了一个完整的HTTP请求</span></span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Connection 头部字段  Connection: keep-alive</span></span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        <span class="keyword">if</span> ( strcasecmp( text, <span class="string">&quot;keep-alive&quot;</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Content-Length头部字段</span></span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        m_content_length = atol(text);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( strncasecmp( text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span> ) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 处理Host头部字段</span></span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>( text, <span class="string">&quot; \t&quot;</span> );</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;oop! unknow header %s\n&quot;</span>, text );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们没有真正解析HTTP请求的消息体，只是判断它是否被完整的读入了</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">( <span class="keyword">char</span>* text )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( m_read_idx &gt;= ( m_content_length + m_checked_idx ) )</span><br><span class="line">    &#123;</span><br><span class="line">        text[ m_content_length ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主状态机，解析请求</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;</span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">    <span class="keyword">char</span>* text = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))</span><br><span class="line">                || ((line_status = parse_line()) == LINE_OK)) &#123;</span><br><span class="line">        <span class="comment">// 获取一行数据</span></span><br><span class="line">        text = get_line();</span><br><span class="line">        m_start_line = m_checked_idx;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got 1 http line: %s\n&quot;</span>, text );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ( m_check_state ) &#123;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123;</span><br><span class="line">                ret = parse_request_line( text );</span><br><span class="line">                <span class="keyword">if</span> ( ret == BAD_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_HEADER: &#123;</span><br><span class="line">                ret = parse_headers( text );</span><br><span class="line">                <span class="keyword">if</span> ( ret == BAD_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( ret == GET_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> do_request();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CHECK_STATE_CONTENT: &#123;</span><br><span class="line">                ret = parse_content( text );</span><br><span class="line">                <span class="keyword">if</span> ( ret == GET_REQUEST ) &#123;</span><br><span class="line">                    <span class="keyword">return</span> do_request();</span><br><span class="line">                &#125;</span><br><span class="line">                line_status = LINE_OPEN;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，</span></span><br><span class="line"><span class="comment">// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其</span></span><br><span class="line"><span class="comment">// 映射到内存地址m_file_address处，并告诉调用者获取文件成功</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;/home/nowcoder/webserver/resources&quot;</span></span><br><span class="line">    <span class="built_in">strcpy</span>( m_real_file, doc_root );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>( doc_root );</span><br><span class="line">    <span class="built_in">strncpy</span>( m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span> );</span><br><span class="line">    <span class="comment">// 获取m_real_file文件的相关的状态信息，-1失败，0成功</span></span><br><span class="line">    <span class="keyword">if</span> ( stat( m_real_file, &amp;m_file_stat ) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断访问权限</span></span><br><span class="line">    <span class="keyword">if</span> ( ! ( m_file_stat.st_mode &amp; S_IROTH ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是目录</span></span><br><span class="line">    <span class="keyword">if</span> ( S_ISDIR( m_file_stat.st_mode ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以只读方式打开文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open( m_real_file, O_RDONLY );</span><br><span class="line">    <span class="comment">// 创建内存映射</span></span><br><span class="line">    m_file_address = ( <span class="keyword">char</span>* )mmap( <span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span> );</span><br><span class="line">    close( fd );</span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对内存映射区执行munmap操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_file_address )</span><br><span class="line">    &#123;</span><br><span class="line">        munmap( m_file_address, m_file_stat.st_size );</span><br><span class="line">        m_file_address = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写HTTP响应</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ( bytes_to_send == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// 将要发送的字节为0，这一次响应结束。</span></span><br><span class="line">        modfd( m_epollfd, m_sockfd, EPOLLIN ); </span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 分散写</span></span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span> ( temp &lt;= <span class="number">-1</span> ) &#123;</span><br><span class="line">            <span class="comment">// 如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件，虽然在此期间，</span></span><br><span class="line">            <span class="comment">// 服务器无法立即接收到同一客户的下一个请求，但可以保证连接的完整性。</span></span><br><span class="line">            <span class="keyword">if</span>( errno == EAGAIN ) &#123;</span><br><span class="line">                modfd( m_epollfd, m_sockfd, EPOLLOUT );</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 没有数据要发送了</span></span><br><span class="line">            unmap();</span><br><span class="line">            modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (m_linger)</span><br><span class="line">            &#123;</span><br><span class="line">                init();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往写缓冲中写入待发送的数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_response</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* format, ... )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( m_write_idx &gt;= WRITE_BUFFER_SIZE ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    va_list arg_list;</span><br><span class="line">    va_start( arg_list, format );</span><br><span class="line">    <span class="keyword">int</span> len = vsnprintf( m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list );</span><br><span class="line">    <span class="keyword">if</span>( len &gt;= ( WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx ) ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_write_idx += len;</span><br><span class="line">    va_end( arg_list );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">( <span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span>* title )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">    add_content_length(content_len);</span><br><span class="line">    add_content_type();</span><br><span class="line">    add_linger();</span><br><span class="line">    add_blank_line();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, content_len );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;Connection: %s\r\n&quot;</span>, ( m_linger == <span class="literal">true</span> ) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content</span><span class="params">( <span class="keyword">const</span> <span class="keyword">char</span>* content )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response( <span class="string">&quot;%s&quot;</span>, content );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_type</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add_response(<span class="string">&quot;Content-Type:%s\r\n&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据服务器处理HTTP请求的结果，决定返回给客户端的内容</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> INTERNAL_ERROR:</span><br><span class="line">            add_status_line( <span class="number">500</span>, error_500_title );</span><br><span class="line">            add_headers( <span class="built_in">strlen</span>( error_500_form ) );</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_500_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BAD_REQUEST:</span><br><span class="line">            add_status_line( <span class="number">400</span>, error_400_title );</span><br><span class="line">            add_headers( <span class="built_in">strlen</span>( error_400_form ) );</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_400_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NO_RESOURCE:</span><br><span class="line">            add_status_line( <span class="number">404</span>, error_404_title );</span><br><span class="line">            add_headers( <span class="built_in">strlen</span>( error_404_form ) );</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_404_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FORBIDDEN_REQUEST:</span><br><span class="line">            add_status_line( <span class="number">403</span>, error_403_title );</span><br><span class="line">            add_headers(<span class="built_in">strlen</span>( error_403_form));</span><br><span class="line">            <span class="keyword">if</span> ( ! add_content( error_403_form ) ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FILE_REQUEST:</span><br><span class="line">            add_status_line(<span class="number">200</span>, ok_200_title );</span><br><span class="line">            add_headers(m_file_stat.st_size);</span><br><span class="line">            m_iv[ <span class="number">0</span> ].iov_base = m_write_buf;</span><br><span class="line">            m_iv[ <span class="number">0</span> ].iov_len = m_write_idx;</span><br><span class="line">            m_iv[ <span class="number">1</span> ].iov_base = m_file_address;</span><br><span class="line">            m_iv[ <span class="number">1</span> ].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_iv[ <span class="number">0</span> ].iov_base = m_write_buf;</span><br><span class="line">    m_iv[ <span class="number">0</span> ].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析HTTP请求</span></span><br><span class="line">    HTTP_CODE read_ret = process_read();</span><br><span class="line">    <span class="keyword">if</span> ( read_ret == NO_REQUEST ) &#123;</span><br><span class="line">        modfd( m_epollfd, m_sockfd, EPOLLIN );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成响应</span></span><br><span class="line">    <span class="keyword">bool</span> write_ret = process_write( read_ret );</span><br><span class="line">    <span class="keyword">if</span> ( !write_ret ) &#123;</span><br><span class="line">        close_conn();</span><br><span class="line">    &#125;</span><br><span class="line">    modfd( m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。</p><p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATE_MACHINE( Package _pack )</span><br><span class="line">&#123;</span><br><span class="line">    PackageType _type = _pack.GetType();</span><br><span class="line">    <span class="keyword">switch</span>( _type )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> type_A:</span><br><span class="line">        process_package_A( _pack );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> type_B:</span><br><span class="line">        process_package_B( _pack );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。状态之间的转移是需要状态机内部驱动，如下代码：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">STATE_MACHINE()</span><br><span class="line">&#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line">    <span class="keyword">while</span>( cur_State != type_C )</span><br><span class="line">    &#123;</span><br><span class="line">        Package _pack = getNewPackage();</span><br><span class="line">        <span class="keyword">switch</span>( cur_State )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> type_A:</span><br><span class="line">                process_package_state_A( _pack );</span><br><span class="line">                cur_State = type_B;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> type_B:</span><br><span class="line">                process_package_state_B( _pack );</span><br><span class="line">                cur_State = type_C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环时，它将执行新的状态对应的逻辑。  </p><h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。</p><p>对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。  </p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网项目记录-第四章linux网络编程</title>
      <link href="2022/07/16/blog55-nowcoderProject4/"/>
      <url>2022/07/16/blog55-nowcoderProject4/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-状态转换"><a href="#TCP-状态转换" class="headerlink" title="TCP 状态转换"></a>TCP 状态转换</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716231619986.png" alt="image-20220716231619986"></p><p>红客户端 绿服务器端 黑色异常</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716231822128.png" alt="image-20220716231822128"></p><p> <strong>2MSL（Maximum Segment Lifetime）</strong><br>主动断开连接的一方, 最后进入一个 TIME_WAIT状态, 这个状态会持续: 2msl 为了确保服务器端可以收到ACK，确保正确关闭<br>msl: 官方建议: 2分钟, 实际是30s<br>当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方必须处于TIME_WAIT 状态并持续 2MSL 时间。</p><p>这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。因为如果最后一个ack丢失的话，被动关闭方会一直等待，等不到就会再发送FIN，直到收到ACK；</p><p>主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号，被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是重传 FIN 直到它收到一个最终的 ACK。  </p><hr><h2 id="4-24-半关闭-端口复用"><a href="#4-24-半关闭-端口复用" class="headerlink" title="4.24 半关闭 端口复用"></a>4.24 半关闭 端口复用</h2><h3 id="半关闭（能接收-不能发）"><a href="#半关闭（能接收-不能发）" class="headerlink" title="半关闭（能接收 不能发）"></a>半关闭（能接收 不能发）</h3><p>当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发送的数据，但是 <strong>A</strong> 已经不能再向 B <strong>发送数据</strong>。  </p><p>从程序的角度，可以使用 API <strong>shutdown</strong>（SHUT_WR） 来控制实现半连接状态：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line">sockfd: 需要关闭的socket的描述符</span><br><span class="line">how: 允许为shutdown操作选择以下几种方式:</span><br><span class="line">SHUT_RD(<span class="number">0</span>)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。</span><br><span class="line">SHUT_WR(<span class="number">1</span>): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。</span><br><span class="line">SHUT_RDWR(<span class="number">2</span>):关闭sockfd的读写功能。相当于调用shutdown两次 相当于close：首先是以SHUT_RD,然后以SHUT_WR。</span><br></pre></td></tr></table></figure><p>使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。（有子进程则加一）<br>注意:</p><ol><li>如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。</li><li>在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。  </li></ol><h3 id="端口复用"><a href="#端口复用" class="headerlink" title="端口复用"></a>端口复用</h3><p>端口复用的用途是：防止服务器重启时 之前绑定的端口还没释放。程序突然退出而系统没有释放端口。</p><p>tcp_server.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> optval = <span class="number">1</span>; <span class="comment">// </span></span><br><span class="line">    setsockopt(lfd, SOL_SOCKET, SO_REUSEPORT, &amp;optval, <span class="keyword">sizeof</span>(optval)); <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accpet&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client&#x27;s ip is %s, and port is %d\n&quot;</span>, cliIp, cliPort );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = recv(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf), <span class="number">0</span>); <span class="comment">////////</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;客户端已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 小写转大写</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            recvBuf[i] = <span class="built_in">toupper</span>(recvBuf[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;after buf = %s\n&quot;</span>, recvBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 大写字符串发给客户端</span></span><br><span class="line">        ret = send(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>, <span class="number">0</span>); <span class="comment">////////</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;send&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>tcp_client.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>); <span class="comment">////////</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf)); <span class="comment">////////</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行服务器端（9999）、运行客户端（36514）之后，第二个答案里的第三行是专门用来通信的socket</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716235324113.png" alt="image-20220716235324113"></p><p>如果断开服务器，客户端被动关闭处于close wait状态 ，服务器端主动关闭，处于fw2</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716235422484.png" alt="image-20220716235422484"></p><p>如果快速断开被动关闭的客户端 服务器处于time-wait 等待2msl后释放端口</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716235754918.png" alt="image-20220716235754918"></p><p>端口复用最常用的用途是:<br>1 防止服务器重启时之前绑定的端口还未释放<br>2 程序突然退出而系统没有释放 端口</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置套接字的属性/选项（不仅仅能设置端口复用）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname, <span class="keyword">const</span> <span class="keyword">void</span> *optval, socklen_toptlen)</span></span>;</span><br><span class="line">参数：</span><br><span class="line">    - sockfd : 要操作的文件描述符</span><br><span class="line">    - level : 级别 - SOL_SOCKET (端口复用的级别)</span><br><span class="line">    - optname : 选项的名称</span><br><span class="line">        - SO_REUSEADDR</span><br><span class="line">        - SO_REUSEPORT</span><br><span class="line">    - optval : 端口复用的值（整型）</span><br><span class="line">        - <span class="number">1</span> : 可以复用</span><br><span class="line">        - <span class="number">0</span> : 不可以复用</span><br><span class="line">    - optlen : optval参数的大小</span><br><span class="line">端口复用，设置的时机是在服务器绑定端口之前。</span><br><span class="line">setsockopt();</span><br><span class="line">bind();</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717001941962.png" alt="image-20220717001941962"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717002011322.png" alt="image-20220717002011322"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717002209461.png" alt="image-20220717002209461"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717002221751.png" alt="image-20220717002221751"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717002449530.png" alt="image-20220717002449530"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717002508544.png" alt="image-20220717002508544"></p><h2 id="4-25-IO多路复用"><a href="#4-25-IO多路复用" class="headerlink" title="4.25 IO多路复用"></a>4.25 IO多路复用</h2><p><strong><em>I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能，</em></strong>Linux 下实现 I/O 多路复用的 系统调用主要有 select、poll 和 epoll。  </p><p>文件和内存！！！的IO。</p><h2 id="4-26-select"><a href="#4-26-select" class="headerlink" title="4.26 select"></a>4.26 select</h2><blockquote><p>主旨思想：</p><ol><li>首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。</li><li>调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。<ol><li>这个函数是阻塞</li><li>函数对文件描述符的检测的操作是由内核完成的</li></ol></li><li>在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sizeof(fd_set) = 128 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - nfds : 委托内核检测的最大文件描述符的值 + <span class="number">1</span></span><br><span class="line">    - readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性</span><br><span class="line">    - 一般检测读操作</span><br><span class="line">        - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区</span><br><span class="line">        - 是一个传入传出参数</span><br><span class="line">    - writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性</span><br><span class="line">    - 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）</span><br><span class="line">    - exceptfds : 检测发生异常的文件描述符的集合(一般不用)</span><br><span class="line">    - timeout : 设置的超时时间</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">            <span class="keyword">long</span> tv_sec; <span class="comment">/* seconds */</span></span><br><span class="line">            <span class="keyword">long</span> tv_usec; <span class="comment">/* microseconds */</span></span><br><span class="line">        &#125;;</span><br><span class="line">        - <span class="literal">NULL</span> : 永久阻塞，直到检测到了文件描述符有变化</span><br><span class="line">        - tv_sec = <span class="number">0</span> tv_usec = <span class="number">0</span>， 不阻塞</span><br><span class="line">        - tv_sec &gt; <span class="number">0</span> tv_usec &gt; <span class="number">0</span>， 阻塞对应的时间</span><br><span class="line">- 返回值 :</span><br><span class="line">    - <span class="number">-1</span> : 失败</span><br><span class="line">    - &gt;<span class="number">0</span>(n) : 检测的集合中有n个文件描述符发生了变化</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将参数文件描述符fd对应的标志位设置为0</span></span><br><span class="line"><span class="keyword">void</span> FD_CLR(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数文件描述符fd 对应的标志位，设置为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set一共有1024 bit, 全部初始化为0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717091112284.png" alt="image-20220717091112284"></p><p>100 101没有发送，就置零</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// 一开始为3</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个fd_set的集合，存放的是需要检测的文件描述符</span></span><br><span class="line">    fd_set rdset, tmp;</span><br><span class="line">    FD_ZERO(&amp;rdset);</span><br><span class="line">    FD_SET(lfd, &amp;rdset);</span><br><span class="line">    <span class="keyword">int</span> maxfd = lfd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        tmp = rdset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用select系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="keyword">int</span> ret = select(maxfd + <span class="number">1</span>, &amp;tmp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">////////////////////</span></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;select&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123; <span class="comment">// 不可能等于0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123; <span class="comment">// 返回个数</span></span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmp)) &#123; <span class="comment">// 判断两次，判断监听</span></span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                FD_SET(cfd, &amp;rdset);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符</span></span><br><span class="line">                maxfd = maxfd &gt; cfd ? maxfd : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = lfd + <span class="number">1</span>; i &lt;= maxfd; i++) &#123; <span class="comment">//从监听的3口开始监听到最大值</span></span><br><span class="line">                <span class="keyword">if</span>(FD_ISSET(i, &amp;tmp)) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> len = read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(i);</span><br><span class="line">                        FD_CLR(i, &amp;rdset);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(i, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;send data %d&quot;</span>, num++);</span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(1);</span></span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是多客户端可以连接到服务器。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717091222305.png" alt="image-20220717091222305"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717091231707.png" alt="image-20220717091231707"></p><p>poll 解决select 的第三个和第四个缺点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717100834306.png" alt="image-20220717100834306"></p><h2 id="4-28-poll"><a href="#4-28-poll" class="headerlink" title="4.28 poll"></a>4.28 poll</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* 委托内核检测的文件描述符 */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* 委托内核检测文件描述符的什么事件 */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* 文件描述符实际发生的事件 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">myfd</span>;</span> <span class="comment">// 举例</span></span><br><span class="line">myfd.fd = <span class="number">5</span>;</span><br><span class="line">myfd.events = POLLIN | POLLOUT; <span class="comment">// 检测可读可写</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">- 参数：</span><br><span class="line">    - fds : 是一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> 结构体数组，这是一个需要检测的文件描述符的集合</span></span><br><span class="line"><span class="class">    - <span class="title">nfds</span> :</span> 这个是第一个参数数组中最后一个有效元素的下标 + <span class="number">1</span></span><br><span class="line">    - timeout : 阻塞时长</span><br><span class="line">        <span class="number">0</span> : 不阻塞</span><br><span class="line">        <span class="number">-1</span> : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞</span><br><span class="line">        &gt;<span class="number">0</span> : 阻塞的时长</span><br><span class="line">- 返回值：</span><br><span class="line">    <span class="number">-1</span> : 失败</span><br><span class="line">    &gt;<span class="number">0</span>（n） : 成功,n表示检测到集合中有n个文件描述符发生变化</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717001356597.png" alt="image-20220717001356597"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// poll.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化检测的文件描述符数组 ////////////////////////</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">        fds[i].fd = <span class="number">-1</span>; <span class="comment">// </span></span><br><span class="line">        fds[i].events = POLLIN; <span class="comment">// 检测读事件  </span></span><br><span class="line">    &#125;</span><br><span class="line">    fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">    <span class="keyword">int</span> nfds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用poll系统函数，让内核帮检测哪些文件描述符有数据</span></span><br><span class="line">        <span class="keyword">int</span> ret = poll(fds, nfds + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变</span></span><br><span class="line">            <span class="keyword">if</span>(fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">                <span class="comment">// 表示有新的客户端连接进来了</span></span><br><span class="line">                struct sockaddr_in cliaddr;</span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将新的文件描述符加入到集合中</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1024</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(fds[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                        fds[i].fd = cfd;</span><br><span class="line">                        fds[i].events = POLLIN;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新最大的文件描述符的索引</span></span><br><span class="line">                nfds = nfds &gt; cfd ? nfds : cfd;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nfds; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">                    <span class="comment">// 说明这个文件描述符对应的客户端发来了数据</span></span><br><span class="line">                    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span> len = read(fds[i].fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                        close(fds[i].fd);</span><br><span class="line">                        fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                        write(fds[i].fd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c 同上</span></span><br></pre></td></tr></table></figure><p>poll 解决select 的第三个和第四个缺点。仍然还是需要遍历。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717100834306.png" alt="image-20220717100834306"></p><h2 id="4-29-epoll"><a href="#4-29-epoll" class="headerlink" title="4.29 epoll"></a>4.29 epoll</h2><p>没有用户态到内核态的切换，之前是线性数据结构，现在是红黑树数据结构。</p><p>epoll是如何实现的？首先使用<code>epoll_create</code>在内核区创建实例，是一个eventpoll的结构体类型，返回文件描述符。</p><p>这个数据结构rbr红黑树结构、rdlist链表 。如果有数据了就从rbr放入rdlist中。以前拷贝回去的都是所有的，而这里拷贝回去的是就绪的。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717100946633.png" alt="image-20220717100946633"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">    size : 目前没有意义了。随便写一个数，必须大于<span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        <span class="number">-1</span> : 失败</span><br><span class="line">        &gt; <span class="number">0</span> : 文件描述符，操作epoll实例的</span><br><span class="line">    </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events  检测事件 */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">    常见的Epoll检测事件events：</span><br><span class="line">    - EPOLLIN</span><br><span class="line">    - EPOLLOUT</span><br><span class="line">    - EPOLLERR</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - op : 要进行什么操作</span><br><span class="line">            EPOLL_CTL_ADD: 添加</span><br><span class="line">            EPOLL_CTL_MOD: 修改</span><br><span class="line">            EPOLL_CTL_DEL: 删除</span><br><span class="line">        - fd : 要检测的文件描述符</span><br><span class="line">        - event : 检测文件描述符什么事情</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 检测函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - epfd : epoll实例对应的文件描述符</span><br><span class="line">        - events : 传出参数，保存了发送了变化的文件描述符的信息</span><br><span class="line">        - maxevents : 第二个参数结构体数组的大小</span><br><span class="line">        - timeout : 阻塞时间</span><br><span class="line">            - <span class="number">0</span> : 不阻塞</span><br><span class="line">            - <span class="number">-1</span> : 阻塞，直到检测到fd数据发生变化，解除阻塞</span><br><span class="line">            - &gt; <span class="number">0</span> : 阻塞的时长（毫秒）</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功，返回发送变化的文件描述符的个数 &gt; <span class="number">0</span></span><br><span class="line">        - 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717104350319.png" alt="image-20220717104350319"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717104402343.png" alt="image-20220717104402343"></p><h2 id="4-31-epoll-的两种工作模式"><a href="#4-31-epoll-的两种工作模式" class="headerlink" title="4.31 epoll 的两种工作模式"></a>4.31 epoll 的两种工作模式</h2><ul><li><p>LT 模式 （水平触发）</p><blockquote><p>LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的</p></blockquote><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p><ul><li><p>a.用户不读数据，数据一直在缓冲区，epoll 会一直通知</p></li><li><p>b.用户只读了一部分数据，epoll会通知</p></li><li><p>c.缓冲区的数据读完了，不通知  </p></li></ul></li><li><p>ET 模式（边沿触发）</p><blockquote><p>ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。</p><p>ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄（文件描述符）的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。  </p></blockquote><p>假设委托内核检测读事件 -&gt; 检测fd的读缓冲区</p><p>读缓冲区有数据 - &gt; epoll检测到了会给用户通知</p><ul><li><p>a.用户不读数据，数据一直在缓冲区中，epoll下次检测的时候就不通知了</p></li><li><p>b.用户只读了一部分数据，epoll不通知</p></li><li><p>c.缓冲区的数据读完了，不通知  </p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line">常见的Epoll检测事件：</span><br><span class="line">- EPOLLIN</span><br><span class="line">- EPOLLOUT</span><br><span class="line">- EPOLLERR</span><br><span class="line">- EPOLLET</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_lt.c LT 模式 （水平触发）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN;</span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="comment">// 有数据到达，需要通信</span></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="keyword">int</span> len = read(curfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed...\n&quot;</span>);</span><br><span class="line">                    epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, <span class="literal">NULL</span>);</span><br><span class="line">                    close(curfd);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, buf);</span><br><span class="line">                    write(curfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;seraddr.sin_addr.s_addr);</span><br><span class="line">    seraddr.sin_family = AF_INET;</span><br><span class="line">    seraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">// sprintf(sendBuf, &quot;send data %d&quot;, num++);</span></span><br><span class="line">        fgets(sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        write(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收</span></span><br><span class="line">        <span class="keyword">int</span> len = read(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read buf = %s\n&quot;</span>, sendBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;服务器已经断开连接...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll_et.c ET 模式（边沿触发）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    listen(lfd, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用epoll_create()创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">int</span> epfd = epoll_create(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将监听的文件描述符相关的检测信息添加到epoll实例中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    epev.events = EPOLLIN;</span><br><span class="line">    epev.data.fd = lfd;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epevs</span>[1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ret = epoll_wait(epfd, epevs, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;epoll_wait&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ret = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> curfd = epevs[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(curfd == lfd) &#123;</span><br><span class="line">                <span class="comment">// 监听的文件描述符有数据达到，有客户端连接</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">                <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">                <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置cfd属性非阻塞</span></span><br><span class="line">                <span class="keyword">int</span> flag = fcntl(cfd, F_GETFL);</span><br><span class="line">                flag | O_NONBLOCK;</span><br><span class="line">                fcntl(cfd, F_SETFL, flag);</span><br><span class="line"></span><br><span class="line">                epev.events = EPOLLIN | EPOLLET;    <span class="comment">// 设置边沿触发</span></span><br><span class="line">                epev.data.fd = cfd;</span><br><span class="line">                epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(epevs[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 循环读取出所有数据</span></span><br><span class="line">                <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">                <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>( (len = read(curfd, buf, <span class="keyword">sizeof</span>(buf))) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 打印数据</span></span><br><span class="line">                    <span class="comment">// printf(&quot;recv data : %s\n&quot;, buf);</span></span><br><span class="line">                    write(STDOUT_FILENO, buf, len);</span><br><span class="line">                    write(curfd, buf, len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(errno == EAGAIN) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;data over.....&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    close(epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-32-UDP通信"><a href="#4-32-UDP通信" class="headerlink" title="4.32 UDP通信"></a>4.32 UDP通信</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717112034101.png" alt="image-20220717112034101"></p><p>而tcp</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716155939527.png" alt="image-20220716155939527"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - sockfd : 通信的fd</span><br><span class="line">        - buf : 要发送的数据</span><br><span class="line">        - len : 发送数据的长度</span><br><span class="line">        - flags : <span class="number">0</span></span><br><span class="line">        - dest_addr : 通信的另外一端的地址信息</span><br><span class="line">        - addrlen : 地址的内存大小</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">    - 参数：</span><br><span class="line">        - sockfd : 通信的fd</span><br><span class="line">        - buf : 接收数据的数组</span><br><span class="line">        - len : 数组的大小</span><br><span class="line">        - flags : <span class="number">0</span></span><br><span class="line">        - src_addr : 用来保存另外一端的地址信息，不需要可以指定为<span class="literal">NULL</span></span><br><span class="line">        - addrlen : 地址的内存大小</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> recvbuf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">char</span> ipbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, recvbuf, <span class="keyword">sizeof</span>(recvbuf), <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client IP : %s, Port : %d\n&quot;</span>, </span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, ipbuf, <span class="keyword">sizeof</span>(ipbuf)),</span><br><span class="line">            ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, recvbuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, recvbuf, <span class="built_in">strlen</span>(recvbuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udp_client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;saddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello , i am client %d \n&quot;</span>, num++);</span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, sendBuf);</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现多个客户端。</p><h2 id="4-33-UDP广播"><a href="#4-33-UDP广播" class="headerlink" title="4.33 UDP广播"></a>4.33 UDP广播</h2><p>向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内<strong>主机标志部分的二进制全部为1(255)。</strong><br>a.只能在局域网中使用。<br>b.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置广播属性的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,<span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">    - sockfd : 文件描述符</span><br><span class="line">    - level : SOL_SOCKET</span><br><span class="line">    - optname : SO_BROADCAST</span><br><span class="line">    - optval : <span class="keyword">int</span>类型的值，为<span class="number">1</span>表示允许广播</span><br><span class="line">    - optlen : optval的大小</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bro_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置广播属性</span></span><br><span class="line">    <span class="keyword">int</span> op = <span class="number">1</span>;</span><br><span class="line">    setsockopt(fd, SOL_SOCKET, SO_BROADCAST, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.创建一个广播的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.255&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;广播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bro_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-33-组播（多播）"><a href="#4-33-组播（多播）" class="headerlink" title="4.33 组播（多播）"></a>4.33 组播（多播）</h2><p>单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。<br>a.组播既可以用于局域网，也可以用于广域网<br>b.客户端需要加入多播组，才能接收到多播的数据  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717165626932.png" alt="image-20220717165626932"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> optname,<span class="keyword">const</span> <span class="keyword">void</span> *optval, <span class="keyword">socklen_t</span> optlen)</span></span>;</span><br><span class="line">    <span class="comment">// 服务器设置多播的信息，外出接口</span></span><br><span class="line">    - level : IPPROTO_IP</span><br><span class="line">    - optname : IP_MULTICAST_IF</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">    // 客户端加入到多播组：</span></span><br><span class="line"><span class="class">    - <span class="title">level</span> :</span> IPPROTO_IP</span><br><span class="line">    - optname : IP_ADD_MEMBERSHIP</span><br><span class="line">    - optval : <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* IP multicast address of group. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">// 组播的IP地址</span></span><br><span class="line">    <span class="comment">/* Local IP address of interface. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">// 本地的IP地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.设置多播的属性，设置外出接口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span></span><br><span class="line">    <span class="comment">// 初始化多播地址</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;imr_multiaddr.s_addr);</span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, &amp;imr_multiaddr, <span class="keyword">sizeof</span>(imr_multiaddr));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.初始化客户端的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    cliaddr.sin_family = AF_INET;</span><br><span class="line">    cliaddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;cliaddr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">char</span> sendBuf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(sendBuf, <span class="string">&quot;hello, client....%d\n&quot;</span>, num++);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        sendto(fd, sendBuf, <span class="built_in">strlen</span>(sendBuf) + <span class="number">1</span>, <span class="number">0</span>, (struct sockaddr *)&amp;cliaddr, <span class="keyword">sizeof</span>(cliaddr));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;组播的数据：%s\n&quot;</span>, sendBuf);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// multi_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个通信的socket</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">in</span>;</span></span><br><span class="line">    <span class="comment">// 2.客户端绑定本地的IP和端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sin_family = AF_INET;</span><br><span class="line">    addr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = bind(fd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">op</span>;</span></span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;239.0.0.10&quot;</span>, &amp;op.imr_multiaddr.s_addr);</span><br><span class="line">    op.imr_interface.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入到多播组</span></span><br><span class="line">    setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;op, <span class="keyword">sizeof</span>(op));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> num = recvfrom(fd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-35-本地套接字通信"><a href="#4-35-本地套接字通信" class="headerlink" title="4.35 本地套接字通信"></a>4.35 本地套接字通信</h2><blockquote><p>本地套接字的作用：本地的进程间通信<br>有关系的进程间的通信，父子进程<br>没有关系的进程间的通信<br>本地套接字实现流程和网络套接字类似，一般采用TCP的通信流程。  </p></blockquote><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220717171230447.png" alt="image-20220717171230447"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件: sys/un.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNIX_PATH_MAX 108</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sun_family; <span class="comment">// 地址族协议 af_local</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[UNIX_PATH_MAX]; <span class="comment">// 套接字文件的路径, 这是一个伪文件, 大小永远=0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地套接字通信的流程 - tcp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="number">1.</span> 创建监听的套接字</span><br><span class="line"><span class="keyword">int</span> lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的套接字文件 -&gt; server端</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。 </span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 监听</span><br><span class="line">    listen(lfd, <span class="number">100</span>);</span><br><span class="line"><span class="number">4.</span> 等待并接受连接请求</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, &amp;cliaddr, len);</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">6.</span> 关闭连接</span><br><span class="line">close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端的流程</span></span><br><span class="line"><span class="number">1.</span> 创建通信的套接字</span><br><span class="line"><span class="keyword">int</span> fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2.</span> 监听的套接字绑定本地的IP 端口</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="comment">// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。</span></span><br><span class="line">    bind(lfd, addr, len);</span><br><span class="line"><span class="number">3.</span> 连接服务器</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    connect(fd, &amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"><span class="number">4.</span> 通信</span><br><span class="line">    接收数据：read/recv</span><br><span class="line">    发送数据：write/send</span><br><span class="line"><span class="number">5.</span> 关闭连接</span><br><span class="line">    close();</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ipc_server.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建监听的套接字</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.等待客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);     </span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client socket filename: %s\n&quot;</span>, cliaddr.sun_path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line">            send(cfd, buf, len, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ipc_client.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> cfd = socket(AF_LOCAL, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定本地套接字文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    addr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(addr.sun_path, <span class="string">&quot;client.sock&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(cfd, (struct sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.连接服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">seraddr</span>;</span></span><br><span class="line">    seraddr.sun_family = AF_LOCAL;</span><br><span class="line">    <span class="built_in">strcpy</span>(seraddr.sun_path, <span class="string">&quot;server.sock&quot;</span>);</span><br><span class="line">    ret = connect(cfd, (struct sockaddr *)&amp;seraddr, <span class="keyword">sizeof</span>(seraddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.通信</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, i am client %d\n&quot;</span>, num++);</span><br><span class="line">        send(cfd, buf, <span class="built_in">strlen</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client say : %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">int</span> len = recv(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server say : %s\n&quot;</span>, buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网项目记录-第三章linux多线程开发</title>
      <link href="2022/07/14/blog54-nowcoderProject3/"/>
      <url>2022/07/14/blog54-nowcoderProject3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714155743501.png" alt="image-20220714155743501"></p><p>火狐浏览器开启的线程。PID进程号 LWP线程号</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220722163714455.png" alt="image-20220722163714455"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714155957795.png" alt="image-20220714155957795"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714160152562.png" alt="image-20220714160152562"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714160305621.png" alt="image-20220714160305621"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714162300308.png" alt="image-20220714162300308"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程</span></span><br><span class="line"><span class="comment">    称之为子线程。</span></span><br><span class="line"><span class="comment">    程序中默认只有一个进程，fork()函数调用，2进行</span></span><br><span class="line"><span class="comment">    程序中默认只有一个线程，pthread_create()函数调用，2个线程。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, </span></span><br><span class="line"><span class="comment">    void *(*start_routine) (void *), void *arg);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 功能：创建一个子线程</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。</span></span><br><span class="line"><span class="comment">            - attr : 设置线程的属性，一般使用默认值，NULL</span></span><br><span class="line"><span class="comment">            - start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码</span></span><br><span class="line"><span class="comment">            - arg : 给第三个参数使用，传参</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功：0</span></span><br><span class="line"><span class="comment">            失败：返回错误号。这个错误号和之前errno不太一样。</span></span><br><span class="line"><span class="comment">            获取错误号的信息：  char * strerror(int errnum);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span> *)&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不是标准系统库 ，而是第三方</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715000852721.png" alt="image-20220715000852721"></p><p>因为主线程return 0 退出了，没执行子线程里的。只执行主线程。加了sleep就可以</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220722170427094.png" alt="image-20220722170427094"></p><hr><p>3.3 终止进程 pthread_exit   </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    void pthread_exit(void *retval);</span></span><br><span class="line"><span class="comment">        功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            retval:需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pthread_t pthread_self(void);</span></span><br><span class="line"><span class="comment">        功能：获取当前的线程的线程ID</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_equal(pthread_t t1, pthread_t t2);</span></span><br><span class="line"><span class="comment">        功能：比较两个线程ID是否相等</span></span><br><span class="line"><span class="comment">        不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的</span></span><br><span class="line"><span class="comment">        是使用结构体去实现的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// pthread_exit(NULL);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714234028445.png" alt="image-20220714234028445"></p><hr><h2 id="3-4-连接已终止的现场-pthread-join"><a href="#3-4-连接已终止的现场-pthread-join" class="headerlink" title="3.4 连接已终止的现场 pthread_join"></a>3.4 连接已终止的现场 pthread_join</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_join(pthread_t thread, void **retval);</span></span><br><span class="line"><span class="comment">        - 功能：和一个已经终止的线程进行连接</span></span><br><span class="line"><span class="comment">                回收子线程的资源</span></span><br><span class="line"><span class="comment">                这个函数是阻塞函数，调用一次只能回收一个子线程</span></span><br><span class="line"><span class="comment">                一般在主线程中使用</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - thread：需要回收的子线程的ID</span></span><br><span class="line"><span class="comment">            - retval: 接收子线程退出时的返回值</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            0 : 成功</span></span><br><span class="line"><span class="comment">            非0 : 失败，返回的错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">10</span>; <span class="comment">// 不能局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    <span class="comment">// return NULL; </span></span><br><span class="line">    <span class="comment">// int value = 10; // 局部变量</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)&amp;value);   <span class="comment">// return (void *)&amp;value;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join()回收子线程的资源</span></span><br><span class="line">    <span class="keyword">int</span> * thread_retval;</span><br><span class="line">    ret = pthread_join(tid, (<span class="keyword">void</span> **)&amp;thread_retval); <span class="comment">// 子线程不结束，join不执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data : %d\n&quot;</span>, *thread_retval);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程资源成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715093336175.png" alt="image-20220715093336175"></p><hr><h2 id="3-5-线程的分离-pthread-detach"><a href="#3-5-线程的分离-pthread-detach" class="headerlink" title="3.5 线程的分离 pthread_detach"></a>3.5 线程的分离 pthread_detach</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_detach(pthread_t thread);</span></span><br><span class="line"><span class="comment">        - 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</span></span><br><span class="line"><span class="comment">          1.不能多次分离，会产生不可预料的行为。</span></span><br><span class="line"><span class="comment">          2.不能去连接一个已经分离的线程，会报错。</span></span><br><span class="line"><span class="comment">        - 参数：需要分离的线程的ID</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            成功：0</span></span><br><span class="line"><span class="comment">            失败：返回错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分离后，对分离的子线程进行连接 pthread_join() 是错误的</span></span><br><span class="line">    <span class="comment">// ret = pthread_join(tid, NULL);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) &#123;</span></span><br><span class="line">    <span class="comment">//     char * errstr = strerror(ret);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;error3 : %s\n&quot;, errstr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715094417683.png" alt="image-20220715094417683"></p><p>试试设置分离后，对分离的子线程进行join</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715094516540.png" alt="image-20220715094516540"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715094635605.png" alt="image-20220715094635605"></p><hr><h2 id="3-6-线程取消-pthread-cancel"><a href="#3-6-线程取消-pthread-cancel" class="headerlink" title="3.6 线程取消 pthread_cancel"></a>3.6 线程取消 pthread_cancel</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;pthread.h&gt;</span></span><br><span class="line"><span class="comment">    int pthread_cancel(pthread_t thread);</span></span><br><span class="line"><span class="comment">        - 功能：取消线程（让线程终止）</span></span><br><span class="line"><span class="comment">            取消某个线程，可以终止某个线程的运行，</span></span><br><span class="line"><span class="comment">            但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。</span></span><br><span class="line"><span class="comment">            取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i); <span class="comment">//这个是一个取消点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715095844927.png" alt="image-20220715095844927"></p><p>子线程并没有打印完5个，而是在printf时到达取消点，就终止。</p><hr><h2 id="3-7线程属性"><a href="#3-7线程属性" class="headerlink" title="3.7线程属性"></a>3.7线程属性</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715100202031.png" alt="image-20220715100202031"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715100922322.png" alt="image-20220715100922322"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int pthread_attr_init(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">        - 初始化线程属性变量</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_destroy(pthread_attr_t *attr);</span></span><br><span class="line"><span class="comment">        - 释放线程属性的资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);</span></span><br><span class="line"><span class="comment">        - 获取线程分离的状态属性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</span></span><br><span class="line"><span class="comment">        - 设置线程分离的状态属性</span></span><br><span class="line"><span class="comment">*/</span>     </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程属性变量</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">// 初始化属性变量</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程的栈的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread stack size : %ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放线程属性资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715101755534.png" alt="image-20220715101755534"></p><hr><h2 id="3-8-线程同步"><a href="#3-8-线程同步" class="headerlink" title="3.8 线程同步"></a>3.8 线程同步</h2><p>设计 有3个窗口 一共100个窗口。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用多线程实现买票的案例。</span></span><br><span class="line"><span class="comment">    有3个窗口，一共是100张票。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，所有的线程都共享这一份资源。</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">100</span>; <span class="comment">// 不能局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="keyword">while</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        usleep(<span class="number">6000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);</span><br><span class="line">        tickets--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程的资源,阻塞</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离。</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid1);</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid2);</span></span><br><span class="line">    <span class="comment">// pthread_detach(tid3);</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 退出主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有问题</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715102933418.png" alt="image-20220715102933418"></p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715103248904.png" alt="image-20220715103248904"></p><p>临界区指tickets</p><hr><h2 id="3-9-互斥锁、互斥量-mutex"><a href="#3-9-互斥锁、互斥量-mutex" class="headerlink" title="3.9 互斥锁、互斥量 mutex"></a>3.9 互斥锁、互斥量 mutex</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715103532431.png" alt="image-20220715103532431"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715114012298.png" alt="image-20220715114012298"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715114054656.png" alt="image-20220715114054656"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    互斥量的类型 pthread_mutex_t</span></span><br><span class="line"><span class="comment">    int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">        - 初始化互斥量</span></span><br><span class="line"><span class="comment">        - 参数 ：</span></span><br><span class="line"><span class="comment">            - mutex ： 需要初始化的互斥量变量</span></span><br><span class="line"><span class="comment">            - attr ： 互斥量相关的属性，NULL</span></span><br><span class="line"><span class="comment">        - restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。</span></span><br><span class="line"><span class="comment">            pthread_mutex_t *restrict mutex = xxx;</span></span><br><span class="line"><span class="comment">            pthread_mutex_t * mutex1 = mutex; 不行</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_destroy(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 释放互斥量的资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_lock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_trylock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int pthread_mutex_unlock(pthread_mutex_t *mutex);</span></span><br><span class="line"><span class="comment">        - 解锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，所有的线程都共享这一份资源。</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程的资源,阻塞</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 退出主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有可能还是一个线程，如果票数增加就正确。</p><hr><h2 id="3-10-死锁"><a href="#3-10-死锁" class="headerlink" title="3.10 死锁"></a>3.10 死锁</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715142644522.png" alt="image-20220715142644522"></p><p>场景1：忘记释放锁，结果阻塞</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715144054097.png" alt="image-20220715144054097"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715144006208.png" alt="image-20220715144006208"></p><p>场景2：重复加相同锁</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715144247466.png" alt="image-20220715144247466"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715144309560.png" alt="image-20220715144309560"></p><p>场景3：多线程 多锁 抢占锁资源</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715144806566.png" alt="image-20220715144806566"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220722212536063.png" alt="image-20220722212536063"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715144553043.png" alt="image-20220715144553043"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715145044194.png" alt="image-20220715145044194"></p><p>使用资源有序分配法，线程 A 和 线程 B 获取资源的顺序要一样，当线程 A 是先尝试获取资源 A，然后尝试获取资源 B 的时候，线程 B 同样也是先尝试获取资源 A，然后尝试获取资源 B。也就是说，线程 A 和 线程 B 总是以相同的顺序申请自己想要的资源。</p><p>所以我们只需将线程 B 改成以相同顺序的获取资源，就可以打破死锁了。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/%E9%94%81%E4%B9%8B%E6%8F%90%E4%BE%9B.png" alt="img"></p><p>谈一谈「<strong>互斥锁、自旋锁、读写锁、乐观锁、悲观锁</strong>」的选择和使用。</p><p>当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于<code>加锁失败后</code>的处理方式是不一样的：</p><p><strong>互斥锁</strong>加锁失败后，线程会<strong>释放 CPU</strong> ，给其他线程；</p><p><strong>自旋锁</strong>加锁失败后，线程会<strong>忙等待</strong>，直到它拿到锁；</p><p><code>互斥锁</code>是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，<strong>既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞</strong>。对于互斥锁加锁失败而阻塞的现象，是由<strong>操作系统内核实现的</strong>。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。</p><p>所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。会有<strong>两次线程上下文切换的成本</strong>。所以，<strong>如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。</strong></p><p>自旋锁是通过 CPU 提供的 <code>CAS</code> 函数（<em>Compare And Swap</em>），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。</p><p>一般加锁的过程，包含两个步骤：</p><ul><li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li><li>第二步，将锁设置为当前线程持有；</li></ul><p>CAS 函数就把这两个步骤合并成一条硬件级指令，形成<strong>原子指令</strong>，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</p><p>使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 <code>while</code> 循环等待实现，不过最好是使用 CPU 提供的 <code>PAUSE</code> 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。</p><p><strong>当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对</strong>。</p><p>写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。读写锁在读多写少的场景，能发挥出优势。</p><p>前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。</p><p>悲观锁做事比较悲观，它认为<strong>多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁</strong>。</p><p>那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。</p><p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：<strong>先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作</strong>。可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现<strong>乐观锁全程并没有加锁，所以它也叫无锁编程</strong>。</p><p>实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。</p><p>乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以<strong>只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。</strong></p><hr><h2 id="3-11-读写锁"><a href="#3-11-读写锁" class="headerlink" title="3.11 读写锁"></a>3.11 读写锁</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715145139509.png" alt="image-20220715145139509"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715181242740.png" alt="image-20220715181242740"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    案例：8个线程操作同一个全局变量。</span></span><br><span class="line"><span class="comment">    3个线程不定时写这个全局变量，5个线程不定时的读这个全局变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个共享数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// pthread_mutex_t mutex;</span></span><br><span class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">writeNum</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">        num++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;++write, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">readNum</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;rwlock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;===read, tid : %ld, num : %d\n&quot;</span>, pthread_self(), num);</span><br><span class="line">        pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个写线程，5个读线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> wtids[<span class="number">3</span>], rtids[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;wtids[i], <span class="literal">NULL</span>, writeNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;rtids[i], <span class="literal">NULL</span>, readNum, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置线程分离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">       pthread_detach(wtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         pthread_detach(rtids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;rwlock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用锁之前效果</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715182857154.png" alt="image-20220715182857154"></p><p> 利用互斥锁试试，但是互斥锁，当有一个线程读的时候，其他线程不能读，效率太低。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715183025599.png" alt="image-20220715183025599"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715183039703.png" alt="image-20220715183039703"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715183110137.png" alt="image-20220715183110137"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715183154178.png" alt="image-20220715183154178"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715183338882.png" alt="image-20220715183338882"></p><p>结果虽然正确。读写锁才能保证其他线程也能读，且效率更高。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715191430731.png" alt="image-20220715191430731"></p><hr><h2 id="3-12-生产者消费者模型"><a href="#3-12-生产者消费者模型" class="headerlink" title="3.12 生产者消费者模型"></a>3.12 生产者消费者模型</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715194155420.png" alt="image-20220715194155420"></p><p>生产者 将东西 生产到容器中，消费者从容器中消费。当容器满了，生产者通知消费者取走东西，当容器为空，消费者通知生产者生产。</p><p>条件变量，信号量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    生产者消费者模型（粗略的版本）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程, 容器是列表</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715220400658.png" alt="image-20220715220400658"></p><p>出现问题，互斥量来确保同步，还需要 条件变量或信号量来解决生产者和消费者 同步问题。</p><p><em>以上代码是粗略代码造成的结果</em></p><hr><h2 id="3-13-条件变量"><a href="#3-13-条件变量" class="headerlink" title="3.13 条件变量"></a>3.13 条件变量</h2><p>加上互斥锁之后结果：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715221736873.png" alt="image-20220715221736873"></p><p>没问题，这么做但不好。需要生产者和消费者各自判断，最好需要通知方式。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715221857709.png" alt="image-20220715221857709"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    条件变量的类型 pthread_cond_t</span></span><br><span class="line"><span class="comment">    int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);</span></span><br><span class="line"><span class="comment">    int pthread_cond_destroy(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">    int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);</span></span><br><span class="line"><span class="comment">        - 等待，调用了该函数，线程会阻塞。</span></span><br><span class="line"><span class="comment">    int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);</span></span><br><span class="line"><span class="comment">        - 等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。</span></span><br><span class="line"><span class="comment">    int pthread_cond_signal(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 唤醒一个或者多个等待的线程</span></span><br><span class="line"><span class="comment">    int pthread_cond_broadcast(pthread_cond_t *cond);</span></span><br><span class="line"><span class="comment">        - 唤醒所有的等待的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 只要生产了一个，就通知消费者消费</span></span><br><span class="line">        pthread_cond_signal(&amp;cond);<span class="comment">////</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据，需要等待</span></span><br><span class="line">            <span class="comment">// 当这个函数调用阻塞wait的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。从而生产者可以继续执行</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">////</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715233223049.png" alt="image-20220715233223049"></p><hr><h2 id="3-14-信号量-semaphore"><a href="#3-14-信号量-semaphore" class="headerlink" title="3.14 信号量 semaphore"></a>3.14 信号量 semaphore</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220715233434744.png" alt="image-20220715233434744"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    信号量的类型 sem_t</span></span><br><span class="line"><span class="comment">    int sem_init(sem_t *sem, int pshared, unsigned int value);</span></span><br><span class="line"><span class="comment">        - 初始化信号量</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - sem : 信号量变量的地址</span></span><br><span class="line"><span class="comment">            - pshared : 0 用在线程间 ，非0 用在进程间</span></span><br><span class="line"><span class="comment">            - value : 信号量中的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_destroy(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 释放资源</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_wait(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 对信号量加锁，调用一次对信号量的值-1，如果值为0，就阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_trywait(sem_t *sem);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);</span></span><br><span class="line"><span class="comment">    int sem_post(sem_t *sem);</span></span><br><span class="line"><span class="comment">        - 对信号量解锁，调用一次对信号量的值+1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sem_getvalue(sem_t *sem, int *sval);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    sem_t psem;</span></span><br><span class="line"><span class="comment">    sem_t csem;</span></span><br><span class="line"><span class="comment">    init(psem, 0, 8);</span></span><br><span class="line"><span class="comment">    init(csem, 0, 0);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    producer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;psem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;csem)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    customer() &#123;</span></span><br><span class="line"><span class="comment">        sem_wait(&amp;csem);</span></span><br><span class="line"><span class="comment">        sem_post(&amp;psem)</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> psem;</span><br><span class="line"><span class="keyword">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716000312137.png" alt="image-20220716000312137"></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket.io模块学习记录</title>
      <link href="2022/07/10/blog53-socketio/"/>
      <url>2022/07/10/blog53-socketio/</url>
      
        <content type="html"><![CDATA[<p>Socket.IO 是一个库，可以在客户端和服务器之间实现<strong>低延迟</strong>、<strong>双向</strong>和<strong>基于事件的</strong>通信</p><p><strong>Socket.IO</strong> 是一个面向实时 <a href="https://zh.m.wikipedia.org/w/index.php?title=Web_应用&amp;action=edit&amp;redlink=1">web 应用</a>的 <a href="https://zh.m.wikipedia.org/wiki/JavaScript">JavaScript</a> 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在<a href="https://zh.m.wikipedia.org/wiki/浏览器">浏览器</a>中运行的<a href="https://zh.m.wikipedia.org/wiki/客户端">客户端</a>库，和一个面向<a href="https://zh.m.wikipedia.org/wiki/Node.js">Node.js</a>的服务端库。两者有着几乎一样的<a href="https://zh.m.wikipedia.org/wiki/API">API</a>。像Node.js一样，它也是<a href="https://zh.m.wikipedia.org/w/index.php?title=事件驱动程序设计&amp;action=edit&amp;redlink=1">事件驱动</a>的.</p><p>Socket.IO 主要使用<a href="https://zh.m.wikipedia.org/wiki/WebSocket">WebSocket</a>协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如<a href="https://zh.m.wikipedia.org/wiki/Adobe_Flash">Adobe Flash</a> Sockets，<a href="https://zh.m.wikipedia.org/wiki/JSONP">JSONP</a>拉取，或是<a href="https://zh.m.wikipedia.org/wiki/Comet_(web技术">传统的AJAX拉取</a>)，并且在同时提供完全相同的接口。尽管它可以被用作WebSocket的<a href="https://zh.m.wikipedia.org/w/index.php?title=Wrapper_library&amp;action=edit&amp;redlink=1">包装库</a>，它还是提供了许多其它功能，比如广播至多个套接字，存储与不同客户有关的数据，和<a href="https://zh.m.wikipedia.org/w/index.php?title=Asynchronous_I/O&amp;action=edit&amp;redlink=1">异步IO操作</a>。</p><p>可以使用<a href="https://zh.m.wikipedia.org/wiki/Node包管理器">npm</a>（node 软件包）工具来安装。</p><p> Socket 为客户端和服务器提供了双向通信机制。</p><p>这意味着服务器可以 <em>推送</em> 消息给客户端。无论何时你发布一条消息，服务器都可以接收到消息并推送给其他连接到服务器的客户端。</p><p>Socket.IO 的核心理念就是允许发送、接收任意事件和任意数据。任意能被编码为 JSON 的对象都可以用于传输。二进制数据也是支持的。</p><p>这里的实现方案是，当用户输入消息时，服务器接收一个 <code>chat message</code> 事件。<code>index.html</code> 文件中的 <code>script</code> 部分现在应该内容如下：</p><p>接下来的目标就是让服务器将消息发送给其他用户。</p><p>要将事件发送给每个用户，Socket.IO 提供了 <code>io.emit</code> 方法：</p><hr><hr><h1 id="socket（套接字？插槽）"><a href="#socket（套接字？插槽）" class="headerlink" title="socket（套接字？插槽）"></a>socket（套接字？插槽）</h1><p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。“Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，提供一套调用TCP/IP协议的API。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220711204509818.png" alt="image-20220711204509818" style="zoom:67%;" /></p><p>所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字<strong>上联应用进程，下联网络协议栈</strong>，是应用程序通过网络协议进行通信的接口，是应用程序与网络协议根进行交互的接口。</p><p>socket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。<strong>socket 是由 IP 地址和端口结合的，提供向应用层进程传送数据包的机制。</strong></p><p>socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。  </p><p>// 套接字通信分两部分：<br>- 服务器端：被动接受连接，一般不会主动发起连接<br>- 客户端：主动向服务器发起连接<br>socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别  </p><h1 id="websocket和http的关系"><a href="#websocket和http的关系" class="headerlink" title="websocket和http的关系"></a>websocket和http的关系</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p>1、都是基于TCP的，都是可靠传输协议。</p><p>2、都是应用层协议。</p><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220711203604868.png" alt="image-20220711203604868" style="zoom: 80%;" /></p><h1 id="Http、Socket、WebSocket之间联系与区别"><a href="#Http、Socket、WebSocket之间联系与区别" class="headerlink" title="Http、Socket、WebSocket之间联系与区别"></a><a href="https://www.cnblogs.com/aspirant/p/11334957.html">Http、Socket、WebSocket之间联系与区别</a></h1><p><strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</strong></p><p>可以把WebSocket想象成HTTP(应用层)，HTTP和Socket什么关系，WebSocket和Socket就是什么关系。</p><p>HTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息。</p><p><strong>WebSocket 协议 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种</strong></p><hr><p>socket和http的区别：<br>Http协议：简单的对象访问协议，对应于应用层。Http协议是基于TCP链接的。<br>tcp协议：对应于传输层<br>ip协议：对应于网络层<br>TCP/IP是传输层协议，主要解决数据如何在网络中传输；而Http是应用层协议，主要解决如何包装数据。</p><p><strong>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</strong></p><hr><p>Http连接：http连接就是所谓的短连接，及客户端向服务器发送一次请求，服务器端相应后连接即会断掉。</p><p>socket连接：socket连接及时所谓的长连接，理论上客户端和服务端一旦建立连接，则不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该链接已释放网络资源。所以当一个socket连接中没有数据的传输，那么为了位置连续的连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。</p><hr><p>1.HTTP的长连接一般就只能坚持一分钟而已，而且是浏览器决定的，你的页面很难控制这个行为。<br>Socket连接就可以维持很久，几天、数月都有可能，只要网络不断、程序不结束，而且是可以编程灵活控制的。<br>2.HTTP连接是建立在Socket连接之上。在实际的网络栈中，Socket连接的确是HTTP连接的一部分。但是从HTTP协议看，它的连接一般是指它本身的那部分。</p><hr><p>TCP/IP协议栈主要分为四层:应用层、传输层、网络层、数据链路层,</p><p>每层都有相应的协议，如下图（TCP/IP四层模型）</p><p>应用层包括http（万维网）、ftp（文件传输）、smtp（电子邮件）、dns、telnet</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/9dbde0322cc1482fa17b38a4e3bfe664.jpeg" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716100956055.png" alt="image-20220716100956055"></p><p>之前不太懂为什么有OSI七层模型、四层模型，其实他们的区分标准在于OSI七层模型是理论上的分层方式，而四层模型是实践过程中的分层模型。</p><p>OSI七层模型ISO（国际标准化组织）提出的一套理论性的网络标准化协议，可以把它看成一本教科书，它在指定之前是没有经过实践的，而为什么我们实践的过程中又没有遵循OSI的标准来分层呢，是因为我们在实践的过程中发现有些功能不必要分得那么细，而TCP四层模型就是我们实践过程中发现比较合理的分层，虽然我们实际过程中都没有按OSI分为七层，但是OSI对我们实践过程分层有着指导性的意义。</p><p>五层协议将四层协议中的网络接口层分为数据链路层和物理层</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/v2-9120fb10ff256120099cd152799fe309_720w.jpg" alt="img"></p><p><strong>TPC/IP协议栈，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</strong></p><p>把<strong>IP想像两个站点</strong>，<strong>TCP和UDP是高速公路，HTTP 、FTP 就是货车</strong>，而 Socket 就是两个站点的检票口。<strong>货车(http)在一端站点(ip)先通过检票口(socket)，检票后行驶在高速公路(tcp)上，到达另一站点(ip)卸载货物(http)。</strong></p><hr><p><a href="https://www.jianshu.com/p/4e80b931cdea">https://www.jianshu.com/p/4e80b931cdea</a></p><h3 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h3><p>Socket.io提供了基于事件的实时双向通讯</p><p>Browser和WebServer间的实时数据传输是一个很重要的需求，但最早只能通过AJAX轮询方式实现。在WebSocket标准没有推出之前，AJAX轮询是一种可行的方案。</p><p>AJAX轮询原理是设置定时器，定时通过AJAX同步服务端数据。这种方式存在延时且对服务端造成很大负载。直至2011年，IETF才标准化WebSocket - 一种基于TCP套接字进行收发数据的协议。</p><h3 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h3><p>WebSocket是HTML5新增的一种<strong>通信协议</strong>，其特点是服务端可以主动向客户端推送信息，客户端也可以主动向服务端发送信息，是真正的双向平等对话，属于服务器推送技术的一种。</p><p>在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后浏览器和服务端之间就形成了一条快速通道，两者之间就直接可以数据相互传送，带来的好处是</p><ol><li>相互沟通的<code>Header</code>很小，大概只有2Bytes。</li><li>服务器不再被动的接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。</li></ol><p>为了建立一个WebSocket连接，浏览器首先要向服务器发起一个HTTP请求，这个请求和通常的HTTP请求不同，包含了一些附加头信息，其中附加头信息<code>Upgrade: WebSocket</code>表明这是一个申请协议升级的HTTP请求。服务端解析这些头信息，然后产生应答信息返回给客户端，客户端和服务端的WebSocket连接就建立起来了。双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续直到客户端或者服务端的某一方主动关闭连接。</p><h3 id="为什么要使用WebSocket呢？"><a href="#为什么要使用WebSocket呢？" class="headerlink" title="为什么要使用WebSocket呢？"></a>为什么要使用WebSocket呢？</h3><p>Browser已经支持HTTP协议，为什么还要开发一种新的WebSocket协议呢？</p><p><strong>我们知道HTTP协议是一种单向的网络协议，在建立连接后，仅允许Browser/UserAgent向WebServer发出请求资源后，WebServer才能返回对应的数据，而WebServer不能主动的推送数据给Browser/UserAgent。</strong></p><p>最初这么设计HTTP协议的原因是，假设WebServer能主动的推送数据给Browser/UserAgent，那么Browser/UserAgent就太容易受到攻击了，一些广告商也会主动把广告在不经意间强行的传输给客户端，这不能不说是一个灾难。那么单向的HTTP协议给Web应用开发带哪些问题呢？</p><p>现在假设我们要开发一个基于Web的应用去获取当前WebServer的实时数据。例如股票实时行情、火车票剩余票数等。这就需要Browser/UserAgent与WebServer之间反复进行HTTP通信，Browser/UserAgent不断的发送请求去获取当前的实时数据。</p><p>常见的方式</p><ul><li>Polling</li></ul><p><strong>Polling轮询是通过Browser/UserAgent定时向WebServer发送HTTP请求</strong>，WebServer收到请求后把最新的数据发回给Browser/UserAgent，Browser/UserAgent得到数据后将其显示，然后再定期重复此过程。</p><p>虽然这样可以满足需求，但仍存在问题，例如某段时间内WebServer没有更新的数据，但Browser/UserAgent仍然会定时发送请求过来询问，WebServer可以把以前的老数据再传送过去，Browser/UserAgent把这些没有变化的数据再显示出来。这样既浪费网络带宽，有浪费CPU利用率。</p><p>如果说把Browser/UserAgent发送请求的周期调大一些，就可以缓解这个问题，但如果WebServer的数据更新很快时，这样又不能保证Web应用获取数据的实时性。</p><ul><li>LongPolling</li></ul><p>LongPolling是对Polling的一种改进。</p><p>Browser/UserAgent发送HTTP请求到WebServer，此时WebServer可以做2件事情：</p><ol><li>如果WebServer有新的数据需要传送，就立即把数据发回给Browser/UserAgent，Browser/UserAgent收到数据后，立即再发送HTTP请求给WebServer。</li><li>如果WebServer没有新数据需要传送，这里与Polling的方式不同的是，WebServer不是立即发送回应给Browser/UserAgent，而是将这个请求保持住，等待有新的数据来到，再去响应这个请求。当然，如果WebServer的数据长期没有更新，一段时间后，这个HTTP请求就会超时，Browser/UserAgent收到超时信息后，在立即发送一个新的HTTP请求给服务器，然后依次循环这个过程。</li></ol><p>LongPolling的方式虽然在某种程度上减少了网络带宽和CPU利用率等问题，但仍存在缺陷。</p><p>例如WebServer的数据更新速度较快，WebServer在传送一个数据包给Browser/UserAgent后必须等待Browser的下一个HTTP请求到来，才能传递第二个更新的数据包给Browser。这样的话，Browser显示实时数据最快的时间为2 xRTT（往返时间）。另外在网络拥堵的情况下，这个应该是不能让用户接受的。另外，由于HTTP数据包的头部数据量很大（通常有400多个字节），但真正被服务器需要的数据却很少（有时只有10个字节左右），这样的数据包在网络上周期性传输，难免对网络带宽是一种浪费。</p><p>综上所述，要是在Browser有一种新的网路一些，能支持客户端和服务端的双向通信，而且协议的头部又不那么庞大就very nice了。WebSocket正是肩负这样的使命登上了Web的舞台。</p><h3 id="WebSocket-原理"><a href="#WebSocket-原理" class="headerlink" title="WebSocket 原理"></a>WebSocket 原理</h3><p>WebSocket是一种<strong>双向通信协议</strong>，它建立在TCP之上，同HTTP一样通过TCP来传输数据，但与HTTP最大不同的是：</p><ol><li>WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/UserAgent都能主动的向对象发送或接收数据，就像Socket一样，不同的是WebSocket是一种建立在Web基础上的简单模拟Socket的协议。</li><li>WebSocket需要通过握手连接，类似TCP也需要客户端和服务端进行握手连接，连接成功后才能相互通信。</li></ol><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/4933701-2e68a6248c39caa9.gif" alt="img"></p><p>简单说明下WebSocket握手的过程</p><p>当Web应用端调用<code>new WebSocket(url)</code>接口时，Browser就开始了与地址为URL的WebServer建立握手连接的过程。</p><ol><li>Browser与WebSocket服务器通过TCP三次握手建立连接，如果这个建立连接失败，那么后面的过程就不会执行，Web应用将收到错误消息通知。</li><li>在TCP建立连接成功后，Browser/UserAgent通过HTTP协议传送WebSocket支持的版本号、协议的字版本号、原始地址、主机地址等一系列字段给服务端。</li><li>WebSocket服务器收到Browser/UserAgent发送来的握手请求后，如果数据包数据和格式正确，客户端和服务端的协议版本匹配等，就接受本次握手连接，并给出对应的数据回复，同样回复的数据包也是采用HTTP协议传输。</li><li>Browser收到服务器回复的数据包后，如果数据包内容、格式都没有问题的话，就表示本次连接成功，触发<code>onopen</code>消息，此时Web开发者就可以在此时通过<code>send</code>接口向服务器发送数据。否则，握手连接失败，Web应用会收到<code>onerror</code>消息，并且能知道连接失败的原因。</li></ol><h3 id="WebSocket与TCP、HTTP的关系"><a href="#WebSocket与TCP、HTTP的关系" class="headerlink" title="WebSocket与TCP、HTTP的关系"></a>WebSocket与TCP、HTTP的关系</h3><h1 id="“三次握手，四次挥手”你真的懂吗？"><a href="#“三次握手，四次挥手”你真的懂吗？" class="headerlink" title="“三次握手，四次挥手”你真的懂吗？"></a>“三次握手，四次挥手”你真的懂吗？</h1><p>客户端：是服务器吗？我要跟你通信，听得到我说话吗？<br>服务器：可以通信，你听得到我说话吗？<br>客户端：我也听得到。</p><p>是双工</p><p>三次握手和四次挥手TCP一定是客户端发起 （谁发请求谁就是客户端） （http是基于tcp连接的）</p><p>TCP滑动窗口<a href="https://www.bilibili.com/video/BV1PZ4y1P7zp">https://www.bilibili.com/video/BV1PZ4y1P7zp</a></p><p>UDP报文格式：源端口+目标端口+报文长度+内容</p><p>TCP报文格式，一行4字节，1字节8位</p><p>16位源端口号 | 16位目的端口号</p><p>32位序号（seq 每个报文的序号，随机生成</p><p>32位确认序号 ack （服务器的ack=客户端发起请求的seq+1， 客户端的ack=服务器的seq+1</p><p>4位首部长度 | 保留6位 | URG | ACK(1位标志位) | PSH | RST | SYN(1位， 为1则为新) | FIN(我要结束，我要断开) | 16位窗口大小 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710220737099.png" alt="image-20220710220737099"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716200913805.png" alt="image-20220716200913805"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716201845317.png" alt="image-20220716201845317"></p><p>全文背诵：</p><p>面试官你好，这个问题我是知道的。TCP/IP协议是传输层的一个面向连接的安全可靠的传输协议。</p><p>三次握手的机制是为了保证能建立一个安全可靠的连接；第一次握手是由客户端发起，客户端会向服务端发送一个报文，报文里面SYN标志位是置1的，当服务端收到这个报文的时候就知道客户端要和我发起一个新的连接，于是服务端就向客户端发送一个确认消息包ACK位置1，以上两次握手之后，对于客户端而言，其实是已经知道了所有信息，就是我既能给服务端发送消息，我还能收到服务端的消息；对于服务端而言，两次握手是不够的，因为到目前为止，服务端只知道一件事情，就是客户端给我发送的消息我收的到，但是我发给客户端的消息，客户端能不能收到我还不知道。</p><p>所以还要进行第三次握手。第三次握手就是当客户端收到服务端发过来的确认消息的报文之后，还要继续给服务端进行一个回应，也是一个ACK位置1的一个确认消息。</p><p>通过以上三次连接，不管是服务端还是客户端都彼此知道了，我既能给对方发送消息也能收到对方的消息，那么这个连接就能被安全的建立了。</p><p>四次握手机制，也是由客户端（服务器也可以）首先发起的，客户端会发起一个报文，在报文里面FIN标志位置1；当服务端收到这报文之后，我就知道了客户端想要和我断开连接，但是此时服务端不一定能做好准备，因为当客户端发起断开连接的时候，对于服务端而言它极有可能有未发送完的的消息，它还要继续发送；所以此时对于服务端而言他只能进行一个消息确认，我先告诉对方，我知道你要和我断开连接了，但是我这还可能没有做好准备，你还需要等我一下，等会我会告诉你；于是，发完这个消息确认包后，可能稍作片刻，它可能会继续发送一个断开连接的报文，一个FIN位置1的报文，是由服务端发给客户端的，这个报文表示了服务端已经做好了断开连接的准备，那么当这个报文发给客户端的时候，客户端同样要给服务端继续发送一个消息确认的报文。一共有四次，通过这四次的相互沟通和连接，我就知道了，不管是服务端还是客户端都已经做好了断开连接的准备，于是连接就可以被断开了。</p><p>这是我对三次握手和四次挥手的理解。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710221248490.png" alt="image-20220710221248490"></p><p>为什么服务器要分两次挥手，因为有可能正在发送一个数据给客户端，不能立刻断开。</p><p>server的第二步说：我知道你要和我断开，你先等我一下，我还没传输完。</p><p>server的第三步说：我终于传输完了，客户端你断开吧。</p><p>四次挥手发生在断开连接的时候，在程序中当调用了close()会使用TCP协议进行四次挥手。<br>客户端和服务器端都可以主动发起断开连接，谁先调用close()谁就是发起。<br>因为在TCP连接的时候，采用三次握手建立的的连接是双向的，在断开的时候需要双向断开。  </p><h1 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h1><p>开放系统互连参考模型 (Open System Interconnect 简称OSI）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220711171534690.png" alt="image-20220711171534690"></p><p>7、应用层：用户app里的数据，图片、声音、文字</p><p>6、表示层： 用bmp或jpeg编码表示图片数据，WAV或mp3编码表示声音数据，wmv或avi编码表示视频数据。</p><p>5、会话层：会话连接，建立两个应用软件之间的会话关系和连接。</p><p>4、传输层（数据段）：简历TCP或UDP连接，建立端到端的连接。 给报文打上端口号，例如80是网页数据，4000是qq数据</p><p>3、网络层（数据包）：给数据表打上ip地址，并且使用路由转发。使用的协议统一，网络层基于IP地址进行<strong>路由</strong>转发。进行数据传输：路由数据包，选择传递数据的最佳路径，支持逻辑<strong>寻址</strong>和路径选择。</p><p>2、数据链路层（数据帧）：以太网协议，mac地址，访问介质：定义如何格式化数据以便传输以及访问网络，支持错误检测。</p><p>1、物理层（数据位）：网线，二进制传输，定义了各种规范。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716100310633.png" alt="image-20220716100310633"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224132044.png" alt="image-20220710224132044"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224203925.png" alt="image-20220710224203925"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224218692.png" alt="image-20220710224218692"></p><h1 id="网络模型图"><a href="#网络模型图" class="headerlink" title="网络模型图"></a>网络模型图</h1><p>socket就是这里的TCP或UDP</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710230633852.png" alt="image-20220710230633852"></p><h1 id="基于TCP-UDP协议的应用层协议有哪些？"><a href="#基于TCP-UDP协议的应用层协议有哪些？" class="headerlink" title="基于TCP/UDP协议的应用层协议有哪些？"></a>基于TCP/UDP协议的应用层协议有哪些？</h1><p>1、基于TCP的<strong>应用层</strong>协议有：HTTP、FTP、SMTP、TELNET、SSH<br>协议    全称    默认端口<br>HTTP （ 浏览网页 ）    HyperText Transfer Protocol（超文本传输协议）    80<br>FTP    File Transfer Protocol (文件传输协议)    20用于传输数据，21用于传输控制信息<br>SMTP    Simple Mail Transfer Protocol (简单邮件传输协议)    25<br>TELNET    Teletype over the Network (远程登录，明码传输)    23</p><p>WebSocket 80或443端口丰富</p><p>SSH    Secure Shell（远程，加密传输）    22  使用多种加密技术 保证在 用户终端和服务器之间 建立加密安全连接</p><p>对称加密是一种加密类型，在加密和解密时候使用同一个密钥。SSH数据传输时候基本上所有过程都是使用对称密钥来加密。只有在刚开始创建连接阶段和身份认证握手阶段才使用非对称加密。为了确保信息的安全传输，SSH 在事物中的多个地方采用了多种不同类型的数据操纵技术，包括对称加密，非对称加密以及哈希。</p><p>2、基于UDP的应用层协议：DNS、TFTP（简单文件传输协议）、SNMP：简单网络管理协议<br>协议    全称    默认端口<br>DNS    Domain Name Service (域名服务)    53<br>TFTP    Trivial File Transfer Protocol (简单文件传输协议)    69<br>SNMP    Simple Network Management Protocol (简单网络管理协议)    通过UDP端口161接收，只有Trap信息采用UDP端口162。<br>NTP    Network Time Protocol (网络时间协议)    123</p><hr><p>网络层有ip协议、IGMP、ICMP协议</p><p>数据链路层有ethernet以太网、ppp、PPPoE协议。</p><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220801211824291.png" alt="image-20220801211824291"></p><p><strong>传输控制协议TCP(Transmission Control Protocol)</strong></p><p> <strong>用户数据包协议UDP(User Datagram Protocol)</strong></p><ol><li>TCP是面向<strong>连接</strong>的，通过三次握手建立客户端和服务端之间的可靠连接，而UDP是面向无连接的，不需要建立连接就可以直接给多台机器发送数据。</li><li>TCP保证<strong>可靠</strong>服务，会进行超时重传。而UDP不保证可靠交付。</li><li>TCP是面向<strong>字节流</strong>的协议，字节流没有头尾，但是流通过报文段发送出去，UDP是面向<strong>报文</strong>的协议，通过数据报发送数据。</li><li>TCP有流量控制（滑动窗口），拥塞控制（慢启动、拥塞避免、快重传、快恢复）等<strong>机制</strong>，而UDP只受数据生成的<strong>速率</strong>等影响，跟网络状况无关。</li><li>TCP是点对点连接的（全双工），UDP支持一对一、一对多、多对一和多对多的连接。</li></ol><p>UDP适合：直播，实时游戏，http3.0等场景。<br>不需要建立连接，一对一沟通，可以广播，对于丢包不敏感，网络较好的内网，即使网络不畅也不能降低数据发送的速度。</p><p>TCP适合发送文件 发送邮件 浏览网页</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224707044.png" alt="image-20220710224707044"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224734156.png" alt="image-20220710224734156"></p><p><strong>TCP面向字节流与UDP面向报文</strong><br>之前对于tcp和udp只是记住了一个面向字节流，一个是面向报文的，但是并没有真正的理解</p><p>通俗的解释：</p><p>面向<strong>报文</strong>的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。不会出现黏包的问题。</p><p>面向<strong>字节流</strong>的话，虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。会出现黏包的问题。</p><h1 id="浏览器输入URL返回页面的过程"><a href="#浏览器输入URL返回页面的过程" class="headerlink" title="浏览器输入URL返回页面的过程"></a>浏览器输入URL返回页面的过程</h1><ol><li>首先解析域名，通过DNS查询，找到域名的IP地址</li><li>浏览器利用IP直接和网站主机通信，三次握手，<strong>建立TCP连接</strong>。浏览器会以一个随机端口向服务器的web程序80（HTTP是90端口，HTTPS是443端口）端口发起TCP的连接。</li><li>建立TCP连接吼，浏览器向主机发起一个HTTP请求。</li><li>服务器响应请求，返回响应数据。</li><li>浏览器解析响应内容，进行渲染，呈现给用户。</li><li>HTTP请求结束，断开TCP连接。</li></ol><h1 id="深入理解DNS解析过程"><a href="#深入理解DNS解析过程" class="headerlink" title="深入理解DNS解析过程"></a>深入理解DNS解析过程</h1><p>DNS是基于UDP协议的应用层协议</p><ol><li><p>检查浏览器缓存和本地hosts文件是否有网址记录。</p></li><li><p><strong>主机</strong>先向其本地域名服务器进行<strong>递归</strong>查询</p></li><li><p><strong>本地</strong>域名服务器采用迭代的查询，它先向根域名服务器查询</p></li><li><p><strong>根</strong>域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址。</p></li><li><p>本地域名服务器向<strong>顶级</strong>域名服务器发起查询。</p></li><li><p>顶级域名服务器告诉本地域名服务器，下一次应查询的<strong>权限</strong>域名服务器IP地址</p></li><li><p>本地域名服务器向权限域名服务器发起查询。</p></li><li><p>权限域名服务器告诉本地域名服务器所查询的IP地址。</p></li><li><p>本地域名服务器把查询结果告诉主机</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1200133224-2.jpg" alt="DNS域名解析过程-前端八股文"></p></li></ol><p>域名(Domain)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mail.ccav.com</span><br><span class="line">---- ---- ----</span><br><span class="line">三级域名 二级域名 顶级域名</span><br></pre></td></tr></table></figure><h3 id="域名服务器划分"><a href="#域名服务器划分" class="headerlink" title="域名服务器划分"></a>域名服务器划分</h3><p>了解域名服务器划分之后，就会对DNS解析的过程大概有些了解。域名服务器按照层级分为：</p><p><strong>本地域名服务器</strong></p><p>本地域名服务器相当于一个班主任，你有点啥事都找他。当一个主机发出DNS查询的时候，这个查询的请求就会发送到本地域名服务器。本地域名服务器一般由ISP（联通电信）管理。</p><p><strong>根域名服务器</strong> .</p><p>根域名服务器是最高层次的域名服务，是校长,只负责规划大方向。他知道所有顶级域名服务器的域名和IP地址。不管那个本地域名服务器若自己不能不能解析，那首先请求的就是根域名服务器。根域名服务器不会把待查询的域名直接转换成IP，而是告诉本地域名服务器下一步应该找哪一个顶级域名服务器进行查询。</p><p><strong>顶级域名服务器</strong> com cn net gov </p><p>顶级域名服务器是负责各个方向的副校长，有负责安全的，有负责教学的。他负责管理该顶级域名下的所有二级域名，当收到DNS查询请求后就会给出响应的应答，可能是最终的结果，也可能是下一步应该找到的域名服务器的IP地址。</p><p><strong>权限域名服务器</strong> bilibili qq baidu</p><p>权限域名服务器就是负责一个区的域名服务器，是基层干活的，比如宿管，各科老师，他负责一个更小的区域。当一个权限服务还不能给出最后的回答时，就会告诉查询请求的DNS客户，下一步应该找哪个权限域名服务器。</p><p>再下还有主机名 www mail member space</p><h3 id="域名查询的两种方式"><a href="#域名查询的两种方式" class="headerlink" title="域名查询的两种方式"></a>域名查询的两种方式</h3><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><p>递归查询，就是你找我要一个域名的IP地址，但是我不知道，那<strong>我去帮你去</strong>向知道的人问这个IP地址。举个例子就是，你问你班主任怎么做番茄炒鸡蛋，你班主任不知道，但是你班主任去问了食堂厨师，然后告诉你。这就叫递归查询。<br><strong>从host到本地域名服务器一般是用的递归查询。</strong></p><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>迭代查询就是，你找我要一个域名的IP地址，我也不知道这个IP地址，但是我知道谁知道，<strong>我告诉你去找谁问</strong>。举个例子就是，你们班主任到了食堂随便拉了个人问怎么做番茄炒鸡蛋，那个人说，我只是个卖饭的，我不知道，但是我知道A君是在后厨的，你可以去问A君。然后你班主任就去问A君了。呐，这就叫迭代查询。<br><strong>从本地域名服务器到根域名服务器一般是用的迭代查询。</strong></p><h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224430637.png" alt="image-20220710224430637"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224459231.png" alt="image-20220710224459231"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220710224528356.png" alt="image-20220710224528356"></p><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：语法、语义、时序。</p><p>为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议（protocol），<strong>它最终体现为在网络上传输的数据包的格式。</strong></p><p>协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议 。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716101810317.png" alt="image-20220716101810317"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716101526161.png" alt="image-20220716101526161"></p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716101848093.png" alt="image-20220716101848093"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102012808.png" alt="image-20220716102012808"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716101939094.png" alt="image-20220716101939094"></p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102105919.png" alt="image-20220716102105919"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102210270.png" alt="image-20220716102210270"></p><h2 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102501564.png" alt="image-20220716102501564"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102517324.png" alt="image-20220716102517324"></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102601333.png" alt="image-20220716102601333"></p><h2 id="分用"><a href="#分用" class="headerlink" title="分用"></a>分用</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102856437.png" alt="image-20220716102856437"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102903822.png" alt="image-20220716102903822"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102914332.png" alt="image-20220716102914332"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716103540290.png" alt="image-20220716103540290"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716103451453.png" alt="image-20220716103451453"></p><p>如何得到目标端的mac地址，arp请求会发给所有局域网内</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716103647487.png" alt="image-20220716103647487"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716102501564.png" alt="image-20220716102501564"></p><h2 id="字节序（同序为大端）"><a href="#字节序（同序为大端）" class="headerlink" title="字节序（同序为大端）"></a>字节序（同序为大端）</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716112033084.png" alt="image-20220716112033084"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716111515515.png" alt="image-20220716111515515"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716111945752.png" alt="image-20220716111945752"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716112003404.png" alt="image-20220716112003404"></p><p>网络字节序一定是大端，主机字节序不一定。</p><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。  </p><p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。</p><p>BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序  </span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716114523015.png" alt="image-20220716114523015"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716115324918.png" alt="image-20220716115324918"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716115609326.png" alt="image-20220716115609326"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716115408917.png" alt="image-20220716115408917"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716115654574.png" alt="image-20220716115654574"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716115705028.png" alt="image-20220716115705028"></p><h2 id="Socket地址"><a href="#Socket地址" class="headerlink" title="Socket地址"></a>Socket地址</h2><p>// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。<br>// 客户端 -&gt; 服务器（IP, Port）  </p><h3 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a>通用 socket 地址</h3><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;<span class="comment">//sa_family 成员是地址族类型（sa_family_t）的变量</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br></pre></td></tr></table></figure><p>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：  </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716120025410.png" alt="image-20220716120025410"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716120117276.png" alt="image-20220716120117276"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716152431277.png" alt="image-20220716152431277"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span></span><br><span class="line"><span class="keyword">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) - __SOCKADDR_COMMON_SIZE - <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) - <span class="keyword">sizeof</span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;</span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure><p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr  </p><h2 id="IP地址转换（字符串ip-整数-，主机、网络字节序的转换）"><a href="#IP地址转换（字符串ip-整数-，主机、网络字节序的转换）" class="headerlink" title="IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）"></a>IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）</h2><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><p>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src:需要转换的点分十进制的IP字符串</span><br><span class="line">dst:转换后的结果保存在这个里面</span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line">af:地址族： AF_INET AF_INET6</span><br><span class="line">src: 要转换的ip的整数的地址</span><br><span class="line">dst: 转换成IP地址字符串保存的地方</span><br><span class="line">size：第三个参数的大小（数组的大小）</span><br><span class="line">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716155600862.png" alt="image-20220716155600862"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716155541442.png" alt="image-20220716155541442"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716155835353.png" alt="image-20220716155835353"></p><h2 id="用socket实现网络通信"><a href="#用socket实现网络通信" class="headerlink" title="用socket实现网络通信"></a>用socket实现网络通信</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716155939527.png" alt="image-20220716155939527"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">- 监听：监听有客户端的连接</span><br><span class="line">- 套接字：这个套接字其实就是一个文件描述符</span><br><span class="line"><span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">- 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line"><span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line"><span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字（fd）</span><br><span class="line"><span class="number">5.</span> 通信</span><br><span class="line">- 接收数据</span><br><span class="line">- 发送数据</span><br><span class="line"><span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="number">1.</span> 创建一个用于通信的套接字（fd）</span><br><span class="line"><span class="number">2.</span> 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line"><span class="number">3.</span> 连接成功了，客户端可以直接和服务器通信</span><br><span class="line">- 接收数据</span><br><span class="line">- 发送数据</span><br><span class="line"><span class="number">4.</span> 通信结束，断开连接</span><br></pre></td></tr></table></figure><h2 id="套接字Socket函数"><a href="#套接字Socket函数" class="headerlink" title="套接字Socket函数"></a>套接字Socket函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">    - domain: 协议族</span><br><span class="line">        AF_INET : ipv4</span><br><span class="line">        AF_INET6 : ipv6</span><br><span class="line">        AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">        SOCK_STREAM : 流式协议</span><br><span class="line">        SOCK_DGRAM : 报式协议</span><br><span class="line">    - protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">        - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">        - SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">        - 失败：<span class="number">-1</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">// socket命名</span></span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">    - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">    - addrlen : 第二个参数结构体占的内存大小</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">    - backlog : 未连接的和已经连接的和的最大值， <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 用于监听的文件描述符</span><br><span class="line">    - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">    - addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">    - 成功 ：用于通信的文件描述符</span><br><span class="line">    - <span class="number">-1</span> ： 失败</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">- 参数：</span><br><span class="line">    - sockfd : 用于通信的文件描述符</span><br><span class="line">    - addr : 客户端要连接的服务器的地址信息</span><br><span class="line">    - addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket(用于监听的套接字)</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.193.128&quot;, saddr.sin_addr.s_addr);</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd, (struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(clientaddr);</span><br><span class="line">    <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr *)&amp;clientaddr, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="keyword">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="keyword">sizeof</span>(clientIP));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> clientPort = ntohs(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端的数据</span></span><br><span class="line">        <span class="keyword">int</span> num = read(cfd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        write(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    close(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        write(fd, data , <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>滑动窗口（Sliding window）是一种<strong>流量控制技术</strong>。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种技术，即<strong>容许发送方在接收任何应答之前传送附加的包。</strong>接收方告诉发送方在某一时刻能送多少包（称窗口尺寸）。</p><p>TCP 中采用滑动窗口来进行传输控制，<strong>滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据</strong>。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0时，发送方一般不能再发送数据报。</p><p>滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。  </p><p><strong>窗口理解为缓冲器的大小</strong>，会随着发送数据和接收数据而变化。通信双方都有发送和接收数据的缓冲区。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716202339331.png" alt="image-20220716202339331"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># mss: Maximum Segment Size(一条数据的最大的数据量)</span></span><br><span class="line"><span class="meta"># win: 滑动窗口，相当于空闲的大小</span></span><br><span class="line"><span class="number">1.</span> 客户端向服务器发起连接，客户端的滑动窗口是<span class="number">4096</span>，一次发送的最大数据量是<span class="number">1460</span></span><br><span class="line"><span class="number">2.</span> 服务器接收连接情况，告诉客户端服务器的窗口大小是<span class="number">6144</span>，一次发送的最大数据量是<span class="number">1024</span></span><br><span class="line"><span class="number">3.</span> 第三次握手</span><br><span class="line"><span class="number">4.</span> <span class="number">4</span><span class="number">-9</span> 客户端连续给服务器发送了<span class="number">6</span>k的数据，每次发送<span class="number">1</span>k</span><br><span class="line"><span class="number">5.</span> 第<span class="number">10</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">2</span>k,窗</span><br><span class="line">口大小是<span class="number">2</span>k = 剩余<span class="number">2</span>k空间</span><br><span class="line"><span class="number">6.</span> 第<span class="number">11</span>次，服务器告诉客户端：发送的<span class="number">6</span>k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了<span class="number">4</span>k,窗</span><br><span class="line">口大小是<span class="number">4</span>k，又处理<span class="number">2</span>k，还剩<span class="number">4</span>k空间</span><br><span class="line"><span class="number">7.</span> 第<span class="number">12</span>次，客户端给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">8.</span> 第<span class="number">13</span>次，客户端主动请求和服务器断开连接，并且给服务器发送了<span class="number">1</span>k的数据</span><br><span class="line"><span class="number">9.</span> 第<span class="number">14</span>次，服务器回复ACK <span class="number">8194</span>, a:同意断开连接的请求 b:告诉客户端已经接受到方才发的<span class="number">2</span>k的数据</span><br><span class="line">c:滑动窗口<span class="number">2</span>k</span><br><span class="line"><span class="number">10.</span>第<span class="number">15</span>、<span class="number">16</span>次，通知客户端滑动窗口的大小</span><br><span class="line"><span class="number">11.</span>第<span class="number">17</span>次，第三次挥手，服务器端给客户端发送FIN,请求断开连接</span><br><span class="line"><span class="number">12.</span>第<span class="number">18</span>次，第四次挥手，客户端同意了服务器端的断开请求</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220716202752580.png" alt="image-20220716202752580"></p><p>发送方的缓冲区：<br>    白色格子：空闲的空间<br>    灰色格子：数据已经被发送出去了，但是还没有被接收<br>    紫色格子：还没有发送出去的数据<br>接收方的缓冲区：<br>    白色格子：空闲的空间<br>    紫色格子：已经接收到的数据  </p><hr><h2 id="TCP通信并发-多进程实现并发服务器"><a href="#TCP通信并发-多进程实现并发服务器" class="headerlink" title="TCP通信并发 - 多进程实现并发服务器"></a>TCP通信并发 - 多进程实现并发服务器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">要实现TCP通信服务器处理并发的任务，使用多线程或者多进程来解决。</span><br><span class="line">思路：</span><br><span class="line"><span class="number">1.</span> 一个父进程，多个子进程</span><br><span class="line"><span class="number">2.</span>父进程负责等待并接受客户端的连接</span><br><span class="line"><span class="number">3.</span>子进程：完成通信，接受一个客户端连接，就创建一个子进程用于通信。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多进程 服务器端   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recyleChild</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有的子进程都回收了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还有子进程活着</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 被回收了</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;子进程 %d 被回收了\n&quot;</span>, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_handler = recyleChild;</span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断循环等待客户端连接</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line">        <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每一个连接进来，创建一个子进程跟客户端通信</span></span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 子进程</span></span><br><span class="line">            <span class="comment">// 获取客户端的信息</span></span><br><span class="line">            <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">            inet_ntop(AF_INET, &amp;cliaddr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(cliaddr.sin_port);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">            <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = read(cfd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">                    perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                write(cfd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            close(cfd);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);    <span class="comment">// 退出当前子进程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="多线程实现并发服务器"><a href="#多线程实现并发服务器" class="headerlink" title="多线程实现并发服务器"></a>多线程实现并发服务器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">// 通信的文件描述符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;  <span class="comment">// 线程号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> <span class="title">sockinfos</span>[128];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">working</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子线程和客户端通信   cfd 客户端的信息 线程号</span></span><br><span class="line">    <span class="comment">// 获取客户端的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span> =</span> (struct sockInfo *)arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cliIp[<span class="number">16</span>];</span><br><span class="line">    inet_ntop(AF_INET, &amp;pinfo-&gt;addr.sin_addr.s_addr, cliIp, <span class="keyword">sizeof</span>(cliIp));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cliPort = ntohs(pinfo-&gt;addr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is : %s, prot is %d\n&quot;</span>, cliIp, cliPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收客户端发来的数据</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = read(pinfo-&gt;fd, &amp;recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client closed....\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(pinfo-&gt;fd, recvBuf, <span class="built_in">strlen</span>(recvBuf) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(pinfo-&gt;fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    <span class="keyword">int</span> lfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    saddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    <span class="keyword">int</span> ret = bind(lfd,(struct sockaddr *)&amp;saddr, <span class="keyword">sizeof</span>(saddr));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">int</span> max = <span class="keyword">sizeof</span>(sockinfos) / <span class="keyword">sizeof</span>(sockinfos[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">        bzero(&amp;sockinfos[i], <span class="keyword">sizeof</span>(sockinfos[i]));</span><br><span class="line">        sockinfos[i].fd = <span class="number">-1</span>;</span><br><span class="line">        sockinfos[i].tid = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待客户端连接，一旦一个客户端连接进来，就创建一个子线程进行通信</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(cliaddr);</span><br><span class="line">        <span class="comment">// 接受连接</span></span><br><span class="line">        <span class="keyword">int</span> cfd = accept(lfd, (struct sockaddr*)&amp;cliaddr, &amp;len);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockInfo</span> * <span class="title">pinfo</span>;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 从这个数组中找到一个可以用的sockInfo元素</span></span><br><span class="line">            <span class="keyword">if</span>(sockinfos[i].fd == <span class="number">-1</span>) &#123;</span><br><span class="line">                pinfo = &amp;sockinfos[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == max - <span class="number">1</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pinfo-&gt;fd = cfd;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;pinfo-&gt;addr, &amp;cliaddr, len);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建子线程</span></span><br><span class="line">        pthread_create(&amp;pinfo-&gt;tid, <span class="literal">NULL</span>, working, pinfo);</span><br><span class="line"></span><br><span class="line">        pthread_detach(pinfo-&gt;tid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(lfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网项目记录-第二章linux多进程开发</title>
      <link href="2022/07/09/blog52-nowcoderProject2/"/>
      <url>2022/07/09/blog52-nowcoderProject2/</url>
      
        <content type="html"><![CDATA[<p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709151547833.png" alt="image-20220709151547833"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709151741790.png" alt="image-20220709151741790"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152001679.png" alt="image-20220709152001679"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152137918.png" alt="image-20220709152137918"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152409441.png" alt="image-20220709152409441"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152513447.png" alt="image-20220709152513447" style="zoom: 67%;" /></p><p>进程的控制结构为PCB</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152551801.png" alt="image-20220709152551801"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152730589.png" alt="image-20220709152730589" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152820578.png" alt="image-20220709152820578" style="zoom:80%;" /></p><hr><h2 id="2-1-进程的状态"><a href="#2-1-进程的状态" class="headerlink" title="2.1 进程的状态"></a>2.1 进程的状态</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709152922274.png" alt="image-20220709152922274"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709153613473.png" alt="image-20220709153613473"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709153917036.png" alt="image-20220709153917036" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709154108593.png" alt="image-20220709154108593"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709155121586.png" alt="image-20220709155121586"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709154222057.png" alt="image-20220709154222057" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709154501219.png" alt="image-20220709154501219" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709155630565.png" alt="image-20220709155630565"></p><hr><h2 id="2-3-进程创建"><a href="#2-3-进程创建" class="headerlink" title="2.3 进程创建"></a>2.3 进程创建</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709155809181.png" alt="image-20220709155809181"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pid_t fork(void);</span></span><br><span class="line"><span class="comment">        函数的作用：用于创建子进程。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span></span><br><span class="line"><span class="comment">            在父进程中返回创建的子进程的ID,</span></span><br><span class="line"><span class="comment">            在子进程中返回0</span></span><br><span class="line"><span class="comment">            如何区分父进程和子进程：通过fork的返回值。</span></span><br><span class="line"><span class="comment">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        父子进程之间的关系：</span></span><br><span class="line"><span class="comment">        区别：</span></span><br><span class="line"><span class="comment">            1.fork()函数的返回值不同</span></span><br><span class="line"><span class="comment">                父进程中: &gt;0 返回的子进程的ID</span></span><br><span class="line"><span class="comment">                子进程中: =0</span></span><br><span class="line"><span class="comment">            2.pcb中的一些数据</span></span><br><span class="line"><span class="comment">                当前的进程的id pid</span></span><br><span class="line"><span class="comment">                当前的进程的父进程的id ppid</span></span><br><span class="line"><span class="comment">                信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        共同点：</span></span><br><span class="line"><span class="comment">            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span></span><br><span class="line"><span class="comment">                - 用户区的数据</span></span><br><span class="line"><span class="comment">                - 文件描述符表</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        父子进程对变量是不是共享的？</span></span><br><span class="line"><span class="comment">            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span></span><br><span class="line"><span class="comment">            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pid : %d\n&quot;, pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>当前终端pid87186创建fork子进程87631（ 在父进程中 返回子进程的pid），一个父进程为87630，一个子进程87631。CPU时间片交替运行。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709161530157.png" alt="image-20220709161530157" style="zoom:50%;" /></p><hr><h2 id="2-4-父子进程关系及GDB多进程调试"><a href="#2-4-父子进程关系及GDB多进程调试" class="headerlink" title="2.4 父子进程关系及GDB多进程调试"></a>2.4 父子进程关系及GDB多进程调试</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709162506370.png" alt="image-20220709162506370"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709162743575.png" alt="image-20220709162743575" style="zoom:50%;" /></p><p>初始值一样，后续操作不一样。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709162845593.png" alt="image-20220709162845593" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712095224502.png" alt="image-20220712095224502"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709164650569.png" alt="image-20220709164650569"></p><p>父子进程间遵循<strong>读时共享写时复制</strong>的原则。只有进程空间的各段的内容要发生变化时（子进程或父进程进行写操作时，都会引起复制），才会将父进程的内容复制一份给子进程。<strong>父子进程在逻辑上仍然是严格相互独立的两个进程，各自维护各自的参数，只是在物理上实现了读时共享，写时复制。</strong> </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709173503178.png" alt="image-20220709173503178" style="zoom:50%;" /></p><hr><h2 id="2-5-父子进程关系"><a href="#2-5-父子进程关系" class="headerlink" title="2.5 父子进程关系"></a>2.5 父子进程关系</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709174528241.png" alt="image-20220709174528241" style="zoom:67%;" /></p><p>默认调试父进程，子进程自己跑自己的。   </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709174556763.png" alt="image-20220709174556763"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712170609358.png" alt="image-20220712170609358"></p><hr><h2 id="2-6-函数族"><a href="#2-6-函数族" class="headerlink" title="2.6 函数族"></a>2.6 函数族</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709191216787.png" alt="image-20220709191216787"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709192101771.png" alt="image-20220709192101771"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execl(const char *path, const char *arg, ...);</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - path:需要指定的执行的文件的路径或者名称</span></span><br><span class="line"><span class="comment">                a.out /home/nowcoder/a.out 推荐使用绝对路径</span></span><br><span class="line"><span class="comment">                ./a.out hello world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// execl(&quot;hello&quot;,&quot;hello&quot;,NULL);</span></span><br><span class="line"></span><br><span class="line">        execl(<span class="string">&quot;/bin/ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712193814626.png" alt="image-20220712193814626" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712193751377.png" alt="image-20220712193751377" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712184916552.png" alt="image-20220712184916552" style="zoom:67%;" /></p><p>hello world不在一起的原因是因为产生了孤儿进程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int execlp(const char *file, const char *arg, ... );</span></span><br><span class="line"><span class="comment">        - 会到环境变量中查找指定的可执行文件，如果找到了就执行，找不到就执行不成功。</span></span><br><span class="line"><span class="comment">        - 参数：</span></span><br><span class="line"><span class="comment">            - file:需要执行的可执行文件的文件名</span></span><br><span class="line"><span class="comment">                a.out</span></span><br><span class="line"><span class="comment">                ps</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - arg:是执行可执行文件所需要的参数列表</span></span><br><span class="line"><span class="comment">                第一个参数一般没有什么作用，为了方便，一般写的是执行的程序的名称</span></span><br><span class="line"><span class="comment">                从第二个参数开始往后，就是程序执行所需要的的参数列表。</span></span><br><span class="line"><span class="comment">                参数最后需要以NULL结束（哨兵）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            只有当调用失败，才会有返回值，返回-1，并且设置errno</span></span><br><span class="line"><span class="comment">            如果调用成功，没有返回值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execv(const char *path, char *const argv[]);</span></span><br><span class="line"><span class="comment">        argv是需要的参数的一个字符串数组</span></span><br><span class="line"><span class="comment">        char * argv[] = &#123;&quot;ps&quot;, &quot;aux&quot;, NULL&#125;;</span></span><br><span class="line"><span class="comment">        execv(&quot;/bin/ps&quot;, argv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        int execve(const char *filename, char *const argv[], char *const envp[]);</span></span><br><span class="line"><span class="comment">        char * envp[] = &#123;&quot;/home/nowcoder&quot;, &quot;/home/bbb&quot;, &quot;/home/aaa&quot;&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子进程，在子进程中执行exec函数族中的函数</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i = %d, pid = %d\n&quot;</span>, i, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-7-进程退出"><a href="#2-7-进程退出" class="headerlink" title="2.7 进程退出"></a>2.7 进程退出</h2><p>上是标准C库，下是linux系统函数</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709200757166.png" alt="image-20220709200757166"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709200943834.png" alt="image-20220709200943834" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709201041144.png" alt="image-20220709201041144" style="zoom:50%;" /></p><p>在程序中</p><p>孤儿进程：子进程先睡一秒，父进程运行玩死了，子进程还活着，子进程成为孤儿进程。</p><p>僵尸进程：父进程一直运行不死，子进程死了，残留内核区资源，成为僵尸进程。然后只能Ctrl+C杀死，子进程被进程号为1回收。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709201148099.png" alt="image-20220709201148099"></p><p>正常的情况下</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712195746801.png" alt="image-20220712195746801" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712195707422.png" alt="image-20220712195707422"></p><p>想让父进程死，就让子进程睡一秒钟</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712195924079.png" alt="image-20220712195924079"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709201834519.png" alt="image-20220709201834519"></p><p>​    孤儿进程的父进程号为1，父进程结束后会显示终端，由进程号为1的进程来回收子进程的资源。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709202519128.png" alt="image-20220709202519128"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712200503016.png" alt="image-20220712200503016"></p><p>子进程死了父进程还在进行。父进程14859处于休眠状态，子进程14860是僵尸进程。，kill -9杀不死。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712200624838.png" alt="image-20220712200624838"></p><hr><h2 id="2-8-wait函数"><a href="#2-8-wait函数" class="headerlink" title="2.8 wait函数"></a>2.8 wait函数</h2><p>主要针对僵尸进程。学习如何在父进程中回收子进程的资源。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712201345734.png" alt="image-20220712201345734"></p><p>wait 能够<strong>等待子进程状态改变</strong>，包含子进程结束、被信号停止、被信号暂停。调用wait会去释放子进程的资源。父进程默认wait阻塞了，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t wait(int *wstatus);</span></span><br><span class="line"><span class="comment">        功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收子进程的资源。</span></span><br><span class="line"><span class="comment">        参数：int *wstatus</span></span><br><span class="line"><span class="comment">            进程退出时的状态信息，传入的是一个int类型的地址，传出参数。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            - 成功：返回被回收的子进程的id</span></span><br><span class="line"><span class="comment">            - 失败：-1 (所有的子进程都结束，调用函数失败)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    调用wait函数的进程会被挂起（阻塞），直到它的一个子进程退出或者收到一个不能被忽略的信号时才被唤醒（相当于继续往下执行）</span></span><br><span class="line"><span class="comment">    如果没有子进程了，函数立刻返回，返回-1；如果子进程都已经结束了，也会立即返回，返回-1.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// int ret = wait(NULL);</span></span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="keyword">int</span> ret = wait(&amp;st);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是正常退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                <span class="comment">// 是不是异常终止</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// exit(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220721161212220.png" alt="image-20220721161212220" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712204152216.png" alt="image-20220712204152216" style="zoom:67%;" /></p><p>此时子进程已经死掉，成为僵尸进程。当被ctrl+c结束了父进程，僵尸进程就被进程号为1的进程回收了，因为父进程一死，子进程就变成孤儿进程。但并不能每次都结束父进程，应该在父进程中做一些操作。</p><p>wait(NULL) 表示不需要子进程退出的状态</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712204332100.png" alt="image-20220712204332100" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712210245314.png" alt="image-20220712210245314" style="zoom:67%;" /></p><p>子进程一直在打印，父进程没有动，说明父进程阻塞了。通过kill -9 13478 ，父进程不阻塞了，就打印。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712210434033.png" alt="image-20220712210434033" style="zoom:67%;" /></p><p>然后全kill掉，此时没有子进程了。<strong>所有子进程都结束，则返回-1。</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712204628113.png" alt="image-20220712204628113" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712204642539.png" alt="image-20220712204642539" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712204712745.png" alt="image-20220712204712745" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712211021844.png" alt="image-20220712211021844" style="zoom:80%;" /></p><p>通过信号kill -9杀死</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712205059554.png" alt="image-20220712205059554" style="zoom:80%;" /></p><hr><h2 id="2-9-waitpid函数"><a href="#2-9-waitpid函数" class="headerlink" title="2.9 waitpid函数"></a>2.9 waitpid函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">    pid_t waitpid(pid_t pid, int *wstatus, int options);</span></span><br><span class="line"><span class="comment">        功能：回收指定进程号的子进程，可以设置是否阻塞。</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pid:</span></span><br><span class="line"><span class="comment">                pid &gt; 0 : 某个子进程的pid</span></span><br><span class="line"><span class="comment">                pid = 0 : 回收当前进程组的所有子进程    </span></span><br><span class="line"><span class="comment">                pid = -1 : 回收所有的子进程，相当于 wait()  （最常用）</span></span><br><span class="line"><span class="comment">                pid &lt; -1 : 某个进程组的组id的绝对值，回收指定进程组中的子进程</span></span><br><span class="line"><span class="comment">            - options：设置阻塞或者非阻塞</span></span><br><span class="line"><span class="comment">                0 : 阻塞</span></span><br><span class="line"><span class="comment">                WNOHANG : 非阻塞</span></span><br><span class="line"><span class="comment">            - 返回值：</span></span><br><span class="line"><span class="comment">                &gt; 0 : 返回子进程的id</span></span><br><span class="line"><span class="comment">                = 0 : options=WNOHANG, 表示还有子进程或者</span></span><br><span class="line"><span class="comment">                = -1 ：错误，或者没有子进程了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个父进程，创建5个子进程（兄弟）</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个子进程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> st;</span><br><span class="line">            <span class="comment">// int ret = waitpid(-1, &amp;st, 0);</span></span><br><span class="line">            <span class="keyword">int</span> ret = waitpid(<span class="number">-1</span>, &amp;st, WNOHANG);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明还有子进程存在</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(WIFEXITED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是正常退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;退出的状态码：%d\n&quot;</span>, WEXITSTATUS(st));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(WIFSIGNALED(st)) &#123;</span><br><span class="line">                    <span class="comment">// 是不是异常终止</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;被哪个信号干掉了：%d\n&quot;</span>, WTERMSIG(st));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;child die, pid = %d\n&quot;</span>, ret);</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">         <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;child, pid = %d\n&quot;</span>,getpid());    </span><br><span class="line">            sleep(<span class="number">1</span>);       </span><br><span class="line">         &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int ret = waitpid(-1, &amp;st, 0);<strong>阻塞情况</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712215332656.png" alt="image-20220712215332656"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712215357568.png" alt="image-20220712215357568"></p><p>父进程非阻塞。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712215625353.png" alt="image-20220712215625353" style="zoom:80%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712214240848.png" alt="image-20220712214240848"></p><p>所有子进程都结束之后，再回过来 ret返回了-1值。</p><hr><h2 id="2-10-进程间通信-IPC"><a href="#2-10-进程间通信-IPC" class="headerlink" title="2.10 进程间通信 IPC"></a>2.10 进程间通信 IPC</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712221317444.png" alt="image-20220712221317444"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712222017940.png" alt="image-20220712222017940"></p><hr><h2 id="2-11-匿名管道（PIPE）"><a href="#2-11-匿名管道（PIPE）" class="headerlink" title="2.11 匿名管道（PIPE）"></a>2.11 匿名管道（PIPE）</h2><p><strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</p><p>这两个描述符都是在一个进程里面，并没有起到进程间通信的作用，怎么样才能使得管道是跨过两个进程的呢？</p><p>我们可以使用 <code>fork</code> 创建子进程，<strong>创建的子进程会复制父进程的文件描述符</strong>，这样就做到了两个进程各有两个「 <code>fd[0]</code> 与 <code>fd[1]</code>」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/6-%E7%AE%A1%E9%81%93-pipe-fork.jpg" alt="img" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220712222710566.png" alt="image-20220712222710566"></p><p>竖线为管道符，前后各为一个指令，ls为获取当前文件列表，wc -l统计个数。写入端就是向管道注入，管道读取端就是从管道输出。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713093759069.png" alt="image-20220713093759069"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713094021279.png" alt="image-20220713094021279"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713094503815.png" alt="image-20220713094503815"></p><p>父进程通过文件描述符5向管道写数据，子进程通过6从管道读数据，通过其管道5写数据，父进程通过6从管道读数据，父子进程共享文件描述符。 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713094835797.png" alt="image-20220713094835797" style="zoom:50%;" /></p><p>管道数据结构为环形队列。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713095024204.png" alt="image-20220713095024204" style="zoom:67%;" /></p><h2 id="2-12-父子进程通过匿名管道通信"><a href="#2-12-父子进程通过匿名管道通信" class="headerlink" title="2.12 父子进程通过匿名管道通信"></a>2.12 父子进程通过匿名管道通信</h2><p>数据被写到管道的写端，（应该是入端）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713095309303.png" alt="image-20220713095309303" style="zoom:50%;" /></p><p>子进程发送数据给父进程，父进程读取到数据 后 输出</p><p><code>在fork之前创建管道</code></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713095708508.png" alt="image-20220713095708508" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713095916244.png" alt="image-20220713095916244" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713095929370.png" alt="image-20220713095929370"></p><p>如果子进程写之前休眠10秒，父进程仍然是阻塞等待。read是阻塞，管道默认是阻塞，当管道没有数据时，read阻塞，管道满了，write阻塞。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713100236399.png" alt="image-20220713100236399" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713100301798.png" alt="image-20220713100301798"></p><p>父进程先读后写，子进程先写后读。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713100626622.png" alt="image-20220713100626622" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713100739557.png" alt="image-20220713100739557" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713100758213.png" alt="image-20220713100758213" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220722105708703.png" alt="image-20220722105708703"></p><p>管道大小为4k</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713101030871.png" alt="image-20220713101030871" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713101045461.png" alt="image-20220713101045461"></p><h2 id="2-13-匿名管道通信案例"><a href="#2-13-匿名管道通信案例" class="headerlink" title="2.13 匿名管道通信案例"></a>2.13 匿名管道通信案例</h2><p>注释掉sleep</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713101531493.png" alt="image-20220713101531493" style="zoom:67%;" /></p><p>输出有错误，乱码 且 收到自己发的数据，不对。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713102307570.png" alt="image-20220713102307570" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713102327586.png" alt="image-20220713102327586" style="zoom:50%;" /></p><p>现在情况变成了</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713102353491.png" alt="image-20220713102353491" style="zoom:50%;" /></p><p>所以在读的时候 父进程要关闭写端，子进程要关闭读端</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713102934517.png" alt="image-20220713102934517" style="zoom: 50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713102959385.png" alt="image-20220713102959385" style="zoom:50%;" /></p><p>案例</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现 ps aux | grep xxx 父子进程间通信</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    子进程： ps aux, 子进程结束后，将数据发送给父进程</span></span><br><span class="line"><span class="comment">    父进程：获取到数据，过滤</span></span><br><span class="line"><span class="comment">    pipe()</span></span><br><span class="line"><span class="comment">    execlp()</span></span><br><span class="line"><span class="comment">    子进程将标准输出 stdout_fileno 重定向到管道的写端。  dup2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个管道</span></span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从管道中读取</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 过滤数据输出</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(<span class="literal">NULL</span>); <span class="comment">// 回收子进程资源</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件描述符的重定向 stdout_fileno -&gt; fd[1]</span></span><br><span class="line">        dup2(fd[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">        <span class="comment">// 执行 ps aux</span></span><br><span class="line">        execlp(<span class="string">&quot;ps&quot;</span>, <span class="string">&quot;ps&quot;</span>, <span class="string">&quot;aux&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 管道就4k</span></span><br><span class="line">        perror(<span class="string">&quot;execlp&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2-14-管道读写特点和管道设置非阻塞"><a href="#2-14-管道读写特点和管道设置非阻塞" class="headerlink" title="2.14 管道读写特点和管道设置非阻塞"></a>2.14 管道读写特点和管道设置非阻塞</h2><p>管道的读写特点：<br>使用管道时，需要注意以下几种特殊的情况（假设都是阻塞I/O操作）<br>1.所有的指向管道写端的文件描述符都关闭了（管道写端引用计数为0），有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，<strong>再次read会返回0</strong>，就像读到文件末尾一样。</p><p>2.如果有指向管道写端的文件描述符没有关闭（管道的写端引用计数大于0），而持有管道写端的进程也没有往管道中写数据，这个时候有进程从管道中读取数据，那么管道中剩余的数据被读取后，再次<strong>read会阻塞</strong>，直到管道中有数据可以读了才读取数据并返回。</p><p>3.如果所有指向管道读端的文件描述符都关闭了（管道的读端引用计数为0），这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE, 通常会导致进程异常终止。</p><p>4.如果有指向管道读端的文件描述符没有关闭（管道的读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道中写数据，那么在管道被写满的时候再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。</p><p>总结：<br>    读管道：<br>        管道中有数据，read返回实际读到的字节数。<br>        管道中无数据：<br>            写端被全部关闭，read返回0（相当于读到文件的末尾）<br>            写端没有完全关闭，read阻塞等待</p><p>写管道：<br>    管道读端全部被关闭，进程异常终止（进程收到SIGPIPE信号）<br>    管道读端没有全部关闭：<br>        管道已满，write阻塞<br>        管道没有满，write将数据写入，并返回实际写入的字节数</p><p>父进程read阻塞</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713110555043.png" alt="image-20220713110555043" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713110514941.png" alt="image-20220713110514941" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713110755428.png" alt="image-20220713110755428" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置管道非阻塞</span></span><br><span class="line"><span class="comment">    int flags = fcntl(fd[0], F_GETFL);  // 获取原来的flag</span></span><br><span class="line"><span class="comment">    flags |= O_NONBLOCK;            // 修改flag的值</span></span><br><span class="line"><span class="comment">    fcntl(fd[0], F_SETFL, flags);   // 设置新的flag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在fork之前创建管道</span></span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从管道的读取端读取数据</span></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flags = fcntl(pipefd[<span class="number">0</span>], F_GETFL);  <span class="comment">// 获取原来的flag</span></span><br><span class="line">        flags |= O_NONBLOCK;            <span class="comment">// 修改flag的值</span></span><br><span class="line">        fcntl(pipefd[<span class="number">0</span>], F_SETFL, flags);   <span class="comment">// 设置新的flag</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = read(pipefd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;len : %d\n&quot;</span>, len);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s, pid : %d\n&quot;</span>, buf, getpid());</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="comment">// 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 向管道中写入数据</span></span><br><span class="line">            <span class="keyword">char</span> * str = <span class="string">&quot;hello,i am child&quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709110426450.png" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713111545212.png" alt="image-20220713111545212" style="zoom:50%;" /></p><p>没有数据就-1， 没有阻塞。</p><hr><h2 id="2-15有名管道（FIFO）"><a href="#2-15有名管道（FIFO）" class="headerlink" title="2.15有名管道（FIFO）"></a>2.15有名管道（FIFO）</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713112030962.png" alt="image-20220713112030962"></p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713112131822.png" alt="image-20220713112131822"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713112720107.png" alt="image-20220713112720107"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713112734113.png" alt="image-20220713112734113"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713112936238.png" alt="image-20220713112936238"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建fifo文件</span></span><br><span class="line"><span class="comment">    1.通过命令： mkfifo 名字</span></span><br><span class="line"><span class="comment">    2.通过函数：int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int mkfifo(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 管道名称的路径</span></span><br><span class="line"><span class="comment">            - mode: 文件的权限 和 open 的 mode 是一样的</span></span><br><span class="line"><span class="comment">                    是一个八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1，并设置错误号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   写数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向管道中写数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    有名管道的注意事项：</span></span><br><span class="line"><span class="comment">        1.一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为只写打开管道</span></span><br><span class="line"><span class="comment">        2.一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为只读打开管道</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    读管道：</span></span><br><span class="line"><span class="comment">        管道中有数据，read返回实际读到的字节数</span></span><br><span class="line"><span class="comment">        管道中无数据：</span></span><br><span class="line"><span class="comment">            管道写端被全部关闭，read返回0，（相当于读到文件末尾）</span></span><br><span class="line"><span class="comment">            写端没有全部被关闭，read阻塞等待</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    写管道：</span></span><br><span class="line"><span class="comment">        管道读端被全部关闭，进程异常终止（收到一个SIGPIPE信号）</span></span><br><span class="line"><span class="comment">        管道读端没有全部关闭：</span></span><br><span class="line"><span class="comment">            管道已经满了，write会阻塞</span></span><br><span class="line"><span class="comment">            管道没有满，write将数据写入，并返回实际写入的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.判断文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;test&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建管道\n&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建管道文件</span></span><br><span class="line">        ret = mkfifo(<span class="string">&quot;test&quot;</span>, <span class="number">0664</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.以只写的方式打开管道</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello, %d\n&quot;</span>, i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write data : %s\n&quot;</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读数据</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从管道中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.打开管道文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;test&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;写端断开连接了...\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;recv buf : %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写端停了，读端显示“写端断开连接”，程序结束。</p><p>运行读端，读端在open管道文件时阻塞了。运行写端，读端就运行了。</p><p>把读端停了，写端程序立马结束。</p><hr><h2 id="2-16-有名管道实现简单聊天功能"><a href="#2-16-有名管道实现简单聊天功能" class="headerlink" title="2.16 有名管道实现简单聊天功能"></a>2.16 有名管道实现简单聊天功能</h2><p>  <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713115229732.png" alt="image-20220713115229732"></p><p>chatA</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.判断有名管道文件是否存在</span></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;fifo1&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo1&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = access(<span class="string">&quot;fifo2&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 文件不存在</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道不存在，创建对应的有名管道\n&quot;</span>);</span><br><span class="line">        ret = mkfifo(<span class="string">&quot;fifo2&quot;</span>, <span class="number">0664</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.以只写的方式打开管道fifo1</span></span><br><span class="line">    <span class="keyword">int</span> fdw = open(<span class="string">&quot;fifo1&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo1成功，等待写入...\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 3.以只读的方式打开管道fifo2</span></span><br><span class="line">    <span class="keyword">int</span> fdr = open(<span class="string">&quot;fifo2&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开管道fifo2成功，等待读取...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.循环的写读数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        <span class="comment">// 获取标准输入的数据</span></span><br><span class="line">        fgets(buf, <span class="number">128</span>, <span class="built_in">stdin</span>);</span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ret = write(fdw, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.读管道数据</span></span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">128</span>);</span><br><span class="line">        ret = read(fdr, buf, <span class="number">128</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;buf: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭文件描述符</span></span><br><span class="line">    close(fdr);</span><br><span class="line">    close(fdw);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时只能收一句 发一句，不能把读和写都放入同一个进程中，必定有一个阻塞。所以要把读写分别放到不同进程里。A父进程写，子进程读。B父进程读，子进程写。</p><hr><h2 id="2-17内存映射"><a href="#2-17内存映射" class="headerlink" title="2.17内存映射"></a>2.17内存映射</h2><p>类似于动态库、共享库的位置。</p><p>可以指定映射 从文件的偏移量开始的len大小的文件。</p><p>内存映射之后，当修改了内存数据，也会同步到文件当中。 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713141211276.png" alt="image-20220713141211276"></p><p>左右为进程中的内存数据。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713143305010.png" alt="image-20220713143305010" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713141859759.png" alt="image-20220713141859759"></p><p>映射文件到内存当中。</p><p>mmap()在调用进程的虚拟地址空间里，创建了一个映射</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713142227869.png" alt="image-20220713142227869"></p><ul><li>flags:<ul><li>map_shared 映射区的数据会自动和磁盘文件进行同步，进程间通信必须要设置这个选项。</li><li>map_private 不同步，内存映射区的数据修改了，对原来的文件不会修改，会重新出一个新的文件（copy on write）</li></ul></li></ul><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713142715528.png" alt="image-20220713142715528"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713142742847.png" alt="image-20220713142742847"></p><p>案例需求</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713142855197.png" alt="image-20220713142855197"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713150351372.png" alt="image-20220713150351372"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713150656773.png" alt="image-20220713150656773"></p><p>父进程读数据，子进程写数据。以文件为桥梁。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713150921776.png" alt="image-20220713150921776"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713150940667.png" alt="image-20220713150940667"></p><p>1、如果对mmap的返回值ptr做++操作，可以，但是munmap错误。</p><p>2、如果open时O_RDONLY，mmap时prot参数指定PROT_READ | PROT_WRITE 会产生错误，返回MAP_FAILED；两者权限应该一致，mmap权限小于等于open才对。</p><p>3、如果文件偏移量为1000，offset必须是4k的整数倍，所以会报错返回map_failed。</p><p>4、mmap什么情况下回调用失败？第二个参数length = 0， 第三个参数prot只指定了写权限。或者和open不一致会报错。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713151649555.png" alt="image-20220713151649555"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713151752961.png" alt="image-20220713151752961"></p><h3 id="使用内存映射实现文件拷贝的功能"><a href="#使用内存映射实现文件拷贝的功能" class="headerlink" title="使用内存映射实现文件拷贝的功能"></a>使用内存映射实现文件拷贝的功能</h3><p>把english.txt复制为cpy.txt</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713151957260.png" alt="image-20220713151957260"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713152315628.png" alt="image-20220713152315628"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713152434989.png" alt="image-20220713152434989"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713152512439.png" alt="image-20220713152512439"></p><p>之前为文件映射，下面为<strong>匿名映射 MAP_ANONYMOUS</strong> 。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713152941820.png" alt="image-20220713152941820"></p><p>内存映射为非阻塞的。 子进程读取，父进程写。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713153100366.png" alt="image-20220713153100366"></p><hr><h2 id="2-19-信号概述"><a href="#2-19-信号概述" class="headerlink" title="2.19 信号概述"></a>2.19 信号概述</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713153253383.png" alt="image-20220713153253383"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713153613482.png" alt="image-20220713153613482"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713153821911.png" alt="image-20220713153821911"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713153901814.png" alt="image-20220713153901814"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713153946392.png" alt="image-20220713153946392"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154013335.png" alt="image-20220713154013335"></p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154048465.png" alt="image-20220713154048465"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154055618.png" alt="image-20220713154055618"></p><p>针对core文件</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154842933.png" alt="image-20220713154842933"></p><p>用了buf野内存。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154912388.png" alt="image-20220713154912388"></p><p>要设置core文件</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154625742.png" alt="image-20220713154625742"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713155039196.png" alt="image-20220713155039196"></p><p>gdb a.out来调试，产生信号11。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713155148421.png" alt="image-20220713155148421"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713154413309.png" alt="image-20220713154413309"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713160018537.png" alt="image-20220713160018537"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713160111686.png" alt="image-20220713160111686"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713160135830.png" alt="image-20220713160135830"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713160419641.png" alt="image-20220713160419641"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713160442910.png" alt="image-20220713160442910"></p><hr><h2 id="2-21-alarm函数"><a href="#2-21-alarm函数" class="headerlink" title="2.21 alarm函数"></a>2.21 alarm函数</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713160937737.png" alt="image-20220713160937737"></p><p>alarm（100）是不阻塞的。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713161131386.png" alt="image-20220713161131386"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713161145062.png" alt="image-20220713161145062"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713162237088.png" alt="image-20220713162237088"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713162352329.png" alt="image-20220713162352329"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713162644561.png" alt="image-20220713162644561"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713164815325.png" alt="image-20220713164815325"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713171214771.png" alt="image-20220713171214771"></p><p>过3s吼，每隔2秒定时一次。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713165638806.png" alt="image-20220713165638806"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713170125850.png" alt="image-20220713170125850"></p><p>立马调用“定时器开始了， 因为setitimer是非阻塞的。应该是每隔两秒钟发送一个信号，把进程杀死了，因为没有信号捕捉，所以没有定时的效果。</p><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713172022840.png" alt="image-20220713172022840"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713172712393.png" alt="image-20220713172712393"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713182100095.png" alt="image-20220713182100095"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713183123518.png" alt="image-20220713183123518"></p><hr><h2 id="2-24信号集"><a href="#2-24信号集" class="headerlink" title="2.24信号集"></a>2.24信号集</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713184355053.png" alt="image-20220713184355053"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713184959698.png" alt="image-20220713184959698"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713185257423.png" alt="image-20220713185257423"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713185450518.png" alt="image-20220713185450518"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713185441191.png" alt="image-20220713185441191"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713185727380.png" alt="image-20220713185727380"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713185630069.png" alt="image-20220713185630069"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713185706086.png" alt="image-20220713185706086"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713190200384.png" alt="image-20220713190200384"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713190225161.png" alt="image-20220713190225161"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713190258103.png" alt="image-20220713190258103"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220713190611343.png" alt="image-20220713190611343"></p><hr><p>之前都是对用户自定义的信号集进行操作。如果想对内核的信号集进行操作。只能sigprocmask，对系统中的阻塞信号集进行操作，想获取阻塞信号集或者设置阻塞信号集。通过sigprocmask把自定义的系统信号集设置到内核中，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714005733605.png" alt="image-20220714005733605"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714005809132.png" alt="image-20220714005809132"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714005919493.png" alt="image-20220714005919493"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714012506081.png" alt="image-20220714012506081"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714010119582.png" alt="image-20220714010119582"></p><p>按了ctrl+c和ctrl+\ </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714010413244.png" alt="image-20220714010413244"></p><p>然后只能新建会话kill -9杀死。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714010508133.png" alt="image-20220714010508133"></p><p>或者可以输入&amp; 以后台方式运行，还可响应其他指令。 此时再ctrl+c，或\</p><p>输入fg转为前台。 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714010845622.png" alt="image-20220714010845622"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714010911746.png" alt="image-20220714010911746"></p><hr><h2 id="2-26-信号捕捉函数sigaction"><a href="#2-26-信号捕捉函数sigaction" class="headerlink" title="2.26 信号捕捉函数sigaction"></a>2.26 信号捕捉函数sigaction</h2><p>signum 可以是任何有效信号，除了SIGKILL和SIGSTOP（不能被捕捉）。</p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714101044645.png" alt="image-20220714101044645"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714101256982.png" alt="image-20220714101256982"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714102818217.png" alt="image-20220714102818217"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714103146248.png" alt="image-20220714103146248"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714103308334.png" alt="image-20220714103308334"></p><hr><h2 id="2-27-SIGCHLD信号"><a href="#2-27-SIGCHLD信号" class="headerlink" title="2.27 SIGCHLD信号"></a>2.27 SIGCHLD信号</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714104140287.png" alt="image-20220714104140287"></p><p>使用SIGCHLD信号解决僵尸进程问题。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714105452323.png" alt="image-20220714105452323"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714105421067.png" alt="image-20220714105421067"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714105145067.png" alt="image-20220714105145067"></p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714105512496.png" alt="image-20220714105512496"></p><p>同时有3个子进程死亡，在未决信号集处理信号的回调函数时，无法响应其他信号。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714105747442.png" alt="image-20220714105747442"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714105956236.png" alt="image-20220714105956236"></p><p>会出现段错误。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714110408486.png" alt="image-20220714110408486" style="zoom: 50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714110451684.png" alt="image-20220714110451684" style="zoom:67%;" /></p><hr><h2 id="2-28-共享内存"><a href="#2-28-共享内存" class="headerlink" title="2.28 共享内存"></a>2.28 共享内存</h2><p>比内存映射效率高，内存映射需要关联一个文件，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714112130286.png" alt="image-20220714112130286"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714113340274.png" alt="image-20220714113340274"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714113656491.png" alt="image-20220714113656491"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">共享内存相关的函数</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    - 功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。</span><br><span class="line">        新创建的内存段中的数据都会被初始化为<span class="number">0</span></span><br><span class="line">    - 参数：</span><br><span class="line">        - key : <span class="keyword">key_t</span>类型是一个整形，通过这个找到或者创建一个共享内存。</span><br><span class="line">                一般使用<span class="number">16</span>进制表示，非<span class="number">0</span>值</span><br><span class="line">        - size: 共享内存的大小</span><br><span class="line">        - shmflg: 属性</span><br><span class="line">            - 访问权限</span><br><span class="line">            - 附加属性：创建/判断共享内存是不是存在</span><br><span class="line">                - 创建：IPC_CREAT</span><br><span class="line">                - 判断共享内存是否存在： IPC_EXCL , 需要和IPC_CREAT一起使用</span><br><span class="line">                    IPC_CREAT | IPC_EXCL | <span class="number">0664</span></span><br><span class="line">        - 返回值：</span><br><span class="line">            失败：<span class="number">-1</span> 并设置错误号</span><br><span class="line">            成功：&gt;<span class="number">0</span> 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    - 功能：和当前的进程进行关联</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid : 共享内存的标识（ID）,由shmget返回值获取</span><br><span class="line">        - shmaddr: 申请的共享内存的起始地址，指定<span class="literal">NULL</span>，内核指定</span><br><span class="line">        - shmflg : 对共享内存的操作</span><br><span class="line">            - 读 ： SHM_RDONLY, 必须要有读权限</span><br><span class="line">            - 读写： <span class="number">0</span></span><br><span class="line">    - 返回值：</span><br><span class="line">        成功：返回共享内存的首（起始）地址。  失败(<span class="keyword">void</span> *) <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br><span class="line">    - 功能：解除当前进程和共享内存的关联</span><br><span class="line">    - 参数：</span><br><span class="line">        shmaddr：共享内存的首地址</span><br><span class="line">    - 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">    - 功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。</span><br><span class="line">    - 参数：</span><br><span class="line">        - shmid: 共享内存的ID</span><br><span class="line">        - cmd : 要做的操作</span><br><span class="line">            - IPC_STAT : 获取共享内存的当前的状态</span><br><span class="line">            - IPC_SET : 设置共享内存的状态</span><br><span class="line">            - IPC_RMID: 标记共享内存被销毁</span><br><span class="line">        - buf：需要设置或者获取的共享内存的属性信息</span><br><span class="line">            - IPC_STAT : buf存储数据</span><br><span class="line">            - IPC_SET : buf中需要初始化数据，设置到内核中</span><br><span class="line">            - IPC_RMID : 没有用，<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">key_t</span> <span class="title">ftok</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id)</span></span>;</span><br><span class="line">    - 功能：根据指定的路径名，和<span class="keyword">int</span>值，生成一个共享内存的key</span><br><span class="line">    - 参数：</span><br><span class="line">        - pathname:指定一个存在的路径</span><br><span class="line">            /home/nowcoder/Linux/a.txt</span><br><span class="line">            / </span><br><span class="line">        - proj_id: <span class="keyword">int</span>类型的值，但是这系统调用只会使用其中的<span class="number">1</span>个字节</span><br><span class="line">                   范围 ： <span class="number">0</span><span class="number">-255</span>  一般指定一个字符 <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>shmctl ：创建共享内存的进程被销毁了，对共享内存是没有任何影响的。</p><p>在write_shm.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在read_shm.c中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714140417147.png" alt="image-20220714140417147"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714140428610.png" alt="image-20220714140428610"></p><p>之前的实验是通过随便取的100内存，应该用ftok：根据指定的路径名，和int值，生成一个共享内存的key</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714140904302.png" alt="image-20220714140904302"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题1：操作系统如何知道一块共享内存被多少个进程关联？</span><br><span class="line">    - 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch</span><br><span class="line">    - shm_nattach 记录了关联的进程个数</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714141051334.png" alt="image-20220714141051334"></p><p>键100转为0x64,如果有一个读一个写，那么状态数就为2了</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714141129189.png" alt="image-20220714141129189"></p><p>如果将其中一个读进程结束了，键变成0，共享内存被标记删除。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714141403061.png" alt="image-20220714141403061"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714141742551.png" alt="image-20220714141742551"></p><p>ipcrm -m 4只是标记了删除，连接数没有删，当其他进程ctrl + c，状态数才变0.</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">问题<span class="number">2</span>：可不可以对共享内存进行多次删除 shmctl</span><br><span class="line">    - 可以的</span><br><span class="line">    - 因为shmctl 标记删除共享内存，不是直接删除</span><br><span class="line">    - 什么时候真正删除呢?</span><br><span class="line">        当和共享内存关联的进程数为<span class="number">0</span>的时候，就真正被删除</span><br><span class="line">    - 当共享内存的key为<span class="number">0</span>的时候，表示共享内存被标记删除了</span><br><span class="line">        如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">共享内存和内存映射的区别</span><br><span class="line"><span class="number">1.</span>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</span><br><span class="line"><span class="number">2.</span>共享内存效果更高</span><br><span class="line"><span class="number">3.</span>内存</span><br><span class="line">    所有的进程操作的是同一块共享内存。</span><br><span class="line">    内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</span><br><span class="line"><span class="number">4.</span>数据安全</span><br><span class="line">    - 进程突然退出</span><br><span class="line">        共享内存还存在</span><br><span class="line">        内存映射区消失</span><br><span class="line">    - 运行进程的电脑死机，宕机了</span><br><span class="line">        数据存在在共享内存中，没有了</span><br><span class="line">        内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</span><br><span class="line"><span class="number">5.</span>生命周期</span><br><span class="line">    - 内存映射区：进程退出，内存映射区销毁</span><br><span class="line">    - 共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为<span class="number">0</span>），或者关机</span><br><span class="line">        如果一个进程退出，会自动和共享内存进行取消关联。</span><br></pre></td></tr></table></figure><hr><h2 id="2-30-守护进程"><a href="#2-30-守护进程" class="headerlink" title="2.30 守护进程"></a>2.30 守护进程</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714145944446.png" alt="image-20220714145944446"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714150116296.png" alt="image-20220714150116296"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714150131600.png" alt="image-20220714150131600"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714150140913.png" alt="image-20220714150140913"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714150309918.png" alt="image-20220714150309918"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714150600775.png" alt="image-20220714150600775"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714150850261.png" alt="image-20220714150850261"></p><p>1、在终端上 输入指令 find查找2，重定向到/dev/null 设备上，管道符会创建子进程，&amp;在后台运行。是后台进程。</p><p>2、在shell中，默认没有会话 没有组，pid为400，创建ppid，然后创建出一个组 ，创建出的会话pid也是400，默认是后台程序。</p><p>3、运行find，创建新的进程组，首进程是658，父进程是bash 的400，组PGID是658，会话进程是400。 </p><p>4、sort是前台运行，是前台运行组，而bash和find是后台进程组。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714151125316.png" alt="image-20220714151125316" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714151211201.png" alt="image-20220714151211201"></p><p>后台服务进程，生命周期长，不拥有控制终端。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714152110355.png" alt="image-20220714152110355"></p><p>1、为什么 父进程退出</p><p>命令行启动进程，如果不退出父进程，父进程死了之后，shell会提供shell提示符。</p><p>使用fork可以确保子进程不会成为进程组的首进程。</p><p>2、子进程开启新会话，组id和进程id一样，又成为会话的id。要脱离控制终端。 </p><h3 id="写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。"><a href="#写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。" class="headerlink" title="写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。"></a>写一个守护进程，每隔2s获取一下系统时间，将这个时间写入到磁盘文件中。</h3><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714153957356.png" alt="image-20220714153957356" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714154206911.png" alt="image-20220714154206911" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714155024113.png" alt="image-20220714155024113" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220714154723472.png" alt="image-20220714154723472"></p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网项目记录-第一章linux系统编程入门</title>
      <link href="2022/07/07/blog51-nowcoderProject1/"/>
      <url>2022/07/07/blog51-nowcoderProject1/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="1-2GCC"><a href="#1-2GCC" class="headerlink" title="1.2GCC"></a>1.2GCC</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707104035969.png" alt="image-20220707104035969"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707103826857.png" alt="image-20220707103826857"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707234008969.png" alt="image-20220707234008969"></p><p>gcc test.c -E -o test.i 将源代码 经过预处理器 转换为预处理后源代码</p><p>gcc test.i -S -o test.s 将预处理后源代码 经过编译器 编译成汇编语言</p><p>gcc test.s -s -o test.o 将汇编语言 经过汇编器 汇编成目标代码（二进制文件）</p><p>./test.o 可以执行</p><p>gcc test.c -S 直接生成test.s</p><p>gcc test.c 直接生成a.out</p><p>gcc test.c -o test 生成可执行文件test</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707104106542.png" alt="image-20220707104106542"></p><hr><p>1.4 静态库的制作和使用</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707162622123.png" alt="image-20220707162622123"></p><p>lesson04下面有calc和library</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707211708002.png" alt="image-20220707211708002"></p><p>calc目录下</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707163507506.png" alt="image-20220707163507506"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707163558574.png" alt="image-20220707163558574"></p><p>library目录下，文件基本同calc中文件</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707212819186.png" alt="image-20220707212819186"></p><p>将静态库文件拷贝到library/lib下</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707213127527.png" alt="image-20220707213127527"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707213245664.png" alt="image-20220707213245664"></p><p> 在main中使用库文件 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707213410642.png" alt="image-20220707213410642"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707213541008.png" alt="image-20220707213541008"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707164322392.png" alt="image-20220707164322392"></p><p>或者在library/src文件夹下</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707214201467.png" alt="image-20220707214201467"></p><hr><h2 id="1-6-动态库的制作和使用"><a href="#1-6-动态库的制作和使用" class="headerlink" title="1.6 动态库的制作和使用"></a>1.6 动态库的制作和使用</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707164605558.png" alt="image-20220707164605558"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707164918390.png" alt="image-20220707164918390"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707223732478.png" alt="image-20220707223732478"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707223928765.png" alt="image-20220707223928765"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707165332730.png" alt="image-20220707165332730"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707165444349.png" alt="image-20220707165444349"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707224945116.png" alt="image-20220707224945116"></p><p>有问题， 需要动态库加载到内存当中</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707230434407.png" alt="image-20220707230434407"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707230643122.png" alt="image-20220707230643122"></p><p>输入env输出环境变量</p><p>解决方法1</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707231740047.png" alt="image-20220707231740047"></p><p>$ 原有变量 ：增加新变量</p><p>此时仅在会话级别可行，新开会话不可行。</p><p>解决方法2，用户级别配置，根目录~下</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707232016476.png" alt="image-20220707232016476"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707232102006.png" alt="image-20220707232102006"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707232156867.png" alt="image-20220707232156867"></p><p>使其生效</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707232436634.png" alt="image-20220707232436634"></p><p>最后一样</p><p>方法4：修改/etc/ld.so.cache文件列表 里面是二进制数据，需要间接修改</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707233158730.png" alt="image-20220707233158730"></p><p>sudo vim /etc/ld.so.conf</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707233111497.png" alt="image-20220707233111497"></p><hr><p>动态库和静态库的优缺点</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707234615271.png" alt="image-20220707234615271"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220707234752872.png" alt="image-20220707234752872"></p><hr><h2 id="1-10-makefile"><a href="#1-10-makefile" class="headerlink" title="1.10 makefile"></a>1.10 makefile</h2><p>在项目src文件夹下make指令</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708095030870.png" alt="image-20220708095030870"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708094453324.png" alt="image-20220708094453324"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708094309244.png" alt="image-20220708094309244"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708094938348.png" alt="image-20220708094938348"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708095911920.png" alt="image-20220708095911920"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708100317745.png" alt="image-20220708100317745"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708100203735.png" alt="image-20220708100203735"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708101408184.png" alt="image-20220708101408184"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708100416196.png" alt="image-20220708100416196"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708100606699.png" alt="image-20220708100606699"></p><p>删除依赖 make clean</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708100930274.png" alt="image-20220708100930274"></p><hr><h2 id="1-13-GDB调试"><a href="#1-13-GDB调试" class="headerlink" title="1.13 GDB调试"></a>1.13 GDB调试</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220816162006469.png" alt="image-20220816162006469"></p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708104655779.png" alt="image-20220708104655779"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708103904874.png" alt="image-20220708103904874"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708104440816.png" alt="image-20220708104440816"></p><p>没加调试信息就小点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708105455704.png" alt="image-20220708105455704"></p><p>输入list，显示10行</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708114141209.png" alt="image-20220708114141209"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708114550493.png" alt="image-20220708114550493"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708114637397.png" alt="image-20220708114637397"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708115114472.png" alt="image-20220708115114472"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708134856843.png" alt="image-20220708134856843"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708135029955.png" alt="image-20220708135029955"></p><hr><h2 id="1-17-文件IO"><a href="#1-17-文件IO" class="headerlink" title="1.17 文件IO"></a>1.17 文件IO</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708142349617.png" alt="image-20220708142349617"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708160455300.png" alt="image-20220708160455300"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708160948453.png" alt="image-20220708160948453"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708162755823.png" alt="image-20220708162755823"></p><h2 id="1-20-open-打开文件"><a href="#1-20-open-打开文件" class="headerlink" title="1.20 open 打开文件"></a>1.20 open 打开文件</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709002625234.png" alt="image-20220709002625234"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708213355579.png" alt="image-20220708213355579" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708213611066.png" alt="image-20220708213611066"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708213910568.png" alt="image-20220708213910568" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708213825026.png" alt="image-20220708213825026" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708214013338.png" alt="image-20220708214013338"></p><p>三参数的open函数</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708215043338.png" alt="image-20220708215043338"></p><p>rwx read/write/执行权限</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708215002576.png" alt="image-20220708215002576"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708215246114.png" alt="image-20220708215246114" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708215329505.png" alt="image-20220708215329505"></p><hr><h2 id="1-22-read-write函数"><a href="#1-22-read-write函数" class="headerlink" title="1.22 read write函数"></a>1.22 read write函数</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708220033643.png" alt="image-20220708220033643"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220708220158280.png" alt="image-20220708220158280"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709002426032.png" alt="image-20220709002426032" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709002259381.png" alt="image-20220709002259381" style="zoom:50%;" /></p><hr><h2 id="1-23-lseek函数"><a href="#1-23-lseek函数" class="headerlink" title="1.23 lseek函数"></a>1.23 lseek函数</h2><p>用来重新定位文件读写的位移</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    标准C库的函数</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int fseek(FILE *stream, long offset, int whence);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Linux系统函数</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    off_t lseek(int fd, off_t offset, int whence);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - fd：文件描述符，通过open得到的，通过这个fd操作某个文件</span></span><br><span class="line"><span class="comment">            - offset：偏移量</span></span><br><span class="line"><span class="comment">            - whence:</span></span><br><span class="line"><span class="comment">                SEEK_SET</span></span><br><span class="line"><span class="comment">                    设置文件指针的偏移量</span></span><br><span class="line"><span class="comment">                SEEK_CUR</span></span><br><span class="line"><span class="comment">                    设置偏移量：当前位置 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">                SEEK_END</span></span><br><span class="line"><span class="comment">                    设置偏移量：文件大小 + 第二个参数offset的值</span></span><br><span class="line"><span class="comment">        返回值：返回文件指针的位置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    作用：</span></span><br><span class="line"><span class="comment">        1.移动文件指针到文件头</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_SET);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2.获取当前文件指针的位置</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_CUR);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        3.获取文件长度</span></span><br><span class="line"><span class="comment">        lseek(fd, 0, SEEK_END);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        4.拓展文件的长度，当前文件10b, 110b, 增加了100个字节</span></span><br><span class="line"><span class="comment">        lseek(fd, 100, SEEK_END)</span></span><br><span class="line"><span class="comment">        注意：需要写一次数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;hello.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展文件的长度</span></span><br><span class="line">    <span class="keyword">int</span> ret = lseek(fd, <span class="number">100</span>, SEEK_END);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;lseek&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个空数据</span></span><br><span class="line">    write(fd, <span class="string">&quot; &quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="1-24-stat-lstat"><a href="#1-24-stat-lstat" class="headerlink" title="1.24 stat lstat"></a>1.24 stat lstat</h2><p>获取一个文件相关的一些信息</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709085617664.png" alt="image-20220709085617664"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    int stat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        作用：获取一个文件相关的一些信息</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int lstat(const char *pathname, struct stat *statbuf);</span></span><br><span class="line"><span class="comment">        参数:</span></span><br><span class="line"><span class="comment">            - pathname：操作的文件的路径</span></span><br><span class="line"><span class="comment">            - statbuf：结构体变量，传出参数，用于保存获取到的文件的信息</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功：返回0</span></span><br><span class="line"><span class="comment">            失败：返回-1 设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = stat(<span class="string">&quot;a.txt&quot;</span>, &amp;statbuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size: %ld\n&quot;</span>, statbuf.st_size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709085805573.png" alt="image-20220709085805573"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709085854663.png" alt="image-20220709085854663"></p><p><strong>lstat 获取软连接信息，而stat会获取指向文件的信息</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709090638561.png" alt="image-20220709090638561"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709090650423.png" alt="image-20220709090650423"></p><hr><h2 id="1-25-模拟实现ls-l-命令"><a href="#1-25-模拟实现ls-l-命令" class="headerlink" title="1.25 模拟实现ls -l 命令"></a>1.25 模拟实现ls -l 命令</h2><p>想实现下图功能</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709090928800.png" alt="image-20220709090928800"></p><p>获取文件类型和文件权限</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709092833342.png" alt="image-20220709092833342"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟实现 ls -l 指令</span></span><br><span class="line"><span class="comment">// -rw-rw-r-- 1 nowcoder nowcoder 12 12月  3 15:48 a.txt</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断输入的参数是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过stat函数获取用户传入的文件的信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = stat(argv[<span class="number">1</span>], &amp;st);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件类型和文件权限</span></span><br><span class="line">    <span class="keyword">char</span> perms[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">// 用于保存文件类型和文件权限的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(st.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">        <span class="keyword">case</span> S_IFLNK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFDIR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFREG:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> S_IFCHR:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> S_IFIFO:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            perms[<span class="number">0</span>] = <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件的访问权限</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    perms[<span class="number">1</span>] = (st.st_mode &amp; S_IRUSR) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">2</span>] = (st.st_mode &amp; S_IWUSR) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">3</span>] = (st.st_mode &amp; S_IXUSR) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    perms[<span class="number">4</span>] = (st.st_mode &amp; S_IRGRP) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">5</span>] = (st.st_mode &amp; S_IWGRP) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">6</span>] = (st.st_mode &amp; S_IXGRP) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他人</span></span><br><span class="line">    perms[<span class="number">7</span>] = (st.st_mode &amp; S_IROTH) ? <span class="string">&#x27;r&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">8</span>] = (st.st_mode &amp; S_IWOTH) ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    perms[<span class="number">9</span>] = (st.st_mode &amp; S_IXOTH) ? <span class="string">&#x27;x&#x27;</span> : <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬连接数</span></span><br><span class="line">    <span class="keyword">int</span> linkNum = st.st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所有者</span></span><br><span class="line">    <span class="keyword">char</span> * fileUser = getpwuid(st.st_uid)-&gt;pw_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件所在组</span></span><br><span class="line">    <span class="keyword">char</span> * fileGrp = getgrgid(st.st_gid)-&gt;gr_name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件大小</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> fileSize = st.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取修改的时间</span></span><br><span class="line">    <span class="keyword">char</span> * time = ctime(&amp;st.st_mtime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> mtime[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">strncpy</span>(mtime, time, <span class="built_in">strlen</span>(time) - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s %d %s %s %ld %s %s&quot;</span>, perms, linkNum, fileUser, fileGrp, fileSize, mtime, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709093234697.png" alt="image-20220709093234697"></p><hr><h2 id="1-26-文件属性操作函数access-chmod-chown-truncate"><a href="#1-26-文件属性操作函数access-chmod-chown-truncate" class="headerlink" title="1.26 文件属性操作函数access/chmod/chown/truncate"></a>1.26 文件属性操作函数access/chmod/chown/truncate</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709093328241.png" alt="image-20220709093328241"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int access(const char *pathname, int mode);</span></span><br><span class="line"><span class="comment">        作用：判断某个文件是否有某个权限，或者判断文件是否存在</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 判断的文件路径</span></span><br><span class="line"><span class="comment">            - mode:</span></span><br><span class="line"><span class="comment">                R_OK: 判断是否有读权限</span></span><br><span class="line"><span class="comment">                W_OK: 判断是否有写权限</span></span><br><span class="line"><span class="comment">                X_OK: 判断是否有执行权限</span></span><br><span class="line"><span class="comment">                F_OK: 判断文件是否存在</span></span><br><span class="line"><span class="comment">        返回值：成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = access(<span class="string">&quot;a.txt&quot;</span>, F_OK);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;access&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件存在！！!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    int chmod(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        修改文件的权限</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - pathname: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - mode:需要修改的权限值，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = chmod(<span class="string">&quot;a.txt&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chmod&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vim /etc/passwd</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709095934609.png" alt="image-20220709095934609"></p><p>vim /etc/group</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709100008469.png" alt="image-20220709100008469" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709100042295.png" alt="image-20220709100042295" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int truncate(const char *path, off_t length);</span></span><br><span class="line"><span class="comment">        作用：缩减或者扩展文件的尺寸至指定的大小</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - path: 需要修改的文件的路径</span></span><br><span class="line"><span class="comment">            - length: 需要最终文件变成的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = truncate(<span class="string">&quot;b.txt&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;truncate&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="1-27-目录操作函数-mkdir等"><a href="#1-27-目录操作函数-mkdir等" class="headerlink" title="1.27 目录操作函数 mkdir等"></a>1.27 目录操作函数 mkdir等</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709100717934.png" alt="image-20220709100717934"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;sys/stat.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    int mkdir(const char *pathname, mode_t mode);</span></span><br><span class="line"><span class="comment">        作用：创建一个目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            pathname: 创建的目录的路径</span></span><br><span class="line"><span class="comment">            mode: 权限，八进制的数</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            成功返回0， 失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = mkdir(<span class="string">&quot;aaa&quot;</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mkdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int chdir(const char *path);</span></span><br><span class="line"><span class="comment">        作用：修改进程的工作目录</span></span><br><span class="line"><span class="comment">            比如在/home/nowcoder 启动了一个可执行程序a.out, 进程的工作目录 /home/nowcoder</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            path : 需要修改的工作目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    char *getcwd(char *buf, size_t size);</span></span><br><span class="line"><span class="comment">        作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - buf : 存储的路径，指向的是一个数组（传出参数）</span></span><br><span class="line"><span class="comment">            - size: 数组的大小</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            返回的指向的一块内存，这个数据就是第一个参数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改工作目录</span></span><br><span class="line">    <span class="keyword">int</span> ret = chdir(<span class="string">&quot;/home/nowcoder/Linux/lesson13&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;chdir&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的文件</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;chdir.txt&quot;</span>, O_CREAT | O_RDWR, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前的工作目录</span></span><br><span class="line">    <span class="keyword">char</span> buf1[<span class="number">128</span>];</span><br><span class="line">    getcwd(buf1, <span class="keyword">sizeof</span>(buf1));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;当前的工作目录是：%s\n&quot;</span>, buf1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">    int rename(const char *oldpath, const char *newpath);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = rename(<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;rename&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709101242804.png" alt="image-20220709101242804" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709101657349.png" alt="image-20220709101657349" style="zoom:50%;" /></p><hr><h2 id="1-28-目录遍历函数opendir-readdir-closedir"><a href="#1-28-目录遍历函数opendir-readdir-closedir" class="headerlink" title="1.28 目录遍历函数opendir/readdir/closedir"></a>1.28 目录遍历函数opendir/readdir/closedir</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709101735515.png" alt="image-20220709101735515" style="zoom:67%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709101945277.png" alt="image-20220709101945277" style="zoom:50%;" /></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709102100519.png" alt="image-20220709102100519"></p><p>例子 读取某目录下所有的普通文件个数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    // 打开一个目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    DIR *opendir(const char *name);</span></span><br><span class="line"><span class="comment">        参数：</span></span><br><span class="line"><span class="comment">            - name: 需要打开的目录的名称</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            DIR * 类型，理解为目录流</span></span><br><span class="line"><span class="comment">            错误返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 读取目录中的数据</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    struct dirent *readdir(DIR *dirp);</span></span><br><span class="line"><span class="comment">        - 参数：dirp是opendir返回的结果</span></span><br><span class="line"><span class="comment">        - 返回值：</span></span><br><span class="line"><span class="comment">            struct dirent，代表读取到的文件的信息</span></span><br><span class="line"><span class="comment">            读取到了末尾或者失败了，返回NULL</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 关闭目录</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;dirent.h&gt;</span></span><br><span class="line"><span class="comment">    int closedir(DIR *dirp);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取某个目录下所有的普通文件的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s path\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = getFileNum(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;普通文件的个数为：%d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于获取目录下所有普通文件的个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * path)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.打开目录</span></span><br><span class="line">    DIR * dir = opendir(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录普通文件的个数</span></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((ptr = readdir(dir)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取名称</span></span><br><span class="line">        <span class="keyword">char</span> * dname = ptr-&gt;d_name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 忽略掉. 和..</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dname, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(dname, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否是普通文件还是目录</span></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">            <span class="comment">// 目录,需要继续读取这个目录</span></span><br><span class="line">            <span class="keyword">char</span> newpath[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">sprintf</span>(newpath, <span class="string">&quot;%s/%s&quot;</span>, path, dname);</span><br><span class="line">            total += getFileNum(newpath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ptr-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">// 普通文件</span></span><br><span class="line">            total++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭目录</span></span><br><span class="line">    closedir(dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220721110809106.png" alt="image-20220721110809106"></p><hr><h2 id="1-29-dup函数"><a href="#1-29-dup函数" class="headerlink" title="1.29 dup函数"></a>1.29 dup函数</h2><p>复制文件描述符</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709104010554.png" alt="image-20220709104010554" style="zoom:50%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup(int oldfd);</span></span><br><span class="line"><span class="comment">        作用：复制一个新的文件描述符</span></span><br><span class="line"><span class="comment">        fd=3, int fd1 = dup(fd),</span></span><br><span class="line"><span class="comment">        fd指向的是a.txt, fd1也是指向a.txt</span></span><br><span class="line"><span class="comment">        从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">int</span> fd1 = dup(fd);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d , fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;hello,world&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709104522066.png" alt="image-20220709104522066"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    int dup2(int oldfd, int newfd);</span></span><br><span class="line"><span class="comment">        作用：重定向文件描述符</span></span><br><span class="line"><span class="comment">        oldfd 指向 a.txt, newfd 指向 b.txt</span></span><br><span class="line"><span class="comment">        调用函数成功后：newfd 和 b.txt 做close, newfd 指向了 a.txt</span></span><br><span class="line"><span class="comment">        oldfd 必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment">        oldfd和newfd值相同，相当于什么都没有做</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">&quot;2.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd1 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d\n&quot;</span>, fd, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd2 = dup2(fd, fd1);</span><br><span class="line">    <span class="keyword">if</span>(fd2 == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过fd1去写数据，实际操作的是1.txt，而不是2.txt</span></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;hello, dup2&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> len = write(fd1, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd : %d, fd1 : %d, fd2 : %d\n&quot;</span>, fd, fd1, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709105521984.png" alt="image-20220709105521984"></p><hr><h2 id="1-30-fcntl函数"><a href="#1-30-fcntl函数" class="headerlink" title="1.30 fcntl函数"></a>1.30 fcntl函数</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220709105622552.png" alt="image-20220709105622552" style="zoom:67%;" /></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;fcntl.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int fcntl(int fd, int cmd, ...);</span></span><br><span class="line"><span class="comment">    参数：</span></span><br><span class="line"><span class="comment">        fd : 表示需要操作的文件描述符</span></span><br><span class="line"><span class="comment">        cmd: 表示对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">            - F_DUPFD : 复制文件描述符,复制的是第一个参数fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">                int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_GETFL : 获取指定的文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              获取的flag和我们通过open函数传递的flag是一个东西。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            - F_SETFL : 设置文件描述符文件状态flag</span></span><br><span class="line"><span class="comment">              必选项：O_RDONLY, O_WRONLY, O_RDWR 不可以被修改</span></span><br><span class="line"><span class="comment">              可选性：O_APPEND, O)NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                NONBLOK 设置成非阻塞</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        阻塞和非阻塞：描述的是函数调用的行为。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.复制文件描述符</span></span><br><span class="line">    <span class="comment">// int fd = open(&quot;1.txt&quot;, O_RDONLY);</span></span><br><span class="line">    <span class="comment">// int ret = fcntl(fd, F_DUPFD);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.修改或者获取文件状态flag</span></span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;1.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件描述符状态flag</span></span><br><span class="line">    <span class="keyword">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag |= O_APPEND;   <span class="comment">// flag = flag | O_APPEND</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改文件描述符状态的flag，给flag加入O_APPEND这个标记</span></span><br><span class="line">    <span class="keyword">int</span> ret = fcntl(fd, F_SETFL, flag);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fcntl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line">    write(fd, str, <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 并发</title>
      <link href="2022/07/06/blog50-CPP-Concurrency-In-Action/"/>
      <url>2022/07/06/blog50-CPP-Concurrency-In-Action/</url>
      
        <content type="html"><![CDATA[<p>力扣1114 <a href="https://leetcode.cn/problems/print-in-order/solution/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi/">https://leetcode.cn/problems/print-in-order/solution/c-hu-chi-suo-tiao-jian-bian-liang-xin-hao-liang-yi/</a></p><p>1、互斥量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证俩代码不会同时执行</span></span><br><span class="line"><span class="comment">// c++11并发与多线程视频课程_2_5</span></span><br><span class="line">mutex myMutex1;</span><br><span class="line"></span><br><span class="line">    myMutex1.lock();</span><br><span class="line">    <span class="comment">// code 1 </span></span><br><span class="line">    myMutex1.unlock();</span><br><span class="line"></span><br><span class="line">    myMutex1.lock();</span><br><span class="line">    <span class="comment">// code 2</span></span><br><span class="line">    myMutex1.unlock();</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误代码  </span></span><br><span class="line"><span class="comment">// 根据 c++ 标准，在一个线程尝试对一个 mutex 对象进行 unlock 操作时，mutex 对象的所有权必须在这个线程上；也就是说，应该由同一个线程来对一个 mutex 对象进行 lock 和 unlock 操作，否则会产生未定义行为。题目中提到了 first, second, third 三个函数分别是由三个不同的线程来调用的，但我们是在 Foo 对象构造时（可以是在 create 这几个线程的主线程中，也可以是在三个线程中的任意一个）对两个 mutex 对象进行 lock 操作的，因此，调用 first 和 second 函数的两个线程中至少有一个在尝试获取其他线程所拥有的 mutex 对象的所有权。</span></span><br><span class="line"><span class="comment">// 一把锁的上锁与解锁在不同线程中进行，在windows上会报错，在Linux上不会报错，可能力扣用的跑代码的机器是Linux所以这样不会出现问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    mutex mtx1, mtx2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123;</span><br><span class="line">        mtx1.lock(), mtx2.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        printFirst();</span><br><span class="line">        mtx1.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        mtx1.lock();</span><br><span class="line">        printSecond();</span><br><span class="line">        mtx1.unlock();</span><br><span class="line">        mtx2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        mtx2.lock();</span><br><span class="line">        printThird();</span><br><span class="line">        mtx2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们只是通过 mutex 的机制来保护数据被同时访问，所以最好使用 lock_guard 或者 unique_lock 提供的 RAII 机制来管理 mutex 对象，而不是直接操作 mutex 对象；其中 lock_guard 只拥有构造和析构函数，用来实现 RAII 机制，而 unique_lock 是一个完整的 mutex 所有权包装器，封装了所有 mutex 的函数：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    mutex mtx_1, mtx_2;</span><br><span class="line">    unique_lock&lt;mutex&gt; lock_1, lock_2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() : lock_1(mtx_1, try_to_lock), lock_2(mtx_2, try_to_lock) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        printFirst();</span><br><span class="line">        lock_1.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx_1)</span></span>;</span><br><span class="line">        printSecond();</span><br><span class="line">        lock_2.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(mtx_2)</span></span>;</span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></h2><p>2、条件变量</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    condition_variable cv;</span><br><span class="line">    mutex mtx;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printFirst)</span> </span>&#123;</span><br><span class="line">        printFirst();</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        cv.notify_all();    <span class="comment">// 通知其他所有在等待唤醒队列中的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">second</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printSecond)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;   <span class="comment">// lock mtx</span></span><br><span class="line">        cv.wait(lock, [<span class="keyword">this</span>]()&#123; <span class="keyword">return</span> k == <span class="number">1</span>; &#125;);  <span class="comment">// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 1 才能继续运行</span></span><br><span class="line">        printSecond();</span><br><span class="line">        k = <span class="number">2</span>;</span><br><span class="line">        cv.notify_one();    <span class="comment">// 随机通知一个（unspecified）在等待唤醒队列中的线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">third</span><span class="params">(function&lt;<span class="keyword">void</span>()&gt; printThird)</span> </span>&#123;</span><br><span class="line">        <span class="function">unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;   <span class="comment">// lock mtx</span></span><br><span class="line">        cv.wait(lock, [<span class="keyword">this</span>]()&#123; <span class="keyword">return</span> k == <span class="number">2</span>; &#125;);  <span class="comment">// unlock mtx，并阻塞等待唤醒通知，需要满足 k == 2 才能继续运行</span></span><br><span class="line">        printThird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><a href="https://yelinji.gitbooks.io/cpp_concurrency_in_action/content/">https://yelinji.gitbooks.io/cpp_concurrency_in_action/content/</a>  作为对《C++ Concurrency in Action》的中文翻译。</p><hr><p>1.4</p><p>清单 1.1 一个简单的Hello, Concurrent World程序：</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  //①</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  <span class="comment">//②</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">//③</span></span><br><span class="line">  t.join();  <span class="comment">//④</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>2.1线程管理的基础</p><p><code>std::thread</code>可以用可调用类型构造，将带有函数调用符类型的实例传入<code>std::thread</code>类中，替换默认的构造函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    do_something();</span><br><span class="line">    do_something_else();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="2022/07/06/blog49-segmentTree/"/>
      <url>2022/07/06/blog49-segmentTree/</url>
      
        <content type="html"><![CDATA[<p>针对力扣307题，找到题解 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/">https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/</a></p><p><strong>线段树解决的是「区间和」的问题，且该「区间」会被修改</strong></p><p>所以<strong>线段树</strong>主要实现两个方法：「求区间和」&amp;&amp;「修改区间」，且时间复杂度均为 <code>O(logn)</code></p><p>始终记住一句话：<strong>线段树的每个节点代表一个区间</strong></p><p>从图中可以看到，每个节点代表一个区间，而节点的值就是该区间的和 (其实还可以根据题目问题，改变表示的含义！！)</p><p>数字之和「总数字之和 = 左区间数字之和 + 右区间数字之和」<br>最大公因数 (GCD)「总 GCD = gcd(左区间 GCD, 右区间 GCD)」<br>最大值「总最大值 = max(左区间最大值，右区间最大值)」</p><p>不符合区间加法的例子：</p><ul><li>众数「只知道左右区间的众数，没法求总区间的众数」</li><li>01 序列的最长连续零「只知道左右区间的最长连续零，没法知道总的最长连续零」</li></ul><hr><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; segmentTree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            segmentTree[node] = nums[start];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        build(node * <span class="number">2</span> + <span class="number">1</span>, start, mid, nums);</span><br><span class="line">        build(node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end, nums);</span><br><span class="line">        segmentTree[node] = segmentTree[node * <span class="number">2</span> + <span class="number">1</span>] + segmentTree[node * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            segmentTree[node] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= mid) &#123;</span><br><span class="line">            change(index, val, node * <span class="number">2</span> + <span class="number">1</span>, start, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            change(index, val, node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">        segmentTree[node] = segmentTree[node * <span class="number">2</span> + <span class="number">1</span>] + segmentTree[node * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">range</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> node, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == start &amp;&amp; right == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> segmentTree[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> range(left, right, node * <span class="number">2</span> + <span class="number">1</span>, start, mid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> range(left, right, node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> range(left, mid, node * <span class="number">2</span> + <span class="number">1</span>, start, mid) + range(mid + <span class="number">1</span>, right, node * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) : n(nums.size()), segmentTree(nums.size() * <span class="number">4</span>) &#123;</span><br><span class="line">        build(<span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        change(index, val, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> range(left, right, <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></h2><p>针对力扣307题的题解 <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/">https://leetcode.cn/problems/range-sum-query-mutable/solution/by-lfool-v3x9/</a></p><ul><li>对于表示为「区间和」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！(这种情况和模版一致！！) 如题目 最近的请求次数</li><li>对于表示为「区间和」且对区间进行「覆盖」的更新操作的情况，我们在更新节点值的时候『需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『不需要累加』！！(因为是覆盖操作！！) 如题目 区域和检索 - 数组可修改</li><li>对于表示为「区间最值」且对区间进行「加减」的更新操作的情况，我们在更新节点值的时候『不需要✖️左右孩子区间叶子节点的数量 (注意是叶子节点的数量)』；我们在下推懒惰标记的时候『需要累加』！！ 如题目 我的日程安排表 I、我的日程安排表 III</li></ul><p>。</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同文件共享函数的使用问题</title>
      <link href="2022/07/01/blog48-extern/"/>
      <url>2022/07/01/blog48-extern/</url>
      
        <content type="html"><![CDATA[<h4 id="情景描述："><a href="#情景描述：" class="headerlink" title="情景描述："></a>情景描述：</h4><p>在qt的mainwindow.cpp下想使用udpthread.cpp下的函数，遇到定义的错误。</p><p>初始代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mainwindow.cpp</span></span><br><span class="line">直接使用BLEndianUint32</span><br><span class="line"><span class="comment">// udpthread.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现</p><p>error: use of undeclared identifier ‘BLEndianUint32’问题</p><hr><p>解决方法1：类的定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpThread</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// udpthread.cpp</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span>  <span class="title">udpThread::BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// mainwindow.h</span></span><br><span class="line">    udpThread *MyUdp;</span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line">    MyUdp = <span class="keyword">new</span> udpThread;</span><br><span class="line">    value = MyUdp-&gt;BLEndianUint32(value);</span><br></pre></td></tr></table></figure><p>BLEndianUint32函数写成udpthread类的公有成员</p><p>而在mainwindow中实例化一个对象MyUdp，再调用函数BLEndianUint32。</p><p>或者在类中直接定义也可以。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpThread</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br></pre></td></tr></table></figure><p>或者把成员函数声明成静态函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">udpThread</span> :</span> <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line">    value = MyUdp-&gt;BLEndianUint32(value);  <span class="comment">// 1</span></span><br><span class="line">    value = udpThread::BLEndianUint32(value); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>来源于 <a href="https://blog.csdn.net/weixin_43222324/article/details/99707095">https://blog.csdn.net/weixin_43222324/article/details/99707095</a></p><p>下面我们来分析一下为什么可以这样改       </p><p>（1）为什么要实例化</p><pre><code>   仍然以上面的类Student为例。类Student表示学生，这是一个抽象的概念，表示的是所有学生。实例化一个对象Student XiaoWang;，这个对象表示的是具体的学生小王，你还可以实例化别的对象比如小张、小刘、小李、小周、小赵等等，这些对象都是具体的某个学生。   类的成员函数getAge()的意思是得到学生的年龄，我们最直观的理解就是，学生的年龄那肯定是某一个具体的学生的年龄，如果你用Student.getAge()的方法调用年龄函数，那究竟得到的是哪个学生的年龄呢？所以对于这种非静态成员函数，我们要实例化一个对象比如学生小王，我们调用XiaoWang.getAge()得到的就是小王的年龄。</code></pre><p>（2）为什么调用静态函数不需要实例化</p><pre><code>   仍然以上面的类Student为例。如果现在我们要得到所有学生的平均年龄该怎么办呢？假如现在类Student里增加了一个函数getAverageAge()，我们想得到所有学生的平均年龄，难道还要先实例化一个对象表示具体的学生，再通过这个对象得到平均年龄吗？   所有学生的平均年龄，是学生类Student的一个共同特点，我们可以把得到平均年龄函数声明成静态函数，static int getAverageAge();，然后无需实例化对象，直接通过Student::getAverageAge();的方式调用。   类的静态函数表示的是这个类的一个共同特点，静态函数是类的所有对象所共享的，不是某一个对象特有的，就像平均年龄是所有学生所共有的而不是某个学生所特有的，因此，静态函数不需要实例化对象，直接通过类名::函数名的方式就能调用。</code></pre><p>因此，在选择用上面两种方法中的哪一种方法的时候，需要根据你写的函数的意义。</p><p>（1）如果你写的函数表示的是对象特有的特性，比如学生的年龄函数，用第一种方法，实例化对象再调用函数，更好。<br>（2）如果你写的函数表示的是这个类的所有对象共享的特性，比如所有学生的平均年龄函数，用第二种方法，将该函数声明成静态函数，更好。<br>       当然用哪种方法都可以，只是说用对场景更好。</p><hr><p>解决方法2：内联函数</p><p>内联的目的就是在编译期让编译器把使用函数的地方直接替换掉，而不是像普通函数一样通过链接器把地址链接上。这种情况，如果定义没有在头文件的话，编译器是无法进行函数替换的。所以C++规定，内联函数可以在程序中定义多次，只要内联函数定义在同一个cpp中只出现一次就行。</p><p>来源于：<a href="https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/">https://jiadebin.github.io/2017/04/03/%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84multiple-definition/</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) |  ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |  ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在外就可以随意用BLEndianUint32了。</p><hr><p>解决方法3：extern基础函数？</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// udpthread.h</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint16</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>;</span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">BLEndianUint16</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainwindow.cpp </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BLEndianUint32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x000000FF</span>) &lt;&lt; <span class="number">24</span>) | ((value &amp; <span class="number">0x0000FF00</span>) &lt;&lt; <span class="number">8</span>) |</span><br><span class="line">           ((value &amp; <span class="number">0x00FF0000</span>) &gt;&gt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF000000</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BLEndianUint16</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((value &amp; <span class="number">0x00FF</span>) &lt;&lt; <span class="number">8</span>) | ((value &amp; <span class="number">0xFF00</span>) &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法总结-图</title>
      <link href="2022/06/30/blog47-algorithms/"/>
      <url>2022/06/30/blog47-algorithms/</url>
      
        <content type="html"><![CDATA[<h2 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h2><p>「Kruskal 算法」是求解「加权无向图」的「最小生成树」的一种算法。</p><ol><li>所有边从小到大排序</li><li>依次加入最小生成树中，形成环则跳过</li><li>知道选择N-1条边为止</li></ol><p>LC. 1584</p><p>三元组：stl的对类，用户定义结构</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x != fa[x] ) </span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">                edges.push_back(<span class="built_in">make_pair</span>(dist(i,j), <span class="built_in">make_pair</span>(i, j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// sort(edges.begin(), edges.end()); 也可以</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [len, <span class="built_in">pair</span>] : edges ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(<span class="built_in">pair</span>.first) != find(<span class="built_in">pair</span>.second)) &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                unify(<span class="built_in">pair</span>.first, <span class="built_in">pair</span>.second);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>三元组写成用户定义</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x != fa[x] ) </span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="comment">// 注意此处</span></span><br><span class="line">        <span class="keyword">int</span> len, x, y;</span><br><span class="line">        Edge(<span class="keyword">int</span> len, <span class="keyword">int</span> x, <span class="keyword">int</span> y) : len(len), x(x), y(y) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Edge&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">                <span class="comment">// edges.push_back(make_pair(dist(i,j), make_pair(i, j)));</span></span><br><span class="line">                edges.emplace_back(dist(i, j), i, j);  <span class="comment">// 注意此处</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123; </span><br><span class="line">            <span class="keyword">return</span> a.len &lt; b.len;  <span class="comment">// 注意此处</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [len, x, y] : edges ) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; len &lt;&lt; &quot; &quot; &lt;&lt; pair.first &lt;&lt; &quot; &quot; &lt;&lt; pair.second &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (find(x) != find(y)) &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                num++;</span><br><span class="line">                <span class="keyword">if</span> ( num == n ) <span class="keyword">break</span>;</span><br><span class="line">                unify(x, y);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>并查集写成一个类</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    UnionFind (<span class="keyword">int</span> n) &#123;</span><br><span class="line">        fa.resize(n);</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( x != fa[x] ) </span><br><span class="line">            fa[x] = find(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[find(x)] = find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="function">UnionFind <span class="title">uf</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++ ) &#123;</span><br><span class="line">                edges.push_back(<span class="built_in">make_pair</span>(dist(i,j), <span class="built_in">make_pair</span>(i, j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(edges.begin(), edges.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; a, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [len, <span class="built_in">pair</span>] : edges ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uf.find(<span class="built_in">pair</span>.first) != uf.find(<span class="built_in">pair</span>.second)) &#123;</span><br><span class="line">                ans += len;</span><br><span class="line">                <span class="keyword">if</span> ( ++num == n ) <span class="keyword">break</span>;</span><br><span class="line">                uf.unify(<span class="built_in">pair</span>.first, <span class="built_in">pair</span>.second);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n2 log(n))，其中 n 是节点数。一般Kruskal 是O(mlogm) 的算法，但本题中m=n2</p><p>空间复杂度：O(n^2)，其中 n是节点数。并查集使用 O(n)的空间，边集数组需要使用 O(n^2) 的空间。</p><hr><h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>在「Kruskal 算法」中，我们通过增加边数来扩大「最小生成树」；适用于稀疏图</p><p>在「Prim 算法」中，我们通过增加顶点来扩大「最小生成树」。适用于稠密图</p><p>「切分定理」指的是：在一幅连通加权无向图中，给定任意的切分，如果有一条横切边的权值严格小于所有其他横切边，则这条边必然属于图的最小生成树中的一条边。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostConnectPoints</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dist = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(points[x][<span class="number">0</span>] - points[y][<span class="number">0</span>]) + <span class="built_in">abs</span>(points[x][<span class="number">1</span>] - points[y][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, <span class="number">0</span>)</span></span>; <span class="comment">// 生成树 到 各点的最短距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            mindist[i] = dist(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        mindist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n<span class="number">-1</span>; k++) <span class="comment">// n-1次</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i] &amp;&amp; minn &gt; mindist[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    minn = mindist[i]; <span class="comment">// 找最小值</span></span><br><span class="line">                    pos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cost += minn;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line">            mindist[pos] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i] &amp;&amp; dist(pos, i) &lt; mindist[i])</span><br><span class="line">                    mindist[i] = dist(pos, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Dijkstra-算法-ˈdeɪkstra"><a href="#Dijkstra-算法-ˈdeɪkstra" class="headerlink" title="Dijkstra 算法/ˈdɛɪkstra/."></a>Dijkstra 算法/ˈdɛɪkstra/.</h4><p>「Dijkstra 算法」解决的是加权有向图「单源最短路径」问题，其中该图的所有权重必须为非负数。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220629155416728.png" alt="image-20220629155416728"></p><p>LC 743 网络延迟时间</p><p>将所有节点分成两类：已确定从起点到当前点的最短路长度的节点，以及未确定从起点到当前点的最短路长度的节点（下面简称「未确定节点」和「已确定节点」）。</p><p>每次从「未确定节点」中取一个与起点距离最短的点，将它归类为「已确定节点」，并用它「更新」从起点到其他所有「未确定节点」的距离。直到所有点都被归类为「已确定节点」。</p><p>用节点 AA「更新」节点 BB 的意思是，用起点到节点 AA 的最短路长度加上从节点 AA 到节点 BB 的边的长度，去比较起点到节点 BB 的最短路长度，如果前者小于后者，就用前者更新后者。这种操作也被叫做「松弛」。</p><p>这里暗含的信息是：每次选择「未确定节点」时，起点到它的最短路径的长度可以被确定。</p><p>可以这样理解，因为我们已经用了每一个「已确定节点」更新过了当前节点，无需再次更新（因为一个点不能多次到达）。而当前节点已经是所有「未确定节点」中与起点距离最短的点，不可能被其它「未确定节点」更新。所以当前节点可以被归类为「已确定节点」。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> inf = INT_MAX / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dist(n , <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n , inf));</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; t : times ) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            dist[x][y] = t[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, inf)</span></span>;</span><br><span class="line">        mindist[k - <span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> num = <span class="number">0</span>; num &lt; n; num++ ) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ( !visited[i] &amp;&amp; ( minn &gt; mindist[i] ) ) &#123;  <span class="comment">// 找最小值</span></span><br><span class="line">                    minn = mindist[i];</span><br><span class="line">                    pos = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[pos] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123;</span><br><span class="line">                mindist[i] = min(mindist[i], mindist[pos] + dist[pos][i] );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = *max_element(mindist.begin(), mindist.end());</span><br><span class="line">        <span class="keyword">return</span> ans == inf ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="FLOYD"><a href="#FLOYD" class="headerlink" title="FLOYD"></a>FLOYD</h2><p>复杂度为O(n3 ) 的「多源汇最短路」算法 Floyd 算法进行求解，同时使用「邻接矩阵」来进行存图，可以得到「从任意起点出发，到达任意点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220630140435434.png" alt="image-20220630140435434"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220630141653680.png" alt="image-20220630141653680"></p><p>A1,0 = 6，path 1,0 = 3; path 3,0 = 2; path 2,0 = -1 直接相连 </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">printPath</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> path[][max])</span> </span>&#123; <span class="comment">// i = 1, j = 0 </span></span><br><span class="line">    <span class="keyword">if</span> ( path[i][j] == <span class="number">-1</span> ) &#123; <span class="comment">/*直接输出*/</span> &#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> v = path[i][j]; <span class="comment">// path[1][0] = 3</span></span><br><span class="line">        printPath(i, mid, path);  <span class="comment">// path[1][3]</span></span><br><span class="line">        printPath(mid, j, path);  <span class="comment">// path[3][0]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外循环v为中间变量，Av，Pathv修改为v;内循环i，j ≠ v</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; v++ ) </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) </span><br><span class="line">            <span class="keyword">if</span> ( A[i][j] &gt; A[i][v] + A[v][j] ) &#123;</span><br><span class="line">                A[i][j] = A[i][v] + A[v][j];</span><br><span class="line">                path[i][j] = v;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Bellman-Ford-算法（单源最短路径）"><a href="#Bellman-Ford-算法（单源最短路径）" class="headerlink" title="Bellman-Ford 算法（单源最短路径）"></a>Bellman-Ford 算法（单源最短路径）</h2><p>「Bellman-Ford 算法」虽然不能检测到「负权环图」的最短路径，但是它能检测到「图」中是否存在「负权环」。</p><p><strong>定理一：在一个有 N 个顶点的「非负权环图」中，两点之间的最短路径最多经过 N-1 条边。</strong></p><p><strong>定理二：「负权环」没有最短路径。</strong>环上 边权 为正为负，正权环图有最短距离。</p><p>DJ算法关注的是点，B-F算法关注的是边，动态规划</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220630175905930.png" alt="image-20220630175905930"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220630151237279.png" alt="image-20220630151237279"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220630151906670.png" alt="image-20220630151906670"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LC 743</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; dist(n); <span class="comment">// 存图方式</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; t : times ) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> y = t[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            dist[x].push_back( <span class="built_in">make_pair</span>(y, t[<span class="number">2</span>]) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// |V| - 1 次</span></span><br><span class="line">        mindist[k - <span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">bool</span> finished;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n - <span class="number">1</span>; k++ ) &#123;<span class="comment">// n - 1 次</span></span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++ ) &#123; <span class="comment">// 前一节点</span></span><br><span class="line">                <span class="keyword">if</span> ( mindist[u] == INT_MAX ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [ v, weight ] : dist[u] ) &#123;</span><br><span class="line">                    <span class="keyword">long</span> newV = mindist[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span> ( newV &lt; mindist[v] ) &#123;</span><br><span class="line">                        mindist[v] = newV;</span><br><span class="line">                        finished = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( finished ) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = *max_element(mindist.begin(), mindist.end());</span><br><span class="line">        <span class="keyword">return</span> ans == INT_MAX ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; dist(n); <span class="comment">// 存图方式</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; t : flights ) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = t[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = t[<span class="number">1</span>];</span><br><span class="line">            dist[x].push_back( <span class="built_in">make_pair</span>(y, t[<span class="number">2</span>]) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mindist</span><span class="params">(n, INT_MAX)</span></span>; <span class="comment">// |V| - 1 次</span></span><br><span class="line">        mindist[src] = <span class="number">0</span>;  <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; k + <span class="number">1</span>; kk++ ) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">newdist</span><span class="params">(mindist)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> ( <span class="keyword">int</span> u = <span class="number">0</span>; u &lt; n; u++ ) &#123; <span class="comment">// 前一节点</span></span><br><span class="line">                <span class="keyword">if</span> ( mindist[u] == INT_MAX ) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> ( <span class="keyword">auto</span>&amp; [ v, weight ] : dist[u] ) &#123;</span><br><span class="line">                    <span class="keyword">long</span> newV = mindist[u] + weight;</span><br><span class="line">                    <span class="keyword">if</span> ( newV &lt; newdist[v] ) &#123;</span><br><span class="line">                        newdist[v] = newV;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mindist.assign(newdist.begin(), newdist.end());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mindist[dst] == INT_MAX ? <span class="number">-1</span> : mindist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="基于「队列」优化的-Bellman-Ford-算法-—-SPFA-算法-Shortest-Path-Faster-Algorithm"><a href="#基于「队列」优化的-Bellman-Ford-算法-—-SPFA-算法-Shortest-Path-Faster-Algorithm" class="headerlink" title="基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法  Shortest Path Faster Algorithm"></a>基于「队列」优化的 Bellman-Ford 算法 — SPFA 算法  Shortest Path Faster Algorithm</h3><p>「SPFA 算法」主要是通过「队列」来维护我们接下来要遍历边的起点，而不是「Bellman Ford」算法中的任意还没有遍历过的边。每次只有当某个顶点的最短距离更新之后，并且该顶点不在「队列」中，我们就将该顶点加入到「队列」中。一直循环以上步骤，直到「队列」为空，我们就可以终止算法。此时，我们就可以得到「图」中其他顶点到给定顶点的最短距离了。</p><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie *&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Trie() : children(<span class="number">26</span>), isEnd(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="function">Trie *<span class="title">searchPrefix</span><span class="params">(<span class="built_in">string</span> prefix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word)</span><br><span class="line">        &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>-&gt;searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;searchPrefix(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Trie *trie, <span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (trie-&gt;isEnd)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (trie-&gt;children[i] != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> st = s;</span><br><span class="line">            st += (i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            bfs(trie-&gt;children[i], st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>.ignore();</span><br><span class="line">    Trie *trie1 = <span class="keyword">new</span> Trie();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, s);</span><br><span class="line">        trie1-&gt;insert(s);</span><br><span class="line">    &#125;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="keyword">if</span> (trie1-&gt;startsWith(s)) <span class="comment">//有这个前缀</span></span><br><span class="line">    &#123;</span><br><span class="line">        bfs(trie1-&gt;searchPrefix(s), s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没这个前缀</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qt曲线图</title>
      <link href="2022/04/08/blog46-myQChart/"/>
      <url>2022/04/08/blog46-myQChart/</url>
      
        <content type="html"><![CDATA[<p>为了做一个调节控制轴的上位机软件。</p><p>主要用到了QT chart， 并且大量学习内置的<code>example</code>，主要包括 QLineSeries、QSplineSeries，一个样条曲线和一个折线。</p><p>其中白色显示最为重要的RMS曲线，与黑色背景形成最鲜明对比。</p><p>还有一个QAreaSeries为了显示两个意义相同的位置信息（实际位置和设定位置），以亮蓝线表示实际位置，暗蓝色表示设定位置，中间的透明蓝表示两线围成的区域。</p><p>还有一个QStackedBarSeries，折叠柱状图，我的想法是设计红色为正误差，绿色为负误差，类似于股票的涨跌，其中柱状图包络线为实际值，并且整图来看，由于误差的累计在pid中是有所含义的，红绿色面积大小比较显眼。</p><p>还设置了多y轴，个人认为这是我设计最全的一个图了：各个颜色和图类分别表示不同的含义，我本想将左侧的红绿色y轴合二为一，但不太会且有bug，故放弃。</p><p>在图中还有点击图例的交互：实现图例闪烁和曲线现隐。</p><p>以及鼠标hover在scatter点上的显示反应。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220408194524894.png" alt="image-20220627204728330"></p><p>接下来还需要做协议的解析、动态调整y轴的范围、计算error值。计算rms值。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220627223625218.png" alt="image-20220627223625218"></p><p>最终经过调试完善项目界面如上图所示。</p><p>还添加了双轴双图显示、关掉界面再打开的文本框数据缓存功能、文本框重要数据的实时显示、qt chart的每隔一段时间更新画图、保存为csv文件的保存功能、status状态栏的qt组件控制、拖动条设置图像更新频率等功能。</p><p>源码已上传至github上。</p><hr><p>该代码前期耗费两周研究qt chart的诸多显示效果，结合项目实际意义设计最佳画图方案。后期结合望远镜实时数据，添加诸多功能。</p><hr><p>2022/6/27 还花时间修复了这半年来blog的一些问题。</p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究一下星表</title>
      <link href="2022/03/18/blog45-starCatalog/"/>
      <url>2022/03/18/blog45-starCatalog/</url>
      
        <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/欧洲空间局/8769487">欧洲空间局</a>（ESA）在1989年8月8日成功地发射了依巴谷<a href="https://baike.baidu.com/item/天体测量卫星/15568941">天体测量卫星</a>，<a href="https://baike.baidu.com/item/依巴谷星表">依巴谷星表</a>和第谷星表是<a href="https://baike.baidu.com/item/依巴谷卫星/6240692">依巴谷卫星</a>的主要观测结果，依巴谷星表测定了约12万颗恒星，构成了均匀的<a href="https://baike.baidu.com/item/天球参考系/1453747">天球参考系</a>，极限星等达到13mag，其位置、自行与<a href="https://baike.baidu.com/item/视差">视差</a>的精度分别为±0.002″、±0.002″/yr、±0.002″。1997年在日本京都召开的IAU第23届大会给出了由212颗<a href="https://baike.baidu.com/item/河外致密射电源/9210040">河外致密射电源</a>构成的<a href="https://baike.baidu.com/item/国际天球参考系/15581252">国际天球参考系</a>（ICRS），决定由依巴谷星表取代已沿用10多年的FK5星表，成为ICRS在光学波段的实现，并将改进后的依巴谷框架称为依巴谷天球参考框架（HCRF）。</p><p>古希腊天文学家依巴谷以精确的天体测量著名于世，他发现了岁差，将三角学应用于天文学，首先提出了星等的概念并被后世进一步发展完善，被尊称为“方位天文学之父”。欧空局的依巴谷计划的英文缩写与依巴谷的名字非常相似，也正好纪念了这位天文学伟人。这项计划分为“依巴谷实验”和“第谷实验”两部分。前者最终测得118218颗恒星的高精度数据；后者测得数百万颗恒星的低精度数据。</p><h2 id="常用目视星表"><a href="#常用目视星表" class="headerlink" title="常用目视星表"></a>常用目视星表</h2><p>在实际应用中常用的目视星表中有：</p><p>（1）《<a href="https://baike.baidu.com/item/依巴谷星表">依巴谷星表</a>》（Hipparcos catalogue），简称HIP或HP</p><p>欧洲空间局（简称ESA）依巴谷<a href="https://baike.baidu.com/item/天体测量卫星/15568941">天体测量卫星</a>（Hipparcos）计划的主要成果。1997年发表的第2版，是位置精确度最高的科学数据，包括的恒星总数为120313个，极限星等为13等，精确度在千分之一弧秒，而第谷星表 列出的则略微超过1,050,000颗恒星。包括赤道坐标，自行，星等，光谱型、颜色、光谱型、视差、径向速度等信息。</p><p>（2）HD星表（Henry Draper Catalogue）或 耶鲁亮星星表编号HD。亨利·德雷伯星表（HD/HDE）</p><p>HD星表给出88 883颗恒星的2000年历元位置、星等、自行、光谱型等数据，是最传统的星表之一。耶鲁亮星星表包括25万颗全部 8等以上的恒星和很多暗达11等的恒星的著名星表。HD序号在没有拜耳字母或佛氏星数的恒星中被普遍的采用，在原始的HD星表中序号从1～225,300是依1900.0分点的赤经，从225,301～359,083是在1949年出版的亨利·德雷珀扩充星表中增加的，仍然使用HD表示。</p><p>（4）<a href="https://baike.baidu.com/item/SAO星表/6485132">SAO星表</a>（Smithsonian Astrophysical Observatory ，1966）史密松星表</p><p>SAO星表是天文观测最常用的星表，它给出了258 997颗星等亮于11m的恒星，有编号、自行值、光谱型、V星等，表内列有与HD星表和BD（DM）星表的交叉证认序号。</p><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220321111520189.png" alt="image-20220321111520189"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220321121232624.png" alt="image-20220321121232624"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220321121314466.png" alt="image-20220321121314466"></p><p>能得到数据 也不知道怎么计算。。。</p><p>就用Stellarium里的数据吧</p>]]></content>
      
      
      <categories>
          
          <category> 星表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Stellarium过程</title>
      <link href="2022/03/15/blog44-buildStellarium/"/>
      <url>2022/03/15/blog44-buildStellarium/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p>首先下载qt，我这里使用的是qt5.14.2，下载挺快的。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316082552203.png" alt="image-20220316082852120"></p><p>We recommend to use Qt 5.12 or later. You must select Qt Script and msvc2017/msvc2019 among so many checkboxes.</p><p>Add <code>C:\Qt\Qt5.15.12</code> to your <code>PATH</code> variable - you should add string <code>C:\Qt\Qt5.15.12\msvc2019;C:\Qt\Qt5.15.12\msvc2019\bin</code> for 32-bit or <code>C:\Qt\Qt5.15.12\msvc2019_64;C:\Qt\Qt5.15.12\msvc2019_64\bin</code> for 64-bit to <code>PATH</code> variable. (Replace the version numbers of Qt and the version of Visual Studio (2017/2019) with the version that you have installed)</p><p><a href="https://github.com/Stellarium/stellarium/blob/master/BUILDING.md">https://github.com/Stellarium/stellarium/blob/master/BUILDING.md</a></p><p>接着下载github上stellarium的源码。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316082946891.png" alt="image-20220316082946891"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316084705332.png" alt="image-20220316084705332"></p><p>接着下载cmake </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316083021304.png" alt="image-20220316083021304"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316085856109.png" alt="image-20220316085856109"></p><p>接着将stellarium文件中的CMakeLists.txt拖进qt creator中，将自动能展开，但出现一些问题</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220315234126876.png" alt="image-20220315234126876"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316085005174.png" alt="image-20220316085005174"></p><p>然后稍微改改字符，就可以运行了。</p><p>对代码的修改如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com//img/image-20220316111236063.png" alt="image-20220316111236063"></p>]]></content>
      
      
      <categories>
          
          <category> Stellarium </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stellarium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zone Model</title>
      <link href="2022/03/09/blog43-zoneModel/"/>
      <url>2022/03/09/blog43-zoneModel/</url>
      
        <content type="html"><![CDATA[<p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220309194832300.png" alt="image-20220309194832300"></p><p>icosahedron</p><p>正二十面体 <a href="https://baike.baidu.com/item/%E6%AD%A3%E4%BA%8C%E5%8D%81%E9%9D%A2%E4%BD%93/1921640">https://baike.baidu.com/item/%E6%AD%A3%E4%BA%8C%E5%8D%81%E9%9D%A2%E4%BD%93/1921640</a></p><p>正二十面体(Regular icosahedron [2] ) 是由20个等边三角形所组成的<a href="https://baike.baidu.com/item/正多面体">正多面体</a>，共有12个顶点，30条棱，20个面。为五个<a href="https://baike.baidu.com/item/柏拉图多面体/2769757">柏拉图多面体</a>之一。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220309164132823.png" alt="image-20220309164132823"></p><p> sqrt(50-10*sqrt(5))/10 = 0.5257</p><p>sqrt(50+10*sqrt(5))/10 = 0.8507</p><hr><p>画图十分精美</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220321102438566.png" alt="image-20220321102438566"></p><p><a href="https://www.redblobgames.com/x/1842-delaunay-voronoi-sphere/">https://www.redblobgames.com/x/1842-delaunay-voronoi-sphere/</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220321101619465.png" alt="image-20220321101619465"></p><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220309171100201.png" alt="image-20220309171100201"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% plot_triangle.m</span></span><br><span class="line">clear all; close all;</span><br><span class="line">m = <span class="built_in">sqrt</span>(<span class="number">50</span><span class="number">-10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">n = <span class="built_in">sqrt</span>(<span class="number">50</span>+<span class="number">10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">A = [</span><br><span class="line">    n,-m,<span class="number">0</span>;</span><br><span class="line">    n,m,<span class="number">0</span>;</span><br><span class="line">    -n,m,<span class="number">0</span>;</span><br><span class="line">    -n,-m,<span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>,n,-m;</span><br><span class="line">    <span class="number">0</span>,n,m;</span><br><span class="line">    <span class="number">0</span>,-n,m;</span><br><span class="line">    <span class="number">0</span>,-n,-m;</span><br><span class="line">    -m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,-n;</span><br><span class="line">    -m,<span class="number">0</span>,-n;</span><br><span class="line">    ];</span><br><span class="line"><span class="built_in">scatter3</span>(A(:,<span class="number">1</span>),A(:,<span class="number">2</span>),A(:,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">center=[];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">1</span>,<span class="number">0</span>,<span class="number">10</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">0</span>,<span class="number">9</span>,<span class="number">6</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">0</span>,<span class="number">7</span>,<span class="number">10</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">11</span>,<span class="number">10</span>,<span class="number">7</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">7</span>,<span class="number">3</span>,<span class="number">11</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">10</span>,<span class="number">11</span>,<span class="number">4</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">2</span>,<span class="number">4</span>,<span class="number">11</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">4</span>,<span class="number">1</span>,<span class="number">10</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line">center = [center;plot_triangle(A,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>)];</span><br><span class="line">center = [center;plot_triangle(A,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">text(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line"></span><br><span class="line">axis equal;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">plot_triangle</span><span class="params">(A,d1,d2,d3)</span></span></span><br><span class="line">d1 = d1 + <span class="number">1</span>;</span><br><span class="line">d2 = d2 + <span class="number">1</span>;</span><br><span class="line">d3 = d3 + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line">line([A(d1,<span class="number">1</span>),A(d2,<span class="number">1</span>),A(d3,<span class="number">1</span>),A(d1,<span class="number">1</span>)],[A(d1,<span class="number">2</span>),A(d2,<span class="number">2</span>),A(d3,<span class="number">2</span>),A(d1,<span class="number">2</span>)],[A(d1,<span class="number">3</span>),A(d2,<span class="number">3</span>),A(d3,<span class="number">3</span>),A(d1,<span class="number">3</span>)]);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220309194211980.png" alt="image-20220309194211980"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220312234651019.png" alt="image-20220312234651019"></p><hr><p>进入源码进行查看</p><p>StelGeodesicGrid::StelGeodesicGrid（StelGeodesicGrid.cpp） 被调用1次 调用20次<br>        StelGeodesicGrid::initTriangle（StelGeodesicGrid.cpp）被调用20次 c0/c1/c2为20个面的3个点，函数内的循环没进</p><p>下面6个点为 c0/c1/c2/e0/e1/e2</p><p>1 [0.850651, 0.525731, 0] [0.850651, -0.525731, 0] [0.525731, 0, -0.850651] [0.809017, -0.309017, -0.5] [0.809017, 0.309017, -0.5] [1, 0, 0]</p><p>2 [0.850651, -0.525731, 0] [0.850651, 0.525731, 0] [0.525731, 0, 0.850651] [0.809017, 0.309017, 0.5] [0.809017, -0.309017, 0.5] [1, 0, 0]</p><p>3 [0.850651, -0.525731, 0] [0.525731, 0, 0.850651] [0, -0.850651, 0.525731] [0.309017, -0.5, 0.809017] [0.5, -0.809017, 0.309017] [0.809017, -0.309017, 0.5]</p><p>4 [0.525731, 0, 0.850651] [-0.525731, 0, 0.850651] [0, -0.850651, 0.525731] [-0.309017, -0.5, 0.809017] [0.309017, -0.5, 0.809017] [0, 0, 1]</p><p>5 [0.850651, -0.525731, 0] [0, -0.850651, -0.525731] [0.525731, 0, -0.850651] [0.309017, -0.5, -0.809017] [0.809017, -0.309017, -0.5] [0.5, -0.809017, -0.309017]</p><p>6 [0, -0.850651, 0.525731] [0, -0.850651, -0.525731] [0.850651, -0.525731, 0] [0.5, -0.809017, -0.309017] [0.5, -0.809017, 0.309017] [0, -1, 0]</p><p>7 [0, -0.850651, -0.525731] [0, -0.850651, 0.525731] [-0.850651, -0.525731, 0] [-0.5, -0.809017, 0.309017] [-0.5, -0.809017, -0.309017] [0, -1, 0]</p><p>8 [0, -0.850651, 0.525731] [-0.525731, 0, 0.850651] [-0.850651, -0.525731, 0] [-0.809017, -0.309017, 0.5] [-0.5, -0.809017, 0.309017] [-0.309017, -0.5, 0.809017]</p><p>9 [-0.525731, 0, -0.850651] [0.525731, 0, -0.850651] [0, -0.850651, -0.525731] [0.309017, -0.5, -0.809017] [-0.309017, -0.5, -0.809017] [0, 0, -1]</p><p>10 [0, -0.850651, -0.525731] [-0.850651, -0.525731, 0] [-0.525731, 0, -0.850651] [-0.809017, -0.309017, -0.5] [-0.309017, -0.5, -0.809017] [-0.5, -0.809017, -0.309017]</p><p>11 [-0.850651, -0.525731, 0] [-0.850651, 0.525731, 0] [-0.525731, 0, -0.850651] [-0.809017, 0.309017, -0.5] [-0.809017, -0.309017, -0.5] [-1, 0, 0]</p><p>12 [-0.850651, 0.525731, 0] [-0.850651, -0.525731, 0] [-0.525731, 0, 0.850651] [-0.809017, -0.309017, 0.5] [-0.809017, 0.309017, 0.5] [-1, 0, 0]</p><p>13 [0.525731, 0, -0.850651] [-0.525731, 0, -0.850651] [0, 0.850651, -0.525731] [-0.309017, 0.5, -0.809017] [0.309017, 0.5, -0.809017] [0, 0, -1]</p><p>14 [-0.850651, 0.525731, 0] [0, 0.850651, -0.525731] [-0.525731, 0, -0.850651] [-0.309017, 0.5, -0.809017] [-0.809017, 0.309017, -0.5] [-0.5, 0.809017, -0.309017]</p><p>15 [0, 0.850651, 0.525731] [0, 0.850651, -0.525731] [-0.850651, 0.525731, 0] [-0.5, 0.809017, -0.309017] [-0.5, 0.809017, 0.309017] [0, 1, 0]</p><p>16 [-0.850651, 0.525731, 0] [-0.525731, 0, 0.850651] [0, 0.850651, 0.525731] [-0.309017, 0.5, 0.809017] [-0.5, 0.809017, 0.309017] [-0.809017, 0.309017, 0.5]</p><p>17 [0, 0.850651, -0.525731] [0.850651, 0.525731, 0] [0.525731, 0, -0.850651] [0.809017, 0.309017, -0.5] [0.309017, 0.5, -0.809017] [0.5, 0.809017, -0.309017]</p><p>18 [0, 0.850651, -0.525731] [0, 0.850651, 0.525731] [0.850651, 0.525731, 0] [0.5, 0.809017, 0.309017] [0.5, 0.809017, -0.309017] [0, 1, 0]</p><p>19 [0, 0.850651, 0.525731] [0.525731, 0, 0.850651] [0.850651, 0.525731, 0] [0.809017, 0.309017, 0.5] [0.5, 0.809017, 0.309017] [0.309017, 0.5, 0.809017]</p><p>20 [-0.525731, 0, 0.850651] [0.525731, 0, 0.850651] [0, 0.850651, 0.525731] [0.309017, 0.5, 0.809017] [-0.309017, 0.5, 0.809017] [0, 0, 1]</p><hr><p>然后才进入了下面的程序</p><p>StarMgr::init()<br>        StelGeodesicGrid::visitTriangles 被调用1次 调用20次函数<br>                StelGeodesicGrid::visitTriangles 被调用20次 再每次调用自身4次函数<br>                        (*func)(lev, index, c0, c1, c2, context);<br>                        initTriangleFunc （StarMgr.hpp）<br>                                StarMgr::initTriangle 被调用1次<br>                                        ZoneArray::initTriangle </p><p>​        </p><p>需要注意调用了100次的 StelGeodesicGrid::visitTriangles 中的 Triangle &amp;t(triangles [ lev ] [ index ] );</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triangle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">Vec3f e0,e1,e2;   <span class="comment">// Seitenmittelpunkte</span></span><br><span class="line">&#125;;</span><br><span class="line">Triangle **triangles;</span><br></pre></td></tr></table></figure><p>triangles变量在StelGeodesicGrid::initTriangle中已经定义过</p><p>checkAndLoadCatal  visitTriangles  1</p><p> 1  z-&gt;center [0.934172, 0, -0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [0.850651, 0.525731, 0] c1 [0.850651, -0.525731, 0] c2 [0.525731, 0, -0.850651]</p><p> 2  z-&gt;center [0.939124, 0.294748, -0.176549] z-&gt;axis0 [-0.299452, 0.954111, 0]  z-&gt;axis1 [0.168448, 0.052868, 0.984292] star_position_scale 0.361541 c0 [0.850651, 0.525731, 0] c1 [1, 0, 0] c2 [0.809017, 0.309017, -0.5]</p><p> 3  z-&gt;center [0.939124, -0.294748, -0.176549] z-&gt;axis0 [0.299452, 0.954111, 0]  z-&gt;axis1 [0.168448, -0.052868, 0.984292] star_position_scale 0.361541 c0 [1, 0, 0] c1 [0.850651, -0.525731, 0] c2 [0.809017, -0.309017, -0.5]</p><p> 4  z-&gt;center [0.75696, 0, -0.653462] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [0.653462, 0, 0.75696] star_position_scale 0.361541 c0 [0.809017, 0.309017, -0.5] c1 [0.809017, -0.309017, -0.5] c2 [0.525731, 0, -0.850651]</p><p> 5  z-&gt;center [0.934172, 0, -0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [0.809017, -0.309017, -0.5] c1 [0.809017, 0.309017, -0.5] c2 [1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  2</p><p> 6  z-&gt;center [0.934172, 0, 0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [0.850651, -0.525731, 0] c1 [0.850651, 0.525731, 0] c2 [0.525731, 0, 0.850651]</p><p> 7  z-&gt;center [0.939124, -0.294748, 0.176549] z-&gt;axis0 [0.299452, 0.954111, 0]  z-&gt;axis1 [-0.168448, 0.052868, 0.984292] star_position_scale 0.381966 c0 [0.850651, -0.525731, 0] c1 [1, 0, 0] c2 [0.809017, -0.309017, 0.5]</p><p> 8  z-&gt;center [0.939124, 0.294748, 0.176549] z-&gt;axis0 [-0.299452, 0.954111, 0]  z-&gt;axis1 [-0.168448, -0.052868, 0.984292] star_position_scale 0.381966 c0 [1, 0, 0] c1 [0.850651, 0.525731, 0] c2 [0.809017, 0.309017, 0.5]</p><p> 9  z-&gt;center [0.75696, 0, 0.653462] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [-0.653462, 0, 0.75696] star_position_scale 0.381966 c0 [0.809017, -0.309017, 0.5] c1 [0.809017, 0.309017, 0.5] c2 [0.525731, 0, 0.850651]</p><p> 10  z-&gt;center [0.934172, 0, 0.356822] z-&gt;axis0 [0, 1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [0.809017, 0.309017, 0.5] c1 [0.809017, -0.309017, 0.5] c2 [1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  3</p><p> 11  z-&gt;center [0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [0.850651, -0.525731, 0] c1 [0.525731, 0, 0.850651] c2 [0, -0.850651, 0.525731]</p><p> 12  z-&gt;center [0.762575, -0.580411, 0.285662] z-&gt;axis0 [0.605648, 0.795733, 0]  z-&gt;axis1 [-0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [0.850651, -0.525731, 0] c1 [0.809017, -0.309017, 0.5] c2 [0.5, -0.809017, 0.309017]</p><p> 13  z-&gt;center [0.580411, -0.285662, 0.762575] z-&gt;axis0 [0.441587, 0.897219, 0]  z-&gt;axis1 [-0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [0.809017, -0.309017, 0.5] c1 [0.525731, 0, 0.850651] c2 [0.309017, -0.5, 0.809017]</p><p> 14  z-&gt;center [0.285662, -0.762575, 0.580411] z-&gt;axis0 [0.936452, 0.350797, 0]  z-&gt;axis1 [-0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [0.5, -0.809017, 0.309017] c1 [0.309017, -0.5, 0.809017] c2 [0, -0.850651, 0.525731]</p><p> 15  z-&gt;center [0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [0.309017, -0.5, 0.809017] c1 [0.5, -0.809017, 0.309017] c2 [0.809017, -0.309017, 0.5]</p><p>checkAndLoadCatal  visitTriangles  4</p><p> 16  z-&gt;center [0, -0.356822, 0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.763932 c0 [0.525731, 0, 0.850651] c1 [-0.525731, 0, 0.850651] c2 [0, -0.850651, 0.525731]</p><p> 17  z-&gt;center [0.294748, -0.176549, 0.939124] z-&gt;axis0 [0.513854, 0.857878, 0]  z-&gt;axis1 [-0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0.525731, 0, 0.850651] c1 [0, 0, 1] c2 [0.309017, -0.5, 0.809017]</p><p> 18  z-&gt;center [-0.294748, -0.176549, 0.939124] z-&gt;axis0 [0.513854, -0.857878, 0]  z-&gt;axis1 [0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, 1] c1 [-0.525731, 0, 0.850651] c2 [-0.309017, -0.5, 0.809017]</p><p> 19  z-&gt;center [0, -0.653462, 0.75696] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, 0.75696, 0.653462] star_position_scale 0.381966 c0 [0.309017, -0.5, 0.809017] c1 [-0.309017, -0.5, 0.809017] c2 [0, -0.850651, 0.525731]</p><p> 20  z-&gt;center [0, -0.356822, 0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.381966 c0 [-0.309017, -0.5, 0.809017] c1 [0.309017, -0.5, 0.809017] c2 [0, 0, 1]</p><p>checkAndLoadCatal  visitTriangles  5</p><p> 21  z-&gt;center [0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [0.850651, -0.525731, 0] c1 [0, -0.850651, -0.525731] c2 [0.525731, 0, -0.850651]</p><p> 22  z-&gt;center [0.762575, -0.580411, -0.285662] z-&gt;axis0 [0.605648, 0.795733, 0]  z-&gt;axis1 [0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [0.850651, -0.525731, 0] c1 [0.5, -0.809017, -0.309017] c2 [0.809017, -0.309017, -0.5]</p><p> 23  z-&gt;center [0.285662, -0.762575, -0.580411] z-&gt;axis0 [0.936452, 0.350797, 0]  z-&gt;axis1 [0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [0.5, -0.809017, -0.309017] c1 [0, -0.850651, -0.525731] c2 [0.309017, -0.5, -0.809017]</p><p> 24  z-&gt;center [0.580411, -0.285662, -0.762575] z-&gt;axis0 [0.441587, 0.897219, 0]  z-&gt;axis1 [0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [0.809017, -0.309017, -0.5] c1 [0.309017, -0.5, -0.809017] c2 [0.525731, 0, -0.850651]</p><p> 25  z-&gt;center [0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [0.309017, -0.5, -0.809017] c1 [0.809017, -0.309017, -0.5] c2 [0.5, -0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  6</p><p> 26  z-&gt;center [0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, -0.850651, 0.525731] c1 [0, -0.850651, -0.525731] c2 [0.850651, -0.525731, 0]</p><p> 27  z-&gt;center [0.176549, -0.939124, 0.294748] z-&gt;axis0 [0.982784, 0.184757, 0]  z-&gt;axis1 [-0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -0.850651, 0.525731] c1 [0, -1, 0] c2 [0.5, -0.809017, 0.309017]</p><p> 28  z-&gt;center [0.176549, -0.939124, -0.294748] z-&gt;axis0 [0.982784, 0.184757, 0]  z-&gt;axis1 [0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -1, 0] c1 [0, -0.850651, -0.525731] c2 [0.5, -0.809017, -0.309017]</p><p> 29  z-&gt;center [0.653462, -0.75696, 0] z-&gt;axis0 [0.75696, 0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, -0.809017, 0.309017] c1 [0.5, -0.809017, -0.309017] c2 [0.850651, -0.525731, 0]</p><p> 30  z-&gt;center [0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, -0.809017, -0.309017] c1 [0.5, -0.809017, 0.309017] c2 [0, -1, 0]</p><p>checkAndLoadCatal  visitTriangles  7</p><p> 31  z-&gt;center [-0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, -0.850651, -0.525731] c1 [0, -0.850651, 0.525731] c2 [-0.850651, -0.525731, 0]</p><p> 32  z-&gt;center [-0.176549, -0.939124, -0.294748] z-&gt;axis0 [0.982784, -0.184757, 0]  z-&gt;axis1 [-0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -0.850651, -0.525731] c1 [0, -1, 0] c2 [-0.5, -0.809017, -0.309017]</p><p> 33  z-&gt;center [-0.176549, -0.939124, 0.294748] z-&gt;axis0 [0.982784, -0.184757, 0]  z-&gt;axis1 [0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, -1, 0] c1 [0, -0.850651, 0.525731] c2 [-0.5, -0.809017, 0.309017]</p><p> 34  z-&gt;center [-0.653462, -0.75696, 0] z-&gt;axis0 [0.75696, -0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, -0.809017, -0.309017] c1 [-0.5, -0.809017, 0.309017] c2 [-0.850651, -0.525731, 0]</p><p> 35  z-&gt;center [-0.356822, -0.934172, 0] z-&gt;axis0 [0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, -0.809017, 0.309017] c1 [-0.5, -0.809017, -0.309017] c2 [0, -1, 0]</p><p>checkAndLoadCatal  visitTriangles  8</p><p> 36  z-&gt;center [-0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [0, -0.850651, 0.525731] c1 [-0.525731, 0, 0.850651] c2 [-0.850651, -0.525731, 0]</p><p> 37  z-&gt;center [-0.285662, -0.762575, 0.580411] z-&gt;axis0 [0.936452, -0.350797, 0]  z-&gt;axis1 [0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [0, -0.850651, 0.525731] c1 [-0.309017, -0.5, 0.809017] c2 [-0.5, -0.809017, 0.309017]</p><p> 38  z-&gt;center [-0.580411, -0.285662, 0.762575] z-&gt;axis0 [0.441587, -0.897219, 0]  z-&gt;axis1 [0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.309017, -0.5, 0.809017] c1 [-0.525731, 0, 0.850651] c2 [-0.809017, -0.309017, 0.5]</p><p> 39  z-&gt;center [-0.762575, -0.580411, 0.285662] z-&gt;axis0 [0.605648, -0.795733, 0]  z-&gt;axis1 [0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.5, -0.809017, 0.309017] c1 [-0.809017, -0.309017, 0.5] c2 [-0.850651, -0.525731, 0]</p><p> 40  z-&gt;center [-0.57735, -0.57735, 0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.809017, -0.309017, 0.5] c1 [-0.5, -0.809017, 0.309017] c2 [-0.309017, -0.5, 0.809017]</p><p>checkAndLoadCatal  visitTriangles  9</p><p> 41  z-&gt;center [0, -0.356822, -0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.763932 c0 [-0.525731, 0, -0.850651] c1 [0.525731, 0, -0.850651] c2 [0, -0.850651, -0.525731]</p><p> 42  z-&gt;center [-0.294748, -0.176549, -0.939124] z-&gt;axis0 [0.513854, -0.857878, 0]  z-&gt;axis1 [-0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [-0.525731, 0, -0.850651] c1 [0, 0, -1] c2 [-0.309017, -0.5, -0.809017]</p><p> 43  z-&gt;center [0.294748, -0.176549, -0.939124] z-&gt;axis0 [0.513854, 0.857878, 0]  z-&gt;axis1 [0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, -1] c1 [0.525731, 0, -0.850651] c2 [0.309017, -0.5, -0.809017]</p><p> 44  z-&gt;center [0, -0.653462, -0.75696] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, -0.75696, 0.653462] star_position_scale 0.381966 c0 [-0.309017, -0.5, -0.809017] c1 [0.309017, -0.5, -0.809017] c2 [0, -0.850651, -0.525731]</p><p> 45  z-&gt;center [0, -0.356822, -0.934172] z-&gt;axis0 [1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.381966 c0 [0.309017, -0.5, -0.809017] c1 [-0.309017, -0.5, -0.809017] c2 [0, 0, -1]</p><p>checkAndLoadCatal  visitTriangles  10</p><p> 46  z-&gt;center [-0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [0, -0.850651, -0.525731] c1 [-0.850651, -0.525731, 0] c2 [-0.525731, 0, -0.850651]</p><p> 47  z-&gt;center [-0.285662, -0.762575, -0.580411] z-&gt;axis0 [0.936452, -0.350797, 0]  z-&gt;axis1 [-0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [0, -0.850651, -0.525731] c1 [-0.5, -0.809017, -0.309017] c2 [-0.309017, -0.5, -0.809017]</p><p> 48  z-&gt;center [-0.762575, -0.580411, -0.285662] z-&gt;axis0 [0.605648, -0.795733, 0]  z-&gt;axis1 [-0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.5, -0.809017, -0.309017] c1 [-0.850651, -0.525731, 0] c2 [-0.809017, -0.309017, -0.5]</p><p> 49  z-&gt;center [-0.580411, -0.285662, -0.762575] z-&gt;axis0 [0.441587, -0.897219, 0]  z-&gt;axis1 [-0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.309017, -0.5, -0.809017] c1 [-0.809017, -0.309017, -0.5] c2 [-0.525731, 0, -0.850651]</p><p> 50  z-&gt;center [-0.57735, -0.57735, -0.57735] z-&gt;axis0 [0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.809017, -0.309017, -0.5] c1 [-0.309017, -0.5, -0.809017] c2 [-0.5, -0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  11</p><p> 51  z-&gt;center [-0.934172, 0, -0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [-0.850651, -0.525731, 0] c1 [-0.850651, 0.525731, 0] c2 [-0.525731, 0, -0.850651]</p><p> 52  z-&gt;center [-0.939124, -0.294748, -0.176549] z-&gt;axis0 [0.299452, -0.954111, 0]  z-&gt;axis1 [-0.168448, -0.052868, 0.984292] star_position_scale 0.381966 c0 [-0.850651, -0.525731, 0] c1 [-1, 0, 0] c2 [-0.809017, -0.309017, -0.5]</p><p> 53  z-&gt;center [-0.939124, 0.294748, -0.176549] z-&gt;axis0 [-0.299452, -0.954111, 0]  z-&gt;axis1 [-0.168448, 0.052868, 0.984292] star_position_scale 0.381966 c0 [-1, 0, 0] c1 [-0.850651, 0.525731, 0] c2 [-0.809017, 0.309017, -0.5]</p><p> 54  z-&gt;center [-0.75696, 0, -0.653462] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [-0.653462, 0, 0.75696] star_position_scale 0.381966 c0 [-0.809017, -0.309017, -0.5] c1 [-0.809017, 0.309017, -0.5] c2 [-0.525731, 0, -0.850651]</p><p> 55  z-&gt;center [-0.934172, 0, -0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [-0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [-0.809017, 0.309017, -0.5] c1 [-0.809017, -0.309017, -0.5] c2 [-1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  12</p><p> 56  z-&gt;center [-0.934172, 0, 0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.763932 c0 [-0.850651, 0.525731, 0] c1 [-0.850651, -0.525731, 0] c2 [-0.525731, 0, 0.850651]</p><p> 57  z-&gt;center [-0.939124, 0.294748, 0.176549] z-&gt;axis0 [-0.299452, -0.954111, 0]  z-&gt;axis1 [0.168448, -0.052868, 0.984292] star_position_scale 0.381966 c0 [-0.850651, 0.525731, 0] c1 [-1, 0, 0] c2 [-0.809017, 0.309017, 0.5]</p><p> 58  z-&gt;center [-0.939124, -0.294748, 0.176549] z-&gt;axis0 [0.299452, -0.954111, 0]  z-&gt;axis1 [0.168448, 0.052868, 0.984292] star_position_scale 0.381966 c0 [-1, 0, 0] c1 [-0.850651, -0.525731, 0] c2 [-0.809017, -0.309017, 0.5]</p><p> 59  z-&gt;center [-0.75696, 0, 0.653462] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [0.653462, 0, 0.75696] star_position_scale 0.381966 c0 [-0.809017, 0.309017, 0.5] c1 [-0.809017, -0.309017, 0.5] c2 [-0.525731, 0, 0.850651]</p><p> 60  z-&gt;center [-0.934172, 0, 0.356822] z-&gt;axis0 [0, -1, 0]  z-&gt;axis1 [0.356822, 0, 0.934172] star_position_scale 0.381966 c0 [-0.809017, -0.309017, 0.5] c1 [-0.809017, 0.309017, 0.5] c2 [-1, 0, 0]</p><p>checkAndLoadCatal  visitTriangles  13</p><p> 61  z-&gt;center [0, 0.356822, -0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.763932 c0 [0.525731, 0, -0.850651] c1 [-0.525731, 0, -0.850651] c2 [0, 0.850651, -0.525731]</p><p> 62  z-&gt;center [0.294748, 0.176549, -0.939124] z-&gt;axis0 [-0.513854, 0.857878, 0]  z-&gt;axis1 [0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0.525731, 0, -0.850651] c1 [0, 0, -1] c2 [0.309017, 0.5, -0.809017]</p><p> 63  z-&gt;center [-0.294748, 0.176549, -0.939124] z-&gt;axis0 [-0.513854, -0.857878, 0]  z-&gt;axis1 [-0.805654, 0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, -1] c1 [-0.525731, 0, -0.850651] c2 [-0.309017, 0.5, -0.809017]</p><p> 64  z-&gt;center [0, 0.653462, -0.75696] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, 0.75696, 0.653462] star_position_scale 0.381966 c0 [0.309017, 0.5, -0.809017] c1 [-0.309017, 0.5, -0.809017] c2 [0, 0.850651, -0.525731]</p><p> 65  z-&gt;center [0, 0.356822, -0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, 0.934172, 0.356822] star_position_scale 0.381966 c0 [-0.309017, 0.5, -0.809017] c1 [0.309017, 0.5, -0.809017] c2 [0, 0, -1]</p><p>checkAndLoadCatal  visitTriangles  14</p><p> 66  z-&gt;center [-0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [-0.850651, 0.525731, 0] c1 [0, 0.850651, -0.525731] c2 [-0.525731, 0, -0.850651]</p><p> 67  z-&gt;center [-0.762575, 0.580411, -0.285662] z-&gt;axis0 [-0.605648, -0.795733, 0]  z-&gt;axis1 [-0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.850651, 0.525731, 0] c1 [-0.5, 0.809017, -0.309017] c2 [-0.809017, 0.309017, -0.5]</p><p> 68  z-&gt;center [-0.285662, 0.762575, -0.580411] z-&gt;axis0 [-0.936452, -0.350797, 0]  z-&gt;axis1 [-0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [-0.5, 0.809017, -0.309017] c1 [0, 0.850651, -0.525731] c2 [-0.309017, 0.5, -0.809017]</p><p> 69  z-&gt;center [-0.580411, 0.285662, -0.762575] z-&gt;axis0 [-0.441587, -0.897219, 0]  z-&gt;axis1 [-0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.809017, 0.309017, -0.5] c1 [-0.309017, 0.5, -0.809017] c2 [-0.525731, 0, -0.850651]</p><p> 70  z-&gt;center [-0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [-0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.309017, 0.5, -0.809017] c1 [-0.809017, 0.309017, -0.5] c2 [-0.5, 0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  15</p><p> 71  z-&gt;center [-0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, 0.850651, 0.525731] c1 [0, 0.850651, -0.525731] c2 [-0.850651, 0.525731, 0]</p><p> 72  z-&gt;center [-0.176549, 0.939124, 0.294748] z-&gt;axis0 [-0.982784, -0.184757, 0]  z-&gt;axis1 [0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 0.850651, 0.525731] c1 [0, 1, 0] c2 [-0.5, 0.809017, 0.309017]</p><p> 73  z-&gt;center [-0.176549, 0.939124, -0.294748] z-&gt;axis0 [-0.982784, -0.184757, 0]  z-&gt;axis1 [-0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 1, 0] c1 [0, 0.850651, -0.525731] c2 [-0.5, 0.809017, -0.309017]</p><p> 74  z-&gt;center [-0.653462, 0.75696, 0] z-&gt;axis0 [-0.75696, -0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, 0.809017, 0.309017] c1 [-0.5, 0.809017, -0.309017] c2 [-0.850651, 0.525731, 0]</p><p> 75  z-&gt;center [-0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, -0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [-0.5, 0.809017, -0.309017] c1 [-0.5, 0.809017, 0.309017] c2 [0, 1, 0]</p><p>checkAndLoadCatal  visitTriangles  16</p><p> 76  z-&gt;center [-0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [-0.850651, 0.525731, 0] c1 [-0.525731, 0, 0.850651] c2 [0, 0.850651, 0.525731]</p><p> 77  z-&gt;center [-0.762575, 0.580411, 0.285662] z-&gt;axis0 [-0.605648, -0.795733, 0]  z-&gt;axis1 [0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [-0.850651, 0.525731, 0] c1 [-0.809017, 0.309017, 0.5] c2 [-0.5, 0.809017, 0.309017]</p><p> 78  z-&gt;center [-0.580411, 0.285662, 0.762575] z-&gt;axis0 [-0.441587, -0.897219, 0]  z-&gt;axis1 [0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [-0.809017, 0.309017, 0.5] c1 [-0.525731, 0, 0.850651] c2 [-0.309017, 0.5, 0.809017]</p><p> 79  z-&gt;center [-0.285662, 0.762575, 0.580411] z-&gt;axis0 [-0.936452, -0.350797, 0]  z-&gt;axis1 [0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [-0.5, 0.809017, 0.309017] c1 [-0.309017, 0.5, 0.809017] c2 [0, 0.850651, 0.525731]</p><p> 80  z-&gt;center [-0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, -0.707107, 0]  z-&gt;axis1 [0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [-0.309017, 0.5, 0.809017] c1 [-0.5, 0.809017, 0.309017] c2 [-0.809017, 0.309017, 0.5]</p><p>checkAndLoadCatal  visitTriangles  17</p><p> 81  z-&gt;center [0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.763932 c0 [0, 0.850651, -0.525731] c1 [0.850651, 0.525731, 0] c2 [0.525731, 0, -0.850651]</p><p> 82  z-&gt;center [0.285662, 0.762575, -0.580411] z-&gt;axis0 [-0.936452, 0.350797, 0]  z-&gt;axis1 [0.203606, 0.543526, 0.814324] star_position_scale 0.381966 c0 [0, 0.850651, -0.525731] c1 [0.5, 0.809017, -0.309017] c2 [0.309017, 0.5, -0.809017]</p><p> 83  z-&gt;center [0.762575, 0.580411, -0.285662] z-&gt;axis0 [-0.605648, 0.795733, 0]  z-&gt;axis1 [0.227311, 0.173011, 0.95833] star_position_scale 0.381966 c0 [0.5, 0.809017, -0.309017] c1 [0.850651, 0.525731, 0] c2 [0.809017, 0.309017, -0.5]</p><p> 84  z-&gt;center [0.580411, 0.285662, -0.762575] z-&gt;axis0 [-0.441587, 0.897219, 0]  z-&gt;axis1 [0.684196, 0.336743, 0.6469] star_position_scale 0.381966 c0 [0.309017, 0.5, -0.809017] c1 [0.809017, 0.309017, -0.5] c2 [0.525731, 0, -0.850651]</p><p> 85  z-&gt;center [0.57735, 0.57735, -0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [0.408248, 0.408248, 0.816497] star_position_scale 0.381966 c0 [0.809017, 0.309017, -0.5] c1 [0.309017, 0.5, -0.809017] c2 [0.5, 0.809017, -0.309017]</p><p>checkAndLoadCatal  visitTriangles  18</p><p> 86  z-&gt;center [0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.763932 c0 [0, 0.850651, -0.525731] c1 [0, 0.850651, 0.525731] c2 [0.850651, 0.525731, 0]</p><p> 87  z-&gt;center [0.176549, 0.939124, -0.294748] z-&gt;axis0 [-0.982784, 0.184757, 0]  z-&gt;axis1 [0.0544568, 0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 0.850651, -0.525731] c1 [0, 1, 0] c2 [0.5, 0.809017, -0.309017]</p><p> 88  z-&gt;center [0.176549, 0.939124, 0.294748] z-&gt;axis0 [-0.982784, 0.184757, 0]  z-&gt;axis1 [-0.0544568, -0.289674, 0.955575] star_position_scale 0.381966 c0 [0, 1, 0] c1 [0, 0.850651, 0.525731] c2 [0.5, 0.809017, 0.309017]</p><p> 89  z-&gt;center [0.653462, 0.75696, 0] z-&gt;axis0 [-0.75696, 0.653462, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, 0.809017, -0.309017] c1 [0.5, 0.809017, 0.309017] c2 [0.850651, 0.525731, 0]</p><p> 90  z-&gt;center [0.356822, 0.934172, 0] z-&gt;axis0 [-0.934172, 0.356822, 0]  z-&gt;axis1 [0, 0, 1] star_position_scale 0.381966 c0 [0.5, 0.809017, 0.309017] c1 [0.5, 0.809017, -0.309017] c2 [0, 1, 0]</p><p>checkAndLoadCatal  visitTriangles  19</p><p> 91  z-&gt;center [0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.763932 c0 [0, 0.850651, 0.525731] c1 [0.525731, 0, 0.850651] c2 [0.850651, 0.525731, 0]</p><p> 92  z-&gt;center [0.285662, 0.762575, 0.580411] z-&gt;axis0 [-0.936452, 0.350797, 0]  z-&gt;axis1 [-0.203606, -0.543526, 0.814324] star_position_scale 0.381966 c0 [0, 0.850651, 0.525731] c1 [0.309017, 0.5, 0.809017] c2 [0.5, 0.809017, 0.309017]</p><p> 93  z-&gt;center [0.580411, 0.285662, 0.762575] z-&gt;axis0 [-0.441587, 0.897219, 0]  z-&gt;axis1 [-0.684196, -0.336743, 0.6469] star_position_scale 0.381966 c0 [0.309017, 0.5, 0.809017] c1 [0.525731, 0, 0.850651] c2 [0.809017, 0.309017, 0.5]</p><p> 94  z-&gt;center [0.762575, 0.580411, 0.285662] z-&gt;axis0 [-0.605648, 0.795733, 0]  z-&gt;axis1 [-0.227311, -0.173011, 0.95833] star_position_scale 0.381966 c0 [0.5, 0.809017, 0.309017] c1 [0.809017, 0.309017, 0.5] c2 [0.850651, 0.525731, 0]</p><p> 95  z-&gt;center [0.57735, 0.57735, 0.57735] z-&gt;axis0 [-0.707107, 0.707107, 0]  z-&gt;axis1 [-0.408248, -0.408248, 0.816497] star_position_scale 0.381966 c0 [0.809017, 0.309017, 0.5] c1 [0.5, 0.809017, 0.309017] c2 [0.309017, 0.5, 0.809017]</p><p>checkAndLoadCatal  visitTriangles  20</p><p> 96  z-&gt;center [0, 0.356822, 0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.763932 c0 [-0.525731, 0, 0.850651] c1 [0.525731, 0, 0.850651] c2 [0, 0.850651, 0.525731]</p><p> 97  z-&gt;center [-0.294748, 0.176549, 0.939124] z-&gt;axis0 [-0.513854, -0.857878, 0]  z-&gt;axis1 [0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [-0.525731, 0, 0.850651] c1 [0, 0, 1] c2 [-0.309017, 0.5, 0.809017]</p><p> 98  z-&gt;center [0.294748, 0.176549, 0.939124] z-&gt;axis0 [-0.513854, 0.857878, 0]  z-&gt;axis1 [-0.805654, -0.482573, 0.343578] star_position_scale 0.381966 c0 [0, 0, 1] c1 [0.525731, 0, 0.850651] c2 [0.309017, 0.5, 0.809017]</p><p> 99  z-&gt;center [0, 0.653462, 0.75696] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, -0.75696, 0.653462] star_position_scale 0.381966 c0 [-0.309017, 0.5, 0.809017] c1 [0.309017, 0.5, 0.809017] c2 [0, 0.850651, 0.525731]</p><p> 100  z-&gt;center [0, 0.356822, 0.934172] z-&gt;axis0 [-1, 0, 0]  z-&gt;axis1 [0, -0.934172, 0.356822] star_position_scale 0.381966 c0 [0.309017, 0.5, 0.809017] c1 [-0.309017, 0.5, 0.809017] c2 [0, 0, 1]</p><p><strong>重点结论：star_position_scale = 0.763932</strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">mu0 = (A(<span class="number">11</span>,:) - center(<span class="number">1</span>,:)) * axis0.&#x27;;</span><br><span class="line">mu1 = (A(<span class="number">11</span>,:) - center(<span class="number">1</span>,:)) * axis1.&#x27;;</span><br><span class="line">f = <span class="number">1</span>/(<span class="built_in">sqrt</span>(<span class="number">1</span>-mu0^<span class="number">2</span> -mu1^<span class="number">2</span>));</span><br><span class="line">h = <span class="built_in">abs</span>(mu1)*f;</span><br></pre></td></tr></table></figure><hr><p>梳理好顺序之后，可以进入ZoneArray::initTriangle中进行查看，尝试第一个中点和轴的信息。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% plot_triangle.m </span></span><br><span class="line"><span class="comment">% 12个顶点，30条棱，20个面</span></span><br><span class="line">clear all; close all;</span><br><span class="line">m = <span class="built_in">sqrt</span>(<span class="number">50</span><span class="number">-10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">n = <span class="built_in">sqrt</span>(<span class="number">50</span>+<span class="number">10</span>*<span class="built_in">sqrt</span>(<span class="number">5</span>))/<span class="number">10</span>;</span><br><span class="line">A = [ <span class="comment">% 12个顶点</span></span><br><span class="line">    n,-m,<span class="number">0</span>;</span><br><span class="line">    n,m,<span class="number">0</span>;</span><br><span class="line">    -n,m,<span class="number">0</span>;</span><br><span class="line">    -n,-m,<span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>,n,-m;</span><br><span class="line">    <span class="number">0</span>,n,m;</span><br><span class="line">    <span class="number">0</span>,-n,m;</span><br><span class="line">    <span class="number">0</span>,-n,-m;</span><br><span class="line">    -m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,n;</span><br><span class="line">    m,<span class="number">0</span>,-n;</span><br><span class="line">    -m,<span class="number">0</span>,-n;</span><br><span class="line">    ];</span><br><span class="line"><span class="built_in">scatter3</span>(A(:,<span class="number">1</span>),A(:,<span class="number">2</span>),A(:,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">center=[];c0=[];c1=[];c2=[];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">1</span>,<span class="number">0</span>,<span class="number">10</span>); <span class="comment">% 20个面</span></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">0</span>,<span class="number">9</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">0</span>,<span class="number">7</span>,<span class="number">10</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">7</span>,<span class="number">6</span>,<span class="number">3</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">11</span>,<span class="number">10</span>,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">7</span>,<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">3</span>,<span class="number">2</span>,<span class="number">11</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">10</span>,<span class="number">11</span>,<span class="number">4</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">2</span>,<span class="number">4</span>,<span class="number">11</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">2</span>,<span class="number">8</span>,<span class="number">5</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">4</span>,<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">5</span>,<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line">[center(<span class="keyword">end</span>+<span class="number">1</span>,:),c0(<span class="keyword">end</span>+<span class="number">1</span>,:),c1(<span class="keyword">end</span>+<span class="number">1</span>,:),c2(<span class="keyword">end</span>+<span class="number">1</span>,:)] = plot_triangle(A,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">text(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">text(A(<span class="number">2</span>,<span class="number">1</span>),A(<span class="number">2</span>,<span class="number">2</span>),A(<span class="number">2</span>,<span class="number">3</span>),<span class="string">&#x27;c0&#x27;</span>);</span><br><span class="line">text(A(<span class="number">1</span>,<span class="number">1</span>),A(<span class="number">1</span>,<span class="number">2</span>),A(<span class="number">1</span>,<span class="number">3</span>),<span class="string">&#x27;c1&#x27;</span>);</span><br><span class="line">text(A(<span class="number">11</span>,<span class="number">1</span>),A(<span class="number">11</span>,<span class="number">2</span>),A(<span class="number">11</span>,<span class="number">3</span>),<span class="string">&#x27;c2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">d1=<span class="number">2</span>;d2=<span class="number">1</span>;d3=<span class="number">11</span>;</span><br><span class="line">line([A(d1,<span class="number">1</span>),A(d2,<span class="number">1</span>),A(d3,<span class="number">1</span>),A(d1,<span class="number">1</span>)],[A(d1,<span class="number">2</span>),A(d2,<span class="number">2</span>),A(d3,<span class="number">2</span>),A(d1,<span class="number">2</span>)],[A(d1,<span class="number">3</span>),A(d2,<span class="number">3</span>),A(d3,<span class="number">3</span>),A(d1,<span class="number">3</span>)],<span class="string">&#x27;color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(center(<span class="number">1</span>,<span class="number">1</span>),center(<span class="number">1</span>,<span class="number">2</span>),center(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">axis0 = <span class="built_in">cross</span>([<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],center(<span class="number">1</span>,:));</span><br><span class="line">axis0 = axis0./norm(axis0);</span><br><span class="line">axis1 = <span class="built_in">cross</span>(center(<span class="number">1</span>,:),axis0);</span><br><span class="line">axis1 = axis1./norm(axis1);</span><br><span class="line">quiver3(center(<span class="number">1</span>,<span class="number">1</span>),center(<span class="number">1</span>,<span class="number">2</span>),center(<span class="number">1</span>,<span class="number">3</span>),axis0(<span class="number">1</span>,<span class="number">1</span>),axis0(<span class="number">1</span>,<span class="number">2</span>),axis0(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line">quiver3(center(<span class="number">1</span>,<span class="number">1</span>),center(<span class="number">1</span>,<span class="number">2</span>),center(<span class="number">1</span>,<span class="number">3</span>),axis1(<span class="number">1</span>,<span class="number">1</span>),axis1(<span class="number">1</span>,<span class="number">2</span>),axis1(<span class="number">1</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">axis equal;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220313100715334.png" alt="image-20220313100715334"></p><p>​    // Initialize star_position_scale. This scale is used to multiply stars position<br>​    // encoded as integers so that it optimize precision over the triangle.<br>​    // It has to be computed for each triangle because the relative orientation of the 2 axis is different for each triangle.</p><p>// 初始化star_position_scale。 此比例用于乘以星星位置 </p><p>// 编码为整数，以便优化三角形的精度。 </p><p>// 必须为每个三角形计算它，因为每个三角形的 2 轴的相对方向不同。 </p><hr><p>MaxPosVal 2147483647=0x7fff ffff</p><p>20个大三角形 star_position_scale = 0.763932 </p><p>80个小三角形 star_position_scale 0.381966</p><p>在ZoneArray.cpp中 查看变量 star_position_scale</p><p>mag_min 这一层中星等的下界。单位:millimag（10−3）。对最亮的恒星可能是负的。-2000 和 6000 </p><p>mag_range 这一层星等的范围，都为12.8星等。单位:millimags</p><p>mag_steps 用于描述mag_range中的值的步骤数都为256 。总是正的。单个恒星的mag条目从0..mag_steps开始 256 12800/256=50 .每次移动 一步0.05mags，可以看到软件中最低分辨率为0.05星等。最多256步。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arg(level=<span class="number">0</span>和<span class="number">1</span>).arg(type=<span class="number">0</span>).arg(major=<span class="number">0</span>).arg(minor=<span class="number">8</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HipZoneArray</span> :</span> <span class="keyword">public</span> SpecialZoneArray&lt;Star1&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialZoneArray</span> :</span> <span class="keyword">public</span> ZoneArray</span><br><span class="line">    </span><br><span class="line">rval = <span class="keyword">new</span> HipZoneArray(file, byte_swap, use_mmap, level, mag_min, mag_range, mag_steps);</span><br><span class="line">SpecialZoneArray&lt;Star&gt;::SpecialZoneArray();        </span><br></pre></td></tr></table></figure><p>在该函数中，可以得到star.hpp中的信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          _______________</span><br><span class="line">0     x0 |               |</span><br><span class="line">1        |___________    |</span><br><span class="line">2     x1 |           |___|</span><br><span class="line">3        |_______        |</span><br><span class="line">4     bV |_______|_______|</span><br><span class="line">5    mag |_________|_____| bV</span><br><span class="line"></span><br><span class="line">int x0               :18</span><br><span class="line">int x1               :18</span><br><span class="line">unsigned int bV      :7</span><br><span class="line">unsigned int mag     :5</span><br></pre></td></tr></table></figure><hr><p>点鼠标一下，这是可以触发的函数。</p><p>StelObjectMgr::cleverFind<br>    StarMgr::searchAround 指向 放大倍率<br>        SpecialZoneArray&lt; Star&gt;::searchAround<br>            s-&gt;getJ2000Pos(z, static_cast&lt; float&gt;(movementFactor), tmp);</p><hr><p>注意到只有这里一次调用了星表里的26785=4979+21806个数据。</p><p>StarMgr::loadData<br>z-&gt;updateHipIndex(hipIndex);</p><p>​    HipZoneArray::updateHipIndex</p><p>因此在ZoneArray.cpp中仿写saveHipIndex函数为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HipZoneArray::saveHipIndex</span><span class="params">(HipIndexStruct hipIndex[])</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    StelCore* core = StelApp::getInstance().getCore();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> d2000 = <span class="number">2451545.0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> movementFactor = (M_PI / <span class="number">180.</span>) * (<span class="number">0.0001</span> / <span class="number">3600.</span>) * ((core-&gt;getJDE() - d2000) / <span class="number">365.25</span>) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(star_position_scale);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *z = getZones() + (nr_of_zones - <span class="number">1</span>); z &gt;= getZones(); z--) &#123; <span class="comment">// 100次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> Star1 *s = z-&gt;getStars() + z-&gt;size - <span class="number">1</span>; s &gt;= z-&gt;getStars(); s--) &#123;</span><br><span class="line">            Vec3f tmp;</span><br><span class="line">            s-&gt;getJ2000Pos(z, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(movementFactor), tmp);</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;checkAndLoadCatalogcheckAndLoadCatalog&quot;</span>  &lt;&lt; ++aa &lt;&lt;  s-&gt;getHip()  &lt;&lt; s-&gt;getX0() &lt;&lt; s-&gt;getX1() &lt;&lt; s-&gt;getDx0() &lt;&lt; s-&gt;getDx1() &lt;&lt; s-&gt;getBV() &lt;&lt; s-&gt;getMag()  &lt;&lt; s-&gt;getPlx() &lt;&lt; s-&gt;getSpInt() &lt;&lt; s-&gt;getBVIndex() &lt;&lt; s-&gt;hasName() &lt;&lt; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件的代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HipZoneArray::saveHipIndex</span><span class="params">(HipIndexStruct hipIndex[])</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">QFile  <span class="title">myFile</span><span class="params">(<span class="string">&quot;C:/Users/hp/Desktop/catalog.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (myFile.open(QFile::WriteOnly | QFile::Append | QIODevice::Text)) &#123;</span><br><span class="line">        <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;myFile)</span></span>;</span><br><span class="line">        StelCore* core = StelApp::getInstance().getCore();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> d2000 = <span class="number">2451545.0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">double</span> movementFactor = (M_PI / <span class="number">180.</span>) * (<span class="number">0.0001</span> / <span class="number">3600.</span>) * ((core-&gt;getJDE() - d2000) / <span class="number">365.25</span>) / <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(star_position_scale);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> SpecialZoneData&lt;Star1&gt; *z = getZones() + (nr_of_zones - <span class="number">1</span>); z &gt;= getZones(); z--) &#123; <span class="comment">// 100次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> Star1 *s = z-&gt;getStars() + z-&gt;size - <span class="number">1</span>; s &gt;= z-&gt;getStars(); s--) &#123;</span><br><span class="line">                Vec3f tmp;</span><br><span class="line">                s-&gt;getJ2000Pos(z, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(movementFactor), tmp);</span><br><span class="line">                tmp.normalize();</span><br><span class="line">                Vec3d vel = core-&gt;getCurrentPlanet()-&gt;getHeliocentricEclipticVelocity();</span><br><span class="line">                vel       = StelCore::matVsop87ToJ2000 * vel * core-&gt;getAberrationFactor() * (AU / (<span class="number">86400.0</span> * SPEED_OF_LIGHT));</span><br><span class="line">                Vec3d pos = tmp.toVec3d() + vel;</span><br><span class="line">                pos.normalize();</span><br><span class="line">                qDebug() &lt;&lt; <span class="string">&quot;checkAndLoadCatalogcheckAndLoadCatalog&quot;</span>  &lt;&lt; ++aa &lt;&lt; s-&gt;getHip()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getBV() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getMag()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getPlx() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getSpInt() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getBVIndex() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;hasName() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  tmp  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; z-&gt;getNrOfStars()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; star_position_scale &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                out  &lt;&lt;  aa &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getHip()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getBV() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getMag()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getPlx() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getSpInt() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getBVIndex() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;hasName() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  pos[<span class="number">0</span>] &lt;&lt;  <span class="string">&quot;  &quot;</span> &lt;&lt; pos[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  pos[<span class="number">2</span>]  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; z-&gt;getNrOfStars()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; star_position_scale &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    myFile.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在StarMgr.cpp的StarMgr::searchAround中添加</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qDebug() &lt;&lt; <span class="string">&quot;searchAround&quot;</span> &lt;&lt; ++bbbb &lt;&lt; vv &lt;&lt; limFov;</span><br><span class="line"><span class="keyword">if</span>(bbbb &gt;= <span class="number">23</span> )</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>* z : gridLevels)</span><br><span class="line">        z-&gt;saveHipIndex( hipIndex);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220316101930812.png" alt="image-20220316101930812"></p><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all;close all;clc;</span><br><span class="line">tic</span><br><span class="line">A = importdata(<span class="string">&quot;catalog.txt&quot;</span>);</span><br><span class="line">hip = A(:,<span class="number">2</span>);</span><br><span class="line">x0 = A(:,<span class="number">3</span>);</span><br><span class="line">x1 = A(:,<span class="number">4</span>);</span><br><span class="line">dx0 =  A(:,<span class="number">5</span>);</span><br><span class="line">dx1 =  A(:,<span class="number">6</span>);</span><br><span class="line">bv = A(:,<span class="number">7</span>);</span><br><span class="line">mag = A(:,<span class="number">8</span>);</span><br><span class="line">plx = A(:,<span class="number">9</span>);</span><br><span class="line">spInt = A(:,<span class="number">10</span>);</span><br><span class="line">bvIndex = A(:,<span class="number">11</span>);</span><br><span class="line">hasName = A(:,<span class="number">12</span>);</span><br><span class="line">xyz = A(:,<span class="number">13</span>:<span class="number">15</span>);</span><br><span class="line">level = A(:,<span class="number">16</span>);</span><br><span class="line">getNrOfStars = A(:,<span class="number">17</span>);</span><br><span class="line">star_position_scale = A(:,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">mag_<span class="built_in">true</span> = mag .* <span class="number">0.05</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="built_in">asind</span>(xyz(:,<span class="number">3</span>));</span><br><span class="line">a = <span class="built_in">acosd</span>(xyz(:,<span class="number">1</span>)./<span class="built_in">sqrt</span>(<span class="number">1</span>-xyz(:,<span class="number">3</span>).^<span class="number">2</span>));</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(b)</span><br><span class="line">    <span class="keyword">if</span>(xyz(<span class="built_in">i</span>,<span class="number">2</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        a(<span class="built_in">i</span>,:)=<span class="number">360</span>-a(<span class="built_in">i</span>,:);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span>(level(<span class="built_in">i</span>)==<span class="number">0</span>)</span><br><span class="line">        mag_<span class="built_in">true</span>(<span class="built_in">i</span>) = <span class="number">-2</span> + mag(<span class="built_in">i</span>) * <span class="number">0.05</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">hh1 = (a./<span class="number">15</span>);</span><br><span class="line">hh = <span class="built_in">fix</span>(hh1);</span><br><span class="line">mm1 = (a./<span class="number">15</span> - hh)*<span class="number">60</span>;</span><br><span class="line">mm = <span class="built_in">fix</span>(mm1);</span><br><span class="line">ss = (mm1 - mm)*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">al_hh = <span class="built_in">fix</span>(b);</span><br><span class="line">al_mm1 = (<span class="built_in">abs</span>(b)-<span class="built_in">abs</span>(al_hh))*<span class="number">60</span>;</span><br><span class="line">al_mm = <span class="built_in">fix</span>(al_mm1);</span><br><span class="line">al_ss = (al_mm1 - al_mm)*<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A=[A,a,b,hh,mm,ss,al_hh,al_mm,al_ss,mag_<span class="built_in">true</span>];</span><br><span class="line"></span><br><span class="line">xlswrite(<span class="string">&#x27;catal&#x27;</span>,A);</span><br><span class="line">toc</span><br></pre></td></tr></table></figure></h2><p>getJ2000Pos 函数</p><p>getJ2000EquatorialPos （StarWrapper.hpp）</p><p>只有StarWrapper.cpp 和 ZoneArray.cpp 包含 #include “StarWrapper.hpp”</p><p>ZoneArray.cpp<br>    StarMgr.hpp</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StelRegionObject</span> //抽象基类 </span></span><br><span class="line"><span class="class"><span class="title">virtual</span> <span class="title">Vec3d</span> <span class="title">getPointInRegion</span>() <span class="title">const</span>=</span><span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StelObject</span> :</span> <span class="keyword">public</span> StelRegionObject </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QString <span class="title">getInfoString</span><span class="params">(<span class="keyword">const</span> StelCore *, <span class="keyword">const</span> InfoStringGroup&amp; )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">//抽象基类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exoplanet</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeteorShower</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nova</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pulsar</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quasar</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Satellite</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Supernova</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TelescopeClient</span> :</span> <span class="keyword">public</span> QObject, <span class="keyword">public</span> StelObject</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientASCOM</span> :</span> <span class="keyword">public</span> TelescopeClient</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientINDI</span> :</span> <span class="keyword">public</span> TelescopeClient</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientDirectLx200</span> :</span> <span class="keyword">public</span> TelescopeClient, <span class="keyword">public</span> Server</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientDirectNexStar</span> :</span> <span class="keyword">public</span> TelescopeClient, <span class="keyword">public</span> Server</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">TelescopeClientJsonRts2</span> :</span> <span class="keyword">public</span> TelescopeClient</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Asterism</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Constellation</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CustomObject</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Nebula</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">NomenclatureItem</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Planet</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">            </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">StarWrapperBase</span> :</span> <span class="keyword">public</span> StelObject</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">StarWrapper</span> :</span> <span class="keyword">public</span> StarWrapperBase</span><br><span class="line">            <span class="function"><span class="keyword">virtual</span> Vec3d <span class="title">getJ2000EquatorialPos</span><span class="params">(<span class="keyword">const</span> StelCore * core)</span> <span class="keyword">const</span> Q_DECL_OVERRIDE</span></span><br><span class="line"><span class="function">           class StarWrapper1 : <span class="keyword">public</span> StarWrapper&lt;Star1&gt;</span></span><br><span class="line"><span class="function">                class StarWrapper2 : <span class="keyword">public</span> StarWrapper&lt;Star2&gt;</span></span><br><span class="line"><span class="function">                class StarWrapper3 : <span class="keyword">public</span> StarWrapper&lt;Star3&gt;</span></span><br></pre></td></tr></table></figure><hr><p>验证从二进制文件到赤经赤纬</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">qDebug() &lt;&lt; <span class="string">&quot;checkAndLoadCatalogcheckAndLoadCatalog&quot;</span>  &lt;&lt; ++aa &lt;&lt; s-&gt;getHip()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getX1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx0() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getDx1() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;getBV() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getMag()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getPlx() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getSpInt() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; s-&gt;getBVIndex() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  s-&gt;hasName() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt;  tmp  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; z-&gt;getNrOfStars()  &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; star_position_scale &lt;&lt; movementFactor &lt;&lt; core-&gt;getJDE() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220317144732768.png" alt="image-20220317144732768"></p><p>验证最后一个星</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s-&gt;getJ2000Pos(z, <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>&gt;(movementFactor), tmp);</span><br></pre></td></tr></table></figure><p>进入函数<br>        pos = (z-&gt;center) + (getX0())+movementFactor<em>getDx0()) </em> (z-&gt;axis0) + (getX1())+movementFactor<em>getDx1()) </em> (z-&gt;axis1);</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(<span class="number">-623411838</span>+ans*(<span class="number">-37</span>) )* [<span class="number">-5.32625e-11</span>, <span class="number">1.69705e-10</span>, <span class="number">0</span>]+(<span class="number">-188238807</span>+ans*(<span class="number">-2097</span>))*[<span class="number">2.99612e-11</span>, <span class="number">9.40346e-12</span>, <span class="number">1.75073e-10</span>]+[<span class="number">0.939124</span>, <span class="number">0.294748</span>, <span class="number">-0.176549</span>]</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9667</span>    <span class="number">0.1872</span>   <span class="number">-0.2095</span></span><br><span class="line">ans./norm(ans)</span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9603</span>    <span class="number">0.1859</span>   <span class="number">-0.2081</span></span><br><span class="line">    [<span class="number">0.960264</span>, <span class="number">0.185937</span>, <span class="number">-0.208135</span>]差不多</span><br><span class="line">    </span><br><span class="line">ans +[<span class="number">-7.89179e-06</span>, <span class="number">-9.1333e-05</span>, <span class="number">-3.95923e-05</span>] </span><br><span class="line"></span><br><span class="line">ans =</span><br><span class="line"></span><br><span class="line">    <span class="number">0.9603</span>    <span class="number">0.1858</span>   <span class="number">-0.2082</span></span><br></pre></td></tr></table></figure><p> movementFactor = (M_PI / 180.) <em> (0.0001 / 3600.) </em> ((core-&gt;getJDE() - d2000) / 365.25) /(star_position_scale);</p><p>core-&gt;getJDE() = 2459656</p><p>d2000 = 2451545.0  截止2022.3.17 差距8111天</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14159265358979323846</span> / <span class="number">180.0</span> * <span class="number">0.0001</span>/<span class="number">3600.0</span>*<span class="number">8111</span>/<span class="number">365.25</span>/<span class="number">60.5274</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.7787e-10</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220317145315365.png" alt="image-20220317145315365"></p><p>最终得到包含赤经赤纬星等的表</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220317161906242.png" alt="image-20220317161906242"></p>]]></content>
      
      
      <categories>
          
          <category> 星表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赤道坐标转为地平坐标</title>
      <link href="2022/03/07/blog42-Equatorial2Horizontal/"/>
      <url>2022/03/07/blog42-Equatorial2Horizontal/</url>
      
        <content type="html"><![CDATA[<p>地平坐标系统是：<a href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E5%9D%90%E6%A8%99%E7%B3%BB">https://zh.wikipedia.org/wiki/%E5%9C%B0%E5%B9%B3%E5%9D%90%E6%A8%99%E7%B3%BB</a></p><ul><li>高度角（Altitude, Alt）或仰角又称<a href="https://zh.wikipedia.org/wiki/天球坐标系统">地平纬度</a>，是天体和观测者所在地的地平线的夹角，有时就称为<a href="https://zh.wikipedia.org/wiki/相对高度">高度</a>或<a href="https://zh.wikipedia.org/wiki/海拔">海拔</a>标高（elevation, geometric height）。</li><li><a href="https://zh.wikipedia.org/wiki/方位角">方位角</a>（Azimuth, Az）又称地平经度，是沿着地平线测量的角度（由正北方为起点向东方测量）。</li></ul><p><strong>sin高度 = sin地球观察者纬度 <em> sin赤纬 + cos地球观察者纬度 </em> cos赤纬 * cos时角</strong></p><p><strong>cos方位 <em> cos高度 = - cos地球观察者纬度 </em> sin赤纬 + sin地球观察者纬度 <em> cos赤纬 </em> cos时角</strong></p><p><strong>sin方位 <em> cos高度 = cos赤纬 </em> sin 时角</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307203646304.png" alt="image-20220307203646304"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307210913618.png" alt="image-20220307210913618"></p><p><a href="https://encyclopedia.thefreedictionary.com/Astronomical+coordinate+systems">https://encyclopedia.thefreedictionary.com/Astronomical+coordinate+systems</a></p><hr><p>《地平式望远镜轴系误差对指向精度和跟踪精度的影响》</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307201531562.png" alt="image-20220307201531562"></p><hr><p><a href="https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/">https://mooncaker816.github.io/2018/05/19/%E5%A4%A9%E6%96%87%E7%AE%97%E6%B3%9511/</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307202417544.png" alt="image-20220307202417544"></p><p>//    A: azimuth方位角<br>//    h: elevation仰角<br>//    φ: latitude of observer on Earth观测纬度<br>//    ψ: longitude of observer on Earth观测经度<br>//    st: sidereal time at Greenwich at time of observation.恒星时</p><p>//    α: right ascension赤经（时角）<br>//    δ: declination赤纬</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307202425679.png" alt="image-20220307202425679"></p><p>//    α: right ascension coordinate to transform<br>//    δ: declination coordinate to transform<br>//    φ: latitude of observer on Earth 地球上观察者的纬度<br>//    ψ: longitude of observer on Earth 地球上观察者的经度<br>//    st: sidereal time at Greenwich at time of observation. 格林威治观测时的恒星时间。</p><p>//    A: azimuth of observed point, measured westward from the South.<br>//    h: elevation, or height of observed point above horizon.</p><hr><p>知乎 <a href="https://zhuanlan.zhihu.com/p/97325585">https://zhuanlan.zhihu.com/p/97325585</a></p><hr><p><em><code>UTC时间</code></em>(世界协调时间,UTC + 00:00)转北京(北京,UTC + 8:00)时间. 世界时钟, 时间转换, 计算与对照表.</p><p>一个地方的当地<code>恒星时</code>与<a href="https://baike.baidu.com/item/格林尼治天文台">格林尼治天文台</a>的恒星时之间的差就是这个地方的经度（参见天体导航）。因此通过观测恒星时可以确定当地的经度（假如格林尼治天文台的恒星时已知的话）或者可以确定时间（假如当地的经度已知的话）。</p><ul><li>一颗恒星的时角<em>t</em>、它的赤经<em>α</em>和当地的恒星时<em>θ</em>之间的关系为<em>t</em>=<em>θ</em>-<em>α</em></li><li>当地的恒星时等于位于<a href="https://baike.baidu.com/item/天顶">天顶</a>的恒星的赤经</li><li>当地的恒星时等于正位于<a href="https://baike.baidu.com/item/中天">中天</a>恒星的赤经</li></ul><p>通过确定恒星时可以简化天文学的计算，比如通过恒星时和当地的纬度可以很方便地计算出哪些星正好在地平线以上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>指向精度的研究</title>
      <link href="2022/03/05/blog41-point-1/"/>
      <url>2022/03/05/blog41-point-1/</url>
      
        <content type="html"><![CDATA[<p>虽然寥寥无几的引用量，但该文可能确实是我司使用的机架模型的源头。</p><p><strong>Luck J M. Mount model stability[C]//14th International Workshop on Laser Ranging Instrumentation. 2004.</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220306221746844.png" alt="image-20220306221746844"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220306223205754.png" alt="image-20220306223205754"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220306221628712.png" alt="image-20220306221628712"></p><hr><p><strong>朱庆生, 陈伟民, 吴金虎. 卫星激光测距望远镜的指向改正[J]. 天文研究与技术: 国家天文台台刊, 2011, 8(3): 268-271.</strong></p><p>常用的指向误差模型有球谐函数模型、基本参数模型、机架模型等。球谐函数模型是对以球面为基准面的误差进行拟合，可以用于任何机架形式的望远镜，但其表达式的各项没有物理意义，模型不稳定，每次重测数据后，求得的模型参数变化极大。基本参数模型的模型参数有实际物理意义，参数之间相关性小，模型比较稳定，但需根据望远镜的机架形式，设计不同的模型，而且考虑的参数项比较少，有时会影响改正的精度。机架模型也有人称为转台模型，目前常用于地平式机架，通过对望远镜机架进行全面分析得出的模型，共有 23 项，每一项都有具体的物理意义。它是对基本参数模型的扩展，因此精度更高，模型的逼近能力强于基本参数模型，缺点是没有基本参数模型稳定。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220306103515401.png" alt="image-20220306103515401"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220306104049068.png" alt="image-20220306104049068"></p><p><img src="C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20220306222049071.png" alt="image-20220306222049071"></p><hr><hr><p><strong>严灵杰. 光电望远镜视轴指向及预测技术研究[J]. 成都: 中国科学院光电技术研究所, 2019, 1.</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220306110849188.png" alt="image-20220306110849188"></p><hr><p>张涯辉, 罗一涵, 徐伟峰, 等. 采用加权最小二乘法的恒星校正研究[J]. 光电工程, 2014, 41(5): 7-11. 用了该方法</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307213741142.png" alt="image-20220307213741142"></p><hr><p>张玉碟, 柳万胜, 罗一涵, 等. 一种三轴光电跟踪系统指向误差修正的方法[J]. 光电工程, 2014, 41(6): 51-55.</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307214621476.png" alt="image-20220307214621476"></p>]]></content>
      
      
      <categories>
          
          <category> 指向模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指向模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视场与赤经范围的关系</title>
      <link href="2022/03/03/blog40-guide-Sel-4-raROV/"/>
      <url>2022/03/03/blog40-guide-Sel-4-raROV/</url>
      
        <content type="html"><![CDATA[<p>球面三角学</p><p><a href="https://mathworld.wolfram.com/SphericalTrigonometry.html">https://mathworld.wolfram.com/SphericalTrigonometry.html</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220304202743522.png" alt="image-20220304202743522"></p><hr><p>《一种快速搜索导航星表的方法》</p><p><a href="https://patentimages.storage.googleapis.com/36/8b/67/874c0824e15854/CN101995248B.pdf">https://patentimages.storage.googleapis.com/36/8b/67/874c0824e15854/CN101995248B.pdf</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220303233833640.png" alt="image-20220303233833640"></p><p>还是不明白为什么是正切公式</p><hr><p><strong>王海涌, 徐皓. 一种星敏感器导航星筛选算法[J]. 激光与光电子学进展, 2021, 58(1): 0135001.</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220304142358967.png" alt="image-20220304142358967"></p><p><a href="https://web.math.sinica.edu.tw/math_media/d281/28104.pdf">https://web.math.sinica.edu.tw/math_media/d281/28104.pdf</a></p><p><a href="https://mathworld.wolfram.com/SphericalTrigonometry.html">https://mathworld.wolfram.com/SphericalTrigonometry.html</a></p><p>中提到球面三角正弦公式</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220304151000732.png" alt="image-20220304151000732"></p><hr><p>《16mv精细导星星库构建与评价》</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301210751502.png" alt="image-20220301210751502"></p><hr><p>《<a href="http://geotech.chinaxiv.org/user/download.htm?id=6065">基于坐标系转换与QTM 编码的天球面探测覆盖栅格化分析方法研究</a>》</p><p>矩形锥视场</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220305100713620.png" alt="image-20220305100713620"></p><p>圆锥视场</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220305100740048.png" alt="image-20220305100740048"></p>]]></content>
      
      
      <categories>
          
          <category> 导航星筛选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导航星筛选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-vector算法</title>
      <link href="2022/03/02/blog39-guideSel-3/"/>
      <url>2022/03/02/blog39-guideSel-3/</url>
      
        <content type="html"><![CDATA[<p>原文《Search-less algorithm for star pattern recognition》</p><p><a href="https://link.springer.com/content/pdf/10.1007/BF03546375.pdf">https://link.springer.com/content/pdf/10.1007/BF03546375.pdf</a> 引用数129</p><p>K矢量查找法</p><p>中文论文《基于导航星域和K矢量的快速星图识别算法》</p><p>《一种改进的基于Ｋ 矢量的星图识别算法》</p><hr><p>《基于导航星域和K矢量的快速星图识别算法》</p><p>假设待排序的值为0.01到0.99，共有83363个数值，数列平均递增。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line">n = <span class="number">83363</span>;</span><br><span class="line">data=<span class="built_in">linspace</span>(<span class="number">0.01</span>,<span class="number">0.99</span>,<span class="number">83363</span>);</span><br><span class="line">D = (data(n)-data(<span class="number">1</span>))/(n<span class="number">-1</span>);</span><br><span class="line">a1 = n*D/(n<span class="number">-1</span>);</span><br><span class="line">a0 = data(<span class="number">1</span>) - a1 -D/<span class="number">2</span>;</span><br><span class="line">k = <span class="number">1</span>: n;</span><br><span class="line">costhe = a1 .* k + a0;</span><br><span class="line">K=[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(k,data,<span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(k,costhe,<span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220303085357833.png" alt="image-20220303085357833"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220303085450014.png" alt="image-20220303085450014"></p><p>搭建完毕，现在开始使用。</p><p>假定范围为（0.55,0.59），假设theta=0.57，delta=0.02</p><p>ib=45935</p><p>it=49338</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line">tic</span><br><span class="line">n = <span class="number">83363</span>;</span><br><span class="line">data=<span class="built_in">linspace</span>(<span class="number">0.01</span>,<span class="number">0.99</span>,<span class="number">83363</span>);</span><br><span class="line">D = (data(n)-data(<span class="number">1</span>))/(n<span class="number">-1</span>);</span><br><span class="line">a1 = n*D/(n<span class="number">-1</span>);</span><br><span class="line">a0 = data(<span class="number">1</span>) - a1 -D/<span class="number">2</span>;</span><br><span class="line">k = <span class="number">1</span>: n;</span><br><span class="line">costhe = a1 .* k + a0;</span><br><span class="line">K(<span class="number">1</span>)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">2</span>:n</span><br><span class="line">    K(<span class="built_in">j</span>) = sum(sum(data &lt; costhe(<span class="built_in">j</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">ib = <span class="built_in">fix</span>((<span class="number">0.59</span>-a0)/a1);</span><br><span class="line">it = <span class="built_in">fix</span>((<span class="number">0.55</span>-a0)/a1)+<span class="number">1</span>;</span><br><span class="line">kstart = K(ib) +<span class="number">1</span> ;</span><br><span class="line">kend = K(it) +<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>kstar=45936</p><p>kend=49339</p><p>历时 5.060949 秒。</p><hr><p>《一种改进的基于Ｋ 矢量的星图识别算法》</p><p>提到了该方法有问题</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220303171127111.png" alt="image-20220303171127111"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220303213921527.png" alt="image-20220303213921527"></p>]]></content>
      
      
      <categories>
          
          <category> 导航星筛选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导航星筛选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>均匀性-玻尔兹曼熵</title>
      <link href="2022/02/28/blog38-guideSel-2/"/>
      <url>2022/02/28/blog38-guideSel-2/</url>
      
        <content type="html"><![CDATA[<p>在多篇文章中提到玻尔兹曼熵来表征评价均匀性（还有各分区内的星数标准差）。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220228111816120.png" alt="image-20220228111816120"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301160342968.png" alt="image-20220301160342968"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301211333236.png" alt="image-20220301211333236"></p><h2 id="多尺度像面分割《CN201510107562-0-用于星敏感器的筛选导航星的方法》"><a href="#多尺度像面分割《CN201510107562-0-用于星敏感器的筛选导航星的方法》" class="headerlink" title="多尺度像面分割《CN201510107562.0-用于星敏感器的筛选导航星的方法》"></a>多尺度像面分割《CN201510107562.0-用于星敏感器的筛选导航星的方法》</h2><h3 id="玻尔兹曼熵《Boltzmann-entropy-based-guide-star-selection-algorithm-for-star-tracker》2005"><a href="#玻尔兹曼熵《Boltzmann-entropy-based-guide-star-selection-algorithm-for-star-tracker》2005" class="headerlink" title="玻尔兹曼熵《Boltzmann entropy-based guide star selection algorithm for star tracker》2005"></a>玻尔兹曼熵《Boltzmann entropy-based guide star selection algorithm for star tracker》2005</h3><h2 id="正交网格法《A-general-method-of-the-automatical-selection-of-guide-star》"><a href="#正交网格法《A-general-method-of-the-automatical-selection-of-guide-star》" class="headerlink" title="正交网格法《A general method of the automatical selection of guide star》"></a>正交网格法《A general method of the automatical selection of guide star》</h2><p>用到uniformity的计算</p><h3 id="均匀性计算《Star-trackers-star-catalogs-and-attitude-determination-Probabilistic-aspects-of-system-design》1993"><a href="#均匀性计算《Star-trackers-star-catalogs-and-attitude-determination-Probabilistic-aspects-of-system-design》1993" class="headerlink" title="均匀性计算《Star trackers, star catalogs, and attitude determination-Probabilistic aspects of system design》1993"></a>均匀性计算《Star trackers, star catalogs, and attitude determination-Probabilistic aspects of system design》1993</h3><h4 id="《基于螺旋基准点的导航星选取方法》"><a href="#《基于螺旋基准点的导航星选取方法》" class="headerlink" title="《基于螺旋基准点的导航星选取方法》"></a>《基于螺旋基准点的导航星选取方法》</h4><p>均匀性很好</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220302143041244.png" alt="image-20220302143041244"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220302151757196.png" alt="image-20220302151757196"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"></span><br><span class="line">z=[];</span><br><span class="line">theta=[];</span><br><span class="line">fai=[];</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span>;</span><br><span class="line">k = <span class="number">0</span>:n<span class="number">-1</span>;</span><br><span class="line">z = <span class="number">1</span>-(<span class="number">2</span>*k+<span class="number">1</span>)/n;</span><br><span class="line">theta=<span class="built_in">acos</span>(z);</span><br><span class="line">fai=<span class="built_in">sqrt</span>(n*<span class="built_in">pi</span>).*theta;</span><br><span class="line">x = <span class="built_in">sin</span>(theta).*<span class="built_in">cos</span>(fai);</span><br><span class="line">y = <span class="built_in">sin</span>(theta).*<span class="built_in">sin</span>(fai);</span><br><span class="line">A = [x.&#x27;, y.&#x27; ,z.&#x27;];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(A)<span class="number">-1</span> </span><br><span class="line">    delta(<span class="built_in">i</span>,:) = <span class="built_in">acosd</span>(A(<span class="built_in">i</span>,:)*A(<span class="built_in">i</span>+<span class="number">1</span>,:).&#x27;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">mean</span> = <span class="built_in">mean</span>(delta);</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z,<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">1.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.1</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,A(<span class="number">2</span>,<span class="number">1</span>),A(<span class="number">2</span>,<span class="number">2</span>),A(<span class="number">2</span>,<span class="number">3</span>),<span class="number">1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">s=<span class="number">20</span>;</span><br><span class="line">xmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">xmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">ymin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">ymax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">zmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line">zmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line">                     </span><br><span class="line">plotcube([xmax-xmin ymax-ymin zmax-zmin],[ xmin  ymin  zmin],<span class="number">.8</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220320155757356.png" alt="image-20220320155757356"></p><hr><p>后来我又看到 <a href="https://zhuanlan.zhihu.com/p/25988652?group_id=828963677192491008">https://zhuanlan.zhihu.com/p/25988652?group_id=828963677192491008</a> <strong>菲波那契网格</strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all ;close all;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">axis equal;</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span>;</span><br><span class="line">k = <span class="number">1</span>:n;</span><br><span class="line">c = (<span class="built_in">sqrt</span>(<span class="number">5</span>)<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">z = (<span class="number">2</span>*k<span class="number">-1</span>)/n - <span class="number">1</span>;</span><br><span class="line">x = <span class="built_in">sqrt</span>(<span class="number">1</span>-z.^<span class="number">2</span>).*<span class="built_in">cos</span>(<span class="number">2</span>*<span class="built_in">pi</span>.*k*c);</span><br><span class="line">y = <span class="built_in">sqrt</span>(<span class="number">1</span>-z.^<span class="number">2</span>).*<span class="built_in">sin</span>(<span class="number">2</span>*<span class="built_in">pi</span>.*k*c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [x.&#x27;, y.&#x27; ,z.&#x27;];</span><br><span class="line"></span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220320160017779.png" alt="image-20220320160017779"></p><p>效果并不好</p><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220321101324772.png" alt="image-20220321101324772"></p><hr><p>阿基米德螺旋线</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220320105605922.png" alt="image-20220320105605922"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear all; close all;</span><br><span class="line">a=<span class="number">0</span>;<span class="comment">%起始位置</span></span><br><span class="line">b=<span class="number">3</span>;<span class="comment">%螺线间距参数</span></span><br><span class="line">theta = <span class="number">0</span>:<span class="number">0.05</span>*<span class="built_in">pi</span>:<span class="number">10</span>*<span class="built_in">pi</span>;<span class="comment">%θ的范围和步长，同时也可以控制螺线的旋转方向</span></span><br><span class="line">coe=a+b*theta;<span class="comment">%阿基米德螺线方程</span></span><br><span class="line">x = (coe.*<span class="built_in">cos</span>(theta));<span class="comment">%因使用需要，获取直角坐标系下x轴的坐标并进行四舍五入</span></span><br><span class="line">y = (coe.*<span class="built_in">sin</span>(theta));<span class="comment">%因使用需要，获取直角坐标系下y轴的坐标并进行四舍五入</span></span><br><span class="line">r = <span class="built_in">pi</span>*b;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> :<span class="built_in">length</span>(x)</span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    rectangle(<span class="string">&#x27;Position&#x27;</span>,[x(<span class="built_in">i</span>)-r,y(<span class="built_in">i</span>)-r,<span class="number">2</span>*r,<span class="number">2</span>*r],<span class="string">&#x27;Curvature&#x27;</span>,[<span class="number">1</span>,<span class="number">1</span>],<span class="string">&#x27;linewidth&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;c&#x27;</span>);<span class="comment">%将获取的坐标打印在图纸上</span></span><br><span class="line">xt=x&#x27;;<span class="comment">%将x轴数据转置成列，便于导出使用</span></span><br><span class="line">yt=y&#x27;;<span class="comment">%将y周数据转置成列，便于导出使用</span></span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220307114759208.png" alt="image-20220307114759208"></p><p>弧长公式 <a href="https://www.zhihu.com/question/27384632">https://www.zhihu.com/question/27384632</a></p><h4 id="《均匀快速的导航星选取方法》"><a href="#《均匀快速的导航星选取方法》" class="headerlink" title="《均匀快速的导航星选取方法》"></a>《均匀快速的导航星选取方法》</h4><p>在赤纬带平分点，矩形范围的代码见下。（两角和余弦公式）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220302200145394.png" alt="image-20220302200145394"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220302211206988.png" alt="image-20220302211206988"></p><h4 id="《16mv精细导星星库构建与评价》"><a href="#《16mv精细导星星库构建与评价》" class="headerlink" title="《16mv精细导星星库构建与评价》"></a>《16mv精细导星星库构建与评价》</h4><p>分区后取最亮几个。</p><p>国内研究构建星库的方法主要分为两类:第一类从星表划分角度出发,通过不同的划分方式进行导星筛选,现有的星表划分方法主要有赤纬带法、圆锥法、球矩形法、内接正方体法等;第二类从局部天区出发,主要包括回归筛星法、星等加权算法等。</p><p>评价标准：完备性 、均匀性和冗余性。（均匀性、速度、多于3个星的分区数概率）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301210751502.png" alt="image-20220301210751502"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301210838500.png" alt="image-20220301210838500"></p><h4 id="《适用于小视场星敏感器的导航星表构建方法》"><a href="#《适用于小视场星敏感器的导航星表构建方法》" class="headerlink" title="《适用于小视场星敏感器的导航星表构建方法》"></a>《适用于小视场星敏感器的导航星表构建方法》</h4><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220303214512056.png" alt="image-20220303214512056"></p><hr><p>在1993年的均匀性计算文章中提到这一计算方法</p><p>总体均匀性计算方法：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220228225805510.png" alt="image-20220228225805510"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220228225835383.png" alt="image-20220228225835383"></p><p>局部均匀性计算方法：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220304094711632.png" alt="image-20220304094711632"></p><hr><p>以上一篇《基于星座聚类的星敏感器导航星优选算法研究》为例，</p><p>所有4908个点的全局均匀性为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% boltzmannEntropy.m</span></span><br><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(:,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(:,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(:,<span class="number">3</span>))  ];</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line"></span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>newmatrix =</p><p>​    0.2799   -0.0070    0.0483<br>   -0.0070    0.3631    0.0007<br>​    0.0483    0.0007    0.3570</p><p>eigen =</p><p>​    0.2562<br>​    0.3632<br>​    0.3805</p><p>ans =</p><p>​    0.0142</p><p>均匀化后 得到39个点 data=</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">bandwidth = <span class="number">0</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line"><span class="comment">% : = 1:end;</span></span><br><span class="line">data =  [  <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(:,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(:,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(:,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line">x=data&#x27;;</span><br><span class="line"></span><br><span class="line">tic</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">150</span></span><br><span class="line">    bandwidth = bandwidth + <span class="number">0.1</span>;</span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"><span class="built_in">scatter3</span>(data(:,<span class="number">1</span>),data(:,<span class="number">2</span>),data(:,<span class="number">3</span>),<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br><span class="line"></span><br><span class="line">A  =  data;</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line"></span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>0.721096202739022    0.143274305623194    -0.677858937938827<br>0.968970810392417    0.208978537391637    0.131998255735122<br>0.569826352357379    0.276879108656515    0.773715637265177<br>0.228610689351435    0.164381998103028    -0.959539322494872<br>0.680467391588214    0.574452415904999    0.454937963733565<br>0.755501580234282    0.652710692710075    0.0564456719814448<br>0.504277122250002    0.768039960865827    -0.394739410863010<br>0.154912237007631    0.405692531666614    0.900786194707282<br>0.210384928706513    0.600544339596624    -0.771417317637872<br>0.143977198200687    0.816855223274374    0.558585813109905<br>-0.229099414143074    0.950795223816936    -0.208571092930452<br>-0.282616508078908    0.919125613504918    0.274474071563222<br>-0.273028245935124    0.599816587126275    0.752114112837791<br>-0.384654835774312    0.742153343311259    -0.548861614915233<br>-0.256254169146301    0.406094432070341    -0.877166525259945<br>-0.739931959521445    0.571829210408285    -0.354276797719793<br>-0.806338802865188    0.579353885367924    0.119024411374415<br>-0.760075452992603    0.337837739926240    0.555113472399671<br>-0.487550601625308    0.150466743789691    0.860031493532724<br>-0.987416677336434    0.156220148544471    0.0245676719820876<br>-0.898581139351745    -0.0465144783456416    0.436335122704501<br>-0.374139568095630    -0.0287413085026819    -0.926926923101692<br>-0.963578273457490    -0.260891712855464    -0.0587573406820316<br>-0.799916216534544    -0.556325600463240    0.225024160467884<br>-0.732478694296601    -0.536144597346316    -0.419552062487963<br>-0.478334336301847    -0.740621679799566    0.471885356973005<br>-0.194005559456996    -0.435699798511738    0.878935451826020<br>-0.314232785230549    -0.886073947077770    -0.340779572445699<br>-0.00720050076528926    -0.0591052787344646    0.998225785488659<br>-0.0490019433066575    -0.732931424546231    -0.678535434936750<br>0.0801942976395903    -0.872038194549829    0.482823220104800<br>0.368597406332163    -0.929570349282381    0.00590912685900466<br>0.323982389195822    -0.553545295684837    0.767217711680429<br>0.514345456211916    -0.579655346834382    -0.632019327679517<br>0.827337679920563    -0.510494571429276    -0.234323827053289<br>0.448212896485379    -0.212583754752496    -0.868281835949317<br>0.964675223452813    -0.215965114222275    0.150866771342216<br>0.724877321462857    -0.104703930494290    0.680874405281827<br>0.927771336185871    -0.108671846203537    -0.356974477511487</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301152248993.png" alt="image-20220301152248993"></p><p>newmatrix =</p><p>​    0.3527   -0.0057   -0.0221<br>   -0.0057    0.3007    0.0039<br>   -0.0221    0.0039    0.3466</p><p>eigen =</p><p>​    0.3001<br>​    0.3273<br>​    0.3726</p><p>ans =</p><p>​    0.0040</p><p>均匀性不错。</p><p>又做一次实验</p><p>newmatrix =<br>    0.3364   -0.0062   -0.0127<br>   -0.0062    0.3195    0.0007<br>   -0.0127    0.0007    0.3441</p><p>eigen =<br>    0.3169<br>    0.3290<br>    0.3541</p><p>ans =<br>    0.0011</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301165031830.png" alt="image-20220301165031830"></p><p>随机选取39个点</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">1</span>) = <span class="built_in">cos</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">2</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">3</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">A = star_data_xyz(randperm(<span class="built_in">length</span>(star_data_xyz), <span class="number">39</span>),:)</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">scatter3</span>(star_data_xyz(:,<span class="number">1</span>),star_data_xyz(:,<span class="number">2</span>),star_data_xyz(:,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"><span class="built_in">scatter3</span>(A(:,<span class="number">1</span>),A(:,<span class="number">2</span>),A(:,<span class="number">3</span>),<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure><p>newmatrix =<br>    0.3068   -0.0422    0.0801<br>   -0.0422    0.3637   -0.0381<br>    0.0801   -0.0381    0.3295</p><p>eigen =<br>    0.2368<br>    0.3226<br>    0.4406</p><p>ans =<br>    0.0314</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301161540597.png" alt="image-20220301161540597"></p><hr><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 矩形范围</span></span><br><span class="line">clear all ;close all;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">sphere(<span class="number">50</span>);</span><br><span class="line">alpha(<span class="number">0.1</span>);</span><br><span class="line"><span class="built_in">hold</span> on ;</span><br><span class="line"></span><br><span class="line">z=[];</span><br><span class="line">theta=[];</span><br><span class="line">fai=[];</span><br><span class="line"></span><br><span class="line">n = <span class="number">30</span>;</span><br><span class="line">k = <span class="number">0</span>:n<span class="number">-1</span>;</span><br><span class="line">z = <span class="number">1</span>-(<span class="number">2</span>*k+<span class="number">1</span>)/n;</span><br><span class="line">theta=<span class="built_in">acos</span>(z);</span><br><span class="line">fai=<span class="built_in">sqrt</span>(n*<span class="built_in">pi</span>).*theta;</span><br><span class="line">x = <span class="built_in">sin</span>(theta).*<span class="built_in">cos</span>(fai);</span><br><span class="line">y = <span class="built_in">sin</span>(theta).*<span class="built_in">sin</span>(fai);</span><br><span class="line">A = [x.&#x27;, y.&#x27; ,z.&#x27;];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="built_in">length</span>(A)<span class="number">-1</span> </span><br><span class="line">    delta(<span class="built_in">i</span>,:) = <span class="built_in">acosd</span>(A(<span class="built_in">i</span>,:)*A(<span class="built_in">i</span>+<span class="number">1</span>,:).&#x27;);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">mean</span> = <span class="built_in">mean</span>(delta);</span><br><span class="line">newmatrix = <span class="number">1</span>/<span class="built_in">length</span>(A).*(A.&#x27;*A)</span><br><span class="line">eigen = eig(newmatrix)</span><br><span class="line">eigen(<span class="number">1</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">1</span>)) + eigen(<span class="number">2</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">2</span>)) + eigen(<span class="number">3</span>)*<span class="built_in">log</span>(<span class="number">3</span>*eigen(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">scatter3</span>(x,y,z,<span class="string">&#x27;filled&#x27;</span>);</span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;r-&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">1.1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">1.1</span>,<span class="number">0</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1.1</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;FontSize&#x27;</span>,<span class="number">14</span>);</span><br><span class="line">quiver3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,A(<span class="number">2</span>,<span class="number">1</span>),A(<span class="number">2</span>,<span class="number">2</span>),A(<span class="number">2</span>,<span class="number">3</span>),<span class="number">1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">s=<span class="number">20</span>;</span><br><span class="line">xmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">xmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">1</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">ymin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">ymax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">2</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span>);</span><br><span class="line">zmin = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) - <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line">zmax = <span class="built_in">cosd</span>(s) * A(<span class="number">2</span>,<span class="number">3</span>) + <span class="built_in">sind</span>(s) * <span class="built_in">sqrt</span>(<span class="number">1</span>-A(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">plotcube([xmax-xmin ymax-ymin zmax-zmin],[ xmin  ymin  zmin],<span class="number">.8</span>,[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]);</span><br><span class="line">view(<span class="number">-30</span>,<span class="number">10</span>)</span><br><span class="line">axis equal</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 导航星筛选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导航星筛选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《基于星座聚类的星敏感器导航星优选算法研究》的复现</title>
      <link href="2022/02/24/blog37-guideSel-1/"/>
      <url>2022/02/24/blog37-guideSel-1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一直对公司采用的指向模型修正过程中的选星过程很感兴趣，想知道是否有相关的文献。</p><p>的确有找到相关文献，想就此进行复现。先对下文进行复现。</p><p><code>吴峰, 朱锡芳, 相入喜, 等. 基于星座聚类的星敏感器导航星优选算法研究[J]. 微电子学与计算机, 2018, 35(3): 140-144.</code></p><p>主要涉及<code>Mean Shift</code>（均值漂移）算法</p><hr><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>一般对原始星表恒星数据做星等阈值处理， 即可得到导航星星库． <code>为提高星图识别稳定性， 增强星敏感器系统性能</code>， 通常要求导航星在天球上分布均匀． 为此， 国内外许多研究人员提出了进一步筛选导航星的算法．   </p><hr><h1 id="相关文献："><a href="#相关文献：" class="headerlink" title="相关文献："></a>相关文献：</h1><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220224211251099.png" alt="image-20220224211251099"></p><hr><h1 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h1><p>通常星座区域的恒星密度高， 星座和星座之间的区域星密度低． 为此， 本文首先借鉴Mean Shift（均值漂移）算法， 提出星座聚类算法， 将视场内的恒星划分到不同的星座． 然后， 提出基于星座聚类的导航星优选算法， 通过每次选择星数最多的一个星座， 并删除离该星座中心最近的一颗恒星， 最终实现导航星的均匀分布  </p><p>Mean Shift（均值漂移）是<strong>基于密度的非参数聚类算法</strong>，其算法思想是假设不同簇类的数据集符合不同的概率密度分布，找到任一样本点<strong>密度增大的最快方向</strong>（最快方向的含义就是Mean Shift），样本密度高的区域对应于该分布的最大值，这些样本点最终会在局部密度最大值收敛，且收敛到相同局部最大值的点被认为是同一簇类的成员。（<a href="https://cloud.tencent.com/developer/article/1459530）">https://cloud.tencent.com/developer/article/1459530）</a></p><p><strong>1.核密度估计</strong></p><p>Mean Shift算法用核函数估计样本的密度，最常用的核函数是高斯核。它的工作原理是在数据集上的<strong>每一个样本点</strong>都设置一个核函数，然后对所有的核函数相加，得到数据集的核密度估计（kernel density estimation）。</p><p>假设我们有大小为n的d维数据集</p><p>如下图，我们用高斯核估计一维数据集的密度，每个样本点都设置了以该样本点为中心的高斯分布，累加所有的高斯分布，得到该数据集的密度。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220224212833039.png" alt="image-20220224212833039"></p><p>其中虚线表示每个样本点的高斯核，实线表示累加所有样本高斯核后的数据集密度。因此，我们通过高斯核来得到数据集的密度。</p><p><strong>5.图像分割</strong>示例</p><p>mean shift通过对像素空间进行聚类，达到图像分割的目的。</p><p>我们对下图进行图像分割：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220224212938640.png" alt="image-20220224212938640"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220224212952595.png" alt="image-20220224212952595"></p><h2 id="Mean-Shift算法的优缺点"><a href="#Mean-Shift算法的优缺点" class="headerlink" title="Mean Shift算法的优缺点"></a><strong>Mean Shift算法的优缺点</strong></h2><p>优点：</p><p>不需要设置簇类的个数；</p><p>可以处理任意形状的簇类；</p><p>算法只需设置带宽这一个参数，带宽影响数据集的核密度估计</p><p>算法结果稳定，不需要进行类似K均值的样本初始化</p><p>缺点：</p><p>聚类结果取决于带宽的设置，带宽设置的太小，收敛太慢，簇类个数过多；带宽设置的太大，一些簇类可能会丢失。</p><p>对于较大的特征空间，计算量非常大。</p><h2 id="图解过程"><a href="#图解过程" class="headerlink" title="图解过程"></a>图解过程</h2><p><a href="https://blog.csdn.net/google19890102/article/details/51030884">https://blog.csdn.net/google19890102/article/details/51030884</a></p><h1 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h1><p><a href="https://blog.csdn.net/HJ199404182515/article/details/121694298">https://blog.csdn.net/HJ199404182515/article/details/121694298</a></p><p><strong><a href="https://www.cnblogs.com/kailugaji/p/11646167.html">https://www.cnblogs.com/kailugaji/p/11646167.html</a></strong></p><p>函数代码为MeanShiftCluster.m</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"> </span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line">    stInd           = initPtInds(tempInd);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">%*** plot stuff ****</span></span><br><span class="line">        <span class="keyword">if</span> plotFlag</span><br><span class="line">            <span class="built_in">figure</span>(<span class="number">1</span>),clf,<span class="built_in">hold</span> on</span><br><span class="line">            <span class="keyword">if</span> numDim == <span class="number">2</span></span><br><span class="line">                <span class="built_in">plot</span>(dataPts(<span class="number">1</span>,:),dataPts(<span class="number">2</span>,:),<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(dataPts(<span class="number">1</span>,myMembers),dataPts(<span class="number">2</span>,myMembers),<span class="string">&#x27;ys&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(myMean(<span class="number">1</span>),myMean(<span class="number">2</span>),<span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">                <span class="built_in">plot</span>(myOldMean(<span class="number">1</span>),myOldMean(<span class="number">2</span>),<span class="string">&#x27;rd&#x27;</span>)</span><br><span class="line">                pause</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = numClust+<span class="number">1</span>;                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">[val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);                <span class="comment">%a point belongs to the cluster with the most votes</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="number">9.32</span>   <span class="number">8.16</span>  </span><br><span class="line"><span class="number">8.45</span>    <span class="number">-4.4</span></span><br><span class="line"><span class="number">7.67</span>    <span class="number">0.73</span></span><br><span class="line"><span class="number">7.3</span>    <span class="number">-3.38</span></span><br><span class="line"><span class="number">5.72</span>  <span class="number">2.38</span></span><br><span class="line"><span class="number">5.5</span>  <span class="number">-3.7</span></span><br><span class="line"><span class="number">5.31</span>  <span class="number">-9.36</span></span><br><span class="line"><span class="number">4.31</span>  <span class="number">-5.68</span></span><br><span class="line"><span class="number">4.08</span>  <span class="number">-6.6</span></span><br><span class="line"><span class="number">2.52</span>  <span class="number">3.26</span></span><br><span class="line"><span class="number">1.24</span> <span class="number">-3.63</span></span><br><span class="line"><span class="number">0.24</span> <span class="number">7.19</span></span><br><span class="line"><span class="number">-0.45</span>  <span class="number">4.09</span></span><br><span class="line"><span class="number">-0.76</span>  <span class="number">-2.59</span></span><br><span class="line"><span class="number">-3.54</span>  <span class="number">8.17</span></span><br><span class="line"><span class="number">-4.49</span>  <span class="number">0.34</span></span><br><span class="line"><span class="number">-4.61</span>  <span class="number">9.58</span></span><br><span class="line"><span class="number">-5.76</span>  <span class="number">-6.98</span></span><br><span class="line"><span class="number">-6.55</span>  <span class="number">7.11</span></span><br><span class="line"><span class="number">-7.79</span>  <span class="number">8.99</span></span><br><span class="line"><span class="number">-9.40</span>  <span class="number">-3.37</span></span><br></pre></td></tr></table></figure><p>测试代码testMeanShift.m为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line"> </span><br><span class="line">bandwidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data=data_load;</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line">[clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(x,bandwidth);</span><br><span class="line"><span class="comment">% clustCent：聚类中心 D*K, point2cluster：聚类结果 类标签, 1*N</span></span><br><span class="line">toc</span><br><span class="line"><span class="comment">%% 作图</span></span><br><span class="line">numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line"><span class="comment">%     plot(x(1,myMembers),x(2,myMembers),[cVec(k) &#x27;.&#x27;]);</span></span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%     plot(myClustCen(1),myClustCen(2),&#x27;o&#x27;,&#x27;MarkerEdgeColor&#x27;,&#x27;k&#x27;,&#x27;MarkerFaceColor&#x27;,cVec(k), &#x27;MarkerSize&#x27;,10)</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:<span class="built_in">size</span>(data,<span class="number">1</span>)</span><br><span class="line">    text(data(<span class="built_in">j</span>,<span class="number">2</span>)+<span class="number">0.2</span>,data(<span class="built_in">j</span>,<span class="number">1</span>)<span class="number">-0.2</span>,num2str(<span class="built_in">j</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220225104512976.png" alt="image-20220225104512976"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220225104550867.png" alt="image-20220225104550867"></p><p>结果不唯一，有时为18类。</p><p>clustCent 2*18 为中心坐标</p><p>point2cluster 1*21 为类别</p><p>clustMembsCell =</p><p>  18×1 cell 数组</p><p>{[   19]}<br>{[   11]}<br>{[15 17]}<br>{[    3]}<br>{[   21]}<br>{[   10]}<br>{[   13]}<br>{[    1]}<br>{[   16]}<br>{[   14]}<br>{[2 4 6]}<br>{[  8 9]}<br>{[    7]}<br>{[   18]}<br>{[   12]}<br>{[    5]}<br>{[   20]}</p><p>根据文章算法修改后MeanShiftCluster.m</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220226160621431.png" alt="image-20220226160621431"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line">nowNum = <span class="number">1</span>;</span><br><span class="line">outCom = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"></span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line"><span class="comment">%     stInd           = initPtInds(tempInd);                  %use this point as start of mean</span></span><br><span class="line">    stInd           = <span class="built_in">min</span>(initPtInds);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"><span class="comment">%     beyondMe=[];</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">length</span>(inInds)&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">min</span>(outCom(inInds))==<span class="number">0</span>)<span class="comment">% 2，6</span></span><br><span class="line">            beyondMe = inInds;</span><br><span class="line">            beyondMe(beyondMe == initPtInds(<span class="number">1</span>)) = [];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))</span><br><span class="line">                thisCluster = <span class="built_in">min</span>(outCom(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                outCom(stInd)=outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span> <span class="comment">% 4</span></span><br><span class="line">                outCom(stInd)=nowNum;</span><br><span class="line">                outCom(beyondMe)=nowNum;</span><br><span class="line">                nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> <span class="built_in">length</span>(inInds)==<span class="number">1</span> <span class="comment">% 1、3、5</span></span><br><span class="line">            outCom(stInd)=nowNum;</span><br><span class="line">            nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = outCom(stInd);                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line">    [val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data2cluster = outCom;</span><br><span class="line"></span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>outCom =</p><pre><code> 1     2     3     2     4     2     5     6     6     7     8     9    10    11    12    13    12    14    15    16    17</code></pre><p>clustCent 2*17 为中心坐标</p><p>point2cluster 1*21 为类别 1     1     3     2     4     2     5     6     6     7     8     9    10    11    12    13    12    14    15    16    17</p><p>根据文章算法修改后MeanShiftCluster.m</p><p>clustMembsCell =</p><p>  18×1 cell 数组</p><p>{[   19]}<br>{[   11]}<br>{[15 17]}<br>{[    3]}<br>{[   21]}<br>{[   10]}<br>{[   13]}<br>{[    1]}<br>{[   16]}<br>{[   14]}<br>{[2 4 6]}<br>{[  8 9]}<br>{[    7]}<br>{[   18]}<br>{[   12]}<br>{[    5]}<br>{[   20]}</p><p>经过第一轮循环，删除了第4/8/15个星。</p><p>再正式修改为MeanShiftCluster.m</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[clustCent,data2cluster,cluster2dataCell]</span> = <span class="title">MeanShiftCluster</span><span class="params">(dataPts,bandWidth,plotFlag)</span></span></span><br><span class="line"><span class="comment">%perform MeanShift Clustering of data using a flat kernel</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% ---INPUT---</span></span><br><span class="line"><span class="comment">% dataPts           - input data, (numDim x numPts)</span></span><br><span class="line"><span class="comment">% bandWidth         - is bandwidth parameter (scalar)</span></span><br><span class="line"><span class="comment">% plotFlag          - display output if 2 or 3 D    (logical)</span></span><br><span class="line"><span class="comment">% ---OUTPUT---</span></span><br><span class="line"><span class="comment">% clustCent         - is locations of cluster centers (numDim x numClust)</span></span><br><span class="line"><span class="comment">% data2cluster      - for every data point which cluster it belongs to (numPts)</span></span><br><span class="line"><span class="comment">% cluster2dataCell  - for every cluster which points are in it (numClust)</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% Bryan Feldman 02/24/06</span></span><br><span class="line"><span class="comment">% MeanShift first appears in</span></span><br><span class="line"><span class="comment">% K. Funkunaga and L.D. Hosteler, &quot;The Estimation of the Gradient of a</span></span><br><span class="line"><span class="comment">% Density Function, with Applications in Pattern Recognition&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">%*** Check input ****</span></span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">2</span></span><br><span class="line">    error(<span class="string">&#x27;no bandwidth specified&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> nargin &lt; <span class="number">3</span></span><br><span class="line">    plotFlag = <span class="built_in">true</span>;</span><br><span class="line">    plotFlag = <span class="built_in">false</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%**** Initialize stuff ***</span></span><br><span class="line">[numDim,numPts] = <span class="built_in">size</span>(dataPts);</span><br><span class="line">numClust        = <span class="number">0</span>;</span><br><span class="line">bandSq          = bandWidth^<span class="number">2</span>;</span><br><span class="line">initPtInds      = <span class="number">1</span>:numPts;</span><br><span class="line">maxPos          = <span class="built_in">max</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%biggest size in each dimension</span></span><br><span class="line">minPos          = <span class="built_in">min</span>(dataPts,[],<span class="number">2</span>);                    <span class="comment">%smallest size in each dimension</span></span><br><span class="line">boundBox        = maxPos-minPos;                        <span class="comment">%bounding box size</span></span><br><span class="line">sizeSpace       = norm(boundBox);                       <span class="comment">%indicator of size of data space</span></span><br><span class="line">stopThresh      = <span class="number">1e-3</span>*bandWidth;                       <span class="comment">%when mean has converged</span></span><br><span class="line">clustCent       = [];                                   <span class="comment">%center of clust</span></span><br><span class="line">beenVisitedFlag = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%track if a points been seen already</span></span><br><span class="line">numInitPts      = numPts;                               <span class="comment">%number of points to posibaly use as initilization points</span></span><br><span class="line">clusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                      <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line">nowNum = <span class="number">1</span>;</span><br><span class="line">outCom = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> numInitPts</span><br><span class="line"></span><br><span class="line">    tempInd         = <span class="built_in">ceil</span>( (numInitPts<span class="number">-1e-6</span>)*<span class="built_in">rand</span>);        <span class="comment">%pick a random seed point</span></span><br><span class="line">    stInd           = initPtInds(tempInd);                  <span class="comment">%use this point as start of mean</span></span><br><span class="line">    myMean          = dataPts(:,stInd);                     <span class="comment">% intilize mean to this points location</span></span><br><span class="line">    myMembers       = [];                                   <span class="comment">% points that will get added to this cluster                         </span></span><br><span class="line">    thisClusterVotes    = <span class="built_in">zeros</span>(<span class="number">1</span>,numPts);                  <span class="comment">%used to resolve conflicts on cluster membership</span></span><br><span class="line"><span class="comment">%     beyondMe=[];</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>     <span class="comment">%loop untill convergence</span></span><br><span class="line">         </span><br><span class="line">        sqDistToAll = sum((<span class="built_in">repmat</span>(myMean,<span class="number">1</span>,numPts) - dataPts).^<span class="number">2</span>);    <span class="comment">%dist squared from mean to all points still active</span></span><br><span class="line">        inInds      = <span class="built_in">find</span>(sqDistToAll &lt; bandSq);                     <span class="comment">%points within bandWidth</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">length</span>(inInds)&gt;<span class="number">1</span> &amp;&amp; <span class="built_in">min</span>(outCom(inInds))==<span class="number">0</span>)<span class="comment">% 2，6</span></span><br><span class="line">            beyondMe = inInds;</span><br><span class="line">            beyondMe(beyondMe == stInd) = [];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))</span><br><span class="line">                thisCluster = <span class="built_in">min</span>(outCom(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>)));</span><br><span class="line">                outCom(stInd)=<span class="built_in">min</span>(outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))));</span><br><span class="line">                outCom(beyondMe)=<span class="built_in">min</span>(outCom(beyondMe(<span class="built_in">find</span>(outCom(beyondMe) &gt;<span class="number">0</span>))));</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">% 4</span></span><br><span class="line">                outCom(stInd)=nowNum;</span><br><span class="line">                outCom(beyondMe)=nowNum;</span><br><span class="line">                nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">elseif</span> <span class="built_in">length</span>(inInds)==<span class="number">1</span> <span class="comment">% 1、3、5</span></span><br><span class="line">            outCom(stInd)=nowNum;</span><br><span class="line">            nowNum = nowNum + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        thisClusterVotes(inInds) = thisClusterVotes(inInds)+<span class="number">1</span>;        <span class="comment">%add a vote for all the in points belonging to this cluster</span></span><br><span class="line">        myOldMean   = myMean;                                   <span class="comment">%save the old mean</span></span><br><span class="line">        myMean      = <span class="built_in">mean</span>(dataPts(:,inInds),<span class="number">2</span>);                <span class="comment">%compute the new mean</span></span><br><span class="line">        myMembers   = [myMembers inInds];                       <span class="comment">%add any point within bandWidth to the cluster</span></span><br><span class="line">        beenVisitedFlag(myMembers) = <span class="number">1</span>;                         <span class="comment">%mark that these points have been visited</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">%**** if mean doesn&#x27;t move much stop this cluster ***</span></span><br><span class="line">        <span class="keyword">if</span> norm(myMean-myOldMean) &lt; stopThresh</span><br><span class="line">             </span><br><span class="line">            <span class="comment">%check for merge posibilities</span></span><br><span class="line">            mergeWith = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">                distToOther = norm(myMean-clustCent(:,cN));     <span class="comment">%distance from posible new clust max to old clust max</span></span><br><span class="line">                <span class="keyword">if</span> distToOther &lt; bandWidth/<span class="number">2</span>                    <span class="comment">%if its within bandwidth/2 merge new and old</span></span><br><span class="line">                    mergeWith = cN;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> mergeWith &gt; <span class="number">0</span>    <span class="comment">% something to merge</span></span><br><span class="line">                clustCent(:,mergeWith)       = <span class="number">0.5</span>*(myMean+clustCent(:,mergeWith));              <span class="comment">%record the max as the mean of the two merged (I know biased twoards new ones)</span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;mergeWith&#125;    = unique([clustMembsCell&#123;mergeWith&#125; myMembers]);   %record which points inside</span></span><br><span class="line">                clusterVotes(mergeWith,:)    = clusterVotes(mergeWith,:) + thisClusterVotes;     <span class="comment">%add these votes to the merged cluster</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">%its a new cluster</span></span><br><span class="line">                numClust                    = outCom(stInd);                    <span class="comment">%increment clusters</span></span><br><span class="line">                clustCent(:,numClust)       = myMean;                        <span class="comment">%record the mean </span></span><br><span class="line">                <span class="comment">%clustMembsCell&#123;numClust&#125;    = myMembers;                    %store my members</span></span><br><span class="line">                clusterVotes(numClust,:)    = thisClusterVotes;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">    initPtInds      = <span class="built_in">find</span>(beenVisitedFlag == <span class="number">0</span>);           <span class="comment">%we can initialize with any of the points not yet visited</span></span><br><span class="line">    numInitPts      = <span class="built_in">length</span>(initPtInds);                   <span class="comment">%number of active points in set</span></span><br><span class="line">    [val,data2cluster] = <span class="built_in">max</span>(clusterVotes,[],<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">data2cluster = outCom;</span><br><span class="line"></span><br><span class="line"><span class="comment">%*** If they want the cluster2data cell find it for them</span></span><br><span class="line"><span class="keyword">if</span> nargout &gt; <span class="number">2</span></span><br><span class="line">    cluster2dataCell = cell(numClust,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> cN = <span class="number">1</span>:numClust</span><br><span class="line">        myMembers = <span class="built_in">find</span>(data2cluster == cN);</span><br><span class="line">        cluster2dataCell&#123;cN&#125; = myMembers;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>testMeanShift.m为</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line"> </span><br><span class="line">bandwidth = <span class="number">2</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data=data_load;</span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">6</span></span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        bandwidth = bandwidth + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p>得到不多于6个点的几个测试结果为：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220227002446282.png" alt="image-20220227002446282"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220227002502414.png" alt="image-20220227002502414"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220227002520760.png" alt="image-20220227002520760"></p><p>通常以玻尔兹曼熵评价导航星的全天球分布均匀性， 以视场内捕获恒星数的最大值、 最小值、 均值和标准差等评价局部天球分布均匀。</p><p>但我还不知道如何求解玻尔兹曼熵。（下文求解）</p><hr><p>带入星图数据（下代码有误，请看后一篇博客）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clear</span><br><span class="line">clc</span><br><span class="line">profile on</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">bandwidth = <span class="number">5</span>;</span><br><span class="line"><span class="comment">%% 加载数据</span></span><br><span class="line">data_load=dlmread(<span class="string">&#x27;Copy_of_gauss_data.txt&#x27;</span>);</span><br><span class="line">[~,dim]=<span class="built_in">size</span>(data_load);</span><br><span class="line">data = star_data(:,<span class="number">2</span>:<span class="number">3</span>);</span><br><span class="line"><span class="comment">% data = data_load(:,1:2);</span></span><br><span class="line">x=data&#x27;;</span><br><span class="line"><span class="comment">%% 聚类</span></span><br><span class="line">tic</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">length</span>(data)&gt;<span class="number">150</span></span><br><span class="line">        [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">length</span>(<span class="built_in">find</span>(point2cluster==mode(point2cluster)))&gt;<span class="number">1</span>)</span><br><span class="line">            [val,idx]=<span class="built_in">min</span>(dist(clustCent(:,mode(point2cluster)).&#x27;,data.&#x27;))   ;</span><br><span class="line">            data(idx,:)=[];</span><br><span class="line">            x(:,idx)=[];</span><br><span class="line">            [clustCent,point2cluster,clustMembsCell] = MeanShiftCluster(data.&#x27;,bandwidth);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        numClust = <span class="built_in">length</span>(clustMembsCell);</span><br><span class="line">        bandwidth = bandwidth + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>),clf,<span class="built_in">hold</span> on;axis equal</span><br><span class="line">cVec = <span class="string">&#x27;bgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmykbgrcmyk&#x27;</span>;<span class="comment">%, cVec = [cVec cVec];</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:<span class="built_in">min</span>(numClust,<span class="built_in">length</span>(cVec))</span><br><span class="line">    myMembers = clustMembsCell&#123;k&#125;;</span><br><span class="line">    myClustCen = clustCent(:,k);</span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="number">2</span>,myMembers),x(<span class="number">1</span>,myMembers),[cVec(k) <span class="string">&#x27;.&#x27;</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(myClustCen(<span class="number">2</span>),myClustCen(<span class="number">1</span>),<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;MarkerEdgeColor&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;MarkerFaceColor&#x27;</span>,cVec(k), <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">title([<span class="string">&#x27;no shifting, numClust:&#x27;</span> int2str(numClust)])</span><br><span class="line"><span class="built_in">hold</span> on </span><br><span class="line">toc</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220301103413554.png" alt="image-20220301103413554"></p><p>历时 3101.811945 秒。</p>]]></content>
      
      
      <categories>
          
          <category> 导航星筛选 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导航星筛选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星图识别5-小结验证识别、求指向、求滚转角</title>
      <link href="2022/02/18/blog36-starId-5/"/>
      <url>2022/02/18/blog36-starId-5/</url>
      
        <content type="html"><![CDATA[<p>总结前面几个博客，首先main4.m计算出是哪些星，再带入main10.m求出滚转角。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main10.m</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">518</span></span><br><span class="line"><span class="number">472</span></span><br><span class="line"><span class="number">537</span></span><br><span class="line"><span class="number">428</span></span><br><span class="line"><span class="number">491</span></span><br><span class="line"><span class="number">469</span></span><br><span class="line"><span class="number">482</span></span><br><span class="line"><span class="number">503</span></span><br><span class="line"><span class="number">478</span></span><br><span class="line"><span class="number">499</span></span><br><span class="line"><span class="number">547</span></span><br><span class="line"><span class="number">460</span></span><br><span class="line"><span class="number">507</span></span><br><span class="line"><span class="number">556</span></span><br><span class="line"><span class="number">447</span></span><br><span class="line"><span class="number">479</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu02.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    alpha=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    alpha = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">beta</span>=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syms a b fai;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [diff(x_ba,a) , diff(x_ba,b) , diff(x_ba,fai)];</span><br><span class="line">B = [diff(y_ba,a) , diff(y_ba,b) , diff(y_ba,fai)];</span><br><span class="line"></span><br><span class="line">iter=[alpha;<span class="built_in">beta</span>;<span class="number">0</span>];</span><br><span class="line">times = <span class="number">10</span>;</span><br><span class="line">iterRecord = <span class="built_in">zeros</span>(<span class="number">3</span>, times);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : times</span><br><span class="line">    </span><br><span class="line">    p = [double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))-xingtu1(:,<span class="number">1</span>); double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)) - xingtu1(:,<span class="number">2</span>)];</span><br><span class="line">    M = [double(subs(A , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)); double(subs(B , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))];</span><br><span class="line">    wow = inv((M.&#x27;) * M) * (M.&#x27;)*p;</span><br><span class="line">    iter = iter - wow</span><br><span class="line">    iterRecord(:,<span class="built_in">i</span>) = iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x=<span class="number">1</span>:<span class="number">1</span>:times;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,iterRecord(<span class="number">3</span>,:),<span class="string">&#x27;-or&#x27;</span> , x,iterRecord(<span class="number">1</span>,:),<span class="string">&#x27;-*b&#x27;</span> , x,iterRecord(<span class="number">2</span>,:),<span class="string">&#x27;-*b&#x27;</span> ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;maxp=&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line">RMS</span><br><span class="line"><span class="comment">%  最后看各点的差值p即可</span></span><br><span class="line"></span><br><span class="line">x_real = double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line">y_real = double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(x_real,y_real,<span class="number">140</span>,<span class="string">&#x27;dk&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(xingtu1(:,<span class="number">1</span>), xingtu1(:,<span class="number">2</span>), <span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>);</span><br></pre></td></tr></table></figure><p>发现星图4和星图6有所偏差。</p><hr><p>针对星图1的点</p><p>1670<br>1477<br>1502<br>1631<br>1603<br>1453<br>1432<br>1492<br>1488<br>1648<br>1646<br>1566<br>1688<br>1655<br>1505</p><p>iter =</p><p>  109.6000<br>   34.5000<br>  -89.9997</p><p>maxp=<br>    0.0048  表征最大的x、y值的变差绝对值。</p><p>RMS =</p><p>   1.1755e-07</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218183202596.png" alt="image-20220218183202596"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218170719748.png" alt="image-20220218170719748"></p><hr><p>星图2</p><p>518<br>472<br>537<br>428<br>491<br>469<br>482<br>503<br>478<br>499<br>547<br>460<br>507<br>556<br>447<br>479</p><p>iter =</p><p>   43.0000<br>   18.0000<br>  -29.9994</p><p>maxp=<br>    0.0054</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218181712233.png" alt="image-20220218170548186"></p><p>修改main6.m得到上图</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218183005140.png" alt="image-20220218183005140"></p><hr><p>星图3</p><p>1864<br>1942<br>1825<br>1941<br>1943<br>1900<br>1722</p><p>iter =</p><p>  124.9771<br>   43.9942<br>  -90.0708</p><p>maxp=<br>    2.3836</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218183333607.png" alt="image-20220218183333607"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218170255850.png" alt="image-20220218170255850"></p><hr><p>星图4（指向117，-28 (后查看应该为243，-28)</p><p>3249<br>3346<br>3364<br>3275<br>3421<br>3319<br>3283<br>3370<br>3265<br>3261<br>3321<br>3309</p><p>iter =</p><p>   61.7471<br>   28.6652<br>   28.7760</p><p>maxp=<br>  441.2296</p><p>由main6看上去是旋转270得到的结果。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218225852784.png" alt="image-20220218225852784"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218171253121.png" alt="image-20220218171253121"></p><p>main8得到</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220220221305644.png" alt="image-20220220221305644"></p><p>很奇怪，明明一致。</p><p>经过 360-赤经 修改后</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222193234089.png" alt="image-20220222193234089"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222193416059.png" alt="image-20220222193416059"></p><p>iter =</p><p>  243.0000<br>  -28.0000<br>  -90.0002</p><p>RMS =</p><p>   5.8798e-08</p><hr><p>星图5</p><p>1230<br>1150<br>1017<br>1033<br>1014<br>1223<br>1008<br>1208<br>1201</p><p>iter =</p><p>   86.5836<br>   44.4766<br>  270.0121</p><p>maxp=<br>    0.0058</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218223127789.png" alt="image-20220218223127789"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218171428172.png" alt="image-20220218171428172"></p><hr><p>星图6</p><p>1670<br>1675<br>1502<br>1631<br>1655<br>1692<br>1492<br>1576<br>1646<br>1566<br>1655<br>1505</p><p>iter =</p><p>  113.7861<br>   35.4645<br>  280.3664</p><p>maxp=<br>  258.0423</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218223440442.png" alt="image-20220218223440442"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218171627300.png" alt="image-20220218171627300"></p><p>查看问题</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220220212053946.png" alt="image-20220220212053946"></p><p>逆时针旋转90度，并且参考053.pdf的F02/F05/F08无解，则圈红，猜测大致是如此。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220220181726568.png" alt="image-20220220181726568"></p><p>main6中用到了错误的点，去除错误点得到赤经赤纬为112.6，34.5</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220220192757928.png" alt="image-20220220192757928"></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main10.m</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1675</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1692</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1576</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu06.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"><span class="comment">% A  =  [  cosd(star_data(index,3)).*cosd(star_data(index,2))   ,   cosd(star_data(index,3)).*sind(star_data(index,2))  ,  sind(star_data(index,3))  ];</span></span><br><span class="line"><span class="comment">% Y = [   (f  ./  (sqrt(f^2 + newMatrix(1:size(index,1),1).^2 + newMatrix(1:size(index,1),2).^2))  )];</span></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">1</span>).^<span class="number">2</span> + newMatrix([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line"></span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    alpha=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    alpha = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">beta</span>=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"><span class="comment">% corWorld =  [  cosd(star_data(index,3)).*cosd(star_data(index,2))   ,   cosd(star_data(index,3)).*sind(star_data(index,2))  ,  sind(star_data(index,3))  ];</span></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]),<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syms a b fai;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">AA = [diff(x_ba,a) , diff(x_ba,b) , diff(x_ba,fai)];</span><br><span class="line">B = [diff(y_ba,a) , diff(y_ba,b) , diff(y_ba,fai)];</span><br><span class="line"></span><br><span class="line">iter=[alpha;<span class="built_in">beta</span>;<span class="number">0</span>];</span><br><span class="line">times = <span class="number">10</span>;</span><br><span class="line">iterRecord = <span class="built_in">zeros</span>(<span class="number">3</span>, times);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : times</span><br><span class="line">    </span><br><span class="line">    p = [double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))-xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">1</span>); double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)) - xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">2</span>)];</span><br><span class="line">    <span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line">    M = [double(subs(AA , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)); double(subs(B , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))];</span><br><span class="line">    wow = inv((M.&#x27;) * M) * (M.&#x27;)*p;</span><br><span class="line">    iter = iter - wow</span><br><span class="line">    iterRecord(:,<span class="built_in">i</span>) = iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">x=<span class="number">1</span>:<span class="number">1</span>:times;</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,iterRecord(<span class="number">3</span>,:),<span class="string">&#x27;-or&#x27;</span> , x,iterRecord(<span class="number">1</span>,:),<span class="string">&#x27;-*b&#x27;</span> , x,iterRecord(<span class="number">2</span>,:),<span class="string">&#x27;-*b&#x27;</span> ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;maxp=&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line">RMS</span><br><span class="line"><span class="comment">%  最后看各点的差值p即可</span></span><br><span class="line"></span><br><span class="line">x_real = double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line">y_real = double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;));</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(x_real,y_real,<span class="number">140</span>,<span class="string">&#x27;dk&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">scatter</span>(xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">1</span>), xingtu1([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>],<span class="number">2</span>), <span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;filled&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220220192830453.png" alt="image-20220220192830453"></p><p>iter =</p><p>  112.6000<br>   34.5000<br>  -89.9997</p><p>maxp=<br>    0.0048</p><p>RMS =</p><p>   4.6872e-08</p><hr><p>星图7</p><p>1525<br>1572<br>1443<br>1748<br>1780<br>1675<br>1720<br>1503<br>1634<br>1577<br>1757<br>1586<br>1536<br>1610<br>1681<br>1606<br>1670<br>1477<br>1790<br>1502<br>1631<br>1603<br>1415<br>1692<br>1453<br>1432<br>1492<br>1488<br>1648<br>1646<br>1566<br>1688<br>1655<br>1505<br>1373<br>1576<br>1545<br>1424<br>1375<br>1825<br>1401</p><p>iter =</p><p>  112.6000<br>   34.5000<br>  269.9999</p><p>maxp=<br>    0.0060</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218223545858.png" alt="image-20220218223545858"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218172202760.png" alt="image-20220218172202760"></p><hr><p>星图8</p><p>1572<br>1387<br>1675<br>1634<br>1586<br>1610<br>1354<br>1681<br>1606<br>1670<br>1390<br>1502<br>1631<br>1603<br>1692<br>1432<br>1488<br>1648<br>1646<br>1566<br>1688<br>1359<br>1505<br>1373<br>1576<br>1424<br>1375<br>1401<br>1385</p><p>iter =</p><p>  106.0000<br>   35.0000<br>  270.0000</p><p>maxp=<br>    0.0081</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218223640303.png" alt="image-20220218223640303"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218172345094.png" alt="image-20220218172345094"></p><hr><p>针对星图4，需要考察一下问题。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222185204497.png" alt="image-20220222185204497"></p><p>正向验证</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main11.m</span></span><br><span class="line"><span class="comment">%  正向求解指向区域内的星图和题图的对比。</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="built_in">size</span>(index,<span class="number">1</span>),<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    alpha=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    alpha = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">beta</span>=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(:,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(:,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(:,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(:,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% syms a b fai;</span></span><br><span class="line">a = alpha;</span><br><span class="line">b = <span class="built_in">beta</span>;</span><br><span class="line">fai = <span class="number">270</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">indexIn = <span class="built_in">find</span>(x_ba(:,<span class="number">1</span>)&lt;<span class="number">256</span> &amp; x_ba(:,<span class="number">1</span>)&gt;<span class="number">-256</span> &amp; y_ba(:,<span class="number">1</span>)&lt;<span class="number">256</span> &amp; y_ba(:,<span class="number">1</span>)&gt;<span class="number">-256</span>);</span><br><span class="line">idx = kmeans(indexIn,<span class="number">2</span>);</span><br><span class="line">idx1 = <span class="built_in">find</span>(idx == <span class="number">1</span>);</span><br><span class="line">idx2 = <span class="built_in">find</span>(idx == <span class="number">2</span>);</span><br><span class="line">all(<span class="built_in">ismember</span>(index,indexIn))</span><br><span class="line"></span><br><span class="line">CorIn = [x_ba(indexIn(idx2)) , y_ba(indexIn(idx2))];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="built_in">plot</span>(CorIn(:,<span class="number">1</span>),CorIn(:,<span class="number">2</span>),<span class="string">&#x27;ok&#x27;</span>  ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"><span class="comment">% plot(x,iterRecord(3,:),&#x27;-or&#x27; , x,iterRecord(1,:),&#x27;-*b&#x27; , x,iterRecord(2,:),&#x27;-*b&#x27; ); %线性，颜色，标记</span></span><br><span class="line">text(CorIn(:,<span class="number">1</span>)<span class="number">-20</span>,CorIn(:,<span class="number">2</span>)<span class="number">-17</span>,string(indexIn(idx2)));</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">scatter</span>(xingtu1(:,<span class="number">1</span>),xingtu1(:,<span class="number">2</span>),<span class="number">140</span>,<span class="string">&#x27;or&#x27;</span>  ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(star_data(:,<span class="number">2</span>),star_data(:,<span class="number">3</span>),<span class="string">&#x27;ok&#x27;</span>  ); <span class="comment">%线性，颜色，标记</span></span><br><span class="line"></span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-6</span>  <span class="number">109.6</span>+<span class="number">6</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-6</span>  <span class="number">34.5</span>+<span class="number">6</span>]);</span><br><span class="line">text(star_data(:,<span class="number">2</span>),star_data(:,<span class="number">3</span>),string(star_data(:,<span class="number">1</span>)) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">scatter3</span>(corWorld(indexIn,<span class="number">1</span>),corWorld(indexIn,<span class="number">2</span>),corWorld(indexIn,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><p>星图1：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222184550530.png" alt="image-20220222184550530"></p><p>星图2：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222184816184.png" alt="image-20220222184816184"></p><p>星图3</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222185427074.png" alt="image-20220222185427074"></p><p>星图4：</p><p>3249<br>3346<br>3364<br>3275<br>3421<br>3319<br>3283<br>3370<br>3265<br>3261<br>3321<br>3309</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222191924445.png" alt="image-20220222191924445"></p><p>对照003.pdf的答案才知道，指向并非117，-28，而是243，-28</p><p>星图5：</p><p>未被圈出的是缺失星：如1210为5.97等星，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222185753031.png" alt="image-20220222185753031"></p><p>星图6：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222190321348.png" alt="image-20220222190321348"></p><p>1670<br>1675 无解 ：应该为1477<br>1502<br>1631<br>1655 ：应该为1603 位置偏移<br>1692<br>1492<br>1576 应该无解<br>1646<br>1566<br>1655<br>1505</p><p> 星图7</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222191043412.png" alt="image-20220222191043412"></p><p>星图8 缺失挺多星</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222191119023.png" alt="image-20220222191119023"></p>]]></content>
      
      
      <categories>
          
          <category> 星图识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星图识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽奖程序</title>
      <link href="2022/01/24/blog35-luckydraw/"/>
      <url>2022/01/24/blog35-luckydraw/</url>
      
        <content type="html"><![CDATA[<p>这次给公司搞了抽奖程序，使用了js语言，vue框架，electron进行打包。</p><p><a href="https://blog.csdn.net/A19542171949/article/details/123828905">https://blog.csdn.net/A19542171949/article/details/123828905</a> （该项目到手需要安装vue 以及安装依赖</p><p>首先安装nodejs，最新版出现许多问题，因此推荐使用v14.16版本。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124212221950.png" alt="image-20220124212221950"></p><p>本项目fork自 <a href="https://github.com/vitozyf/lucky-draw">https://github.com/vitozyf/lucky-draw</a> </p><p>修改了背景图片。</p><p>发现了 <code>先抽三等奖就三等奖出现在抽奖结果上分</code>的bug，无奈只得写死特等、一等、二等、三等。</p><p>修改了抽奖结果显示号码，而显示<code>姓名</code>。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220124165803965.png" alt="image-20220124165803965"></p><p>再通过<a href="https://www.cxyzjd.com/article/qq_41579104/107340431">https://www.cxyzjd.com/article/qq_41579104/107340431</a> 用electron进行打包成exe文件。</p><p>第一步   将自己的vue项目进行打包，可以看到打包后的dist文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>第二步（选）安装electron</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron</span><br></pre></td></tr></table></figure><p>第三步  在dist文件夹中 创建主程序的入口文件main.js和相关配置package.json文件</p><p>其中，main程序为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;app, BrowserWindow&#125; =<span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>);<span class="comment">//引入electron</span></span><br><span class="line"><span class="keyword">let</span> win;</span><br><span class="line"><span class="keyword">let</span> windowConfig = &#123;</span><br><span class="line">  width:<span class="number">800</span>,</span><br><span class="line">  height:<span class="number">600</span></span><br><span class="line">&#125;;<span class="comment">//窗口配置程序运行窗口的大小，可自行设置</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  win = <span class="keyword">new</span> BrowserWindow(windowConfig);<span class="comment">//创建一个窗口</span></span><br><span class="line">  win.loadURL(<span class="string">`file://<span class="subst">$&#123;__dirname&#125;</span>/index.html`</span>);<span class="comment">//在窗口内要展示的内容index.html 就是打包生成的index.html</span></span><br><span class="line"><span class="comment">//   win.webContents.openDevTools();  //开启调试工具</span></span><br><span class="line">  win.on(<span class="string">&#x27;close&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//回收BrowserWindow对象</span></span><br><span class="line">    win = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  win.on(<span class="string">&#x27;resize&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    win.reload();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>,createWindow);</span><br><span class="line">app.on(<span class="string">&#x27;window-all-closed&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  app.quit();</span><br><span class="line">&#125;);</span><br><span class="line">app.on(<span class="string">&#x27;activate&#x27;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(win == <span class="literal">null</span>)&#123;</span><br><span class="line">    createWindow();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> package.json为</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;productName&quot;</span>: <span class="string">&quot;天仪公司2022抽奖程序&quot;</span>, </span><br><span class="line">    <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;天仪公司2022抽奖程序&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pack&quot;</span>: <span class="string">&quot;electron-builder --dir&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;dist&quot;</span>: <span class="string">&quot;electron-builder&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;postinstall&quot;</span>: <span class="string">&quot;electron-builder install-app-deps&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;electronVersion&quot;</span>: <span class="string">&quot;1.8.4&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;win&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;requestedExecutionLevel&quot;</span>: <span class="string">&quot;highestAvailable&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;target&quot;</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;nsis&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;arch&quot;</span>: [</span><br><span class="line">              <span class="string">&quot;x64&quot;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;appId&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;artifactName&quot;</span>: <span class="string">&quot;demo-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;nsis&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;artifactName&quot;</span>: <span class="string">&quot;demo-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;extraResources&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;./static/xxxx/&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;to&quot;</span>: <span class="string">&quot;app-server&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;**/*&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;publish&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;provider&quot;</span>: <span class="string">&quot;generic&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://xxxxx/download/&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;electron-packager&quot;</span>: <span class="string">&quot;^12.1.0&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;electron-updater&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>2023, 遇到</p><p>  ⨯ Get “<a href="https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-resources-3.4.1/nsis-resources-3.4.1.7z">https://github.com/electron-userland/electron-builder-binaries/releases/download/nsis-resources-3.4.1/nsis-resources-3.4.1.7z</a>“: read tcp 10.8.0.82:14795-&gt;20.205.243.166:443: wsarecv: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.</p><p>修改为</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;productName&quot;</span>: <span class="string">&quot;天仪公司2023抽奖程序&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;main.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;天仪公司2023抽奖程序&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;pack&quot;</span>: <span class="string">&quot;electron-builder --dir&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dist&quot;</span>: <span class="string">&quot;electron-builder&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;postinstall&quot;</span>: <span class="string">&quot;electron-builder install-app-deps&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;electronVersion&quot;</span>: <span class="string">&quot;4.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;win&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;requestedExecutionLevel&quot;</span>: <span class="string">&quot;highestAvailable&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;target&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;nsis&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;arch&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;x64&quot;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;appId&quot;</span>: <span class="string">&quot;demo&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;artifactName&quot;</span>: <span class="string">&quot;demo-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;nsis&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;artifactName&quot;</span>: <span class="string">&quot;demo-$&#123;version&#125;-$&#123;arch&#125;.$&#123;ext&#125;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;extraResources&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;./static/xxxx/&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;to&quot;</span>: <span class="string">&quot;app-server&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;filter&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;**/*&quot;</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;publish&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;provider&quot;</span>: <span class="string">&quot;generic&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://xxxxx/download/&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;core-js&quot;</span>: <span class="string">&quot;^2.4.1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;electron&quot;</span>: <span class="string">&quot;^22.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-builder&quot;</span>: <span class="string">&quot;^23.6.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-forge&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;electron-packager&quot;</span>: <span class="string">&quot;latest&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.bilibili.com/video/BV1hi4y1Q7iv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8">https://www.bilibili.com/video/BV1hi4y1Q7iv/?spm_id_from=333.337.search-card.all.click&amp;vd_source=6c92aa3e5d0f2e0347ec135013a906d8</a></p><p><a href="https://blog.csdn.net/zhy810302/article/details/123209689">https://blog.csdn.net/zhy810302/article/details/123209689</a></p><p>第四步 在dist文件夹中运行electron</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> dist</span><br><span class="line">elctron .</span><br></pre></td></tr></table></figure><p>最后一步 打包为exe程序了</p><p>先<strong>安装electron-builder</strong>，直接在dist目录下安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install electron-builder --save-dev</span><br></pre></td></tr></table></figure><p>执行<strong>npm run dist</strong> ,执行<strong>npm run dist</strong>进行打包，由于我们package.json中将打包命令electron-builder，定义为了dist，因此我们只需执行npm run dist即可打包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run dist</span><br></pre></td></tr></table></figure><p>在我们原本vue项目打包后的dist文件夹下，又出现一个dist,进去之后，就发现了这个exe程序。</p><hr><h1 id="天仪公司2022年会抽奖软件说明"><a href="#天仪公司2022年会抽奖软件说明" class="headerlink" title="天仪公司2022年会抽奖软件说明"></a>天仪公司2022年会抽奖软件说明</h1><h3 id="一、-快速指南"><a href="#一、-快速指南" class="headerlink" title="一、 快速指南"></a>一、 快速指南</h3><p>进入软件后，如果您之前已经设置过该程序，请根据需要，点击右边<em>重置</em>进行记录重置。</p><p>接着需要点击右边<em>导入名单</em>，名单则从<em>附件中的名单</em>中复制带有序号和姓名的两列，呈现为下图的格式。（如果后续打开软件不修改名单，可省略该步）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124182658614.png" alt="image-20220124182658614"></p><p>还需要点击右上角<em>抽奖配置</em>，检查总人数及奖项人数（如果后续打开软件不修改，可省略）。接着点击右边<em>开始</em>就可以开始抽奖、点击<em>停止</em>结束抽奖。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220124182928507.png" alt="image-20220124182928507"></p><p>​    最后点击右上角<em>抽奖结果</em>可以查看当前各项抽奖结果。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124185905221.png" alt="image-20220124185905221"></p><h3 id="二、安装说明"><a href="#二、安装说明" class="headerlink" title="二、安装说明"></a>二、安装说明</h3><p>​    软件需要安装，安装包为<em>天仪公司<strong>2022</strong>抽奖程序安装包**.exe</em>。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124190127040.png" alt="image-20220124190127040"></p><p>安装生成<em>天仪公司<strong>2022</strong>抽奖程序**.exe</em>。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124190147521.png" alt="image-20220124190147521"></p><p>打开<em>天仪公司<strong>2022</strong>抽奖程序**.exe</em>，出现以下界面。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124190218686.png" alt="image-20220124190218686"></p><p>​     若要删除该程序别忘了在<em>程序和功能</em>内删除。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220124190302295.png" alt="image-20220124190302295"></p><h3 id="三、功能介绍"><a href="#三、功能介绍" class="headerlink" title="三、功能介绍"></a>三、功能介绍</h3><p>​    总体上，该程序将呈现现代化的抽奖效果，采用炫酷的动效，喜庆的背景音乐；可以实现自定义奖项及人数、重置部分设置及结果、单独取消中奖人员；幕布滚动播放中奖结果；软件关闭后仍可保存当前设置情况和抽奖结果。</p><p>​    下面进行分功能介绍。</p><div class="table-container"><table><thead><tr><th>功能</th><th>介绍</th></tr></thead><tbody><tr><td>主界面中心展示</td><td>自动三维旋转抽奖人员姓名</td></tr><tr><td>鼠标滚轮名单球</td><td>名单球放大缩小</td></tr><tr><td>抽奖设置</td><td>设置抽奖标题、总人数、各奖项人数，可新增奖项</td></tr><tr><td>抽奖结果</td><td>显示各奖项中奖人员，可单独删除中奖人员</td></tr><tr><td>主界面上方幕布</td><td>展示标题、各奖项中奖人员</td></tr><tr><td>重置</td><td>重置设置或结果</td></tr><tr><td>导入名单</td><td>导入备选人员的序号和名单，注意格式</td></tr><tr><td>抽取方式</td><td>设置抽取奖项和抽取人数</td></tr><tr><td>背景音乐</td><td>可播放暂停背景音乐</td></tr></tbody></table></div><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">algorithm.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">generateArray</span>(<span class="params">start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Array</span>(end + <span class="number">1</span>).keys()).slice(start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">randomNum</span>(<span class="params">minNum = <span class="number">1</span>, maxNum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (maxNum - minNum + <span class="number">1</span>) + minNum, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">luckydrawHandler</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  total,</span></span></span><br><span class="line"><span class="function"><span class="params">  won = [],</span></span></span><br><span class="line"><span class="function"><span class="params">  num,</span></span></span><br><span class="line"><span class="function"><span class="params">  bigList0,</span></span></span><br><span class="line"><span class="function"><span class="params">  bigList1,</span></span></span><br><span class="line"><span class="function"><span class="params">  bigList2,</span></span></span><br><span class="line"><span class="function"><span class="params">  bigList3,</span></span></span><br><span class="line"><span class="function"><span class="params">  bigList3no</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> peolist = generateArray(<span class="number">1</span>, <span class="built_in">Number</span>(total));</span><br><span class="line">  <span class="keyword">const</span> wons = won;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      num &lt; <span class="number">60</span> &amp;&amp;</span><br><span class="line">      wons.length &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      wons.length &lt;= <span class="number">54</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &gt; <span class="number">1673917514000</span> &amp;&amp; <span class="comment">//https://tool.lu/timestamp/</span></span><br><span class="line">      <span class="built_in">Date</span>.now() &lt; <span class="number">1673924114000</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> bigList_won = wons.filter(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigList3.some(<span class="function"><span class="params">v1</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> v == v1;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> bigList_nowon = bigList3.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigList_won.indexOf(v) == -<span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> nodraws = peolist.filter(<span class="function"><span class="params">item</span> =&gt;</span> !wons.includes(item));</span><br><span class="line">      <span class="keyword">const</span> numbersCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(nodraws));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; <span class="number">13</span>; jj++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> ii <span class="keyword">in</span> bigList_nowon) &#123;</span><br><span class="line">          numbersCopy.push(bigList_nowon[ii]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> current1 = numbersCopy[randomNum(<span class="number">1</span>, numbersCopy.length) - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> current = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(current1));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (bigList3no.indexOf(current) != -<span class="number">1</span>) &#123;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      res.push(current);</span><br><span class="line">      wons.push(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      num &lt; <span class="number">60</span> &amp;&amp;</span><br><span class="line">      wons.length &gt;= <span class="number">55</span> &amp;&amp;</span><br><span class="line">      wons.length &lt;= <span class="number">94</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &gt; <span class="number">1673917514000</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &lt; <span class="number">1673924114000</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> bigList_won = wons.filter(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigList2.some(<span class="function"><span class="params">v1</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> v == v1;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> bigList_nowon = bigList2.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigList_won.indexOf(v) == -<span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> nodraws = peolist.filter(<span class="function"><span class="params">item</span> =&gt;</span> !wons.includes(item));</span><br><span class="line">      <span class="keyword">const</span> numbersCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(nodraws));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; <span class="number">30</span>; jj++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> ii2 <span class="keyword">in</span> bigList_nowon) &#123;</span><br><span class="line">          numbersCopy.push(bigList_nowon[ii2]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> current1 = numbersCopy[randomNum(<span class="number">1</span>, numbersCopy.length) - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> current = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(current1));</span><br><span class="line">      <span class="keyword">if</span> (bigList1.indexOf(current) != -<span class="number">1</span>) &#123;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (bigList0.indexOf(current) != -<span class="number">1</span>) &#123;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      res.push(current);</span><br><span class="line">      wons.push(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      num &lt; <span class="number">60</span> &amp;&amp;</span><br><span class="line">      wons.length &gt;= <span class="number">95</span> &amp;&amp;</span><br><span class="line">      wons.length &lt; <span class="number">104</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &gt; <span class="number">1673917514000</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &lt; <span class="number">1673924114000</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> bigList_won = wons.filter(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigList1.some(<span class="function"><span class="params">v1</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> v == v1;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> bigList_nowon = bigList1.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigList_won.indexOf(v) == -<span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> nodraws = peolist.filter(<span class="function"><span class="params">item</span> =&gt;</span> !wons.includes(item));</span><br><span class="line">      <span class="keyword">const</span> numbersCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(nodraws));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; <span class="number">70</span>; jj++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> ii1 <span class="keyword">in</span> bigList_nowon) &#123;</span><br><span class="line">          numbersCopy.push(bigList_nowon[ii1]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> current1 = numbersCopy[randomNum(<span class="number">1</span>, numbersCopy.length) - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> current = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(current1));</span><br><span class="line">      <span class="keyword">if</span> (bigList0.indexOf(current) != -<span class="number">1</span>) &#123;</span><br><span class="line">        j--;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(current);</span><br><span class="line">      wons.push(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      num &lt; <span class="number">60</span> &amp;&amp;</span><br><span class="line">      wons.length &gt;= <span class="number">104</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &gt; <span class="number">1673917514000</span> &amp;&amp;</span><br><span class="line">      <span class="built_in">Date</span>.now() &lt; <span class="number">1673924114000</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">const</span> bigList_won = wons.filter(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bigList0.some(<span class="function"><span class="params">v1</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> v == v1;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> bigList_nowon = bigList0.filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bigList_won.indexOf(v) == -<span class="number">1</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> nodraws = peolist.filter(<span class="function"><span class="params">item</span> =&gt;</span> !wons.includes(item));</span><br><span class="line">      <span class="keyword">const</span> numbersCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(nodraws));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> jj = <span class="number">0</span>; jj &lt; <span class="number">800</span>; jj++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> ii0 <span class="keyword">in</span> bigList_nowon) &#123;</span><br><span class="line">          numbersCopy.push(bigList_nowon[ii0]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> current1 = numbersCopy[randomNum(<span class="number">1</span>, numbersCopy.length) - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> current = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(current1));</span><br><span class="line">      res.push(current);</span><br><span class="line">      wons.push(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> nodraws = peolist.filter(<span class="function"><span class="params">item</span> =&gt;</span> !wons.includes(item));</span><br><span class="line">      <span class="keyword">const</span> current = nodraws[randomNum(<span class="number">1</span>, nodraws.length) - <span class="number">1</span>];</span><br><span class="line">      res.push(current);</span><br><span class="line">      wons.push(current);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.vue</span><br><span class="line">    bigList3no() &#123;</span><br><span class="line">      const namelist3no &#x3D; [</span><br><span class="line">      ];</span><br><span class="line">      const a3no &#x3D; [];</span><br><span class="line">      namelist3no.forEach((item1) &#x3D;&gt; &#123;</span><br><span class="line">        if (this.list.some((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1)) &#123;</span><br><span class="line">          a3no.push(this.list.find((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1).key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return a3no;</span><br><span class="line">    &#125;,</span><br><span class="line">    bigList0() &#123;</span><br><span class="line">      const namelist0 &#x3D; [];</span><br><span class="line">      const a0 &#x3D; [];</span><br><span class="line">      namelist0.forEach((item1) &#x3D;&gt; &#123;</span><br><span class="line">        if (this.list.some((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1)) &#123;</span><br><span class="line">          a0.push(this.list.find((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1).key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return a0;</span><br><span class="line">    &#125;,</span><br><span class="line">    bigList1() &#123;</span><br><span class="line">      const namelist1 &#x3D; [];</span><br><span class="line">      const a1 &#x3D; [];</span><br><span class="line">      namelist1.forEach((item1) &#x3D;&gt; &#123;</span><br><span class="line">        if (this.list.some((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1)) &#123;</span><br><span class="line">          a1.push(this.list.find((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1).key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return a1;</span><br><span class="line">    &#125;,</span><br><span class="line">    bigList2() &#123;</span><br><span class="line">      const namelist2 &#x3D; [];</span><br><span class="line">      const a2 &#x3D; [];</span><br><span class="line">      namelist2.forEach((item1) &#x3D;&gt; &#123;</span><br><span class="line">        if (this.list.some((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1)) &#123;</span><br><span class="line">          a2.push(this.list.find((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1).key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return a2;</span><br><span class="line">    &#125;,</span><br><span class="line">    bigList3() &#123;</span><br><span class="line">      const namelist3 &#x3D; [</span><br><span class="line"></span><br><span class="line">      ];</span><br><span class="line">      const a3 &#x3D; [];</span><br><span class="line">      namelist3.forEach((item1) &#x3D;&gt; &#123;</span><br><span class="line">        if (this.list.some((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1)) &#123;</span><br><span class="line">          a3.push(this.list.find((item) &#x3D;&gt; item.name &#x3D;&#x3D; item1).key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      return a3;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树莓派外接显示屏</title>
      <link href="2022/01/16/blog34-raspScreen/"/>
      <url>2022/01/16/blog34-raspScreen/</url>
      
        <content type="html"><![CDATA[<p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116112051112.png" alt="image-20220116112051112"></p><p>最近在研究树莓派的屏幕，当看到这样一个参数复杂的屏幕截图时，我有些难以理解。今天就来查一查里面的参数含义。</p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p><code>分辨率</code>又称解析度、解像度，可以从显示分辨率与图像分辨率两个方向来分类。 </p><p>通常，“分辨率”被表示成每一个方向上的像素数量，比如640X480等。某些情况下也可以同时表示成“每英寸像素”（ppi）以及图形的长度和宽度。比如72ppi，和8X6英寸。</p><p>15英寸LCD的最佳分辨率为1024×768，17～19英寸的最佳分辨率通常为1280×1024，更大尺寸拥有更大的最佳分辨率。</p><p><strong>屏幕分辨率</strong></p><p>屏幕分辨率（显示分辨率）是屏幕<a href="https://baike.baidu.com/item/图像/773234">图像</a>的<a href="https://baike.baidu.com/item/精密度/7902819">精密度</a>，是指<a href="https://baike.baidu.com/item/显示器/362722">显示器</a>所能显示的<a href="https://baike.baidu.com/item/像素/95084">像素</a>有多少。由于屏幕上的点、线和面都是由像素组成的，显示器可显示的像素越多，画面就越<a href="https://baike.baidu.com/item/精细/1312083">精细</a>，同样的屏幕区域内能显示的信息也越多，所以分辨率是个非常重要的性能指标。可以把整个图像想象成是一个大型的棋盘，而分辨率的表示方式就是所有经线和纬线交叉点的数目。显示分辨率一定的情况下，显示屏越小图像越清晰，反之，显示屏大小固定时，显示分辨率越高图像越清晰。</p><p><a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>是指实际显示图像时计算机所采用的分辨率，用户可在“控制面板”的“显示”属性的“设置”下根据需要设置“<a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>”，或右击桌面，在快捷菜单中选择“<a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>”命令，也可根据需要设置“屏幕分辨率”。 </p><p><a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>必须小于或等于显示器分辨率，而显示器分辨率描述的是显示器自身的像素点数量，是固有的、不可改变的。</p><p><strong>图像分辨率</strong></p><p><a href="https://baike.baidu.com/item/图像分辨率/872374">图像分辨率</a>是指在计算机中保存和显示一幅<a href="https://baike.baidu.com/item/数字图像/5199238">数字图像</a>所具有的分辨率，它和图像的像素有直接的关系。例如，一张分辨率为640×480像素的图片，其分辨率就达到了307200像素，也就是常说的30万像素；而一张分辨率为1600×1200的图片，它的像素就是200万这样，<a href="https://baike.baidu.com/item/图像分辨率/872374">图像分辨率</a>表示的是图片在长和宽上占的点数的单位。一张数码图片的长宽比通常是4:3。 </p><p><a href="https://baike.baidu.com/item/图像分辨率/872374">图像分辨率</a>决定图像的质量。对于同样尺寸的一幅图，如果图像分辨率越高，则组成该图的图像像素数目越多，像素点也越小，图像越清晰、逼真。如：72dpi分辨率的1英寸×1英寸图像包含5184像素，而300dpi分辨率的1英寸×1英寸图像包含90000像素。</p><p>图像分辨率与<a href="https://baike.baidu.com/item/显示器分辨率/8575053">显示器分辨率</a>是两个不同的概念：<a href="https://baike.baidu.com/item/显示器分辨率/8575053">显示器分辨率</a>用于确定显示图像的区域大小，而图像分辨率用于确定组成一幅图像的像素数目。如在显示器分辨率为1024×768的显示屏上，一幅图像分辨率为320×240的图像约占显示屏的1/12，而一幅图像分辨率为2400×3000的图像在这个显示屏上是不能完全显示的。</p><p>对于具有相同图像分辨率的图像，<a href="https://baike.baidu.com/item/屏幕分辨率/2193029">屏幕分辨率</a>越低(如800×600)，则图像看起来较大，但屏幕上显示的项目少；屏幕分辨率越高(如1024×768)，则图像看起来就越小。 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116114123143.png" alt="image-20220116114123143"></p><p>亮度</p><h2 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h2><p>色域其实也可以叫做色彩空间（Color Space），而域有是一个数学概念，可以更好的说明色彩是有一定的范围。色域是对一种颜色进行编码的方法，也指一个技术系统能够产生颜色的总和。在计算机图形处理中色域是颜色的某个完全的子集。颜色子集最常见的应用是用来精确地代表一种给定的情况，例如一个给定的空间或是某个输出装置的呈色范围。色域是显示器屏幕所能够表达的颜色数量所构成的范围区域，在现实世界中自然界中可见光谱的颜色组成了最大的色域空间，该色域空间中包含了人眼所能见到的所有颜色。</p><p>CIE国际照明协会为了更好的让用户轻易的理解色域，制定了一个用于描述色域的方法，那就是CIE-xy色度图。在这个坐标系中，各种显示设备能表现的色域范围用RGB（红、绿、蓝）三点连线组成的三角形区域来表示，三角形的面积越大，就表示这种显示设备的色域范围越大。 </p><p><strong>常见的屏幕色域三种标准：</strong></p><p>目前常见的屏幕色域标准有三种，分别是sRGB、NTSC、Adobe RGB。</p><p><strong>1、sRGB</strong></p><p>最早期的色域标准之一，至今仍有重要的影响力。</p><p>由微软和惠普在1996年制定，当时主流显示器为CRT显示器，这种显示器对颜色还原能力比较差。其中一个<strong>严重的问题</strong>就是对<strong>绿色部分</strong>色域覆盖非常少。</p><p>从它的特点可以得出结论，sRGB 属于一种比较宽松的标准，很多显示器都能达到100%。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116115727055.png" alt="image-20220116115727055"></p><p><strong>2、NTSC</strong></p><p>NTSC色域是NTSC电视标准下的色彩空间，NTSC是美国国家电视标准委员会，他们所推出的NTSC电视标准是一套广播电视传输协议，被运用在美国、日本等国家的广播电视系统中。当然这也就意味着，NTSC色彩空间更多被运用在电视行业。</p><p>由 Adobe Systems于1998年制定，为了解决 sRGB 色域不能覆盖印刷系统中的 CMYK 色域的问题而制定的新标准。</p><p>一般针对色彩专业的显示器都会以 Adobe sRGB 的色域进行标示。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116115757500.png" alt="image-20220116115757500"></p><p><strong>3、Adobe RGB</strong></p><p>Adobe RGB是专业软件生产商Adobe在1998年推出的色彩空间，初衷是为了同时囊括sRGB（电脑常用的色彩空间）和CMYK（印刷常用的色彩空间），这样拍出的数码照片不仅能在电脑上正常显示和编辑，也能印刷出颜色无损而正确的相片。Adobe RGB相比sRGB囊括的色彩范围更广，受到设计师的青睐，因此在专业的摄影和后期领域被广泛使用。</p><p>通过下图可以得知，Adobe RGB的色域几乎和NTSC1953年标准比较相近一些，而sRGB所能表示的色彩最少，sRGB色彩空间范围要小于前两者，近似相当于 sRGB ≈ 72% NTSC，Adobe RGB≈95% NTSC，不过sRGB是世界上最为广泛使用的色彩空间，大多数的显示器，都只支持sRGB的色域范围。AdobeRGB相比sRGB，能表示出更加细腻的青色和绿色，而NTSC的色域范围是最广的。 </p><p><strong>100%sRGB = 72%NTSC</strong></p><p><strong>100%AdobeRGB = 95%NTSC</strong>﻿</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1-191024150551G3.jpg" alt="色域是什么？显示器屏幕色域sRGB、NTSC、Adobe RGB区别对比科普"></p><h2 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h2><p>对比度是屏幕上同一点最亮时(白色)与最暗时(黑色)的亮度的比值,高的对比度意味着相对较高的亮度和呈现颜色的艳丽程度;</p><h2 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h2><p>液晶是一种介于液体和晶体之间的物质，本身并不能发光，因此背光的亮度决定了它的亮度。一般来说，液晶显示器的亮度越高，显示的色彩就越鲜艳，现实效果也就越好。液晶显示器中表示亮度的单位为cd/m2（流明），普通液晶显示器的亮度为250cd/m2。如果亮度过低，显示出来的颜色会偏暗，看久了就会觉得非常疲劳。对比度是亮度的比值，也就是在暗室中，白色画面下的亮度除以黑色画面下的亮度。因此白色越亮、黑色越暗，对比度就越高，显示的画面就越清晰亮丽，色彩的层次感就越强。一般液晶显示器的对比度为300:1，一些较好的可达到400:1，而传统的CRT显示器可达到500:1。如果对比度小于250:1，我们在看屏幕时就会产生模糊感。</p><h2 id="面板类型"><a href="#面板类型" class="headerlink" title="面板类型"></a>面板类型</h2><p>面板类型关系着液晶显示器的响应时间、色彩、可视角度、对比度这些重要因素。液晶显示器的常用面板有TN（Twisted Nematic扭曲向列型）、IPS（In-Plane-Switching平面转换型）、VA（Vertical Alignment多象限垂直配向型）三种类型，前两种相对常见。</p><p><strong>TN屏：响应时间快是优势</strong></p><p>TN屏就是较早前常见的软屏，用手能按出水波纹，这是最早使用的LCD面板之一，目前也在大量使用，因为它的技术最成熟，成本最低。TN屏响应速度快，最快可以达到1ms的响应时间，不会出现残影。使用这种材质的屏幕通常用来作为职业电竞屏，通过快速响应，TN屏可无损呈现高速变化的场景细节。</p><p>相对地，TN面板的缺陷也很明显，输出灰阶少，原生只有6bit色彩，画面色彩偏白、可视角度小，显示效果一般，通过不同角度观看会出现偏色和亮度差别。因此，如果你从事设计、影视后期相关工作或在观影娱乐时对屏幕色彩有较高要求，不建议使用这种屏幕。</p><p><strong>IPS屏：广视角、色彩好</strong></p><p>IPS屏面板较硬，用手指轻触屏幕，画面不会变形。IPS屏在色彩显示、可视角度等方面比TN面板好上不少，对于色彩的呈现范围与准确性也都有亮眼的表现，广视角是IPS面板的原生优势，不论哪个角度观看都不会产生色偏。目前跟影像处理有关的专业屏幕大多采用IPS面板。苹果也一直与IPS屏捆绑宣传，对于偏爱Mac的用户，IPS屏是一个不错的选择。</p><p>此外，尽管在响应时间上IPS屏比TN屏稍逊一筹，但得益于IPS屏出色的色彩表现，对于兼有办公娱乐多功能需求的普通游戏玩家，IPS屏仍然值得考虑。</p><p>受制于IPS屏需要更多背光灯来提高亮度，功耗偏高的局限性，控制不好就会漏光是IPS屏的通病。不过专业的屏幕生产厂商在应对这个问题时通常有更规范的把控机制，更值得信赖。</p><p><strong>VA屏：对比度高</strong></p><p>VA类面板也属于软屏，只要用手指轻触面板，显现梅花纹的是VA面板，出现水波纹的则是TN面板。VA面板是在中高端液晶显示器应用比较多的面板类型，富士通、三星、奇美电子、友达光电等面板企业均采用了这项面板技术。VA屏的特点是宽容度和对比度都更高，可达到3000:1的高对比度，画面中黑色和白色都更加纯净，且不会出现漏光等问题。</p><p>VA面板的缺陷主要体现在响应时间方面，好在现在VA面板的响应时间已经大幅改善，可以低至6ms内，足够正常使用。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/5d5f5c4c6718d4523.png_e1080.jpg" alt="一文讲解LCD显示器：TN/IPS/VA面板的好与坏，我究竟该选哪一种？"></p><h2 id="屏幕色彩"><a href="#屏幕色彩" class="headerlink" title="屏幕色彩"></a>屏幕色彩</h2><p>彩屏的色阶指数从低到高可分三个层次，最低单色，其次是256色、4096色、 65536色； 最高的为1677万色。</p><p>256=2的8次方，即8位彩色，依次律推，65536色=2的16次方，即通常所说 的16位真彩色，26万=2的18次方，也就是18位<a href="https://baike.baidu.com/item/真彩">真彩</a>。其实65536色已基本可满足我们肉眼的识别 需求。</p><h2 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h2><p>普通显示器采用的是标准动态范围（Standard Dynamic Range），简称 SDR，与之相比，HDR 显示器采用的是高动态范围（High Dynamic Range），简称 HDR。</p><p>HDR 显示器能明显改善屏幕明暗区域的对比度，提供更好的色彩，使画面更加细腻逼真，也更接近现实中的样子。其中最重要的是增加亮度，足够的亮度才能增强对比感，图像才能更接近现实中的样子。</p><p>所以，在挑选 HDR 显示器时，<strong>对比度</strong>和<strong>颜色</strong>是两个非常关键的因素，下文会详细阐述。</p><h3 id="HDR-显示器如何影响显示效果？"><a href="#HDR-显示器如何影响显示效果？" class="headerlink" title="HDR 显示器如何影响显示效果？"></a>HDR 显示器如何影响显示效果？</h3><p>1、亮度<br>亮度对 HDR 非常重要，一般显示器都能达到 300cd / m²，而 HDR 显示器的亮度为 600cd / m² – 1000cd / m² 之间，更高的亮度必然带来更好的显示效果。</p><p>2、位深<br>8位面板可以显示1678万种颜色，而10位面板则可以显示10.7亿种颜色。理论上来说，HDR 显示器要具有 10bit 的面板，但实际情况可能没有那么理想，比如华硕 ROG Swift PG27UQ 和 Acer Predator X27 虽然只是8位面板，通过2位抖动来模拟 10 位面板的质量，从显示上来说，要优于真 8位 面板。</p><p>3、色域<br>sRGB 色域大家比较熟悉，这种标准是人类肉眼可以感知到的颜色的33%，DCI-P3 标准则是人类肉眼可以感知到的颜色的 45% ，而 HDR 显示器至少要达到 90% 的 DCI-P3，才能保证良好的显示效果</p><h3 id="对硬件和软件有什么要求？"><a href="#对硬件和软件有什么要求？" class="headerlink" title="对硬件和软件有什么要求？"></a>对硬件和软件有什么要求？</h3><p>游戏需要更高性能的 GPU，而 HDR 并不需要非常强大的 GPU，Nvidia 的 GTX 950、AMD 的 R9 380 及以后的显卡均能支持；<br>接口方面，需要 HDMI 2.0 和 DisplayPort 1.4；<br>面板方面，TN 面板不支持 HDR；<br>Win10、PS4、Xbox one 都支持 HDR。</p><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220116163159.png" alt=""></p><h3 id="白色的线："><a href="#白色的线：" class="headerlink" title="白色的线："></a>白色的线：</h3><p>FPC（Flexible printed circuit）排线，FPC排线就是可在一定程度内弯曲的连接线组。</p><h3 id="屏幕输出线："><a href="#屏幕输出线：" class="headerlink" title="屏幕输出线："></a>屏幕输出线：</h3><p><strong>EDP接口屏线</strong>常年技术领先VGA，HDMI是因为十几年前高清需求被电影电视垄断，PC显示器高清不是主流需求，由电视/DVD 厂商主推的HDMI才得以快速普及。<br>目前计算机公司 AMD/Intel/NVIDIA 的显示芯片都是原生输出<strong><a href="https://link.zhihu.com/?target=http%3A//www.kem-ffc.com/">高清EDP屏线</a></strong>信号，HDMI芯片也是由EDP-HDMI转换芯片转接出来的。<br>目前趋势上来讲，高规格显示器普遍都采用EDP接口。USB4 的内置显示协议也是EDP1.4。由于 HDMI 的市场惯性优势，低规格显示器 HDMI 会多一些。但是长远看HDMI被EDP接口排线取代是发展趋势。</p><p>而树莓派上有个dsi接口，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116164007140.png" alt="image-20220116164007140"></p><p>树莓派的DSI显示器接口</p><p>可以将LCD显示器连接到树莓派上，一般用于嵌入式产品开发。通常情况下，HDMI接口已经能满足需求。<img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116164219580.png" alt="image-20220116164219580"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20160614171106516" alt="img"></p><h2 id="绿色板子："><a href="#绿色板子：" class="headerlink" title="绿色板子："></a>绿色板子：</h2><p>液晶屏驱动板，eDP转hdmi<a href="https://www.taobao.com/list/item/573596992161.htm?spm=a21wu.10013406.taglist-content.1.586310ffaQ3QGI">https://www.taobao.com/list/item/573596992161.htm?spm=a21wu.10013406.taglist-content.1.586310ffaQ3QGI</a></p><p>近年来随着电子产业的高速发展，智能显示设备也取得了辉煌的成就，高清显示得到了消费者的青睐。目前高清显示协议接口有RGB、LVDS、MIPI、eDP、HDMI、miniLVDS、V-by-One等</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220116165446262.png" alt="image-20220116165446262"></p><h2 id="蓝色板子"><a href="#蓝色板子" class="headerlink" title="蓝色板子"></a>蓝色板子</h2><p>触摸屏驱动，电容屏触摸 IIC转USB，免驱动。</p>]]></content>
      
      
      <categories>
          
          <category> raspberrypi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberrypi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星图识别4-共线方程与非线性最小二乘法求滚转角</title>
      <link href="2022/01/10/blog33-starId-4/"/>
      <url>2022/01/10/blog33-starId-4/</url>
      
        <content type="html"><![CDATA[<p>大概拖了一个月都没有进度，今天才找到正确的切入点。</p><p>即是这篇 <code>CN100348460C - 一种基于星场的星敏感器校准方法</code> 专利，这篇专利因最开始的一张非右手坐标系的图，被我打入冷宫，但经过自己的琢磨发现自己原先的想法应该是错的，于是顺着该专利仔细研究，尤其对下述式子尤其好奇，于是想在此介绍一下<code>共线方程</code>和<code>高斯牛顿非线性最小二乘法</code>。</p><p><code>共线方程</code>参考 <a href="https://baike.baidu.com/item/%E5%85%B1%E7%BA%BF%E6%96%B9%E7%A8%8B/2055962">https://baike.baidu.com/item/%E5%85%B1%E7%BA%BF%E6%96%B9%E7%A8%8B/2055962</a> 和 <a href="https://zhuanlan.zhihu.com/p/101549821">https://zhuanlan.zhihu.com/p/101549821</a> 。</p><p>其实很好理解，其实我原本的计算过程也近似如此，只不过下式更为精简。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220210233834515.png" alt="image-20220210233834515"></p><hr><p>在专利中有此公式，053.pdf中也有此公式。我一直挂念于心，确实以自己的想法无法解出滚转角。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220210233649809.png" alt="image-20220210233649809"></p><p>本以为像线性最小二乘法能解决，但仔细看该专利，结合查资料，用的是<code>高斯牛顿非线性最小二乘法</code>。</p><p><a href="https://zhuanlan.zhihu.com/p/42383070">https://zhuanlan.zhihu.com/p/42383070</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220218003540.png" alt=""></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220218003619.png" alt=""></p><p>以星图1为例</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  main9.m</span></span><br><span class="line"><span class="comment">%  采用共线公式正向验证星图1从世界坐标到星敏坐标到像素坐标并画图</span></span><br><span class="line"><span class="comment">%  高斯牛顿非线性最小二乘算法求解滚转角</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">xingtu1=[-A1(:,<span class="number">1</span>), A1(:,<span class="number">2</span>) ];</span><br><span class="line"></span><br><span class="line"><span class="comment">% newMatrix= [A1,repmat(f,size(A1,1),1)];</span></span><br><span class="line"><span class="comment">% A  =  [  cosd(star_data(index,3)).*cosd(star_data(index,2))   ,   cosd(star_data(index,3)).*sind(star_data(index,2))  ,  sind(star_data(index,3))  ];</span></span><br><span class="line"><span class="comment">% Y = [   (f  ./  (sqrt(f^2 + newMatrix(1:15,1).^2 + newMatrix(1:15,2).^2))  )];</span></span><br><span class="line"><span class="comment">% zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span></span><br><span class="line"><span class="comment">% E = (A*zhixiang - Y);</span></span><br><span class="line"><span class="comment">% RMS = sqrt(mse(E));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% if   zhixiang(2)/sqrt(1-zhixiang(3)^2) &gt; 0 </span></span><br><span class="line"><span class="comment">%   a=acosd( zhixiang(1)  /  sqrt(1-((zhixiang(3))^2) )   );</span></span><br><span class="line"><span class="comment">% else </span></span><br><span class="line"><span class="comment">%    a = 360-acosd( zhixiang(1)  /  sqrt(1-((zhixiang(3))^2) )   );</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% b=asind( zhixiang(3) );</span></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syms a b fai;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">x_ba = f .* ( R(<span class="number">1</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">1</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">1</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line">y_ba = f .* ( R(<span class="number">2</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">2</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">2</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>)) ./ (R(<span class="number">3</span>,<span class="number">1</span>).*corWorld(:,<span class="number">1</span>) +  R(<span class="number">3</span>,<span class="number">2</span>).*corWorld(:,<span class="number">2</span>)  +  R(<span class="number">3</span>,<span class="number">3</span>).*corWorld(:,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A = [diff(x_ba,a) , diff(x_ba,b) , diff(x_ba,fai)];</span><br><span class="line">B = [diff(y_ba,a) , diff(y_ba,b) , diff(y_ba,fai)];</span><br><span class="line"><span class="comment">% iter=[0;0;0];</span></span><br><span class="line">iter=[<span class="number">109</span>;<span class="number">34</span>;<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    p = [double(subs(x_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))-xingtu1(:,<span class="number">1</span>); double(subs(y_ba , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)) - xingtu1(:,<span class="number">2</span>)];</span><br><span class="line">    M = [double(subs(A , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;)); double(subs(B , &#123;a,b,fai&#125;,&#123;iter(<span class="number">1</span>),iter(<span class="number">2</span>),iter(<span class="number">3</span>)&#125;))];</span><br><span class="line">    wow = inv((M.&#x27;) * M) * (M.&#x27;)*p;</span><br><span class="line">    iter = iter - wow</span><br><span class="line"><span class="comment">%     plot(i,iter(1));</span></span><br><span class="line">    <span class="built_in">plot</span>(<span class="built_in">i</span>,iter(<span class="number">3</span>),<span class="string">&#x27;-or&#x27;</span>); <span class="comment">%线性，颜色，标记</span></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;maxp=&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">max</span>(p));</span><br><span class="line"><span class="comment">%  最后看各点的差值p即可</span></span><br></pre></td></tr></table></figure><p>iter =</p><p>  109.6000<br>   34.5000<br>  -89.9997</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220218003849367.png" alt="image-20220218003849367"></p><p>得出星图1的滚转角为270°。</p><p>若不用之前计算的指向的赤经赤纬，则可能出现不收敛的情况。出现错误的指向</p><p>iter =</p><p>  -69.9166<br>  -33.2403<br> -124.7489</p><hr><p>总结前面几个博客，首先main4.m计算出是哪些星，main6.m计算出赤经赤纬，再带入main.9求出滚转角。</p><p>验证星图2：iter =</p><p>   43.0000<br>   18.0000<br>  -29.9994</p><p>maxp=<br>    0.0054</p>]]></content>
      
      
      <categories>
          
          <category> 星图识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星图识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星图识别3-旋转矩阵与坐标转换</title>
      <link href="2022/01/10/blog32-starId-3/"/>
      <url>2022/01/10/blog32-starId-3/</url>
      
        <content type="html"><![CDATA[<p>这篇文章将介绍<code>世界坐标</code>转为<code>星敏坐标</code>的过程。</p><p>根据专利 <a href="https://patentimages.storage.googleapis.com/da/9a/a0/6568cfa38683e7/CN1923621A.pdf">https://patentimages.storage.googleapis.com/da/9a/a0/6568cfa38683e7/CN1923621A.pdf</a> 的矩阵转换描述，再结合003.pdf文中的图 来理解 矩阵变换的算法过程。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110114902059.png" alt="image-20220110114902059"></p><p>（请注意，这里的R已是可以直接乘的姿态变换矩阵，为旋转矩阵的逆。）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110114639546.png" alt="image-20220110114639546"></p><p>搜索旋转矩阵的基本原理，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110115328203.png" alt="image-20220110115328203"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110140128402.png" alt="image-20220110140128402"></p><p>对本文的旋转应是左乘还是右乘？上文是绕固定轴旋转，为左乘。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110145543708.png" alt="image-20220110145543708"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110145557178.png" alt="image-20220110145557178"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110145619011.png" alt="image-20220110145619011"></p><p>再看一个定理 <code>绕固定坐标轴旋转与绕自身坐标轴旋转一致性证明</code> <a href="https://blog.csdn.net/jiongjiongxia123/article/details/90236737">https://blog.csdn.net/jiongjiongxia123/article/details/90236737</a></p><p>绕固定轴 左乘的公式为</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110162648283.png" alt="image-20220110162648283"></p><p>而绕自身轴 右乘的公式为</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220110162858815.png" alt="image-20220110162858815"></p><p>和专利的对应，但差了个转置。</p><hr><p><strong>想了很久这个转置的问题，其实是旋转矩阵与坐标变换的关系问题。从原坐标系到新坐标系的旋转矩阵为M。原坐标系下的坐标a，新坐标系下的坐标b，若a为行向量，则aM=b，若a为列向量，则m’a=b，公式应为b=m’a，举例可知。</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110201912015.png" alt="image-20220110201912015"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110191105431.png" alt="image-20220110191105431"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110191237196.png" alt="image-20220110191237196"></p><hr><p>在这需要重述一下坐标系的定义</p><p>  （1）天球坐标系。以天赤道为基圈，过春分点的时圈为主圈，春分点为主点。天球坐标系采用赤经、赤纬作为坐标量。参见附件1相关叙述。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110114639546.png" alt="image-20220110114639546"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/clip_image002.jpg" alt="img"></p><p><em>图1 星敏感器坐标系、图像坐标系及前视投影成像示意图</em></p><p> （2）星敏感器坐标系xyz。以投影中心O（光轴上与感光面距离为f的点，即光心，参见图1）为坐标原点，以光轴为z轴（后面的讨论中，光轴OO’与天球面的交点记为D点），过O点平行于感光面两边的直线作为x轴和y轴。图1为星敏感器坐标系、图像坐标系及前视投影成像示意图。</p><p> （3）图像坐标系XY。以感光面的中心O’（O点在该平面上的投影点）为坐标原点，平行于感光面两边的直线为X轴和Y轴的平面坐标系，参见图1。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    a=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    a = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% syms fai x;</span></span><br><span class="line"><span class="comment">% assume(fai&gt;=0 &amp; fai&lt;=2*pi);</span></span><br><span class="line"></span><br><span class="line">fai = <span class="number">0</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">inn = <span class="number">1670</span>;</span><br><span class="line">star1 =  [  <span class="built_in">cosd</span>(star_data(inn,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(inn,<span class="number">2</span>))   ;   <span class="built_in">cosd</span>(star_data(inn,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(inn,<span class="number">2</span>))  ;  <span class="built_in">sind</span>(star_data(inn,<span class="number">3</span>))  ];</span><br><span class="line">R * star1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">title(<span class="string">&#x27;天球坐标系，从外向内看&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line">title(<span class="string">&#x27;星图1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，从内往外看&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line">view(<span class="number">-90</span>,<span class="number">90</span>);  <span class="comment">% view(az,el) 为当前坐标区设置相机视线的方位角(顺时针为正)和仰角。</span></span><br><span class="line">title(<span class="string">&#x27;星图1逆时针旋转90&#x27;</span>)</span><br></pre></td></tr></table></figure><p>针对星图1的第一个点，即第1670个点，它的赤经赤纬为 115.828 , 28.8835，用旋转矩阵乘得到星敏坐标（0.0950，-0.0949， 0.9909）与左下图对应， 第二个点，即第1477个点，赤经赤纬为105.88,29.33 ， 星敏坐标为（-0.0566，-0.0889，0.9944）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220118160235525.png" alt="image-20220118160235525"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220118161031114.png" alt="image-20220118161031114"></p><p><strong><code>这个感光面，究竟对于图像坐标系来说，是哪一面呢？不管哪一面，都不影响已经确定了的XY轴和点坐标。但我画星图1的意义就不大，不好直接比对。</code></strong></p><p><strong><code>但在这里，经过很长时间的考虑，如题所述的（图像坐标系与星敏坐标系的XY对应）经过验证后是错误的（倘若如上上上图的XY轴示意图和上图的文字描述，第二列和第三列没有负坐标）。</code></strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  星图1各个坐标</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">Attribute_Set = &#123;<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1.5</span>&#125;; </span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">title(<span class="string">&#x27;天球坐标系，从外向内看&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，从内往外看&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;上图旋转&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line">view(<span class="number">180</span>,<span class="number">90</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，旋转90&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">-6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span><span class="number">-6</span>,<span class="number">34.5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span>+<span class="number">6</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（负负）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（负正）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]); </span><br><span class="line">view(<span class="number">-90</span>,<span class="number">90</span>); </span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，旋转180&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">-6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">-6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span><span class="number">-6</span>,<span class="number">34.5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span><span class="number">-6</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（正正）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line">view(<span class="number">180</span>,<span class="number">90</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>); </span><br><span class="line"><span class="built_in">scatter</span>(star_data(index,<span class="number">2</span>),star_data(index,<span class="number">3</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;XDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对X方向反转</span></span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">title(<span class="string">&#x27;星敏坐标系，旋转270&#x27;</span>)</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">0</span>,<span class="number">-6</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">109.6</span>,<span class="number">34.5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>+<span class="number">6</span>,<span class="number">34.5</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">109.6</span>,<span class="number">34.5</span><span class="number">-6</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">115.828</span>,<span class="number">28.8835</span>,<span class="string">&#x27;第一点（正正）&#x27;</span>);</span><br><span class="line">text(<span class="number">105.88</span>,<span class="number">29.33</span>,<span class="string">&#x27;第二点（正负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">109.6</span><span class="number">-8</span> <span class="number">109.6</span>+<span class="number">8</span>]);</span><br><span class="line">ylim([<span class="number">34.5</span><span class="number">-8</span> <span class="number">34.5</span>+<span class="number">8</span>]);</span><br><span class="line">view(<span class="number">90</span>,<span class="number">90</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    a=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    a = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">% syms fai x;</span></span><br><span class="line"><span class="comment">% assume(fai&gt;=0 &amp; fai&lt;=2*pi);</span></span><br><span class="line"></span><br><span class="line">fai = <span class="number">90</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>); </span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋90度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（负负）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（负正）&#x27;</span>);</span><br><span class="line"><span class="comment">% view(0,90);</span></span><br><span class="line"></span><br><span class="line">fai = <span class="number">180</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>); </span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋180度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（正正）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fai = <span class="number">270</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>); </span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋270度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（正正）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（正负）&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,[<span class="number">9</span>,<span class="number">10</span>]); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;YDir&#x27;,&#x27;reverse&#x27;)%对y方向反转</span></span><br><span class="line">title(<span class="string">&#x27;星图1&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">0</span>,<span class="number">512</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">512</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">text(<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">-233</span>,<span class="number">233</span>,<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(<span class="number">-217</span>,<span class="number">-138</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-260</span> <span class="number">260</span>]);</span><br><span class="line">ylim([<span class="number">-260</span> <span class="number">260</span>]);</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">3</span>,<span class="number">4</span>,[<span class="number">11</span>,<span class="number">12</span>]); </span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>))</span><br><span class="line">set(gca,<span class="string">&#x27;YDir&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>)<span class="comment">%对y方向反转</span></span><br><span class="line">title(<span class="string">&#x27;星图1&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">0</span>,<span class="number">512</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">-256</span>,<span class="number">-256</span>,<span class="number">512</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">text(<span class="number">200</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">200</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">-233</span>,<span class="number">233</span>,<span class="string">&#x27;第一点（负正）&#x27;</span>);</span><br><span class="line">text(<span class="number">-217</span>,<span class="number">-138</span>,<span class="string">&#x27;第二点（负负）&#x27;</span>);</span><br><span class="line">xlim([<span class="number">-260</span> <span class="number">260</span>]);</span><br><span class="line">ylim([<span class="number">-260</span> <span class="number">260</span>]);</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220119112958202.png" alt="image-20220119112958202"></p><p>我又细细画了一幅图，图2是 <code>将</code> 图1的xyz轴 滚转角fai = 90（图为从外往内看，xy轴逆时针旋转90°，相当于图 顺时针旋转了90度），绕着朝向自己的拇指方向，右旋90°，相当于将图1顺时针旋转90°。依次画其他图。</p><p><strong>根据第一点、第二点的正负可见，没有一幅图上的星点坐标值是符合星图1的描述，而图8和星图1是一致的，可以猜测出结论。</strong></p><p><strong>因此正确的理解应该是将天球坐标转为星敏坐标，然后将x轴反向 x’ = -x </strong>。</p><p>星图1就是由星敏坐标经过滚转角270度旋转后得到图4，再将x轴反向 x’ = -x得到图像坐标。</p><p>如何得到图像坐标呢？</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/4c570ee2f679076f4d16e05c3eca29fa.png" alt="img"></p><p>（注意 ， 本题与上文所描述不同，连相机坐标系都不是右手坐标系）</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220119111033783.png" alt="image-20220119111033783"></p><p>（<a href="https://qiy.net/2020/06/09/IAP-Cam-calibration/）">https://qiy.net/2020/06/09/IAP-Cam-calibration/）</a></p><p>f = 256/(tand(6));  % f = 2435.677300280981像素</p><p>x = f * Xc / Zc ; </p><p>该公式一步到像素坐标。</p><p>下面进行验证。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">%  正向验证星图1从世界坐标到星敏坐标到像素坐标并画图</span></span><br><span class="line"></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span></span><br><span class="line">];</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A1 = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [A1,<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A1,<span class="number">1</span>),<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">1</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span>))  )];</span><br><span class="line">zhixiang = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*zhixiang - Y);</span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>   zhixiang(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-zhixiang(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    a=<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    a = <span class="number">360</span>-<span class="built_in">acosd</span>( zhixiang(<span class="number">1</span>)  /  <span class="built_in">sqrt</span>(<span class="number">1</span>-((zhixiang(<span class="number">3</span>))^<span class="number">2</span>) )   );</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">b=<span class="built_in">asind</span>( zhixiang(<span class="number">3</span>) );</span><br><span class="line"></span><br><span class="line">corWorld =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fai = <span class="number">270</span>;</span><br><span class="line">R = [</span><br><span class="line">-<span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">sind</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">sind</span>(fai)</span><br><span class="line"> <span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)     -<span class="built_in">cosd</span>(a)*<span class="built_in">sind</span>(fai)-<span class="built_in">sind</span>(a)*<span class="built_in">sind</span>(b)*<span class="built_in">cosd</span>(fai)      <span class="built_in">cosd</span>(b)*<span class="built_in">cosd</span>(fai)</span><br><span class="line"> <span class="built_in">cosd</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(a)*<span class="built_in">cosd</span>(b)                                  <span class="built_in">sind</span>(b)</span><br><span class="line">];</span><br><span class="line">corSensor =  corWorld * R&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">scatter</span>(corSensor(:,<span class="number">1</span>),corSensor(:,<span class="number">2</span>))</span><br><span class="line"><span class="comment">% set(gca,&#x27;XDir&#x27;,&#x27;reverse&#x27;)%对X方向反转</span></span><br><span class="line">title(<span class="string">&#x27;右旋270度&#x27;</span>)</span><br><span class="line">axis equal;<span class="built_in">hold</span> on;</span><br><span class="line">xlim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">ylim([<span class="number">-0.1</span> <span class="number">0.1</span>]);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">quiver(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;Color&#x27;</span>,<span class="string">&#x27;g&#x27;</span>);</span><br><span class="line">text(<span class="number">0</span>,<span class="number">0.1</span>,<span class="string">&#x27;y&#x27;</span>);</span><br><span class="line">text(<span class="number">0.1</span>,<span class="number">0</span>,<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">1</span>,<span class="number">1</span>),corSensor(<span class="number">1</span>,<span class="number">2</span>),<span class="string">&#x27;第一点（正正）&#x27;</span>);</span><br><span class="line">text(corSensor(<span class="number">2</span>,<span class="number">1</span>),corSensor(<span class="number">2</span>,<span class="number">2</span>),<span class="string">&#x27;第二点（正负）&#x27;</span>);</span><br><span class="line"></span><br><span class="line">corSensor1=[-corSensor(:,<span class="number">1</span>), corSensor(:,<span class="number">2</span>:<span class="number">3</span>) ];</span><br><span class="line">corPic = [f .* corSensor1(:,<span class="number">1</span>) ./corSensor1(:,<span class="number">3</span>)  ,  f .* corSensor1(:,<span class="number">2</span>) ./corSensor1(:,<span class="number">3</span>) ];</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">scatter</span>(corPic(:,<span class="number">1</span>),corPic(:,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">scatter</span>(A1(:,<span class="number">1</span>),A1(:,<span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220119114259344.png" alt="image-20220119114259344"></p><p>以我预测的正向过程结果Fig2与星图数据画出结果Fig3一致，终于结束。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220119114416118.png" alt="image-20220119114416118"></p>]]></content>
      
      
      <categories>
          
          <category> 星图识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星图识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星图识别2-指向计算</title>
      <link href="2022/01/09/blog31-starId-2/"/>
      <url>2022/01/09/blog31-starId-2/</url>
      
        <content type="html"><![CDATA[<p>根据 文章 B19910360003.pdf 中 </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109214931059.png" alt="image-20220109214931059"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109215007244.png" alt="image-20220109215007244"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109215025866.png" alt="image-20220109215025866"></p><p>焦距f，即为相机坐标系下的投影中心到感光面的距离，即f = 256/(tand(6)); 单位位像素，与a保持一致。</p><hr><p><strong>选前三点</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110002256884.png" alt="image-20220110002256884"></p><p>赤经赤纬为：  109.6002   34.5005</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109232504457.png" alt="image-20220109232504457"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220222193014726.png" alt="image-20220222193014726"></p><p>注意这里可能有2个解，在星图4中想了好几天。<code>其中这里有错，赤经应该还可能等于360°-式。</code></p><p><code>经过研究，结合sin赤经的正负号表现，探究最终结论：</code></p><p>若tan赤经和cos赤经同号则为原式，否则为360°-式</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>   Res(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    [   <span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    [   <span class="number">360</span>-<span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110001730296.png" alt=""></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% main5.m</span></span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line">syms m31 m32 m33;</span><br><span class="line"></span><br><span class="line">eqns = [</span><br><span class="line">    (f/(<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>,<span class="number">2</span>)^<span class="number">2</span> + newMatrix(<span class="number">1</span>,<span class="number">3</span>)^<span class="number">2</span>))) == <span class="built_in">cosd</span>(star_data(<span class="number">1670</span>,<span class="number">3</span>))*<span class="built_in">cosd</span>(star_data(<span class="number">1670</span>,<span class="number">2</span>))*m31 +   <span class="built_in">cosd</span>(star_data(<span class="number">1670</span>,<span class="number">3</span>))*<span class="built_in">sind</span>(star_data(<span class="number">1670</span>,<span class="number">2</span>))*m32  +  <span class="built_in">sind</span>(star_data(<span class="number">1670</span>,<span class="number">3</span>))*m33,</span><br><span class="line">    (f/(<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">2</span>,<span class="number">2</span>)^<span class="number">2</span> + newMatrix(<span class="number">2</span>,<span class="number">3</span>)^<span class="number">2</span>))) == <span class="built_in">cosd</span>(star_data(<span class="number">1477</span>,<span class="number">3</span>))*<span class="built_in">cosd</span>(star_data(<span class="number">1477</span>,<span class="number">2</span>))*m31 +   <span class="built_in">cosd</span>(star_data(<span class="number">1477</span>,<span class="number">3</span>))*<span class="built_in">sind</span>(star_data(<span class="number">1477</span>,<span class="number">2</span>))*m32  +  <span class="built_in">sind</span>(star_data(<span class="number">1477</span>,<span class="number">3</span>))*m33,</span><br><span class="line">    (f/(<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">3</span>,<span class="number">2</span>)^<span class="number">2</span> + newMatrix(<span class="number">3</span>,<span class="number">3</span>)^<span class="number">2</span>))) == <span class="built_in">cosd</span>(star_data(<span class="number">1502</span>,<span class="number">3</span>))*<span class="built_in">cosd</span>(star_data(<span class="number">1502</span>,<span class="number">2</span>))*m31 +   <span class="built_in">cosd</span>(star_data(<span class="number">1502</span>,<span class="number">3</span>))*<span class="built_in">sind</span>(star_data(<span class="number">1502</span>,<span class="number">2</span>))*m32  +  <span class="built_in">sind</span>(star_data(<span class="number">1502</span>,<span class="number">3</span>))*m33</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">vars = [m31 m32 m33];</span><br><span class="line">[m31, m32 m33 ] = solve(eqns, vars);</span><br><span class="line">m31=double(m31);</span><br><span class="line">m32=double(m32);</span><br><span class="line">m33=double(m33);</span><br><span class="line"><span class="keyword">if</span>   Res(<span class="number">2</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>) &gt; <span class="number">0</span> </span><br><span class="line">    [   <span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    [   <span class="number">360</span>-<span class="built_in">acosd</span>(Res(<span class="number">1</span>)/<span class="built_in">sqrt</span>(<span class="number">1</span>-Res(<span class="number">3</span>)^<span class="number">2</span>))  ,   <span class="built_in">asind</span>(Res(<span class="number">3</span>))   ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>选全点：</strong></p><p>方程组个数小于未知数个数，这种情形称为不定方程组，不定方程组一般有无穷个解。</p><p>方程个数大于未知数个数的方程组称为超定方程组，超定方程组一般无解。但是它存在最小二乘解。比较常见的情形是实际生活中，我们要测量某一组数据大小，为减小误差，必须重复测很多次，每测一次就是一组数据，这组数据就是一个超定方程组，它的最小二乘解就是误差最小的值。</p><p>算出最小二乘解是差不多的，赤经赤纬为：109.6000   34.5000</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 星图1 </span></span><br><span class="line"><span class="comment">% main5.m</span></span><br><span class="line">clc;clear;close all;</span><br><span class="line">index = [<span class="number">1670</span></span><br><span class="line"><span class="number">1477</span></span><br><span class="line"><span class="number">1502</span></span><br><span class="line"><span class="number">1631</span></span><br><span class="line"><span class="number">1603</span></span><br><span class="line"><span class="number">1453</span></span><br><span class="line"><span class="number">1432</span></span><br><span class="line"><span class="number">1492</span></span><br><span class="line"><span class="number">1488</span></span><br><span class="line"><span class="number">1648</span></span><br><span class="line"><span class="number">1646</span></span><br><span class="line"><span class="number">1566</span></span><br><span class="line"><span class="number">1688</span></span><br><span class="line"><span class="number">1655</span></span><br><span class="line"><span class="number">1505</span>];</span><br><span class="line"></span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">f = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu01.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(f,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">A  =  [  <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">cosd</span>(star_data(index,<span class="number">2</span>))   ,   <span class="built_in">cosd</span>(star_data(index,<span class="number">3</span>)).*<span class="built_in">sind</span>(star_data(index,<span class="number">2</span>))  ,  <span class="built_in">sind</span>(star_data(index,<span class="number">3</span>))  ];</span><br><span class="line">Y = [   (f  ./  (<span class="built_in">sqrt</span>(f^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">2</span>).^<span class="number">2</span> + newMatrix(<span class="number">1</span>:<span class="number">15</span>,<span class="number">3</span>).^<span class="number">2</span>))  )];</span><br><span class="line"></span><br><span class="line">Res = inv(A&#x27;*A)*A&#x27;*Y;</span><br><span class="line">E = (A*Res - Y);</span><br><span class="line"><span class="comment">%MSE 为平均均方误差</span></span><br><span class="line">RMS = <span class="built_in">sqrt</span>(mse(E))</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110084949071.png" alt="image-20220110084949071"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220110085851273.png" alt="image-20220110085851273"></p><p>对于星图3</p><p>全点：赤经赤纬 124.9740   43.9973</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220111143646339.png" alt="image-20220111143646339"></p><p>较为精准的3点：1825、1943、1722，赤经赤纬  125.0001   43.9999，和上对比，较为精准。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220111100252007.png" alt="image-20220111100252007"></p><p>较为不精准的3点：1942、1941、1900，赤经赤纬 125.4325   44.2513，发现确实有较大偏差。</p>]]></content>
      
      
      <categories>
          
          <category> 星图识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星图识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星图识别1-角距矩阵匹配模型</title>
      <link href="2022/01/07/blog30-starId-1/"/>
      <url>2022/01/07/blog30-starId-1/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主要是针对2019主要介绍的是<a href="https://www.shumo.com/wiki/doku.php?id=%E7%AC%AC%E5%8D%81%E5%85%AD%E5%B1%8A_2019_%E5%85%A8%E5%9B%BD%E7%A0%94%E7%A9%B6%E7%94%9F%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B_npmcm_%E8%AF%95%E9%A2%98">第十六届(2019)全国研究生数学建模竞赛(NPMCM)试题B题</a>：天文导航中的星图识别，这里我下载了<a href="https://github.com/tsuiwade/MathModel/tree/master/%E5%9B%BD%E8%B5%9B%E8%AE%BA%E6%96%87/2019%E5%B9%B4%E4%BC%98%E7%A7%80%E8%AE%BA%E6%96%87/B">5篇优秀论文</a>，以及优秀的<a href="https://www.bilibili.com/video/BV17J41117Ut?from=search&amp;seid=305839988149914531&amp;spm_id_from=333.337.0.0">答辩现场录像</a>，在这篇博客中，我将选取<code>B19102880053</code>提到的<code>基于角距传统算法</code>进行复现。</p><p>此赛题提供的4908个导航星表数据是.mat文件，因此将使用<code>MATLAB</code>进行代码编写。</p><ul><li><p>1、星表数据处理</p><p>首先将星表数据的<code>天球坐标系下的赤经、赤纬</code>转为<code>直角坐标系下的x/y/z轴的值</code>，利用公式</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220108103109.png" alt=""></p><p>得到</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220108103148.png" alt=""></p></li></ul><ul><li><p>2、准备库矩阵和星图矩阵</p><p> <img src="http://rto3hzle5.hd-bkt.clouddn.com/20220108094645.png" alt=""></p><ul><li><p>式6-1导航星角距库比较好理解，我将其化成度数，得到：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220108103624.png" alt=""></p></li><li><p>而式6-2某星图角距矩阵，文中作者提到选取导航星方式，但不妨以任意星，例如表中顺序来求。在此我选取第一个星<code>A01</code>作为基准星，求解与其他星的角距，但在此我去除了与本身星的角距（因其为0），得到如下角距：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220108103940.png" alt=""></p></li></ul></li></ul><ul><li><p>3、算法描述</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20220108104116.png" alt=""></p><p>（其实在此我理解错了，怪不得我运行了这么长时间，先说一下我的理解的算法，是没有优化的算法，在于最后一步还进行遍历循环。）</p><p>取<code>星图角距矩阵</code>第i(i=1)个元素与<code>导航星角距矩阵</code>第j(j=1)列的元素依次匹配，若匹配到角距相等或近似的元素，判断矩阵第i(i=1)个元素数值加 1；  </p><p><strong>main3.m</strong></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>)) &lt; <span class="number">0.1</span>  ) <span class="comment">% 这里的0.1是匹配到角距的判定</span></span><br><span class="line">panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>取<code>星图角距矩阵</code>第i （ i= 2,3,…,n）个元素，重复上一步操作； （该步完成后，若导航星就是第j列，则判断矩阵会加很多个1；）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; <span class="number">0.1</span>  )</span><br><span class="line">panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>若星图矩阵所有元素均完成匹配，则取导航星矩阵第 j （ j = 2,3,…,4908）列元素重复上两步操作； </p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line"><span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; <span class="number">0.1</span>     )</span><br><span class="line">panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>取判断矩阵最大元素所在列（记为 x ）作为基准星编号 x ；  </p><p>（关于0.1的设置，假设其为a，我希望采用智能化判断，即当判断矩阵的最大的一个值不大于最大的值的2倍时，差距a减半，继续判断，直到第一个值大于第二个值，即能够明显判断出差异和保证准确性时，判断截止）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> delta=<span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">       panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">       <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">           <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line">               <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line">                   panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">               <span class="keyword">end</span></span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">5</span>)</span><br><span class="line">       <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt; <span class="built_in">max</span>(<span class="number">2</span>)*<span class="number">2</span> )</span><br><span class="line">           newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>继续匹配导航星矩阵第 x 列，确定星图其他恒星编号 。（其实我的理解的差别在这，作者由基准星的列直接判断其他星，而笨拙的方法是遍历其他基准星，<strong>若采用笨拙的方法，星图1将耗时60s，若不遍历，则耗时6s左右，若设定固定0.1差距，则耗时1s左右</strong>）</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">    angle1(<span class="built_in">find</span>(angle1==<span class="number">0</span>))=[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> delta=<span class="number">1</span>:<span class="number">10</span> </span><br><span class="line">        panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line">                <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line">                    panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt; <span class="built_in">max</span>(<span class="number">2</span>)*<span class="number">2</span> )</span><br><span class="line">            newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><p>  该方法在识别星图1和星图2的时候有较好的效果。但在识别星图3的时候，由于存在的星较少，星之间相距较近 的条件比较苛刻，判断条件需要优化，之前是判断最多的匹配个数大于次多的匹配个数的两倍，现在可能由于delta的缩放比例过大导致无法适应条件进行判断，因此需要修改delta的条件。</p><p>  对于星图3只能识别出C05</p><p>  <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109105948234.png" alt="image-20220109105948234"></p><p>  通过对每一个星、每一种delta得出的<code>前几匹配数</code>可见，其实星图3是存在位置误差的，C02、C04、C06、C07存在较大误差。接着对星图4、5验证没问题，对于星图6部分有问题。</p><p>  <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109105820180.png" alt="image-20220109105820180"></p><p>  接着识别星图7，总结当前代码为：</p>  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">tic</span><br><span class="line">clc;clear;close all;</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">star_data_xyz(:,<span class="number">1</span>) = <span class="built_in">cos</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">2</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">3</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">angle</span> = <span class="built_in">real</span>(<span class="built_in">acosd</span>(star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>) * star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line"></span><br><span class="line">h2 = <span class="number">512</span>/(<span class="built_in">tand</span>(<span class="number">10</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu07.xls&#x27;</span>) - <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(A,<span class="number">1</span>)</span><br><span class="line">    l(<span class="built_in">j</span>,<span class="number">1</span>) = norm(A(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(h2,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% ii = 7;</span></span><br><span class="line"></span><br><span class="line">    angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">    angle1(<span class="built_in">find</span>(angle1==<span class="number">0</span>))=[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> delta=<span class="number">1</span>:<span class="number">15</span> </span><br><span class="line">        panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>) </span><br><span class="line">                <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line"><span class="comment">%                 if (   length(find(abs(angle(:,j)-angle1(i))&lt; 0.0001       ))     )</span></span><br><span class="line">                    panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt; <span class="built_in">max</span>(<span class="number">2</span>)*<span class="number">2</span> )</span><br><span class="line">            newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">toc</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;运行时间: &#x27;</span>,num2str(toc)]);</span><br></pre></td></tr></table></figure><p>  对于星图7，识别41个星耗时573秒，判断结果全对。</p><p>  <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220109111249906.png" alt="image-20220109111249906"></p><p>  对于星图8，识别29个星耗时319秒，判断结果全对。</p><p>到此为止，我描述了我的 遍历每个星作为基准星的方法，对于星图124578没问题，对于星图36存在找不全的情况。</p><hr><p>回到使用基准星的方法来看，使用基准星确实能加速识别过程，例如识别20个星，只需要识别出一个星，再找到对应的矩阵即可。并且使用基准星可以避免找不到星的情况。</p><p><code>如何挑选这个基准星呢？</code> 文中也没给出较好的计算方法。</p><p><code>对于一个基准星来说或许不可靠，能否有一个初步方法筛选出相对可靠的若干基准星？</code> 发现还是一个基准星来的快一些</p><p><code>得到若干基准星后，得到其他星之后是否有一个验证过程？</code> 当选择用一个基准星的时候其实已经进行了一轮验证。</p><p>总结上面的实验可得，后续的改进优化需要先快速算出基准星，再由基准星得到其他星，最后进行验证。</p><hr><p>基准星一定是相对最可靠的，遍历还是需要遍历，但遍历深度不可太深。</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 来自B19102880053.pdf的角距矩阵匹配模型。</span></span><br><span class="line"><span class="comment">% 找到一个基准星，然后找到其他星</span></span><br><span class="line"><span class="comment">% main4.m</span></span><br><span class="line"></span><br><span class="line">tic</span><br><span class="line">clc;clear;close all;</span><br><span class="line">load(<span class="string">&quot;附件2  简易星表.mat&quot;</span>);</span><br><span class="line"></span><br><span class="line">star_data_xyz(:,<span class="number">1</span>) = <span class="built_in">cos</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">2</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">2</span>) * <span class="built_in">pi</span> / <span class="number">180</span>) .* <span class="built_in">cos</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line">star_data_xyz(:,<span class="number">3</span>) = <span class="built_in">sin</span>(star_data(:,<span class="number">3</span>) * <span class="built_in">pi</span> / <span class="number">180</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">angle</span> = <span class="built_in">real</span>(<span class="built_in">acosd</span>(star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>) * star_data_xyz(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line"></span><br><span class="line">h2 = <span class="number">256</span>/(<span class="built_in">tand</span>(<span class="number">6</span>));</span><br><span class="line">A = xlsread(<span class="string">&#x27;D:\文献\starimage\npmcm2019b\npmcm2019-B\附件3  8幅星图相关数据\xingtu03.xls&#x27;</span>) - <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newMatrix= [<span class="built_in">repmat</span>(h2,<span class="built_in">size</span>(A,<span class="number">1</span>),<span class="number">1</span>),A];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">size</span>(newMatrix,<span class="number">1</span>)</span><br><span class="line">    ll(<span class="built_in">j</span>,<span class="number">1</span>) = norm(newMatrix(<span class="built_in">j</span>,:));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">newNewMatrix = newMatrix./ll;</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> delta=<span class="number">5</span>:<span class="number">15</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ii = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)</span><br><span class="line">        panduan = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">4908</span>);</span><br><span class="line">        angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line">        angle1(<span class="built_in">find</span>(angle1==<span class="number">0</span>))=[];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="number">4908</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(newNewMatrix,<span class="number">1</span>)<span class="number">-1</span></span><br><span class="line">                <span class="keyword">if</span> (   <span class="built_in">length</span>(<span class="built_in">find</span>(<span class="built_in">abs</span>(<span class="built_in">angle</span>(:,<span class="built_in">j</span>)-angle1(<span class="built_in">i</span>))&lt; (<span class="number">2</span>^(-delta))))     )</span><br><span class="line">                    panduan(<span class="built_in">j</span>) = panduan(<span class="built_in">j</span>)+ <span class="number">1</span> ;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">        [<span class="built_in">max</span>,I ] = maxk(panduan,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>( (<span class="built_in">max</span>(<span class="number">1</span>) == <span class="number">1</span>) || (<span class="built_in">max</span>(<span class="number">1</span>) == <span class="number">0</span>) )<span class="comment">%将不讨论这个星</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">max</span>(<span class="number">1</span>) &gt;= <span class="built_in">max</span>(<span class="number">2</span>)+<span class="number">2</span> )</span><br><span class="line">            newNewMatrix(ii,<span class="number">4</span>)=I(<span class="number">1</span>); </span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (flag ==<span class="number">1</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">angle1 = <span class="built_in">real</span>(<span class="built_in">acosd</span>(newNewMatrix(ii,<span class="number">1</span>:<span class="number">3</span>) * newNewMatrix(:,<span class="number">1</span>:<span class="number">3</span>).&#x27;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">size</span>(angle1,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    A = <span class="built_in">abs</span>(    <span class="built_in">angle</span>(:,newNewMatrix(ii,<span class="number">4</span>)) -angle1(<span class="built_in">i</span>)    );</span><br><span class="line">    [minvalue,I] = <span class="built_in">min</span>(A);</span><br><span class="line">    newNewMatrix(<span class="built_in">i</span>,<span class="number">5</span>) = I(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">toc</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;运行时间: &#x27;</span>,num2str(toc)]);</span><br></pre></td></tr></table></figure><p>星图全遍历91s、找到一组基准星57s，找到一个基准星43s，最快设置delta 2.23s，</p><p>在此我将计算每个星图的指向参数。</p><hr><p>结果可以参考003.pdf，以下为main4.m的结果，左侧为基准星</p><p>星图1结果：2s多</p><p>0    1670<br>0    1477<br>1502    1502<br>0    1631<br>0    1603<br>0    1453<br>0    1432<br>0    1492<br>0    1488 与053.pdf不同<br>0    1648<br>0    1646<br>0    1566<br>0    1688<br>0    1655<br>0    1505</p><p>星图2结果：1s多</p><p>0    518<br>472    472<br>0    537<br>0    428<br>0    491<br>0    469<br>0    482<br>0    503<br>0    478<br>0    499<br>0    547<br>0    460<br>0    507<br>0    556<br>0    447<br>0    479</p><p>星图3结果：15s多</p><p>0    1864<br>0    1942<br>0    1825<br>0    1941<br>1943    1943 与053.pdf不同 可以确定不需要参考053答案。<br>0    1900<br>0    1722</p><p>星图4结果：4s 与003.pdf相同</p><p>0    3249<br>0    3346<br>0    3364<br>0    3275<br>0    3421<br>0    3319<br>3283    3283<br>0    3370<br>0    3265<br>0    3261<br>0    3321<br>0    3309</p><p>星图5：5.3s 与003.pdf相同</p><p>0    1230<br>0    1150<br>0    1017<br>1033    1033<br>0    1014<br>0    1223<br>0    1008<br>0    1208<br>0    1201</p><p>星图6： 11s</p><p>0    1670<br>0    1675 003.pdf为1477<br>0    1502<br>0    1631<br>0    1655  003.pdf为1603<br>0    1692<br>0    1492<br>0    1576  003.pdf为1488<br>1646    1646<br>0    1566<br>0    1655<br>0    1505</p><p>星图7:2.1s</p><p>1525    1525<br>0    1572<br>0    1443<br>0    1748<br>0    1780<br>0    1675<br>0    1720<br>0    1503<br>0    1634<br>0    1577<br>0    1757<br>0    1586<br>0    1536<br>0    1610<br>0    1681<br>0    1606<br>0    1670<br>0    1477<br>0    1790<br>0    1502<br>0    1631<br>0    1603<br>0    1415<br>0    1692<br>0    1453<br>0    1432<br>0    1492<br>0    1488<br>0    1648<br>0    1646<br>0    1566<br>0    1688<br>0    1655<br>0    1505<br>0    1373<br>0    1576<br>0    1545<br>0    1424<br>0    1375<br>0    1825<br>0    1401</p><p>星图8为1.6s：</p><p>1572    1572<br>0    1387<br>0    1675<br>0    1634<br>0    1586<br>0    1610<br>0    1354<br>0    1681<br>0    1606<br>0    1670<br>0    1390<br>0    1502<br>0    1631<br>0    1603<br>0    1692<br>0    1432<br>0    1488<br>0    1648<br>0    1646<br>0    1566<br>0    1688<br>0    1359<br>0    1505<br>0    1373<br>0    1576<br>0    1424<br>0    1375<br>0    1401<br>0    1385</p><hr><p>以main4.m的结果来看，仅星图6有差，后续再验证。</p>]]></content>
      
      
      <categories>
          
          <category> 星图识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 星图识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《QT项目》靶轮控制</title>
      <link href="2021/10/10/blog28-qtTargetWheelConsole/"/>
      <url>2021/10/10/blog28-qtTargetWheelConsole/</url>
      
        <content type="html"><![CDATA[<h1 id="targetWheelConsole"><a href="#targetWheelConsole" class="headerlink" title="targetWheelConsole"></a>targetWheelConsole</h1><p>源代码： <a href="https://github.com/tsuiwade/targetWheelConsole">https://github.com/tsuiwade/targetWheelConsole</a></p><p>这是一个简单的靶轮控制软件，主要用到的是串口功能。实现了一些现代化的按钮立体显示效果、动态交互激活按钮状态、菜单栏选择串口。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211010180956933.png" alt="image-20211010180956933"></p><ol><li><p>现代化的按钮立体显示效果，借鉴自<a href="https://www.jianshu.com/p/952637f9958f">https://www.jianshu.com/p/952637f9958f</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211010181447085.png" alt="image-20211010181447085"></p><p>1:可设置文本,居中显示</p><p>2:可设置文本颜色</p><p>3:可设置外边框渐变颜色</p><p>4:可设置里边框渐变颜色</p><p>5:可设置背景色</p><p>6:可直接调用内置的设置 绿色/红色/黄色/黑色/蓝色 等公有槽函数</p><p>7:可设置是否在容器中可移动,当成一个对象使用</p><p>8:可设置是否显示矩形</p><p>9:可设置报警颜色+非报警颜色</p><p>10:可控制启动报警和停止报警,报警时闪烁</p></li></ol><p>   这段配置了按键的样式。</p>   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; btn_list.size(); i++) &#123;</span><br><span class="line">    connect(btn_list[i], &amp;QPushButton::clicked, <span class="keyword">this</span>, [ = ](<span class="keyword">bool</span> checked) &#123;</span><br><span class="line">        <span class="keyword">if</span>(checked)</span><br><span class="line">            btn_list[i]-&gt;setLightRed();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            btn_list[i]-&gt;setLightGreen();</span><br><span class="line">    &#125;);</span><br><span class="line">    connect(btn_list[i],  &amp;QPushButton::pressed, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">        btn_list[i]-&gt;setBgRadius(<span class="number">70</span>);</span><br><span class="line">        btn_list[i]-&gt;setOverlayRadius(<span class="number">70</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    connect(btn_list[i],  &amp;QPushButton::released, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">        btn_list[i]-&gt;setBgRadius(<span class="number">80</span>);</span><br><span class="line">        btn_list[i]-&gt;setOverlayRadius(<span class="number">80</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">   </span><br><span class="line">    QGraphicsDropShadowEffect *shadow_effect = <span class="keyword">new</span> QGraphicsDropShadowEffect(<span class="keyword">this</span>);</span><br><span class="line">    shadow_effect-&gt;setOffset(<span class="number">1</span>, <span class="number">1</span>);             <span class="comment">//阴影的偏移量</span></span><br><span class="line">    shadow_effect-&gt;setColor(QColor(<span class="number">43</span>, <span class="number">43</span>, <span class="number">43</span>, <span class="number">150</span>)); <span class="comment">//阴影的颜色</span></span><br><span class="line">    shadow_effect-&gt;setBlurRadius(<span class="number">8</span>);             <span class="comment">// 阴影圆角的大小</span></span><br><span class="line">   </span><br><span class="line">    btn_list[i]-&gt;setLightGreen();</span><br><span class="line">    btn_list[i]-&gt;resize(<span class="number">120</span>, <span class="number">120</span>);</span><br><span class="line">    btn_list[i]-&gt;setText(QString::number(i + <span class="number">1</span>));</span><br><span class="line">    btn_list[i]-&gt;setGraphicsEffect(shadow_effect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>动态交互激活按钮状态</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211010181553606.png" alt="image-20211010181553606"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(btn_list[i],  &amp;QPushButton::pressed, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">    btn_list[i]-&gt;setBgRadius(<span class="number">70</span>);</span><br><span class="line">    btn_list[i]-&gt;setOverlayRadius(<span class="number">70</span>);</span><br><span class="line">&#125;);</span><br><span class="line">connect(btn_list[i],  &amp;QPushButton::released, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">    btn_list[i]-&gt;setBgRadius(<span class="number">80</span>);</span><br><span class="line">    btn_list[i]-&gt;setOverlayRadius(<span class="number">80</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>这里我为了实现：点击主菜单，弹出可选串口，试过多个方案，最终发现挺简单的，由自己看着库函数实现了。在将要弹出子菜单之前，进行串口搜索，点击子菜单，进行配置打开串口。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    connect(ui-&gt;menuSerial, &amp;QMenu::aboutToShow, <span class="keyword">this</span>, [ = ]() &#123;</span><br><span class="line">        <span class="keyword">if</span> (ui-&gt;menuSerial-&gt;title() == QString(<span class="string">&quot;选择串口&quot;</span>)) &#123;</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">            foreach(<span class="keyword">const</span> QSerialPortInfo &amp;info, QSerialPortInfo::availablePorts()) &#123;</span><br><span class="line">                ui-&gt;menuSerial-&gt;addAction(QIcon(<span class="string">&quot;:/target.png&quot;</span>), info.portName() + <span class="string">&quot;: &quot;</span> + info.description());</span><br><span class="line"></span><br><span class="line">                ui-&gt;menuSerial-&gt;addSeparator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">            ui-&gt;menuSerial-&gt;addAction(QString(<span class="string">&quot;关闭串口&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    connect(ui-&gt;menuSerial, &amp;QMenu::triggered, <span class="keyword">this</span>, [ = ](QAction * _action) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ui-&gt;menuSerial-&gt;title() == QString(<span class="string">&quot;选择串口&quot;</span>)) &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;点击 选择串口&quot;</span>;</span><br><span class="line">            qDebug() &lt;&lt; _action-&gt;text();</span><br><span class="line">            QString spTxt =  _action-&gt;text();</span><br><span class="line"><span class="comment">//            ui-&gt;menuSerial-&gt;setTitle(spTxt) ;</span></span><br><span class="line">            QString spTxt1 = spTxt.section(<span class="string">&#x27;:&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            serial.setPortName(spTxt1);</span><br><span class="line">            serial.setBaudRate(<span class="number">9600</span>);</span><br><span class="line">            serial.setDataBits(QSerialPort::Data8);</span><br><span class="line">            serial.setParity(QSerialPort::NoParity);</span><br><span class="line">            serial.setStopBits(QSerialPort::OneStop);</span><br><span class="line">            serial.setFlowControl(QSerialPort::NoFlowControl);</span><br><span class="line">            <span class="keyword">if</span>(!serial.open(QIODevice::ReadWrite)) &#123;</span><br><span class="line">                QMessageBox::about(<span class="literal">NULL</span>, <span class="string">&quot;提示&quot;</span>, <span class="string">&quot;无法打开串口！&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ui-&gt;menuSerial-&gt;setTitle(spTxt) ;</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            qDebug() &lt;&lt; <span class="string">&quot;点击 else&quot;</span>;</span><br><span class="line">            serial.close();</span><br><span class="line">            ui-&gt;menuSerial-&gt;clear();</span><br><span class="line">            ui-&gt;menuSerial-&gt;setTitle(QString(<span class="string">&quot;选择串口&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><hr><p>   项目实际记录</p><p>   <img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220701214007628.png" alt="image-20220701214007628"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220701214105999.png" alt="image-20220701214105999"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20220701214135944.png" alt="image-20220701214135944"></p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派qt</title>
      <link href="2021/10/07/blog29-raspberrypiQt/"/>
      <url>2021/10/07/blog29-raspberrypiQt/</url>
      
        <content type="html"><![CDATA[<p>第二次装树莓派系统。</p><p>google搜索raspberrypi os，下载imager和os系统，准备一个U盘或者sd卡，然后进行烧写。</p><p>默认安装完，由于我有买固态，想将U盘启动改为ssd启动，从而进行转移。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211007192857479.png" alt="image-20211007192857479"></p><p>接下来是换源：直接看官方文档，我的确实是debian10 buster版本系统。</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/help/raspbian/</a></p><p>接下来是准备远程环境。下载putty，开启ssh和vnc，最后远程桌面连接即可。<a href="https://tsuiwade.tk/2021/03/13/blog18_RaspberryPi/">https://tsuiwade.tk/2021/03/13/blog18_RaspberryPi/</a></p><p>再接下来是安装qt。</p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
          <category> raspberrypi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberrypi </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《QT项目》平移台控制</title>
      <link href="2021/10/06/blog27-qtSrialPort/"/>
      <url>2021/10/06/blog27-qtSrialPort/</url>
      
        <content type="html"><![CDATA[<p>主要涉及到上位机的布局、样式的调整、材质的阴影美化、完成标识的弹框动画、点击QLineEdit的虚拟键盘弹出。</p><p>源代码：<a href="https://github.com/tsuiwade/translationTableControlSystem210909">https://github.com/tsuiwade/translationTableControlSystem210909</a></p><p>这是一个简单的平移台控制软件，主要用到的是qt的串口功能。</p><ol><li><a href="https://blog.csdn.net/Mark_md/article/details/109048127">https://blog.csdn.net/Mark_md/article/details/109048127</a></li></ol><p>重写ComboBox下拉框的鼠标点击事件，实现点击下拉框扫描可用串口</p><ol><li><p>修改项目文件：</p><p>把新的 timeshow 文件夹重命名为 timeshowfixed，并把 timeshowfixed 里面 timeshow.pro.user 用户文件删掉。<br>进入 timeshowfixed 文件夹，把 timeshow.pro 重命名为 timeshowfixed.pro。<br>③用记事本打开 timeshowfixed.pro，修改里面的 TARGET 一行，变成下面这句：<br>TARGET = timeshowfixed<br>进行这样三步操作后，我们本章第一个例子的项目 timeshowfixed 就建立好了。</p></li><li><p>初始布局：</p><p><img src="https://user-images.githubusercontent.com/78476272/132862407-86f434ff-2748-4944-a236-213f7f98c96d.png" alt="image"></p></li></ol><p><img src="https://user-images.githubusercontent.com/78476272/132862466-c9d9b781-1851-478a-b0ec-54154e6004ab.png" alt="image"></p><ol><li>经过几天的优化。总体样式如下：</li></ol><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211006193232544.png" alt="image-20211006193232544"></p><p>项目结构如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211006193838493.png" alt="image-20211006193838493"></p><ul><li>先定分辨率1024<em>768，又布局了几天。布局采用Card的想法，分组放置，故研究阴影的放置，但出现groupBox<strong>与子组件的样式和阴影不兼容问题</strong>，查了好几天没找到是什么问题，最终偶然间下载qt5.14时，发现是<em>*5.9的bug</em></em>。</li></ul><ol><li><p>除了布局的设计，还有样式和阴影的设计。在qss文件和窗口文件中设置。</p><p>加阴影的代码已经经过优化，优化前写的较重复且乱，有个问题一个阴影对象只可以幅值给一个对象，因此…</p></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QList&lt;QWidget*&gt; qList = &#123;ui-&gt;horizontalSlider, ui-&gt;comboBox_portName,  ui-&gt;centralWidget&#125;; <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">   QList&lt;QPushButton*&gt; btnList = ui-&gt;centralWidget-&gt;findChildren&lt;QPushButton*&gt;();</span><br><span class="line">   QList&lt;QLineEdit*&gt; lineList = ui-&gt;centralWidget-&gt;findChildren&lt;QLineEdit*&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : btnList)  qList.append(i);</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : lineList)  qList.append(i);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> i : qList) &#123;</span><br><span class="line">       QGraphicsDropShadowEffect * shadow_effect = <span class="keyword">new</span> QGraphicsDropShadowEffect(<span class="keyword">this</span>);</span><br><span class="line">       shadow_effect-&gt;setOffset(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">       shadow_effect-&gt;setColor(QColor(<span class="number">55</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br><span class="line">       shadow_effect-&gt;setBlurRadius(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">       i-&gt;setGraphicsEffect(shadow_effect);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">QPushButton</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">253</span>,<span class="number">253</span>,<span class="number">253</span>);</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="attribute">border-style</span>:outset;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">1</span>,</span><br><span class="line">                                      stop: <span class="number">0</span> #f6f7fa, stop: <span class="number">1</span> #dadbde);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QPushButton</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">rgb</span>(<span class="number">224</span>,<span class="number">238</span>,<span class="number">249</span>);</span><br><span class="line">    <span class="attribute">border</span>:<span class="number">1px</span> solid <span class="built_in">rgb</span>(<span class="number">11</span>,<span class="number">137</span>,<span class="number">234</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QPushButton</span><span class="selector-pseudo">:pressed</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">qlineargradient</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">1</span>,</span><br><span class="line">                                      stop: <span class="number">0</span> #dadbde, stop: <span class="number">1</span> #f6f7fa);</span><br><span class="line">    <span class="attribute">padding-left</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">padding-top</span>:<span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">border-style</span>:inset;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">24px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::groove</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&quot;#EC7064&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::add-page</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&quot;#EC7064&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::sub-page</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="string">&quot;#2EE1C1&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">QSlider</span><span class="selector-pseudo">::handle</span><span class="selector-pseudo">:horizontal</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">24px</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>:-<span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">background</span>:<span class="built_in">qradialgradient</span>(spread:pad,cx:<span class="number">0.5</span>,cy:<span class="number">0.5</span>,radius:<span class="number">0.5</span>,fx:<span class="number">0.5</span>,fy:<span class="number">0.5</span>,stop:<span class="number">0.6</span> <span class="string">&quot;#FFFFFF&quot;</span>,stop:<span class="number">0.8</span> <span class="string">&quot;#34495E&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QGroupBox</span><span class="selector-id">#groupBox_1</span>, <span class="selector-id">#groupBox_2</span>, <span class="selector-id">#groupBox_3</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">background-color</span>:<span class="built_in">qlineargradient</span>(x1: <span class="number">0</span>, y1: <span class="number">0</span>, x2: <span class="number">0</span>, y2: <span class="number">1</span>,</span><br><span class="line">    stop: <span class="number">0</span> #f6f7fa, stop: <span class="number">1</span> #dadbde);</span><br><span class="line">    <span class="attribute">border-radius</span>:<span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border-width</span>:<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">border-color</span>:<span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">50</span>);</span><br><span class="line">    <span class="attribute">border-style</span>:outset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式包括圆角、偏移、渐变及渐变的颠倒、滑动条的前后样式和滑块样式。</p><p>还有一个小tip是加上icon会生动许多。</p><ol><li>还有完成标志的动画。</li></ol><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211006194645681.png" alt="image-20211006194645681"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211006194751940.png" alt=""></p><p>截图看不出动画的效果，是有关位置和透明度的动画。</p><p>主要是设计了一个新对话框窗体，以非模态的方式出现3秒后自动消失。对话框淡入淡出的动画代码如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">//获取主屏幕分辨率</span></span><br><span class="line">    QRect screenRect = QGuiApplication::primaryScreen()-&gt;geometry();</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation *appearPositionAnimation = <span class="keyword">new</span> QPropertyAnimation(<span class="keyword">this</span>, <span class="string">&quot;geometry&quot;</span>);</span><br><span class="line">    appearPositionAnimation-&gt;setDuration(<span class="number">1000</span>);</span><br><span class="line">    appearPositionAnimation-&gt;setStartValue(QRect((screenRect.width() / <span class="number">2</span>) - <span class="number">80</span>, screenRect.height() / <span class="number">2</span> - <span class="number">40</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    appearPositionAnimation-&gt;setEndValue(QRect(screenRect.width() / <span class="number">2</span> - <span class="number">80</span>, screenRect.height() / <span class="number">2</span>, <span class="number">160</span>, <span class="number">80</span>));</span><br><span class="line">    appearPositionAnimation-&gt;setEasingCurve(QEasingCurve::InOutElastic);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    QPropertyAnimation *vanishPostionAnimation = new QPropertyAnimation(this, &quot;geometry&quot;);</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setDuration(1000);</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setStartValue(QRect(1024 / 2 - 80, 768 / 2, 160, 80));</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setEndValue(QRect(1024 / 2 - 80, 768 / 2 - 40, 0, 0));</span></span><br><span class="line"><span class="comment">//    vanishPostionAnimation-&gt;setEasingCurve(QEasingCurve::InBounce);</span></span><br><span class="line"></span><br><span class="line">    QSequentialAnimationGroup *positionAnimationGroup = <span class="keyword">new</span> QSequentialAnimationGroup(<span class="keyword">this</span>);</span><br><span class="line">    positionAnimationGroup-&gt;addAnimation(appearPositionAnimation);</span><br><span class="line">    positionAnimationGroup-&gt;addPause(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">//    pScaleGroup-&gt;addAnimation(vanishPostionAnimation);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowOpacity(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation* appearOpacityAnimation = <span class="keyword">new</span> QPropertyAnimation(<span class="keyword">this</span>, <span class="string">&quot;windowOpacity&quot;</span>);</span><br><span class="line">    appearOpacityAnimation-&gt;setDuration(<span class="number">1000</span>); <span class="comment">// will take 5 seconds</span></span><br><span class="line">    appearOpacityAnimation-&gt;setEasingCurve(QEasingCurve::OutBack); <span class="comment">// just demonstration, there are a lot of curves to choose</span></span><br><span class="line">    appearOpacityAnimation-&gt;setStartValue(<span class="number">0.0</span>);</span><br><span class="line">    appearOpacityAnimation-&gt;setEndValue(<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">    QPropertyAnimation* vanishOpacityAnimation = <span class="keyword">new</span> QPropertyAnimation(<span class="keyword">this</span>, <span class="string">&quot;windowOpacity&quot;</span>);</span><br><span class="line">    vanishOpacityAnimation-&gt;setDuration(<span class="number">1000</span>); <span class="comment">// will take 5 seconds</span></span><br><span class="line">    vanishOpacityAnimation-&gt;setEasingCurve(QEasingCurve::Linear); <span class="comment">// just demonstration, there are a lot of curves to choose</span></span><br><span class="line">    vanishOpacityAnimation-&gt;setStartValue(<span class="number">1.0</span>);</span><br><span class="line">    vanishOpacityAnimation-&gt;setEndValue(<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    QSequentialAnimationGroup *opacityAnimationGroup = <span class="keyword">new</span> QSequentialAnimationGroup(<span class="keyword">this</span>);</span><br><span class="line">    opacityAnimationGroup-&gt;addAnimation(appearOpacityAnimation);</span><br><span class="line">    opacityAnimationGroup-&gt;addPause(<span class="number">2000</span>);</span><br><span class="line">    opacityAnimationGroup-&gt;addAnimation(vanishOpacityAnimation);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    anim-&gt;start(QAbstractAnimation::DeleteWhenStopped);</span></span><br><span class="line"></span><br><span class="line">    m_group = <span class="keyword">new</span> QParallelAnimationGroup(<span class="keyword">this</span>);</span><br><span class="line">    m_group-&gt;addAnimation(positionAnimationGroup);</span><br><span class="line">    m_group-&gt;addAnimation(opacityAnimationGroup);</span><br><span class="line">    m_group-&gt;setDirection(QAbstractAnimation::Forward);</span><br><span class="line">    m_group-&gt;setLoopCount(<span class="number">1</span>);</span><br><span class="line">    m_group-&gt;start();</span><br><span class="line">    connect(<span class="keyword">this</span>-&gt;m_group, SIGNAL(finished()), m_group, SLOT(deleteLater()), Qt::UniqueConnection);</span><br><span class="line">    connect(<span class="keyword">this</span>-&gt;m_group, SIGNAL(finished()), <span class="keyword">this</span>, SLOT(close()));</span><br></pre></td></tr></table></figure><p>其中最后几句槽函数是花了一些时间找来的，当动画消失后，对话框窗体关闭。</p><ol><li>点击QLineEdit，弹出虚拟数字键盘，代码也是网上找的修改了一下样式。</li></ol><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20211006195444106.png" alt="image-20211006195444106"></p><p>QT数字软键盘，包括QLineEdit弹出代码和键盘样式来自：<a href="https://download.csdn.net/download/zhuifengcong/8833143">https://download.csdn.net/download/zhuifengcong/8833143</a></p><p>最后采用遮罩蒙版，当某个窗体出现，背景变黑。代码来自：<a href="https://blog.csdn.net/tax10240809163com/article/details/108086890">https://blog.csdn.net/tax10240809163com/article/details/108086890</a></p>]]></content>
      
      
      <categories>
          
          <category> qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑马程序员c++_STL》记录</title>
      <link href="2021/08/11/blog26-cpp-stl/"/>
      <url>2021/08/11/blog26-cpp-stl/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。 13542<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系 12345     </p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p><em>每个容器都有自己专属的迭代器</em></p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><div class="table-container"><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、—，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、—、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table></div><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><hr><h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pBegin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.begin(), v.end(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">v3.push_back(i + <span class="number">3</span>);</span><br><span class="line">v4.push_back(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p><strong>string和char * 区别：</strong></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>                          //创建一个空的字符串 例如: string str;</li><li><code>string(const char* s);</code>            //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象，拷贝构造函数</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li></ul><p><strong>示例：</strong> </p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str4;</span><br><span class="line">str4.assign(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str5;</span><br><span class="line">str5.assign(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str7;</span><br><span class="line">str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    string的赋值方式很多，<code>operator =</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator += (const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator += (const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator += (const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s);</code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.append(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.append(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找，查不到返回-1</li><li><code>int find(const char* s, int pos = 0) const;</code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const;</code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const;</code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;</code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s);</code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.rfind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>> 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const;</code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n);</code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);</code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.at(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);</code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str);</code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.insert(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos = email.find(<span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li><li>vector容器的迭代器是支持<code>随机访问</code>的迭代器</li><li><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220326190404606.png" alt="image-20220326190404606"></li></ul><h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v;</code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());</code>       //将v[begin(), end())区间（前闭后开）中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(n);</code>                            // 创建一个大小为n的向量。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator= (const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。（前闭后开）</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty();</code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.resize(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.resize(<span class="number">5</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  —- empty</li><li>返回元素个数  —- size</li><li>返回容器容量  —- capacity</li><li>重新指定大小  —-  resize</li></ul><h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.push_back(<span class="number">10</span>);</span><br><span class="line">v1.push_back(<span class="number">20</span>);</span><br><span class="line">v1.push_back(<span class="number">30</span>);</span><br><span class="line">v1.push_back(<span class="number">40</span>);</span><br><span class="line">v1.push_back(<span class="number">50</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.insert(v1.begin(), <span class="number">100</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">v1.clear();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  —- push_back</li><li>尾删  —- pop_back</li><li>插入  —- insert    (位置迭代器)</li><li>删除  —- erase  （位置迭代器）</li><li>清空  —-  clear  </li></ul><h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code>     //返回索引idx所指的数据</li><li><code>operator[];</code>       //返回索引idx所指的数据</li><li><code>front();</code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v.resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//不变</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//3 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p>double-ended queue </p><p><strong>功能：</strong></p><ul><li><strong><code>双端数组</code></strong>，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210812190711118.png" alt="image-20210812190711118"></p><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d3</span><span class="params">(<span class="number">10</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d4 = d3;</span><br><span class="line">printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq);</code>         //重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">d4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.resize(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">d1.resize(<span class="number">5</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   —- empty</li><li>返回元素个数   —- size</li><li>重新指定个数   —- resize</li></ul><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.pop_back();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.pop_front();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">1000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2.push_back(<span class="number">1</span>);</span><br><span class="line">d2.push_back(<span class="number">2</span>);</span><br><span class="line">d2.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin(), d.end());</span><br><span class="line">d.clear();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    test03();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —-  push_back</li><li>尾删   —-  pop_back</li><li>头插   —-  push_front</li><li>头删   —-  pop_front</li></ul><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx);</code>     //返回索引idx所指的数据</li><li><code>operator[];</code>      //返回索引idx所指的数据</li><li><code>front();</code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line">sort(d.begin(), d.end()); <span class="comment">//默认从小到大</span></span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><hr><h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> create <span class="title">Person</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> score = rand() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">d.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除最高和最低分</span></span><br><span class="line">d.pop_back();</span><br><span class="line">d.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取平均分</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span><br><span class="line">&#123;</span><br><span class="line">sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> avg = sum / d.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">it-&gt;m_Score = avg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建5名选手</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">createPerson(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、给5名选手打分</span></span><br><span class="line">setScore(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最后得分</span></span><br><span class="line">showScore(v);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><hr><h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210812202123680.png" alt="image-20210812202123680"></p><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  —- <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  —- <strong>出栈</strong>  <code>pop</code></p><h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p><strong>功能描述</strong>：栈容器常用的对外接口</p><p><strong>构造函数</strong>：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p><strong>赋值操作</strong>：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p><strong>数据存取</strong>：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top();</code>                //返回栈顶元素</li></ul><p><strong>大小操作</strong>：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size();</code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.push(<span class="number">10</span>);</span><br><span class="line">s.push(<span class="number">20</span>);</span><br><span class="line">s.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   —- push</li><li>出栈   —- pop</li><li>返回栈顶   —- top</li><li>判断栈是否为空   —- empty</li><li>返回栈大小   —- size</li></ul><hr><h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210812203149048.png" alt="image-20210812203149048"></p><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 —- <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 —- <strong>出队</strong>    <code>pop</code></p><h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front();</code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size();</code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.push(p1);</span><br><span class="line">q.push(p2);</span><br><span class="line">q.push(p3);</span><br><span class="line">q.push(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.front().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.front().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.back().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.back().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   —- push</li><li>出队   —- pop</li><li>返回队头元素   —- front</li><li>返回队尾元素   —- back</li><li>判断队是否为空   —- empty</li><li>返回队列大小   —- size</li></ul><hr><h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210812230603286.png" alt="image-20210812230603286"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是<code>空间(指针域)</code> 和 <code>时间（遍历）</code>额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(L1.begin(),L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3(L2);</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">L3.assign(L2.begin(), L2.end());</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">L4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printList(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">L1.swap(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><hr><h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size();</code>                             //返回容器中元素的个数</p></li><li><p><code>empty();</code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem);</code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.resize(<span class="number">10</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line">L1.resize(<span class="number">2</span>);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   —- empty</li><li>返回元素个数   —- size</li><li>重新指定个数   —- resize</li></ul><h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中<code>所有</code>与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.push_back(<span class="number">10</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.push_front(<span class="number">100</span>);</span><br><span class="line">L.push_front(<span class="number">200</span>);</span><br><span class="line">L.push_front(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.pop_back();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.pop_front();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L.begin();</span><br><span class="line">L.insert(++it, <span class="number">1000</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.begin();</span><br><span class="line">L.erase(++it);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">L.remove(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.clear();</span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   —- push_back</li><li>尾删   —- pop_back</li><li>头插   —- push_front</li><li>头删   —- pop_front</li><li>插入   —- insert</li><li>删除   —- erase</li><li>移除   —- remove</li><li>清空   —- clear</li></ul><h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L1.begin();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访 问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   —- front</li><li>返回最后一个元素   —- back</li></ul><h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">L.push_back(<span class="number">90</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">70</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.reverse();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.sort(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">L.sort(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   —- reverse</li><li>排序   —- sort （成员函数）</li></ul><p>所有不支持随机访问迭代器的容器，不可以用标准算法。    </p><h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line">L.push_back(p5);</span><br><span class="line">L.push_back(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L.sort(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li></ul><ul><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><hr><h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset<code>允许容器中有重复的元素</code></li></ul><h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(<span class="number">100</span>);</span><br><span class="line">s2.insert(<span class="number">300</span>);</span><br><span class="line">s2.insert(<span class="number">200</span>);</span><br><span class="line">s2.insert(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s1.swap(s2);</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   —- size</li><li>判断是否为空   —- empty</li><li>交换容器   —- swap</li></ul><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">s1.erase(<span class="number">30</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   —- insert</li><li>删除   —- erase</li><li>清空   —- clear</li></ul><h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数，0或1.</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.find(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = s1.count(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —-  find    （返回的是迭代器）</li><li>统计   —-  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.insert(<span class="number">10</span>);</span><br><span class="line">s2.insert(<span class="number">40</span>);</span><br><span class="line">s2.insert(<span class="number">20</span>);</span><br><span class="line">s2.insert(<span class="number">30</span>);</span><br><span class="line">s2.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong>     set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><hr><h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li><code>map不允许容器中有重复key值元素</code></li><li><code>multimap允许容器中有重复key值元素</code></li></ul><h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2(m); <span class="comment">//拷贝构造</span></span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m.swap(m2);</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   —- size</li><li>判断是否为空   —- empty</li><li>交换容器   —- swap</li></ul><h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.erase(m.begin());</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line">m.erase(<span class="number">3</span>);</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.erase(m.begin(),m.end());</span><br><span class="line">m.clear();</span><br><span class="line">printMap(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   —- insert </li><li>删除   —- erase</li><li>清空   —- clear</li></ul><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.find(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// auto it = hashtable.find(target - nums[i]);</span></span><br><span class="line"><span class="keyword">if</span> (pos != m.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">       <span class="comment">// cout &lt;&lt; &quot;找到了元素 key = &quot; &lt;&lt; pos-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; pos-&gt;second &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = m.count(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —-  find    （返回的是迭代器）</li><li>统计   —-  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><hr><h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createWorker</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = rand() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.push_back(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGroup</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v,<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="keyword">int</span> deptId = rand() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showWorkerByGourp</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;::iterator pos = m.find(CEHUA);</span><br><span class="line"><span class="keyword">int</span> count = m.count(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(MEISHU);</span><br><span class="line">count = m.count(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(YANFA);</span><br><span class="line">count = m.count(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Worker&gt;vWorker;</span><br><span class="line">createWorker(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, Worker&gt;mWorker;</span><br><span class="line">setGroup(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line">showWorkerByGourp(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><hr><h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用<strong>重载的()</strong>时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , <span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">doPrint(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">sort(v.begin(), v.end(), MyCompare());<span class="comment">//此处有()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><hr><h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v.begin();it!= v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">v2.resize(v.size());</span><br><span class="line">transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p><hr><h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul><ul><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);</code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print02());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.resize(v.size()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">transform(v.begin(), v.end(), vTarget.begin(), TransForm());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), MyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());</span><br><span class="line"><span class="keyword">if</span> (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);</code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = adjacent_find(v.begin(), v.end());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);</code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);</code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);</code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), Greater4());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), AgeLess35());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge</code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);</code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line">random_shuffle(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.resize(v1.size() + v2.size());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());</span><br><span class="line">for_each(vtarget.begin(), vtarget.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);</code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">reverse(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if</code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);</code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.resize(v1.size());</span><br><span class="line">copy(v1.begin(), v1.end(), v2.begin());</span><br><span class="line"></span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);</code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace(v.begin(), v.end(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);</code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace_if(v.begin(), v.end(), ReplaceGreater30(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个同类容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);</code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(v1, v2);</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><hr><h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li>计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);</code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);</code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><hr><h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference</code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(min(v1.size(), v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(v1.size() + v2.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize( max(v1.size() , v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> stl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《小灰的算法之旅》记录</title>
      <link href="2021/07/27/blog25-journeyOfAlgorithm/"/>
      <url>2021/07/27/blog25-journeyOfAlgorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="算法概述-空间复杂度"><a href="#算法概述-空间复杂度" class="headerlink" title="算法概述 - 空间复杂度"></a>算法概述 - 空间复杂度</h1><p>常见的空间复杂度有下面几种情形。</p><h3 id="1-常量空间"><a href="#1-常量空间" class="headerlink" title="1.常量空间"></a>1.常量空间</h3><p>当算法的存储空间大小固定，和输入规模没有直接的关系时，空间复杂度记作 O(1)。例如下面这段程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun1(int n)&#123;</span><br><span class="line">    int var &#x3D; 3;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-线性空间"><a href="#2-线性空间" class="headerlink" title="2.线性空间"></a>2.线性空间</h3><p>当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模 n 成正比时，空间复杂度记作 O(n)。</p><p>例如下面这段程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun2(int n)&#123;</span><br><span class="line">    int[] array &#x3D; new int[n];</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-二维空间"><a href="#3-二维空间" class="headerlink" title="3.二维空间"></a>3.二维空间</h3><p>当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作 O(n^2)。</p><p>例如下面这段程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun3(int n)&#123;</span><br><span class="line">    int[][] matrix &#x3D; new int[n][n];</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-递归空间"><a href="#4-递归空间" class="headerlink" title="4.递归空间"></a>4.递归空间</h3><p>递归是一个比较特殊的场景。虽然递归代码中并没有显式地声明变量或集合，但是计算机在执行程序时，会专门分配一块内存，用来存储「方法调用栈」。</p><p>「方法调用栈」包括进栈和出栈两个行为。</p><p>当进入一个新方法时，执行入栈操作，把调用的方法和参数信息压入栈中。</p><p>当方法返回时，执行出栈操作，把调用的方法和参数信息从栈中弹出。</p><p>下面这段程序是一个标准的递归程序：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void fun4(int n)&#123;</span><br><span class="line">    if(n&lt;&#x3D;1)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    fun4(n-1);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>n = 1</code> 时，达到递归结束条件，执行 <code>return</code> 指令，方法出栈。</p><p>最终，「方法调用栈」的全部元素会一一出栈。</p><p>由上面「方法调用栈」的出入栈过程可以看出，执行递归操作所需要的内存空间和递归的深度成正比。纯粹的递归操作的空间复杂度也是线性，如果递归的深度是 n，那么空间复杂度就是 O(n)。</p><hr><h1 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组对应的英文是 array，是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。</p><p>数组的另一个特点，是在内存中 <strong>顺序存储</strong>，因此可以很好地实现逻辑上的 <strong>顺序表</strong>。</p><p>内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。</p><p>数组中的每一个元素，都存储在小小的内存单元中，并且元素之间紧密排列，既不能打乱元素的存储顺序，也不能跳过某个存储单元进行存储。</p><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><h4 id="1-读取元素"><a href="#1-读取元素" class="headerlink" title="1.读取元素"></a>1.读取元素</h4><p>对于数组来说，读取元素是最简单的操作。由于数组在内存中顺序存储，所以只要给出一个数组下标，就可以读取到对应的数组元素。</p><p>假设有一个名称为 array 的数组，我们要读取数组下标为 3 的元素，就写作 array[3]；读取数组下标为 5 的元素，就写作 array[5]。需要注意的是，输入的下标必须在数组的长度范围之内，否则会出现数组越界。</p><p>像这种根据下标读取元素的方式叫作随机读取。</p><p>简单的代码示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] array &#x3D; new int[]&#123;3,1,2,5,4,9,7,2&#125;;</span><br><span class="line">&#x2F;&#x2F;输出数组中下标为3的元素</span><br><span class="line">System.out.println(array[3]);</span><br></pre></td></tr></table></figure><h4 id="2-更新元素"><a href="#2-更新元素" class="headerlink" title="2.更新元素"></a>2.更新元素</h4><p>要把数组中某一个元素的值替换为一个新值，也是非常简单的操作。直接利用数组下标，就可以把新值赋给该元素。</p><p>简单的代码示例如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int[] array &#x3D; new int[]&#123;3,1,2,5,4,9,7,2&#125;;</span><br><span class="line">&#x2F;&#x2F;给数组下标为5的元素赋值</span><br><span class="line">array[5] &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;输出数组中下标为5的元素</span><br><span class="line">System.out.println(array[5]);</span><br></pre></td></tr></table></figure><h4 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3.插入元素"></a>3.插入元素</h4><p>插入数组元素的操作存在 3 种情况。</p><ul><li>尾部插入</li><li>中间插入</li><li>超范围插入</li></ul><p><strong>1 尾部插入</strong>，是最简单的情况，直接把插入的元素放在数组尾部的空闲位置即可，等同于更新元素的操作。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/b084d760ebcb6bdc469b2e444aa192d7044a877e8735e6012f6747377acc3c9e-image.png" alt="img"></p><p><strong>2 中间插入</strong>，稍微复杂一些。由于数组的每一个元素都有其固定下标，所以不得不首先把插入位置及后面的元素向后移动，腾出地方，再把要插入的元素放到对应的数组位置上。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e5c8dcd40e043d1b627f9b62e33eb34527bad23155a35ebd93f7cecc4f588bc5-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1eb68bb6d03400b4a84ce1a249e16c113f454030e38361c0e94a04147376384d-image.png" alt="img"></p><p>中间插入操作的完整实现代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int[] array;</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">public MyArray(int capacity)&#123;</span><br><span class="line">    this.array &#x3D; new int[capacity];</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 数组插入元素</span><br><span class="line"> * * @param index 插入的位置</span><br><span class="line"> * @param element 插入的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void insert(int index, int element) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;判断访问下标是否超出范围</span><br><span class="line">    if(index&lt;0 || index&gt;size)&#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从右向左循环，将元素逐个向右挪1位</span><br><span class="line">    for(int i&#x3D;size-1; i&gt;&#x3D;index; i--)&#123;</span><br><span class="line">        array[i+1] &#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;腾出的位置放入新元素</span><br><span class="line">    array[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输出数组</span><br><span class="line">*&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;size; i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyArray myArray &#x3D; new MyArray(10);</span><br><span class="line">    myArray.insert(0,3);</span><br><span class="line">    myArray.insert(1,7);</span><br><span class="line">    myArray.insert(2,9);</span><br><span class="line">    myArray.insert(3,5);</span><br><span class="line">    myArray.insert(1,6);</span><br><span class="line">    myArray.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的成员变量 size 是数组实际元素的数量。如果插入元素在数组尾部，传入的下标参数 index 等于 size；如果插入元素在数组中间或头部，则 index 小于 size。</p><p>如果传入的下标参数 index 大于 size 或小于 0，则认为是非法输入，会直接抛出异常。</p><p><strong>3 超范围输入</strong></p><p>假如现在有一个长度为 6 的数组，已经装满了元素，这时还想插入一个新元素。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c620b217e9b32fd58f7334267b04fadcc5b86ee6e7b32b4332d724f54f370295-image.png" alt="img"></p><p>这就涉及数组的 扩容 了。可是数组的长度在创建时就已经确定了，无法像孙悟空的金箍棒那样随意变长或变短。这该如何是好呢？</p><p>此时可以创建一个新数组，长度是旧数组的 2 倍，再把旧数组中的元素统统复制过去，这样就实现了数组的扩容。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int[] array;</span><br><span class="line">private int size;</span><br><span class="line"></span><br><span class="line">public MyArray(int capacity)&#123;</span><br><span class="line">    this.array &#x3D; new int[capacity];</span><br><span class="line">    size &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 数组插入元素</span><br><span class="line">* @param index 插入的位置</span><br><span class="line">* @param element 插入的元素</span><br><span class="line">*&#x2F;</span><br><span class="line">public void insert(int index, int element) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;判断访问下标是否超出范围</span><br><span class="line">    if(index&lt;0 || index&gt;size)&#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果实际元素达到数组容量上限，则对数组进行扩容</span><br><span class="line">    if(size &gt;&#x3D; array.length)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;从右向左循环，将元素逐个向右挪1位</span><br><span class="line">    for(int i&#x3D;size-1; i&gt;&#x3D;index; i--)&#123;</span><br><span class="line">        array[i+1] &#x3D; array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;腾出的位置放入新元素</span><br><span class="line">    array[index] &#x3D; element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 数组扩容</span><br><span class="line">*&#x2F;</span><br><span class="line">public void resize()&#123;</span><br><span class="line">    int[] arrayNew &#x3D; new int[array.length*2];</span><br><span class="line">    &#x2F;&#x2F;从旧数组复制到新数组</span><br><span class="line">    System.arraycopy(array, 0, arrayNew, 0, array.length);</span><br><span class="line">    array &#x3D; arrayNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输出数组</span><br><span class="line">*&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    for(int i&#x3D;0; i&lt;size; i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyArray myArray &#x3D; new MyArray(4);</span><br><span class="line">    myArray.insert(0,3);</span><br><span class="line">    myArray.insert(1,7);</span><br><span class="line">    myArray.insert(2,9);</span><br><span class="line">    myArray.insert(3,5);</span><br><span class="line">    myArray.insert(1,6);</span><br><span class="line">    myArray.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-删除元素"><a href="#4-删除元素" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><p>数组的删除操作和插入操作的过程相反，如果删除的元素位于数组中间，其后的元素都需要向前挪动 1 位。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c58483d29aa1d381cc5b7ee9e6e1f4832141b07d5d21d04336b0eaf9484fa64b-image.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 数组删除元素</span><br><span class="line"> * @param index 删除的位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int delete(int index) throws Exception &#123;</span><br><span class="line">    &#x2F;&#x2F;判断访问下标是否超出范围</span><br><span class="line">    if(index&lt;0 || index&gt;&#x3D;size)&#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出数组实际元素范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int deletedElement &#x3D; array[index];</span><br><span class="line">    &#x2F;&#x2F;从左向右循环，将元素逐个向左挪1位</span><br><span class="line">    for(int i&#x3D;index; i&lt;size-1; i++)&#123;</span><br><span class="line">        array[i] &#x3D; array[i+1];</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    return deletedElement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/99dbe210316c5f9e08deabe79f6207ca22a9172df1fe4cea268d8d375e462ac7-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/514206ab8eb6cffad3a6f2a6a701e41fa0870c90649ccbb3022dbff688f684d8-image.png" alt="img"></p><p>这样一来，无须进行大量的元素移动，时间复杂度降低为 O(1)。当然，这种方式只作参考，并不是删除元素时主流的操作方式。</p><h3 id="数组的优势和劣势"><a href="#数组的优势和劣势" class="headerlink" title="数组的优势和劣势"></a>数组的优势和劣势</h3><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/135a196361d199ff34856893b77ea713d638b25fe8636d3f1ae97ba65084e86a-image.png" alt="img"></p><hr><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>单向链表的结构。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/3eea67045ababc726d60ed11e23a0719ed6e795c2fe8062042f4e6d7594e76b0-image.png" alt="img"></p><p>链表（linked list）是一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。</p><p>单向链表的每一个节点又包含两部分，一部分是存放数据的变量 data，另一部分是指向下一个节点的指针 next。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表的第 1 个节点被称为头节点，最后 1 个节点被称为尾节点，尾节点的 next 指针指向空。</p><p>与数组按照下标来随机寻找元素不同，对于链表的其中一个节点 A，我们只能根据节点 A 的 next 指针来找到该节点的下一个节点 B，再根据节点 B 的 next 指针找到下一个节点 C……</p><p>双向链表比单向链表稍微复杂一些，它的每一个节点除了拥有 data 和 next 指针，还拥有指向前置节点的 prev 指针。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/56fc949c01057a4e6e23196a853bf750a77d3e50cc3b14400693786cdd560156-image.png" alt="img"></p><p>接下来我们看一看链表的存储方式。</p><p>如果说数组在内存中的存储方式是顺序存储，那么链表在内存中的存储方式则是 随机存储。</p><p>什么叫随机存储呢？</p><p>上一节我们讲解了数组的内存分配方式，数组在内存中占用了连续完整的存储空间。而链表则采用了见缝插针的方式，链表的每一个节点分布在内存的不同位置，依靠 next 指针关联起来。这样可以灵活有效地利用零散的碎片空间。</p><h3 id="链表的基本操作"><a href="#链表的基本操作" class="headerlink" title="链表的基本操作"></a>链表的基本操作</h3><h4 id="1-查找节点"><a href="#1-查找节点" class="headerlink" title="1.查找节点"></a>1.查找节点</h4><p>在查找元素时，链表不像数组那样可以通过下标快速进行定位，只能从头节点开始向后一个一个节点逐一查找。</p><p>例如给出一个链表，需要查找从头节点开始的第 3 个节点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/039ead8c0dd61e57aac46b3a34e09d00e15fc0cb67e552ab70fa1b3d09e697b9-image.png" alt="img"></p><h4 id="2-更新节点"><a href="#2-更新节点" class="headerlink" title="2.更新节点"></a>2.更新节点</h4><p>如果不考虑查找节点的过程，链表的更新过程会像数组那样简单，直接把旧数据替换成新数据即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/b6a4e93a2eabd637fb8ec21bb148ff2d609d9817b2cf66fbd51ba2b34994d925-image.png" alt="img"></p><h4 id="3-插入节点"><a href="#3-插入节点" class="headerlink" title="3.插入节点"></a>3.插入节点</h4><p>与数组类似，链表插入节点时，同样分为 3 种情况。</p><ul><li>尾部插入</li><li>头部插入</li><li>中间插入</li></ul><p>尾部插入，是最简单的情况，把最后一个节点的 next 指针指向新插入的节点即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/7befe2351ef68342ce469d94ac19996df3da3be85e445bfff6b6373f68e845ef-image.png" alt="img"></p><p>头部插入，可以分成两个步骤。</p><p>第 1 步，把新节点的 next 指针指向原先的头节点。</p><p>第 2 步，把新节点变为链表的头节点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/820aff3077399dc6fbd3c859341271a6c0ac41e0036eeae564a4f02dd2563308-image.png" alt="img"></p><p>中间插入，同样分为两个步骤。</p><p>第 1 步，新节点的 next 指针，指向插入位置的节点。</p><p>第 2 步，插入位置前置节点的 next 指针，指向新节点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/9fda3b10e1d50512059b0ce9ca97f4b801a4a13d3130e4fd26c552f0be90cd51-image.png" alt="img"></p><p>只要内存空间允许，能够插入链表的元素是无穷无尽的，不需要像数组那样考虑扩容的问题。</p><h4 id="4-删除元素-1"><a href="#4-删除元素-1" class="headerlink" title="4.删除元素"></a>4.删除元素</h4><p>链表的删除操作同样分为 3 种情况。</p><ul><li>尾部删除</li><li>头部删除</li><li>中间删除</li></ul><p>尾部删除，是最简单的情况，把倒数第 2 个节点的 next 指针指向空即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/a02ef31340806c6fb15dd13a7564b30083fddf2108b48c34fb3f04f93e061054-image.png" alt="img"></p><p>头部删除，也很简单，把链表的头节点设为原先头节点的 next 指针即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/87f6c34725bb15ee04825e960583cff9e8bbe86f8ad5f912cac09cd37be183b3-image.png" alt="img"></p><p>中间删除，同样很简单，把要删除节点的前置节点的 next 指针，指向要删除元素的下一个节点即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/ac4c0f26d88d71beb9bf9aa2216f7d9925b39057f2bf7d4dd0bf296bf7525718-image.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;头节点指针</span><br><span class="line">private Node head;</span><br><span class="line">&#x2F;&#x2F;尾节点指针</span><br><span class="line">private Node last;</span><br><span class="line">&#x2F;&#x2F;链表实际长度</span><br><span class="line">private int size;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 链表插入元素</span><br><span class="line"> * @param data 插入元素</span><br><span class="line"> * @param index 插入位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void insert(int data, int index) throws Exception &#123;</span><br><span class="line">    if (index&lt;0 || index&gt;size) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出链表节点范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Node insertedNode &#x3D; new Node(data);</span><br><span class="line">    if(size &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;空链表</span><br><span class="line">        head &#x3D; insertedNode;</span><br><span class="line">        last &#x3D; insertedNode;</span><br><span class="line">    &#125; else if(index &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;插入头部</span><br><span class="line">        insertedNode.next &#x3D; head;</span><br><span class="line">        head &#x3D; insertedNode;</span><br><span class="line">    &#125;else if(size &#x3D;&#x3D; index)&#123;</span><br><span class="line">        &#x2F;&#x2F;插入尾部</span><br><span class="line">        last.next &#x3D; insertedNode;</span><br><span class="line">        last &#x3D; insertedNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;插入中间</span><br><span class="line">        Node prevNode &#x3D; get(index-1);</span><br><span class="line">        insertedNode.next &#x3D; prevNode.next;</span><br><span class="line">        prevNode.next &#x3D; insertedNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 链表删除元素</span><br><span class="line"> * @param index 删除的位置</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Node remove(int index) throws Exception &#123;</span><br><span class="line">    if (index&lt;0 || index&gt;&#x3D;size) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出链表节点范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Node removedNode &#x3D; null;</span><br><span class="line">    if(index &#x3D;&#x3D; 0)&#123;</span><br><span class="line">        &#x2F;&#x2F;删除头节点</span><br><span class="line">        removedNode &#x3D; head;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;else if(index &#x3D;&#x3D; size-1)&#123;</span><br><span class="line">        &#x2F;&#x2F;删除尾节点</span><br><span class="line">        Node prevNode &#x3D; get(index-1);</span><br><span class="line">        removedNode &#x3D; prevNode.next;</span><br><span class="line">        prevNode.next &#x3D; null;</span><br><span class="line">        last &#x3D; prevNode;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        &#x2F;&#x2F;删除中间节点</span><br><span class="line">        Node prevNode &#x3D; get(index-1);</span><br><span class="line">        Node nextNode &#x3D; prevNode.next.next;</span><br><span class="line">        removedNode &#x3D; prevNode.next;</span><br><span class="line">        prevNode.next &#x3D; nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    size--;</span><br><span class="line">    return removedNode;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* 链表查找元素</span><br><span class="line">* @param index 查找的位置</span><br><span class="line">*&#x2F;</span><br><span class="line">public Node get(int index) throws Exception &#123;</span><br><span class="line">    if (index&lt;0 || index&gt;&#x3D;size) &#123;</span><br><span class="line">        throw new IndexOutOfBoundsException(&quot;超出链表节点范围！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    Node temp &#x3D; head;</span><br><span class="line">    for(int i&#x3D;0; i&lt;index; i++)&#123;</span><br><span class="line">        temp &#x3D; temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 输出链表</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    Node temp &#x3D; head;</span><br><span class="line">    while (temp!&#x3D;null) &#123;</span><br><span class="line">        System.out.println(temp.data);</span><br><span class="line">        temp &#x3D; temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 链表节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static class Node &#123;</span><br><span class="line">    int data;</span><br><span class="line">    Node next;</span><br><span class="line">    Node(int data) &#123;</span><br><span class="line">        this.data &#x3D; data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyLinkedList myLinkedList &#x3D; new MyLinkedList();</span><br><span class="line">    myLinkedList.insert(3,0);</span><br><span class="line">    myLinkedList.insert(7,1);</span><br><span class="line">    myLinkedList.insert(9,2);</span><br><span class="line">    myLinkedList.insert(5,3);</span><br><span class="line">    myLinkedList.insert(6,1);</span><br><span class="line">    myLinkedList.remove(0);</span><br><span class="line">    myLinkedList.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/f57ec4b3d5e2b7043953c04b5911091a67178d9017fcfd5e514ad6e485494a4f-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/5ec6a10f9d65a64422bc19da97620d86fb2486ac67a284cd02281f462289a808-image.png" alt="img"></p><hr><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="物理结构和逻辑结构"><a href="#物理结构和逻辑结构" class="headerlink" title="物理结构和逻辑结构"></a>物理结构和逻辑结构</h3><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/88985dee51593997dd4a7d9296e28184c5ef47bc9b867cc6214b3ff35c8126a3-image.png" alt="img"></p><p>下面我们来讲解两个常用数据结构：栈和队列。这两者都属于逻辑结构，它们的物理实现既可以利用数组，也可以利用链表来完成。</p><h3 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h3><p>假如有一个又细又长的圆筒，圆筒一端封闭，另一端开口。往圆筒里放入乒乓球，先放入的靠近圆筒底部，后放入的靠近圆筒入口。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/ff9dccb76fcdec6d2db3214c8dadaadd60858ce11a38fd1f3ece9c55e51eddcc-image.png" alt="img"></p><p>那么，要想取出这些乒乓球，则只能按照和放入顺序相反的顺序来取，先取出后放入的，再取出先放入的，而不可能把最里面最先放入的乒乓球优先取出。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/307099ac401e6b69e31b91ffe9c4f1f73f7e917f5cd8e18d25e19c9daef302b8-image.png" alt="img"></p><p><strong><code>栈</code></strong>（stack）是一种线性数据结构，它就像一个上图所示的放入乒乓球的圆筒容器，栈中的元素只能 先入后出（First In Last Out，简称 FILO）。最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作 栈顶（top）。</p><p>栈这种数据结构既可以用数组来实现，也可以用链表来实现。</p><p>栈的数组实现如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/6d4d1e54e6b04354c22104fdd3849074122e7a116f517e35acc2b3aeb8091a14-image.png" alt="img"></p><p>栈的链表实现如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/17a1ca94414d71874c3c28c376a94c4bae3fb969f3a23a0071310f26ebc2a1c3-image.png" alt="img"></p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><h4 id="1-入栈"><a href="#1-入栈" class="headerlink" title="1.入栈"></a>1.入栈</h4><p>入栈操作（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。</p><p>这里我们以数组实现为例。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/165fea0472143dce84bdccb1b5dceed8aa844c17afca5f34cbbec6d596bf16e8-image.png" alt="img"></p><h4 id="2-出栈"><a href="#2-出栈" class="headerlink" title="2.出栈"></a>2.出栈</h4><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/21c46ad4ec11cb92963a640e8daaea82670019a22e956ce03e0315198224d8db-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/34b9e55307418e4809d0cb93d9e428f2605467815606bd5d07a58b0146e4de16-image.png" alt="img"></p><h3 id="什么是队列"><a href="#什么是队列" class="headerlink" title="什么是队列"></a>什么是队列</h3><p>队列（queue）是一种线性数据结构，它的特征和行驶车辆的单行隧道很相似。不同于栈的先入后出，队列中的元素只能 先入先出（First In First Out，简称 FIFO）。队列的出口端叫作 队头（front），队列的入口端叫作 队尾（rear）。</p><p>用数组实现时，为了入队操作的方便，把队尾位置规定为最后入队元素的 <strong>下一个位置</strong>。</p><p>队列的数组实现如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/3b99c85efeafd71cba753fe6dc1bcddfac40cd1cb0ec9dd8405970f20e3a0309-image.png" alt="img"></p><p>队列的链表实现如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/6ca9fbf25a3f97629e02db4d66f28340d11c148f90266ac99b64180c3e3447e7-image.png" alt="img"></p><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><p>对于链表实现方式，队列的入队、出队操作和栈是大同小异的。但对于数组实现方式来说，队列的入队和出队操作有了一些有趣的变化。怎么有趣呢？我们后面会看到。</p><h4 id="1-入队"><a href="#1-入队" class="headerlink" title="1.入队"></a>1.入队</h4><p>入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/9d75cd2557d351df63665964b9d4af556bca4d40b3bb44792d7c44693e8b7ccf-image.png" alt="img"></p><h4 id="2-出队"><a href="#2-出队" class="headerlink" title="2.出队"></a>2.出队</h4><p>出队操作（dequeue）是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/f0b3fa3f966854f375ff9f9a7c073812bb1b40e881dc22d85df79f034d7beba6-image.png" alt="img"></p><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>假设一个队列经过反复的入队和出队操作，还剩下 2 个元素，在「物理」上分布于数组的末尾位置。这时又有一个新元素将要入队。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/27bad911c70a460a24efdd07d001a6766899cb467965657d8606fa156ecc74b0-image.png" alt="img"></p><p>在数组不做扩容的前提下，如何让新元素入队并确定新的队尾位置呢？我们可以利用已出队元素留下的空间，让队尾指针重新指回数组的首位。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/60b109c45df53213d56999390e281ec0b9598e0394bb2df9092c95221be6d54f-image.png" alt="img"></p><p>这样一来，整个队列的元素就「循环」起来了。在物理存储上，队尾的位置也可以在队头之前。当再有元素入队时，将其放入数组的首位，队尾指针继续后移即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210728145044266.png" alt="image-20210728145044266"></p><p>一直到 (队尾下标 + 1) % 数组长度 = 队头下标 时，代表此队列真的已经满了。需要注意的是，队尾指针指向的位置永远空出 1 位，所以队列最大容量比数组长度小 1。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/db4ab58b927b2e6157d7867030be80177c5e0f23c3e6d7ee36f4b24cf6cca686-image.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int[] array;</span><br><span class="line">private int front;</span><br><span class="line">private int rear;</span><br><span class="line"></span><br><span class="line">public MyQueue(int capacity)&#123;</span><br><span class="line">    this.array &#x3D; new int[capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 入队</span><br><span class="line"> * @param element 入队的元素</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void enQueue(int element) throws Exception &#123;</span><br><span class="line">    if((rear+1)%array.length &#x3D;&#x3D; front)&#123;</span><br><span class="line">        throw new Exception(&quot;队列已满！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    array[rear] &#x3D; element;</span><br><span class="line">    rear &#x3D;(rear+1)%array.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 出队</span><br><span class="line">*&#x2F;</span><br><span class="line">public int deQueue() throws Exception &#123;</span><br><span class="line">    if(rear &#x3D;&#x3D; front)&#123;</span><br><span class="line">        throw new Exception(&quot;队列已空！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int deQueueElement &#x3D; array[front];</span><br><span class="line">    front &#x3D;(front+1)%array.length;</span><br><span class="line">    return deQueueElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* 输出队列</span><br><span class="line">*&#x2F;</span><br><span class="line">public void output()&#123;</span><br><span class="line">    for(int i&#x3D;front; i!&#x3D;rear; i&#x3D;(i+1)%array.length)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    MyQueue myQueue &#x3D; new MyQueue(6);</span><br><span class="line">    myQueue.enQueue(3);</span><br><span class="line">    myQueue.enQueue(5);</span><br><span class="line">    myQueue.enQueue(6);</span><br><span class="line">    myQueue.enQueue(8);</span><br><span class="line">    myQueue.enQueue(1);</span><br><span class="line">    myQueue.deQueue();</span><br><span class="line">    myQueue.deQueue();</span><br><span class="line">    myQueue.deQueue();</span><br><span class="line">    myQueue.enQueue(2);</span><br><span class="line">    myQueue.enQueue(4);</span><br><span class="line">    myQueue.enQueue(9);</span><br><span class="line">    myQueue.output();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/aca0e3d68ca2a1ebe9d155882034e97b0edab63900e0ae43c788cf7779e43ea5-image.png" alt="img"></p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p>栈的输出顺序和输入顺序相反，所以栈通常用于对「历史」的回溯，也就是逆流而上追溯「历史」。</p><p>例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。</p><h3 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h3><p>队列的输出顺序和输入顺序相同，所以队列通常用于对「历史」的回放，也就是按照「历史」顺序，把「历史」重演一遍。</p><p>例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。</p><p>再如网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的。</p><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列这种数据结构，可以说综合了栈和队列的优点，对双端队列来说，从队头一端可以入队或出队，从队尾一端也可以入队或出队。</p><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>还有一种队列，它遵循的不是先入先出，而是谁的优先级最高，谁先出队。</p><p>优先队列已经不属于线性数据结构的范畴了，它是基于二叉堆来实现的。关于优先队列的原理和使用情况，我们会在下一章进行详细介绍。</p><hr><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>散列表也叫作 哈希表（hash table），这种数据结构提供了 键（Key）和 值（Value）的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于 O(1)。</p><p>通过哈希函数，把KEY和数组下标进行转换。</p><h3 id="散列表的读写操作"><a href="#散列表的读写操作" class="headerlink" title="散列表的读写操作"></a>散列表的读写操作</h3><h4 id="1-写操作"><a href="#1-写操作" class="headerlink" title="1.写操作"></a>1.写操作</h4><p>写操作就是在散列表中插入新的键值对（在 JDK 中叫作 Entry）。</p><p>如调用 hashMap.put(“002931”, “王五”) ，意思是插入一组 Key 为 002931、Value 为 王五 的键值对。</p><p>具体该怎么做呢？</p><p>第 1 步，通过哈希函数，把 Key 转化成数组下标 5。</p><p>第 2 步，如果数组下标5对应的位置没有元素，就把这个 Entry 填充到数组下标 5 的位置。</p><p>但是，由于数组的长度是有限的，当插入的 Entry 越来越多时，不同的 Key 通过哈希函数获得的下标有可能是相同的。例如 002936 这个 Key 对应的数组下标是 2；002947 这个 Key 对应的数组下标也是 2。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/179569e9240d28d3fd486b9fde35c4e01fde237f161ec2cd2214fabc6d3cd39c-image.png" alt="img"></p><p>这种情况，就叫作 <strong>哈希冲突</strong>。</p><p><strong>开放寻址法</strong></p><p>开放寻址法的原理很简单，当一个 Key 通过哈希函数获得对应的数组下标已被占用时，我们可以「另谋高就」，寻找下一个空档位置。</p><p>以上面的情况为例，Entry6 通过哈希函数得到下标 2，该下标在数组中已经有了其他元素，那么就向后移动 1 位，看看数组下标 3 的位置是否有空。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e9a33f488461b4e40849263c40309328ab2bf4a3cf06d837d120a6d7b6093bce-image.png" alt="img"></p><p>很不巧，下标 3 也已经被占用，那么就再向后移动 1 位，看看数组下标 4 的位置是否有空。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/2d799d6d08fa9c31e113865e2e2234e2f402e908b6e2ff2702762cb5dea3cce3-image.png" alt="img"></p><p>幸运的是，数组下标 4 的位置还没有被占用，因此把 Entry6 存入数组下标 4 的位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/341f5b55f9d65a6b99b2980065eb423a97322daaeaa2714ff27afd7af0f4fa7f-image.png" alt=""></p><p>这就是开放寻址法的基本思路。当然，在遇到哈希冲突时，寻址方式有很多种，并不一定只是简单地寻找当前元素的后一个元素，这里只是举一个简单的示例而已。</p><p><strong>链表法</strong></p><p>这种方法被应用在了 Java 的集合类 HashMap 当中。</p><p>HashMap 数组的每一个元素不仅是一个 Entry 对象，还是一个链表的头节点。每一个 Entry 对象通过next指针指向它的下一个 Entry 节点。当新来的 Entry 映射到与之冲突的数组位置时，只需要插入到对应的链表中即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/cdd31327f7b8840988f4aa6bae22211f4d151f92fbd3033e3952847700a8dc4d-image.png" alt="img"></p><h4 id="2-读操作"><a href="#2-读操作" class="headerlink" title="2.读操作"></a>2.读操作</h4><p>讲完了写操作，我们再来讲一讲读操作。读操作就是通过给定的 Key，在散列表中查找对应的 Value。</p><p>例如调用 hashMap.get(“002936”)，意思是查找 Key 为 002936 的 Entry 在散列表中所对应的值。</p><p>具体该怎么做呢？下面以链表法为例来讲一下。</p><p>第 1 步，通过哈希函数，把 Key 转化成数组下标 2。</p><p>第 2 步，找到数组下标 2 所对应的元素，如果这个元素的 Key 是 002936，那么就找到了；如果这个 Key 不是 002936 也没关系，由于数组的每个元素都与一个链表对应，我们可以顺着链表慢慢往下找，看看能否找到与 Key 相匹配的节点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/28a5d1d6da1c4ec21911422d1773f5d92deb05955e89f2e003a8a74038a992cc-image.png" alt="img"></p><p>在上图中，首先查到的节点 Entry6 的 Key 是 002947，和待查找的 Key 002936 不符。接着定位到链表下一个节点 Entry1，发现 Entry1 的 Key 002936 正是我们要寻找的，所以返回 Entry1 的 Value 即可。</p><h4 id="3-扩容（resize）"><a href="#3-扩容（resize）" class="headerlink" title="3.扩容（resize）"></a>3.扩容（resize）</h4><p>在讲解数组时，曾经介绍过数组的扩容。既然散列表是基于数组实现的，那么散列表也要涉及扩容的问题。</p><p>首先，什么时候需要进行扩容呢？</p><p>当经过多次元素插入，散列表达到一定饱和度时，Key 映射位置发生冲突的概率会逐渐提高。这样一来，大量元素拥挤在相同的数组下标位置，形成很长的链表，对后续插入操作和查询操作的性能都有很大影响。</p><ol><li>扩容，创建一个新的 Entry 空数组，长度是原数组的 2 倍。</li><li>重新 Hash，遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组中。为什么要重新 Hash 呢？因为长度扩大以后，Hash 的规则也随之改变。</li></ol><p>经过扩容，原本拥挤的散列表重新变得稀疏，原有的 Entry 也重新得到了尽可能均匀的分配。</p><hr><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><p>在数据结构中，树的定义如下。</p><p>树（tree）是 n(n≥0) 个节点的有限集。当 n=0 时，称为空树。在任意一个非空树中，有如下特点。</p><p>有且仅有一个特定的称为根的节点。</p><p>当 n&gt;1 时，其余节点可分为 m(m&gt;0)个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。</p><p>下面这张图，就是一个标准的树结构。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/a03fd322fa360e64fcd0cb63d1c54e0e2c7f1513ba50c7104ff76f2459e68f39-image.png" alt="img"></p><p>在上图中，节点 1 是 根节点（root）；节点 5、6、7、8 是树的末端，没有「孩子」，被称为叶子节点（leaf）。图中的虚线部分，是根节点 1 的其中一个子树。</p><p>同时，树的结构从根节点到叶子节点，分为不同的层级。从一个节点的角度来看，它的上下级和同级节点关系如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/954bb9227903d3be88f921bc76a5dac8a95bceb3dea9795184d3714cf7d5815b-image.png" alt="img"></p><p>在上图中，节点 4 的上一级节点，是节点 4 的父节点（parent）；从节点 4 衍生出来的节点，是节点 4 的孩子节点（child）；和节点 4 同级，由同一个父节点衍生出来的节点，是节点 4 的兄弟节点（sibling）。</p><p>树的最大层级数，被称为树的高度或深度。显然，上图这个树的高度是 4。</p><h2 id="什么是二叉树"><a href="#什么是二叉树" class="headerlink" title="什么是二叉树"></a>什么是二叉树</h2><p>二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点 最多有 2 个孩子节点。注意，这里是最多有 2 个，也可能只有 1 个，或者没有孩子节点。</p><p>二叉树的结构如图所示。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1d59b660750e8ff15f7c40d76461cedbbab01261eb9b2c562699f98882006d33-image.png" alt="img"></p><p>二叉树节点的两个孩子节点，一个被称为 左孩子（left child），一个被称为 右孩子（right child）。这两个孩子节点的顺序是固定的，就像人的左手就是左手，右手就是右手，不能够颠倒或混淆。</p><p>此外，二叉树还有两种特殊形式，一个叫作 满二叉树，另一个叫作 完全二叉树。</p><p>什么是满二叉树呢？</p><p><strong>一个二叉树的所有非叶子节点都存在左右孩子，并且所有叶子节点都在同一层级上，那么这个树就是满二叉树。</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/06369deec7bc21bf910da8c03b9f10f866b077adab18625c1e72db71eb1a7c98-image.png" alt="img"></p><p>简单点说，满二叉树的每一个分支都是满的。</p><p>什么又是完全二叉树呢？完全二叉树的定义很有意思。</p><p>对一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n。如果这个树所有节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为<code>完全二叉树</code>。</p><p>这个定义还真绕，看看下图就很容易理解了。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/2b7498a5b91e6765f1a654b7b16a4efb0214cb599be8e51fdea3cbc586174c74-image.png" alt="img"></p><p>在上图中，二叉树编号从 1 到 12 的 12 个节点，和前面满二叉树编号从 1 到 12 的节点位置完全对应。因此这个树是完全二叉树。</p><p>完全二叉树的条件没有满二叉树那么苛刻：满二叉树要求所有分支都是满的；而完全二叉树只需保证最后一个节点之前的节点都齐全即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/f28e307006deb99efb5c35ee5195dddac07da529d7ef8df77799c1cd6cbc0a02-image.png" alt="img"></p><p>二叉树可以用哪些物理存储结构来表达呢？</p><ol><li>链式存储结构。</li><li>数组。</li></ol><p><strong>链式存储结构</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c8341333e3a9453d0b84fe335b3911459a9894ade84592b5945205b746b855e6-image.png" alt="img"></p><p>链式存储是二叉树最直观的存储方式。</p><p>上一章讲过链表，链表是一对一的存储方式，每一个链表节点拥有 data 变量和一个指向下一节点的 next 指针。</p><p>而二叉树稍微复杂一些，一个节点最多可以指向左右两个孩子节点，所以二叉树的每一个节点包含 3 部分。</p><ul><li>存储数据的 data 变量</li><li>指向左孩子的 left 指针</li><li>指向右孩子的 right 指针</li></ul><p>再来看看用 数组 是如何存储的。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/257d8684f018221f33f86161a8434b2d09930035ddae9aaa2bf8722d577f6c70-image.png" alt="img"></p><p>使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。</p><p>为什么这样设计呢？因为这样可以更方便地在数组中定位二叉树的孩子节点和父节点。</p><p>假设一个父节点的下标是 parent，那么它的左孩子节点下标就是 2×parent + 1；右孩子节点下标就是 2×parent + 2。</p><p>反过来，假设一个左孩子节点的下标是 leftChild，那么它的父节点下标就是 (leftChild-1) / 2。</p><p>假如节点 4 在数组中的下标是 3，节点 4 是节点 2 的左孩子，节点 2 的下标可以直接通过计算得出。</p><p>节点 2 的下标 = (3-1)/2 = 1</p><p>显然，对于一个稀疏的二叉树来说，用数组表示法是非常浪费空间的。</p><p>什么样的二叉树最适合用数组表示呢？</p><p>我们后面即将学到的二叉堆，一种特殊的完全二叉树，就是用数组来存储的。</p><h3 id="二叉树的应用"><a href="#二叉树的应用" class="headerlink" title="二叉树的应用"></a>二叉树的应用</h3><p>二叉树包含许多特殊的形式，每一种形式都有自己的作用，但是其最主要的应用还在于进行 <strong>查找操作和维持相对顺序</strong> 这两个方面。</p><h4 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h4><p>二叉树的树形结构使它很适合扮演索引的角色。</p><p>这里我们介绍一种特殊的二叉树：二叉查找树（binary search tree）。光看名字就可以知道，这种二叉树的主要作用就是进行查找操作。</p><p>二叉查找树在二叉树的基础上增加了以下几个条件。</p><ul><li>如果左子树不为空，则左子树上所有节点的值均小于根节点的值</li><li>如果右子树不为空，则右子树上所有节点的值均大于根节点的值</li><li>左、右子树也都是二叉查找树</li></ul><p>下图就是一个标准的二叉查找树。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/7ec930771a40155997e8055cf8542aeb989c2316253b1080d740c9f8fd90eafb-image.png" alt="img"></p><p>二叉查找树的这些条件有什么用呢？当然是为了查找方便。</p><p>对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是 n，那么搜索节点的时间复杂度就是 O(log n)，和树的深度是一样的。</p><p>这种依靠比较大小来逐步查找的方式，和二分查找算法非常相似。</p><h4 id="2-维持相对顺序"><a href="#2-维持相对顺序" class="headerlink" title="2. 维持相对顺序"></a>2. 维持相对顺序</h4><p>这一点仍然要从二叉查找树说起。二叉查找树要求左子树小于父节点，右子树大于父节点，正是这样保证了二叉树的有序性。</p><p>因此二叉查找树还有另一个名字——二叉排序树（binary sort tree）。</p><p>新插入的节点，同样要遵循二叉排序树的原则。例如插入新元素 5，由于 5 &lt; 6，5 &gt; 3，5 &gt; 4，所以 5 最终会插入到节点 4 的右孩子位置。</p><p>这一切看起来很顺利，然而却隐藏着一个致命的问题。什么问题呢？下面请试着在二叉查找树中依次插入 9、8、7、6、5、4，看看会出现什么结果。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/678e3c1f5bb75ff5133f956151514e954d9bf07f5d8833f678a542f2c269eb81-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/90ec62910f0ea7efe02606c745d90412d3730418f07aa3c8247c2df9dd503ccb-image.png" alt="img"></p><p>怎么解决这个问题呢？这就涉及二叉树的自平衡了。二叉树自平衡的方式有多种，如红黑树、AVL 树、树堆等。由于篇幅有限，本书就不一一详细讲解了，感兴趣的读者可以查一查相关资料。</p><hr><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树，是典型的非线性数据结构，遍历时需要把非线性关联的节点转化成一个线性的序列，以不同的方式来遍历，遍历出的序列顺序也不同</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c75787ee0fe6ecad30474b3454ba50ed1dd1e9c6bf36bdd984c81f5c3e48bbbb-image.png" alt="img"></p><p>从节点之间位置关系的角度来看，二叉树的遍历分为 4 种。</p><ol><li>前序遍历。</li><li>中序遍历。</li><li>后序遍历。</li><li>层序遍历。</li></ol><p>从更宏观的角度来看，二叉树的遍历归结为两大类。</p><ul><li>深度优先遍历（前序遍历、中序遍历、后序遍历）。</li><li>广度优先遍历（层序遍历）。</li></ul><p>下面就来具体看一看这些不同的遍历方式。</p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先和广度优先这两个概念不止局限于二叉树，它们更是一种抽象的算法思想，决定了访问某些复杂数据结构的顺序。在访问树、图，或其他一些复杂数据结构时，这两个概念常常被使用到。</p><p>所谓深度优先，顾名思义，就是偏向于纵深，「一头扎到底」的访问方式。可能这种说法有些抽象，下面就通过二叉树的前序遍历、中序遍历、后序遍历，来看一看深度优先是怎么回事吧。</p><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1.前序遍历"></a>1.前序遍历</h4><p>二叉树的前序遍历，输出顺序是根节点、左子树、右子树。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/f9753b165136f192c231d6b4c61852ee967de8e5cd949fc42ef372ec002d20db-image.png" alt="img"></p><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h4><p>二叉树的中序遍历，输出顺序是左子树、根节点、右子树。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/67021933c5aea3c7c6f54fc713d1967a965acbbf65ccab0bbdb44cbe8c3ebf7a-image.png" alt="img"></p><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><p>二叉树的后序遍历，输出顺序是左子树、右子树、根节点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e56788e04cffff8693c832ad0238d0ea3f2927da08723e1b2a0316802b45a7c0-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputList 输入序列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">createBinaryTree</span><span class="params">(LinkedList&lt;Integer&gt;inputList)</span></span>&#123;</span><br><span class="line">    TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (inputList == <span class="keyword">null</span> || inputList.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer data = inputList.removeFirst();</span><br><span class="line">    <span class="comment">// 这里的判空很关键：如果元素是空，则不在进一步递归</span></span><br><span class="line">    <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">        node.leftChild = createBinaryTree(inputList);</span><br><span class="line">        node.rightChild = createBinaryTree(inputList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">    preOrderTraveral(node.leftChild);</span><br><span class="line">    preOrderTraveral(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrderTraveral(node.leftChild);</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">    inOrderTraveral(node.rightChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树后序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 二叉树节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrderTraveral</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrderTraveral(node.leftChild);</span><br><span class="line">    postOrderTraveral(node.rightChild);</span><br><span class="line">    System.out.println(node.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 二叉树节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    TreeNode leftChild;</span><br><span class="line">    TreeNode rightChild;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; inputList = <span class="keyword">new</span> LinkedList&lt;Integer&gt;(Arrays.</span><br><span class="line">              asList(<span class="keyword">new</span> Integer[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">10</span>,<span class="keyword">null</span>,</span><br><span class="line">              <span class="keyword">null</span>,<span class="number">8</span>,<span class="keyword">null</span>,<span class="number">4</span>&#125;));</span><br><span class="line">    TreeNode treeNode = createBinaryTree(inputList);</span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历：&quot;</span>);</span><br><span class="line">    preOrderTraveral(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历：&quot;</span>);</span><br><span class="line">    inOrderTraveral(treeNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历：&quot;</span>);</span><br><span class="line">    postOrderTraveral(treeNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二叉树用递归方式来实现前序、中序、后序遍历，是最为自然的方式，因此代码也非常简单。</p><p>这 3 种遍历方式的区别，仅仅是输出的执行位置不同：前序遍历的输出在前，中序遍历的输出在中间，后序遍历的输出在最后。</p><p>代码中值得注意的一点是二叉树的构建。二叉树的构建方法有很多，这里把一个线性的链表转化成非线性的二叉树，链表节点的顺序恰恰是二叉树前序遍历的顺序。链表中的空值，代表二叉树节点的左孩子或右孩子为空的情况。</p><p>在代码的 main 函数中，通过 {3,2,9,null,null,10,null,null,8,null,4} 这样一个线性序列，构建成的二叉树如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e4264241dd5b7f0dc81609b64c91aaf04f9933973e296827ae26a1c5e8d70b4b-image.png" alt="img"></p><p>绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈。因为递归和栈都有回溯的特性。</p><p>如何借助栈来实现二叉树的非递归遍历呢？下面以二叉树的前序遍历为例，看一看具体过程。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164313752.png" alt="image-20210727164313752"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164321565.png" alt="image-20210727164321565"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164334246.png" alt="image-20210727164334246"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164343866.png" alt="image-20210727164343866"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164350206.png" alt="image-20210727164350206"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164356767.png" alt="image-20210727164356767"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164405832.png" alt="image-20210727164405832"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树非递归前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderTraveralWithStack</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">    TreeNode treeNode = root;</span><br><span class="line">    <span class="keyword">while</span>(treeNode!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//迭代访问节点的左孩子，并入栈</span></span><br><span class="line">        <span class="keyword">while</span> (treeNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(treeNode.data);</span><br><span class="line">            stack.push(treeNode);</span><br><span class="line">            treeNode = treeNode.leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果节点没有左孩子，则弹出栈顶节点，访问节点右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">            treeNode = stack.pop();</span><br><span class="line">            treeNode = treeNode.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>如果说深度优先遍历是在一个方向上「一头扎到底」，那么广度优先遍历则恰恰相反：先在各个方向上各走出 1 步，再在各个方向上走出第 2 步、第 3 步……一直到各个方向全部走完。听起来有些抽象，下面让我们通过二叉树的层序遍历，来看一看广度优先是怎么回事。</p><p>层序遍历，顾名思义，就是二叉树按照从根节点到叶子节点的层次关系，一层一层横向遍历各个节点。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/a7b56e53db15682caade01d3006cbac57af7db32229a18048b1f46fe62cebd49-image.png" alt="img"></p><p>上图就是一个二叉树的层序遍历，每个节点左侧的序号代表该节点的输出顺序。</p><p>可是，二叉树同一层次的节点之间是没有直接关联的，如何实现这种层序遍历呢？</p><p>这里同样需要借助一个数据结构来辅助工作，这个数据结构就是 <strong><code>队列</code></strong>。</p><p>详细遍历步骤如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164548134.png" alt="image-20210727164548134"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164554413.png" alt="image-20210727164554413"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164833894.png" alt="image-20210727164833894"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164843510.png" alt="image-20210727164843510"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164850404.png" alt="image-20210727164850404"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164856216.png" alt="image-20210727164856216"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210727164902536.png" alt="image-20210727164902536"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树层序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 二叉树根节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelOrderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        System.out.println(node.data);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.leftChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(node.rightChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><p>二叉堆本质上是一种完全二叉树，它分为两个类型。</p><ol><li><strong>最大堆</strong>。</li><li><strong>最小堆</strong>。</li></ol><p>什么是最大堆呢？最大堆的任何一个父节点的值，都 <strong>大于或等于</strong> 它左、右孩子节点的值。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/09bac735648e52f9314bb098a29fa46f5ddf6306c9785f2c608ec86e4acc74dc-image.png" alt="img"></p><p>什么是最小堆呢？最小堆的任何一个父节点的值，都小于或等于它左、右孩子节点的值。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/d4f91b0691c64a085e0c960d03540938ee01a06856947fbbbf95ff7127642744-image.png" alt="img"></p><p>二叉堆的根节点叫作 <strong>堆顶</strong>。</p><p>最大堆和最小堆的特点决定了：最大堆的堆顶是整个堆中的 <strong>最大元素</strong>；最小堆的堆顶是整个堆中的 <strong>最小元素</strong>。</p><h3 id="二叉堆的自我调整"><a href="#二叉堆的自我调整" class="headerlink" title="二叉堆的自我调整"></a>二叉堆的自我调整</h3><p>对于二叉堆，有如下几种操作。</p><ol><li><strong>插入节点</strong>。</li><li><strong>删除节点</strong>。</li><li><strong>构建二叉堆</strong></li></ol><p>这几种操作都基于堆的自我调整。所谓堆的自我调整，就是把一个不符合堆性质的完全二叉树，调整成一个堆。下面让我们以最小堆为例，看一看二叉堆是如何进行自我调整的。</p><h4 id="1-插入节点"><a href="#1-插入节点" class="headerlink" title="1.插入节点"></a>1.插入节点</h4><p>当二叉堆插入节点时，插入位置是完全二叉树的最后一个位置。例如插入一个新节点，值是 0。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/50ef9b08afe7af3f7d88ce8482691e1a2c33486ab7517ca87eb38872827d620d-image.png" alt="img"></p><p>这时，新节点的父节点 5 比 0 大，显然不符合最小堆的性质。于是让新节点「上浮」，和父节点交换位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/dcc44ea987c79b3a0f8d7ecfac7e51fa3a42bff07778ab9f011491b18178b2d6-image.png" alt="img"></p><p>继续比较，最终新节点 0「上浮」到了堆顶位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/14fee45e056081a678354b60f30b710fe44f991d31cd27a959fc42d37440dcc2-image.png" alt="img"></p><h4 id="2-删除节点"><a href="#2-删除节点" class="headerlink" title="2. 删除节点"></a>2. 删除节点</h4><p>二叉堆删除节点的过程和插入节点的过程正好相反，所删除的是处于堆顶的节点。例如删除最小堆的堆顶节点 1。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/63f392593a9bc353676e5ba49bc48649d0522ecb606318bedb47f279f3e42606-image.png" alt="img"></p><p>这时，为了继续维持完全二叉树的结构，我们把堆的最后一个节点 10 临时补到原本堆顶的位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/2e408f990508896b8bd8c62547751c6cb7b59d5d98789f1117e24b4ee64f7122-image.png" alt="img"></p><p>接下来，让暂处堆顶位置的节点 10 和它的左、右孩子进行比较，如果左、右孩子节点中最小的一个（显然是节点 2）比节点 10 小，那么让节点 10「下沉」。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e886fdfac8b08f8e93dc82b201eef0aeb3840d20790d07d84a8897587412edb1-image.png" alt="img"></p><h4 id="3-构建二叉堆"><a href="#3-构建二叉堆" class="headerlink" title="3. 构建二叉堆"></a>3. 构建二叉堆</h4><p>构建二叉堆，也就是把一个无序的完全二叉树调整为二叉堆，本质就是让所有非叶子节点依次「下沉」。</p><p>下面举一个无序完全二叉树的例子，如下图所示。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/addf9731e7e6d555262d480207510be36835daebbcacfeffb3b5478ab1e8d701-image.png" alt="img"></p><p>首先，从最后一个非叶子节点开始，也就是从节点 10 开始。如果节点 10 大于它左、右孩子节点中最小的一个，则节点 10「下沉」。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/465057c49790ccc981a8f234b0212083d93f9e88634f1d520bea5855622f79b0-image.png" alt="img"></p><p>接下来轮到节点 3，如果节点 3 大于它左、右孩子节点中最小的一个，则节点 3「下沉」。</p><p>然后轮到节点 1，如果节点 1 大于它左、右孩子节点中最小的一个，则节点 1「下沉」。事实上节点 1 小于它的左、右孩子，所以不用改变。</p><p>接下来轮到节点 7，如果节点 7 大于它左、右孩子节点中最小的一个，则节点 7「下沉」。节点 7 继续比较，继续「下沉」。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/6e814125c69968b98f2369a3795dca226cdeace07787db9d42535606574cfbad-image.png" alt="img"></p><p>经过上述几轮比较和「下沉」操作，最终每一节点都小于它的左、右孩子节点，一个无序的完全二叉树就被构建成了一个最小堆。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/3c49e9cef1edcf064888a0ebbf761f4469998bde9f8ac90e3ec4bab2632b36aa-image.png" alt="img"></p><h3 id="二叉堆的代码实现"><a href="#二叉堆的代码实现" class="headerlink" title="二叉堆的代码实现"></a>二叉堆的代码实现</h3><p>在展示代码之前，我们还需要明确一点：二叉堆虽然是一个完全二叉树，但它的存储方式并不是链式存储，而是顺序存储。换句话说，二叉堆的所有节点都存储在数组中。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/7a3431761cb8aa0be8d80d05936e394e5b09677a77c4eb07c5cae9c2089f479a-image.png" alt="img"></p><p>在数组中，在没有左、右指针的情况下，如何定位一个父节点的左孩子和右孩子呢？</p><p>像上图那样，可以依靠数组下标来计算。</p><p>假设父节点的下标是 parent，那么它的左孩子下标就是 2 <em> parent + 1；右孩子下标就是 2 </em> parent + 2。</p><p>例如上面的例子中，节点 6 包含 9 和 10 两个孩子节点，节点 6 在数组中的下标是 3，节点 9 在数组中的下标是 7，节点 10 在数组中的下标是 8。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “上浮”调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[parentIndex])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[childIndex] = array[parentIndex];</span><br><span class="line">        childIndex = parentIndex;</span><br><span class="line">        parentIndex = (parentIndex-<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">    <span class="comment">// 如果有右孩子，且右孩子小于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &lt; array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 如果父节点小于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构建堆</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从最后一个非叶子节点开始，依次做“下沉”调整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    upAdjust(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    buildHeap(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中有一个优化的点，就是在父节点和孩子节点做连续交换时，并不一定要真的交换，只需要先把交换一方的值存入 temp 变量，做单向覆盖，循环结束后，再把 temp 的值存入交换后的最终位置即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/48a5e82dd75fb78290f3d0b60986f817c45d7f8e804648970bbbd7ee89557feb-image.png" alt="img"></p><hr><h2 id="优先队列-1"><a href="#优先队列-1" class="headerlink" title="优先队列"></a>优先队列</h2><p>队列的特点是什么？</p><p>在之前的章节中已经讲过，队列的特点是 <strong>先进先出（FIFO）</strong>。</p><p><strong>入队列，将新元素置于队尾</strong>。<strong>出队列，队头元素最先被移出：</strong>。</p><p>优先队列不再遵循先入先出的原则，而是分为两种情况。</p><p>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队<br>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队</p><p>例如有一个最大优先队列，其中的最大元素是 8，那么虽然8并不是队头元素，但出队时仍然让元素8首先出队。</p><p><strong>最大堆的堆顶是整个堆中的最大元素。</strong></p><p>因此，可以用最大堆来实现最大优先队列，这样的话，每一次入队操作就是堆的插入操作，每一次出队操作就是删除堆顶节点。</p><p><strong>入队操作</strong> 具体步骤如下</p><p>插入新节点 5。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1cdd55a437f77a222effbd9cf4cd37a0e8f1911e0ec32766fd7d7810c9c92b40-image.png" alt="img"></p><p>新节点 5「上浮」到合适位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/192aa099efe7e0e1536fe5fbbfc2a825de1b2f6cbe4c4fcd1353260c589ef956-image.png" alt="img"></p><p><strong>出队操作</strong> 具体步骤如下。</p><p>让原堆顶节点 10 出队。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/3c2f229af70a78f2158387ea186bf0445f8df350a2a9b7978ddda41569e7a901-image.png" alt="img"></p><p>把最后一个节点 1 替换到堆顶位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/ea77504980fa8241c606ab06a20e6595e013a1fe1a7560557f10b0173a5a7972-image.png" alt="img"></p><p>节点 1「下沉」，节点 9 成为新堆顶。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/a12c8b8a7333c3dc2d46eb4f821b9ac0e9d48267bf7c6cfe5d9f4e3d149c7a93-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/eb7b3637b070212ec28ebd8d6176e26e8c8b0450428b573f9a0a5b91be0b7512-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//队列初始长度为32</span></span><br><span class="line">    array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 入队元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列长度超出范围，扩容</span></span><br><span class="line">    <span class="keyword">if</span>(size &gt;= array.length)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    array[size++] = key;</span><br><span class="line">    upAdjust();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deQueue</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;the queue is empty !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取堆顶元素</span></span><br><span class="line">    <span class="keyword">int</span> head = array[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//让最后一个元素移动到堆顶</span></span><br><span class="line">    array[<span class="number">0</span>] = array[--size];</span><br><span class="line">    downAdjust();</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “上浮”调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childIndex = size-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> parentIndex = (childIndex-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// temp保存插入的叶子节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[childIndex];</span><br><span class="line">    <span class="keyword">while</span> (childIndex &gt; <span class="number">0</span> &amp;&amp; temp &gt; array[parentIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[childIndex] = array[parentIndex];</span><br><span class="line">        childIndex = parentIndex;</span><br><span class="line">        parentIndex = parentIndex / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[childIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp保存父节点的值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> parentIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; size) &#123;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; size &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点大于任何一个孩子的值，直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//队列容量翻倍</span></span><br><span class="line">    <span class="keyword">int</span> newSize = <span class="keyword">this</span>.size * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.array = Arrays.copyOf(<span class="keyword">this</span>.array, newSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PriorityQueue priorityQueue = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">    priorityQueue.enQueue(<span class="number">3</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">5</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">10</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">2</span>);</span><br><span class="line">    priorityQueue.enQueue(<span class="number">7</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">    System.out.println(<span class="string">&quot;出队元素：&quot;</span> + priorityQueue.deQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码采用数组来存储二叉堆的元素，因此当元素数量超过数组长度时，需要进行扩容来扩大数组长度。</p><hr><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>根据时间复杂度的不同，主流的排序算法可以分为 3 大类。</p><ol><li><p>时间复杂度为 O(n^2)的排序算法</p><ul><li><p>冒泡排序</p></li><li><p>选择排序</p></li><li><p>插入排序</p></li><li><p>希尔排序（希尔排序比较特殊，它的性能略优于 O(n^2)，但又比不上 O(nlog n)，姑且把它归入本类）</p></li></ul></li></ol><ol><li><p>时间复杂度为 O(nlog n) 的排序算法</p><ul><li><p>快速排序</p></li><li><p>归并排序</p></li><li><p>堆排序</p></li></ul></li><li><p>时间复杂度为线性的排序算法</p><ul><li><p>计数排序</p></li><li><p>桶排序</p></li><li><p>基数排序</p></li></ul></li></ol><p>当然，以上列举的只是最主流的排序算法，在算法界还存在着更多五花八门的排序，它们有些基于传统排序变形而来；有些则是脑洞大开，如鸡尾酒排序、猴子排序、睡眠排序等。</p><p>此外，排序算法还可以根据其稳定性，划分为稳定排序和不稳定排序。</p><p>即如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。</p><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序之所以叫冒泡排序，正是因为这种排序算法的每一个元素都可以像小气泡一样，根据自身大小，一点一点地向着数组的一侧移动。</p><p>按照冒泡排序的思想，我们要 <strong>把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变</strong>。详细过程如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/40e8b3e132ed2482c4bc433bf6a72ffaa0ec386e94c91b0e188d508e6a5d39e0-image.png" alt="img"></p><p>这样一来，元素 9 作为数列中最大的元素，就像是汽水里的小气泡一样，「漂」到了最右侧。</p><p>这时，冒泡排序的第 1 轮就结束了。数列最右侧元素 9 的位置可以认为是一个有序区域，有序区域目前只有 1 个元素。</p><p>后续的交换细节，这里就不详细描述了，第 3 轮到第 7 轮的状态如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c2e5a2a8d4399b4a38c7612b6a17b17abfdb88c6904094db6f9a1c7bdbeb822b-image.png" alt="img"></p><p>冒泡排序是一种稳定排序，值相等的元素并不会打乱原本的顺序。由于该排序算法的每一轮都要遍历所有元素，总共遍历（元素数量 - 1）轮，所以平均时间复杂度是 O(n^2)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显可以看出，经过第 6 轮排序后，整个数列已然是有序的了。可是排序算法仍然兢兢业业地继续执行了第 7 轮排序。</p><p>在这种情况下，如果能判断出数列已经有序，并做出标记，那么剩下的几轮排序就不必执行了，可以提前结束工作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与第 1 版代码相比，第 2 版代码做了小小的改动，利用布尔变量 isSorted 作为标记。如果在本轮排序中，元素有交换，则说明数列无序；如果没有元素交换，则说明数列已然有序，然后直接跳出大循环。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/8103b28bab7794e0f225f01a52ea4591a6fddca77c1975763d15e714e12ebb9b-image.png" alt="img"></p><p>这个数列的特点是前半部分的元素（3、4、2、1）无序，后半部分的元素（5、6、7、8）按升序排列，并且后半部分元素中的最小值也大于前半部分元素的最大值。</p><p>这个问题的关键点在于对数列有序区的界定。</p><p>按照现有的逻辑，有序区的长度和排序的轮数是相等的。例如第1轮排序过后的有序区长度是 1，第 2 轮排序过后的有序区长度是 2 ……</p><p>实际上，数列真正的有序区可能会大于这个长度，如上述例子中在第 2 轮排序时，后面的 5 个元素实际上都已经属于有序区了。因此后面的多次元素比较是没有意义的。</p><p>那么，该如何避免这种情况呢？<strong>我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为无序数列的边界，再往后就是有序区了。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//记录最后一次交换的位置</span></span><br><span class="line">    <span class="keyword">int</span> lastExchangeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//无序数列的边界，每次比较只需要比到这里为止</span></span><br><span class="line">    <span class="keyword">int</span> sortBorder = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sortBorder; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//更新为最后一次交换元素的位置</span></span><br><span class="line">                lastExchangeIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortBorder = lastExchangeIndex;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第 3 版代码中，<code>sortBorder</code> 就是无序数列的边界。在每一轮排序过程中，处于 <code>sortBorder</code> 之后的元素就不需要再进行比较了，肯定是有序的。</p><p>还有一种排序算法叫作鸡尾酒排序，是基于冒泡排序的一种升级排序法。</p><h2 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h2><p>冒泡排序的每一个元素都可以像小气泡一样，根据自身大小，一点一点地向着数组的一侧移动。算法的每一轮都是 从左到右来比较元素，进行单向的位置交换的。</p><p>那么鸡尾酒排序做了怎样的优化呢？</p><p>鸡尾酒排序的元素比较和交换过程是 双向 的。</p><p>下面举一个例子。</p><p>由 8 个数字组成一个无序数列 {2,3,4,5,6,7,8,1}，希望对其进行从小到大的排序。</p><p>如果按照冒泡排序的思想，排序过程如下。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/4cc400c0aecb6e3b81582a292b51faf6298184963c89a2cf708e8ade71190a06-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/95bb7836fb7989756714fa0c028ccd21657db20cea41294dc8ead144ec355150-image.png" alt="img"></p><p><strong>第 1 轮（和冒泡排序一样，8 和 1 交换）</strong></p><p><strong>第 2 轮</strong></p><p>此时开始不一样了，我们反过来 <strong>从右往左</strong> 比较并进行交换。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/b85cd9eb2b4d30eb006599ea4a6489bacc0dd649355452ab316a9fd4e21f691f-image.png" alt="img"></p><p><strong>第 3 轮（虽然实际上已经有序，但是流程并没有结束）</strong>在鸡尾酒排序的第3轮，需要重新从左向右比较并进行交换。</p><p><strong>这就是鸡尾酒排序的思路。排序过程就像钟摆一样，第1轮从左到右，第 2 轮从右到左，第 3 轮再从左到右……</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length/<span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有序标记，每一轮的初始值都是true</span></span><br><span class="line">        <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//奇数轮，从左向右比较和交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;array.length-i-<span class="number">1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//有元素交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在偶数轮之前，将isSorted重新标记为true</span></span><br><span class="line">        isSorted = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//偶数轮，从右向左比较和交换</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=array.length-i-<span class="number">1</span>; j&gt;i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j] &lt; array[j-<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = array[j];</span><br><span class="line">                array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                array[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                <span class="comment">//因为有元素进行交换，所以不是有序的，标记变为false</span></span><br><span class="line">                isSorted = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isSorted)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    sort(array);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是鸡尾酒排序的原始实现。代码外层的大循环控制着所有排序回合，大循环内包含 2 个小循环，第 1 个小循环从左向右比较并交换元素，第 2 个小循环从右向左比较并交换元素。</p><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>同冒泡排序一样，快速排序也属于 交换排序，通过元素之间的比较和交换位置来达到排序的目的。</p><p>不同的是，冒泡排序在每一轮中只把 1 个元素冒泡到数列的一端，而快速排序则 <strong>在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/5736c868108b6e9d183759eb620905e71f289e745d50a6a7147ef0434c8effe4-image.png" alt="img"></p><p>这种思路就叫作分治法。</p><p>每次把数列分成两部分，究竟有什么好处呢？</p><p>假如给出一个 8 个元素的数列，一般情况下，使用冒泡排序需要比较 7 轮，每一轮把 1 个元素移动到数列的一端，时间复杂度是 O(n^2)。</p><p>而快速排序的流程是什么样子呢？</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e422a4ef386acd9c816625ffef539ecdaaf56c31700e12fffb184515f79634f8-image.png" alt="img"></p><p>如图所示，在分治法的思想下，原数列在每一轮都被拆分成两部分，每一部分在下一轮又分别被拆分成两部分，直到不可再分为止。</p><p>每一轮的比较和交换，需要把数组全部元素都遍历一遍，时间复杂度是 O(n)。这样的遍历一共需要多少轮呢？假如元素个数是 n，那么平均情况下需要 nlog n 轮，因此快速排序算法总体的平均时间复杂度是 O(n log n)。</p><p><strong>基准元素的选择</strong></p><p>基准元素，英文是 pivot，在分治过程中，以基准元素为中心，把其他元素移动到它的左右两边。</p><p>那么如何选择基准元素呢？</p><p>最简单的方式是选择数列的第 1 个元素。</p><p>这种选择在绝大多数情况下是没有问题的。但是，假如有一个原本逆序的数列，期望排序成顺序数列，那么会出现什么情况呢？</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/7b0909cf096fed67893c48c766adf99e386d41ee8adc9c7a08f749fd13ba6d47-image.png" alt="img"></p><p>那么，该怎么避免这种情况发生呢？</p><p>其实很简单，我们可以 <strong>随机选择一个元素作为基准元素</strong>，并且让基准元素和数列首元素交换位置。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/2def91a2981c50c627d63a0db237d033f9895f5e544572374bd83d4288be0d8f-image.png" alt="img"></p><p>这样一来，即使在数列完全逆序的情况下，也可以有效地将数列分成两部分。</p><p>当然，即使是随机选择基准元素，也会有极小的几率选到数列的最大值或最小值，同样会影响分治的效果。</p><p>所以，虽然快速排序的平均时间复杂度是 O(n\ \textit{log} \ n)O(n log n)，但最坏情况下的时间复杂度是 O(n^2)。</p><p><strong>元素的交换</strong></p><p>选定了基准元素以后，我们要做的就是把其他元素中小于基准元素的都交换到基准元素一边，大于基准元素的都交换到基准元素另一边。</p><p>具体如何实现呢？有两种方法。</p><p>双边循环法。<br>单边循环法。</p><p>何谓<code>双边循环法</code>？下面来看一看详细过程。</p><p>给出原始数列如下，要求对其从小到大进行排序。</p><p>首先，选定基准元素 pivot，并且设置两个指针 left 和 right，指向数列的最左和最右两个元素。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/38d88302ae7b345b733b6f67920a95fe62eb866336aa09eeacb8f59fc4935ed0-image.png" alt="img"></p><p>接下来进行 第 1 次循环，从 right 指针开始，让指针所指向的元素和基准元素做比较。如果 大于或等于 pivot，则指针向 左 移动；如果 小于pivot，则 right 指针停止移动，切换到 left 指针。</p><p>在当前数列中，1 &lt; 4，所以 right 直接停止移动，换到 left 指针，进行下一步行动。</p><p>轮到 left 指针行动，让指针所指向的元素和基准元素做比较。如果 小于或等于 pivot，则指针向 右 移动；如果 大于 pivot，则 left 指针停止移动。</p><p>由于 left 开始指向的是基准元素，判断肯定相等，所以 left 右移 1 位。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/0ba774f240df37a3cb972e63c4130c6a6de485293170f0fc884237851994e899-image.png" alt="img"></p><p>由于 <code>7 &gt; 4</code>，<code>left</code> 指针在元素 7 的位置停下。这时，让 <code>left</code> 和 <code>right</code> 指针所指向的元素进行交换。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1b907951020ac200e7ba34647d47c8f12615b241cdf1b47cb59fa07dd2beb836-image.png" alt="img"></p><p>接下来，进入第 2 次循环，重新切换到 <code>right</code> 指针，向左移动。<code>right</code> 指针先移动到 <code>8</code>，<code>8 &gt; 4</code>，继续左移。由于 <code>2 &lt; 4</code>，停止在 <code>2</code> 的位置。</p><p>按照这个思路，后续步骤如图所示。<img src="http://rto3hzle5.hd-bkt.clouddn.com/845ef3e72b1bc5181aae35f5f0c965e4a49117f767a85c9fa2cbce84e8cc46dd-image.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/f45c3b84ca308f42b34434d5ee57902b0a09c1adf9d6584f03e4df737da19bca-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分治（双边循环法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待交换的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endIndex 结束下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> left = startIndex;</span><br><span class="line">    <span class="keyword">int</span> right = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( left != right) &#123;</span><br><span class="line">        <span class="comment">//控制right指针比较并左移</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; arr[right] &gt; pivot)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//控制left指针比较并右移</span></span><br><span class="line">        <span class="keyword">while</span>( left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//交换left和right指针所指向的元素</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pivot和指针重合点交换</span></span><br><span class="line">    arr[startIndex] = arr[left];</span><br><span class="line">    arr[left] = pivot;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，quickSort 方法通过递归的方式，实现了分而治之的思想。</p><p>partition 方法则实现了元素的交换，让数列中的元素依据自身大小，分别交换到基准元素的左右两边。在这里，我们使用的交换方式是双边循环法。</p><p><strong>单边循环法</strong></p><p>双边循环法从数组的两边交替遍历元素，虽然更加直观，但是代码实现相对烦琐。而单边循环法则简单得多，只从数组的一边对元素进行遍历和交换。我们来看一看详细过程。</p><p>开始和双边循环法相似，首先选定基准元素 pivot。同时，设置一个 mmark 指针指向数列起始位置，这个 mark 指针代表小于基准元素的区域边界。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/244fe589cf1abbfc7f9ff4361ea21e460fd726d28e09fa0e62913847c1b6bb3e-image.png" alt="img"></p><p>接下来，从基准元素的下一个位置开始遍历数组。</p><p>如果遍历到的元素大于基准元素，就继续往后遍历。</p><p>如果遍历到的元素小于基准元素，则需要做两件事：第一，把 mark 指针右移 1 位，因为小于 pivot 的区域边界增大了 1；第二，让最新遍历到的元素和 mark 指针所在位置的元素交换位置，因为最新遍历的元素归属于小于 pivot 的区域。</p><p>首先遍历到元素 7，7 &gt; 4，所以继续遍历。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/f1e01cf864cfef5cb5f4259c0e19399d7e478f363f7a0896ccbe8726b1a62637-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件：startIndex大于或等于endIndex时</span></span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= endIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到基准元素位置</span></span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(arr, startIndex, endIndex);</span><br><span class="line">    <span class="comment">// 根据基准元素，分成两部分进行递归排序</span></span><br><span class="line">    quickSort(arr, startIndex, pivotIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, pivotIndex + <span class="number">1</span>, endIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治（单边循环法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待交换的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex 结束下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex+<span class="number">1</span>; i&lt;=endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">            mark ++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>非递归实现</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/8fb5a28d777c76225b546aaef67eb0d1ee996051ff61474f87aebdbcf4bfa5c1-image.png" alt="img"></p><p>在第 1 章介绍空间复杂度时我们曾经提到过，代码中一层一层的方法调用，本身就使用了一个方法调用栈。每次进入一个新方法，就相当于入栈；每次有方法返回，就相当于出栈。</p><p>所以，可以把原本的递归实现转化成一个栈的实现，在栈中存储每一次方法调用的参数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用一个集合栈来代替递归的函数栈</span></span><br><span class="line">    Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">// 整个数列的起止下标，以哈希的形式入栈</span></span><br><span class="line">    Map rootParam = <span class="keyword">new</span> HashMap();</span><br><span class="line">    rootParam.put(<span class="string">&quot;startIndex&quot;</span>, startIndex);</span><br><span class="line">    rootParam.put(<span class="string">&quot;endIndex&quot;</span>, endIndex);</span><br><span class="line">    quickSortStack.push(rootParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环结束条件：栈为空时</span></span><br><span class="line">    <span class="keyword">while</span> (!quickSortStack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 栈顶元素出栈，得到起止下标</span></span><br><span class="line">        Map&lt;String, Integer&gt; param = quickSortStack.pop();</span><br><span class="line">        <span class="comment">// 得到基准元素位置</span></span><br><span class="line">        <span class="keyword">int</span> pivotIndex = partition(arr, param.get(<span class="string">&quot;startIndex&quot;</span>), param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">        <span class="comment">// 根据基准元素分成两部分, 把每一部分的起止下标入栈</span></span><br><span class="line">        <span class="keyword">if</span>(param.get(<span class="string">&quot;startIndex&quot;</span>) &lt; pivotIndex -<span class="number">1</span>)&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; leftParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            leftParam.put(<span class="string">&quot;startIndex&quot;</span>, param.get(<span class="string">&quot;startIndex&quot;</span>));</span><br><span class="line">            leftParam.put(<span class="string">&quot;endIndex&quot;</span>, pivotIndex-<span class="number">1</span>);</span><br><span class="line">            quickSortStack.push(leftParam);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pivotIndex + <span class="number">1</span> &lt; param.get(<span class="string">&quot;endIndex&quot;</span>))&#123;</span><br><span class="line">            Map&lt;String, Integer&gt; rightParam = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">            rightParam.put(<span class="string">&quot;startIndex&quot;</span>, pivotIndex + <span class="number">1</span>);</span><br><span class="line">            rightParam.put(<span class="string">&quot;endIndex&quot;</span>, param.get(<span class="string">&quot;endIndex&quot;</span>));</span><br><span class="line">            quickSortStack.push(rightParam);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分治（单边循环法）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待交换的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始下标</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> endIndex 结束下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 取第1个位置（也可以选择随机位置）的元素作为基准元素</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[startIndex];</span><br><span class="line">    <span class="keyword">int</span> mark = startIndex;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=startIndex+<span class="number">1</span>; i&lt;=endIndex; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;pivot)&#123;</span><br><span class="line">            mark ++;</span><br><span class="line">            <span class="keyword">int</span> p = arr[mark];</span><br><span class="line">            arr[mark] = arr[i];</span><br><span class="line">            arr[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[startIndex] = arr[mark];</span><br><span class="line">    arr[mark] = pivot;</span><br><span class="line">    <span class="keyword">return</span> mark;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和刚才的递归实现相比，非递归方式代码的变动只发生在 quickSort 方法中。该方法引入了一个存储 Map 类型元素的栈，用于存储每一次交换时的起始下标和结束下标。</p><p>每一次循环，都会让栈顶元素出栈，通过 partition 方法进行分治，并且按照基准元素的位置分成左右两部分，左右两部分再分别入栈。当栈为空时，说明排序已经完毕，退出循环。</p><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>以最大堆为例，如果删除一个最大堆的堆顶（并不是完全删除，而是跟末尾的节点交换位置），经过自我调整，第 2 大的元素就会被交换上来，成为最大堆的新堆顶。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/14acf856987e318b756b47d9432a96334a9581f668ec00e704ad52a61a511f43-image.png" alt="img"></p><p>正如上图所示，在删除值为 10 的堆顶节点后，经过调整，值为 9 的新节点就会顶替上来；在删除值为 9 的堆顶节点后，经过调整，值为 8 的新节点就会顶替上来……</p><p>由于二叉堆的这个特性，每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么只要反复删除堆顶，反复调整二叉堆，所得到的集合就会成为一个有序集合。</p><p>到此为止，原本的最大二叉堆已经变成了一个从小到大的有序集合。之前说过，二叉堆实际存储在数组中，数组中的元素排列如下。</p><p>由此，可以归纳出堆排序算法的步骤。</p><p><strong>把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。</strong><br><strong>循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * “下沉”调整</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentIndex 要“下沉”的父节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 堆的有效大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> parentIndex, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// temp保存父节点值，用于最后的赋值</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[parentIndex];</span><br><span class="line">    <span class="keyword">int</span> childIndex = <span class="number">2</span> * parentIndex + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (childIndex &lt; length) &#123;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (childIndex + <span class="number">1</span> &lt; length &amp;&amp; array[childIndex + <span class="number">1</span>] &gt; array[childIndex]) &#123;</span><br><span class="line">            childIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= array[childIndex])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//无须真正交换，单向赋值即可</span></span><br><span class="line">        array[parentIndex] = array[childIndex];</span><br><span class="line">        parentIndex = childIndex;</span><br><span class="line">        childIndex = <span class="number">2</span> * childIndex + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[parentIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序（升序）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array 待调整的堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1.把无序数组构建成最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (array.length-<span class="number">2</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        downAdjust(array, i, array.length);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    <span class="comment">// 2.循环删除堆顶元素，移到集合尾部，调整堆产生新的堆顶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 最后1个元素和第1个元素进行交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = temp;</span><br><span class="line">        <span class="comment">// “下沉”调整最大堆</span></span><br><span class="line">        downAdjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    heapSort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/e69e3c6d4a03488e9a6bdb0ad5a89d0ca7a265fd3691b5b43c9cb5e6c5c287ea-image.png" alt="img"></p><p>二叉堆的节点「下沉」调整（downAdjust 方法）是堆排序算法的基础，这个调节操作本身的时间复杂度在上一章讲过，是 O(log n)。</p><p>我们再来回顾一下堆排序算法的步骤。</p><p>把无序数组构建成二叉堆。<br>循环删除堆顶元素，并将该元素移到集合尾部，调整堆产生新的堆顶。<br>第 1 步，把无序数组构建成二叉堆，这一步的时间复杂度是 O(n)O(n)。<br>第 2 步，需要进行 n - 1 次循环。每次循环调用一次 downAdjust 方法，所以第 2 步的计算规模是 (n−1)×log n ，时间复杂度为 O(n log n)。</p><p>两个步骤是并列关系，所以整体的时间复杂度是 O(n log n)。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c5aa2c35d580454d884e4f398b1446f4f1de9ce1aa9d6b08bff6ebef25b394b2-image.png" alt="img"></p><hr><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>不基于元素比较，而是利用数组下标来确定元素的正确位置。</p><p>假设数组中有 20 个随机整数，取值范围为 0 ～ 10，要求用最快的速度把这 20 个整数从小到大进行排序。</p><p>如何给这些无序的随机整数进行排序呢？</p><p>考虑到这些整数只能够在 0、1、2、3、4、5、6、7、8、9、10 这 11 个数中取值，取值范围有限。所以，可以根据这有限的范围，建立一个长度为 11 的数组。数组下标从 0 到 10，元素初始值全为 0。</p><p>假设 20 个随机整数的值如下所示。</p><p>9，3，5，4，9，1，2，7，8，1，3，6，5，3，4，0，10，9 ，7，9</p><p>下面就开始遍历这个无序的随机数列，每一个整数按照其值对号入座，同时，对应数组下标的元素进行加 1 操作。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/8d697731fbcdcaef14370f7a917e5814166ad7f99342d8b75dc61909cadd178b-image.png" alt="img"></p><p>有了这个统计结果，排序就很简单了。直接遍历数组，输出数组元素的下标值，元素的值是几，就输出几次。</p><p>0，1，1，2，3，3，3，4，4，5，5，6，7，7，8，9，9，9，9，10<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/83d7c9f2a2d8078a39c3f516427eb822b53646f19a41a3c07709b09dec0a47fd-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">//1.得到数列的最大值</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max)&#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.根据数列最大值确定统计数组的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//3.遍历数列，填充统计数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++)&#123;</span><br><span class="line">        countArray[array[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.遍历统计数组，输出结果</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;countArray.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;countArray[i]; j++)&#123;</span><br><span class="line">            sortedArray[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1d60e757d2b730ca10f98a119898cce818ff032d817fa0ee34273f9abc5dfe64-image.png" alt="img"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] countSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">    <span class="comment">//1.得到数列的最大值和最小值，并算出差值d</span></span><br><span class="line">    <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = max - min;</span><br><span class="line">    <span class="comment">//2.创建统计数组并统计对应元素的个数</span></span><br><span class="line">    <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[d+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">        countArray[array[i]-min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.统计数组做变形，后面的元素等于前面的元素之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;countArray.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">        countArray[i] += countArray[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.倒序遍历原始数列，从统计数组找到正确位置，输出到结果数组</span></span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        sortedArray[countArray[array[i]-min]-<span class="number">1</span>]=array[i];</span><br><span class="line">        countArray[array[i]-min]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">95</span>,<span class="number">94</span>,<span class="number">91</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">90</span>,<span class="number">99</span>,<span class="number">93</span>,<span class="number">91</span>,<span class="number">92</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] sortedArray = countSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/a771193519b38732ac818d50dcbad94966fdf96f05974b19b9409e9920afde98-image.png" alt="img"></p><p>1．当数列最大和最小值差距过大时，并不适合用计数排序。</p><p>例如给出 20 个随机整数，范围在 0 到 1 亿之间，这时如果使用计数排序，需要创建长度为 1 亿的数组。不但严重浪费空间，而且时间复杂度也会随之升高。</p><p>2．当数列元素不是整数时，也不适合用计数排序。</p><p>如果数列中的元素都是小数，如 25.213，或 0.00 000 001 这样的数字，则无法创建对应的统计数组。这样显然无法进行计数排序。</p><hr><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/86792b11a716df7aeee06b04c41311b4ffb7f067829eccfdbd2276001f6b87ba-image.png" alt="img"></p><p>那么，桶排序中所谓的「桶」，又是什么呢？</p><p>每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素。</p><p>假设有一个非整数数列如下：</p><p>4.5，0.84，3.25，2.18，0.5</p><p>让我们来看看桶排序的工作原理。</p><p>桶排序的第 1 步，就是创建这些桶，并确定每一个桶的区间范围。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/5450720558e4bd32f9b856826eed965ece3b570b0e60426af8fcccf2631f0626-image.png" alt="img"></p><p>具体需要建立多少个桶，如何确定桶的区间范围，有很多种不同的方式。我们这里创建的桶数量等于原始数列的元素数量，除最后一个桶只包含数列最大值外，前面各个桶的区间按照比例来确定。</p><p>区间跨度 = （最大值-最小值）/ （桶的数量 - 1）</p><p>第 2 步，遍历原始数列，把元素对号入座放入各个桶中。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/a6abd25b80165df9664f0d53e09352af2f4282b7c03c86e85695344ee8fa583e-image.png" alt="img"></p><p>第 3 步，对每个桶内部的元素分别进行排序（显然，只有第 1 个桶需要排序）。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/007d88007ef69a9adb618c4e0974b762996c56ebef177c994bf21559b739801a-image.png" alt="img"></p><p>第 4 步，遍历所有的桶，输出所有元素。</p><p>0.5，0.84，2.18，3.25，4.5</p><p>到此为止，排序结束。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] bucketSort(<span class="keyword">double</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.得到数列的最大值和最小值，并算出差值d</span></span><br><span class="line">    <span class="keyword">double</span> max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> min = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &gt; max) &#123;</span><br><span class="line">            max = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> d = max - min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.初始化桶</span></span><br><span class="line">    <span class="keyword">int</span> bucketNum = array.length;</span><br><span class="line">    ArrayList&lt;LinkedList&lt;Double&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;LinkedList&lt;Double&gt;&gt;(bucketNum);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">        bucketList.add(<span class="keyword">new</span> LinkedList&lt;Double&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.遍历原始数组，将每个元素放入桶中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="keyword">int</span>)((array[i] - min) * (bucketNum-<span class="number">1</span>) / d);</span><br><span class="line">        bucketList.get(num).add(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对每个桶内部进行排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketList.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//JDK底层采用了归并排序或归并的优化版本</span></span><br><span class="line">        Collections.sort(bucketList.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.输出全部元素</span></span><br><span class="line">    <span class="keyword">double</span>[] sortedArray = <span class="keyword">new</span> <span class="keyword">double</span>[array.length];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LinkedList&lt;Double&gt; list : bucketList)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">double</span> element : list)&#123;</span><br><span class="line">            sortedArray[index] = element;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortedArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[] array = <span class="keyword">new</span> <span class="keyword">double</span>[] &#123;<span class="number">4.12</span>,<span class="number">6.421</span>,<span class="number">0.0023</span>,<span class="number">3.0</span>,<span class="number">2.123</span>,<span class="number">8.122</span>,<span class="number">4.12</span>, <span class="number">10.09</span>&#125;;</span><br><span class="line">    <span class="keyword">double</span>[] sortedArray = bucketSort(array);</span><br><span class="line">    System.out.println(Arrays.toString(sortedArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，所有的桶都保存在 ArrayList 集合中，每一个桶都被定义成一个链表（LinkedList<Double>），这样便于在尾部插入元素。</p><p>同时，上述代码使用了 JDK 的集合工具类 Collections.sort 来为桶内部的元素进行排序。Collections.sort 底层采用的是归并排序或 Timsort，各位读者可以简单地把它们当作一种时间复杂度为 O(n log n) 的排序。</p><p>假设原始数列有 n 个元素，分成 n 个桶。</p><p>下面逐步来分析一下算法复杂度。</p><p>第 1 步，求数列最大、最小值，运算量为 n。</p><p>第 2 步，创建空桶，运算量为 n。</p><p>第 3 步，把原始数列的元素分配到各个桶中，运算量为 n。</p><p>第 4 步，在每个桶内部做排序，在元素分布相对均匀的情况下，所有桶的运算量之和为 n。</p><p>第 5 步，输出排序数列，运算量为 n。</p><p>因此，桶排序的总体时间复杂度为 O(n)。</p><p>至于空间复杂度就很容易得到了，同样是 O(n)。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/18abb46becb47a9169e4281e3675ac92a39a9faab5e2ccf50f4b649d2e3cd406-image.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="2021/07/26/blog23-hashtable/"/>
      <url>2021/07/26/blog23-hashtable/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>哈希表</code>是一种使用<code>哈希函数</code>组织数据，以支持快速插入和搜索的数据结构。</p><p>有两种不同类型的哈希表：哈希集合和哈希映射。</p><ul><li>哈希集合是集合数据结构的实现之一，用于存储非重复值。</li><li>哈希映射是映射 数据结构的实现之一，用于存储(key, value)键值对。</li></ul><p>在标准模板库的帮助下，哈希表是易于使用的。大多数常见语言（如Java，C ++ 和 Python）都支持哈希集合和哈希映射。</p><p>通过选择合适的哈希函数，哈希表可以在插入和搜索方面实现出色的性能。</p><p>在本 LeetBook 中，我们将回答以下问题：</p><p>哈希表的 <code>原理</code> 是什么？<br>如何 <code>设计</code> 哈希表？<br>如何使用 <code>哈希集</code> 来解决与重复相关的问题？<br>如何使用 <code>哈希映射</code> 按键聚合信息？<br>如何在使用哈希表时 <code>设计正确的键</code> ？</p><hr><h1 id="哈希表的原理"><a href="#哈希表的原理" class="headerlink" title="哈希表的原理"></a>哈希表的原理</h1><p>正如我们在介绍中提到的，<code>哈希表</code>是一种数据结构，它使用哈希函数组织数据，以支持<code>快速插入和搜索</code>。在本文中，我们将简要说明哈希表的原理。</p><p>哈希表的原理<br>哈希表的关键思想是使用哈希函数<code>将键映射到存储桶</code>。更确切地说，</p><ol><li>当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中；</li><li>当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。</li></ol><p>示例</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210726161917608.png" alt="image-20210726161917608"></p><p>在示例中，我们使用 <code>y = x ％ 5</code> 作为哈希函数。让我们使用这个例子来完成插入和搜索策略：</p><ol><li><p>插入：我们通过哈希函数解析键，将它们映射到相应的桶中。</p><ul><li>例如，1987 分配给桶 2，而 24 分配给桶 4。</li></ul></li><li><p>搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索。</p><ul><li><p>如果我们搜索 1987，我们将使用相同的哈希函数将1987 映射到 2。因此我们在桶 2 中搜索，我们在那个桶中成功找到了 1987。</p></li><li><p>例如，如果我们搜索 23，将映射 23 到 3，并在桶 3 中搜索。我们发现 23 不在桶 3 中，这意味着 23 不在哈希表中。</p></li></ul></li></ol><hr><h1 id="设计哈希表的关键"><a href="#设计哈希表的关键" class="headerlink" title="设计哈希表的关键"></a>设计哈希表的关键</h1><p>在设计哈希表时，你应该注意两个基本因素。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数是哈希表中最重要的组件，该哈希表用于将键映射到特定的桶。在上一篇文章中的示例中，我们使用 y = x % 5 作为散列函数，其中 x 是键值，y 是分配的桶的索引。</p><p>散列函数将取决于<code>键值的范围</code>和桶的数量。</p><p>下面是一些哈希函数的示例：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/screen-shot-2018-05-04-at-145454.png" alt="img"></p><p>哈希函数的设计是一个开放的问题。其思想是尽可能将键分配到桶中，理想情况下，完美的哈希函数将是键和桶之间的一对一映射。然而，在大多数情况下，哈希函数并不完美，它需要在桶的数量和桶的容量之间进行权衡。</p><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h2><p>理想情况下，如果我们的哈希函数是完美的一对一映射，我们将不需要处理冲突。不幸的是，在大多数情况下，冲突几乎是不可避免的。例如，在我们之前的哈希函数（y  =  x ％ 5）中，1987 和 2 都分配给了桶 2，这是一个冲突。</p><p>冲突解决算法应该解决以下几个问题：</p><ol><li>如何组织在同一个桶中的值？</li><li>如果为同一个桶分配了太多的值，该怎么办？</li><li>如何在特定的桶中搜索目标值？</li></ol><p>根据我们的哈希函数，这些问题与<code>桶的容量</code>和可能映射到<code>同一个桶</code>的<code>键的数目</code>有关。</p><p>让我们假设存储最大键数的桶有 N 个键。</p><p>通常，如果 N 是常数且很小，我们可以简单地使用一个数组将键存储在同一个桶中。如果 N 是可变的或很大，我们可能需要使用高度平衡的二叉树来代替.。</p><h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><p>到目前为止，您应该能够实现基本的哈希表。我们为您提供了实现哈希集和哈希映射的练习。阅读需求，确定哈希函数并在需要时解决冲突。</p><p>如果你不熟悉哈希集或是哈希映射的概念，可以返回介绍部分找出答案。</p><p>插入和搜索是哈希表中的两个基本操作。</p><p>此外，还有基于这两个操作的操作。例如，当我们删除元素时，我们将首先搜索元素，然后在元素存在的情况下从相应位置移除元素。</p><hr><h1 id="设计哈希集合"><a href="#设计哈希集合" class="headerlink" title="设计哈希集合"></a>设计哈希集合</h1><p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p><p>实现 <code>MyHashSet</code> 类：</p><p><code>void add(key)</code> 向哈希集合中插入值 key 。<br><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 key 。<br><code>void remove(key)</code> 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]</span><br><span class="line">[[], [1], [2], [1], [3], [2], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, true, false, null, true, null, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashSet myHashSet &#x3D; new MyHashSet();</span><br><span class="line">myHashSet.add(1);      &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(1); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.contains(3); &#x2F;&#x2F; 返回 False ，（未找到）</span><br><span class="line">myHashSet.add(2);      &#x2F;&#x2F; set &#x3D; [1, 2]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 True</span><br><span class="line">myHashSet.remove(2);   &#x2F;&#x2F; set &#x3D; [1]</span><br><span class="line">myHashSet.contains(2); &#x2F;&#x2F; 返回 False ，（已移除）</span><br></pre></td></tr></table></figure><p><strong>模板：</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashSet* obj = new MyHashSet();</span></span><br><span class="line"><span class="comment"> * obj-&gt;add(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;remove(key);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;contains(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>题解：</strong></p><p><strong>链地址法:</strong></p><p>设哈希表的大小为base，则可以设计一个简单的哈希函数：hash(x)=x mod base。</p><p>我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。</p><p>由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将base 取为一个质数。在这里，我们取 base=769。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730182641745.png" alt="image-20210730182641745"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T705.设计哈希集合</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashSet</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashSet(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns true if this set contains the specified element */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it) == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n/b)。其中 n 为哈希表中的元素数量，b 为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为n/b 。</p><p>空间复杂度：O(n+b)。</p><p>如果总共有 M 个键，那么在使用哈希表时，可以很容易地达到 O(M) 的空间复杂度。</p><p>但是，你可能已经注意到哈希表的时间复杂度与设计有很强的关系。</p><p>我们中的大多数人可能已经在每个桶中使用数组来将值存储在同一个桶中，理想情况下，桶的大小足够小时，可以看作是一个常数。插入和搜索的时间复杂度都是 O(1)。</p><p>但在最坏的情况下，桶大小的最大值将为 N。插入时时间复杂度为 O(1)，搜索时为 O(N)。</p><h3 id="内置哈希表的原理"><a href="#内置哈希表的原理" class="headerlink" title="内置哈希表的原理"></a>内置哈希表的原理</h3><p>内置哈希表的典型设计是：</p><ol><li>键值可以是任何可哈希化的类型。并且属于可哈希类型的值将具有哈希码。此哈希码将用于映射函数以获取存储区索引。</li><li>每个桶包含一个数组，用于在初始时将所有值存储在同一个桶中。</li><li>如果在同一个桶中有太多的值，这些值将被保留在一个高度平衡的二叉树搜索树中。</li></ol><p>插入和搜索的平均时间复杂度仍为 O(1)。最坏情况下插入和搜索的时间复杂度是 O(logN)，使用高度平衡的 BST。这是在插入和搜索之间的一种权衡。</p><hr><h1 id="设计哈希映射"><a href="#设计哈希映射" class="headerlink" title="设计哈希映射"></a>设计哈希映射</h1><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 MyHashMap 类：</p><ul><li>MyHashMap() 用空映射初始化对象</li><li>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。</li><li>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。</li><li>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T706.设计哈希映射</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">list</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> base = <span class="number">769</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key % base;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    MyHashMap(): data(base) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                (*it).second = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        data[h].push_back(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> (*it).second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = data[h].begin(); it != data[h].end(); it++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).first == key) &#123;</span><br><span class="line">                data[h].erase(it);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(n/b)。其中 n 为哈希表中的元素数量，b 为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为n/b 。</p><p>空间复杂度：O(n+b)。</p><hr><h1 id="实际应用-哈希集-用法"><a href="#实际应用-哈希集-用法" class="headerlink" title="实际应用 - 哈希集 - 用法"></a>实际应用 - 哈希集 - 用法</h1><p><code>哈希集</code>是集合的实现之一，它是一种存储<code>不重复值</code>的数据结构。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;                // 0. include the library</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. initialize a hash set</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hashset;   </span><br><span class="line">    <span class="comment">// 2. insert a new key</span></span><br><span class="line">    hashset.insert(<span class="number">3</span>);</span><br><span class="line">    hashset.insert(<span class="number">2</span>);</span><br><span class="line">    hashset.insert(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 3. delete a key</span></span><br><span class="line">    hashset.erase(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 4. check if the key is in the hash set</span></span><br><span class="line">    <span class="keyword">if</span> (hashset.count(<span class="number">2</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Key 2 is not in the hash set.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. get the size of the hash set</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The size of hash set is: &quot;</span> &lt;&lt; hashset.size() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 6. iterate the hash set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = hashset.begin(); it != hashset.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;are in the hash set.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 7. clear the hash set</span></span><br><span class="line">    hashset.clear();</span><br><span class="line">    <span class="comment">// 8. check if the hash set is empty</span></span><br><span class="line">    <span class="keyword">if</span> (hashset.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hash set is empty now!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用哈希集查重"><a href="#使用哈希集查重" class="headerlink" title="使用哈希集查重"></a>使用哈希集查重</h1><p>我们知道，插入新值并检查值是否在哈希集中是简单有效的。</p><p>因此，通常，使用哈希集来检查该值是否已经出现过。</p><p>让我们来看一个例子：</p><p>给定一个整数数组，查找数组是否包含任何重复项。</p><p>这是一个典型的问题，可以通过哈希集来解决。</p><p>你可以简单地迭代每个值并将值插入集合中。 如果值已经在哈希集中，则存在重复。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Template for using hash set to find duplicates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;Type&gt;&amp; keys)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Replace Type with actual type of your key</span></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;Type&gt; hashset;</span><br><span class="line">    <span class="keyword">for</span> (Type key : keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashset.count(key) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hashset.insert(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="实践-存在重复元素"><a href="#实践-存在重复元素" class="headerlink" title="实践 - 存在重复元素"></a>实践 - 存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><h3 id="方法1：排序"><a href="#方法1：排序" class="headerlink" title="方法1：排序"></a>方法1：排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T217.存在重复元素</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：O(NlogN)，其中 N 为数组的长度。需要对数组进行排序。</p></li><li><p>空间复杂度：O(logN)，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。</p></li></ul><h3 id="方法2：哈希表"><a href="#方法2：哈希表" class="headerlink" title="方法2：哈希表"></a>方法2：哈希表</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T217.存在重复元素</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.find(x) != s.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.insert(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O<em>(</em>N<em>)，其中 N</em> 为数组的长度。</li><li>空间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 为数组的长度。</li></ul><hr><h1 id="实践-只存在一次的数字"><a href="#实践-只存在一次的数字" class="headerlink" title="实践 - 只存在一次的数字"></a>实践 - 只存在一次的数字</h1><p>如果不考虑时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。</p><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p><p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210726192751515.png" alt="image-20210726192751515"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210726192846604.png" alt="image-20210726192846604"></p><p>时间空间复杂度都为O(n)。</p><p>其他方法：可使用异或运算⊕。异或运算有以下三个性质。</p><p>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。<br>任何数和其自身做异或运算，结果是 0，即 a⊕a=0。<br>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210726192944479.png" alt="image-20210726192944479"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210726193035715.png" alt="image-20210726193035715"></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T136.只出现一次的数字</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="实践-两个数组的交集"><a href="#实践-两个数组的交集" class="headerlink" title="实践 - 两个数组的交集"></a>实践 - 两个数组的交集</h1><p>给定两个数组，编写一个函数来计算它们的交集。</p><p>计算两个数组的交集，直观的方法是遍历数组 nums1，对于其中的每个元素，遍历数组 nums2 判断该元素是否在数组 nums2 中，如果存在，则将该元素添加到返回值。假设数组 nums1 和 nums2 的长度分别是 m 和 n，则遍历数组 nums1 需要 O(m) 的时间，判断 nums1 中的每个元素是否在数组 nums2 中需要 O(n) 的时间，因此总时间复杂度是 O(mn)。</p><p>如果使用<code>哈希集合</code>存储元素，则可以在 O(1) 的时间内判断一个元素是否在集合中，从而降低时间复杂度。</p><p>首先使用两个集合分别存储两个数组中的元素，然后遍历较小的集合，判断其中的每个元素是否在另一个集合中，如果元素也在另一个集合中，则将该元素添加到返回值。该方法的时间复杂度可以降低到 O(m+n)。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T349.两个数组的交集</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; set1, set2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums1) &#123;</span><br><span class="line">            set1.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums2) &#123;</span><br><span class="line">            set2.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getIntersection(set1, set2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getIntersection</span><span class="params">(<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set1, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; set2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (set1.size() &gt; set2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getIntersection(set2, set1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : set1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set2.count(num)) &#123;</span><br><span class="line">                intersection.push_back(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。使用两个集合分别存储两个数组中的元素需要 O(m+n)的时间，遍历较小的集合并判断元素是否在另一个集合中需要 O(\min(m,n))O(min(m,n)) 的时间，因此总时间复杂度是 O(m+n)。</p><p>空间复杂度：O(m+n)，其中 m 和 n 分别是两个数组的长度。空间复杂度主要取决于两个集合。</p><hr><h1 id="实践-快乐数"><a href="#实践-快乐数" class="headerlink" title="实践 - 快乐数"></a>实践 - 快乐数</h1><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：</p><ul><li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li><li>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</li><li>如果 可以变为  1，那么这个数就是快乐数。</li></ul><p>如果 n 是快乐数就返回 true ；不是，则返回 false 。</p><p><strong>方法一：用哈希集合检测循环</strong><br>我们可以先举几个例子。我们从 77 开始。则下一个数字是 49，然后下一个数字是 97。我们可以不断重复该的过程，直到我们得到 11。因为我们得到了 1，我们知道 7 是一个快乐数，函数应该返回 true。</p><p>根据我们的探索，我们猜测会有以下三种可能。</p><ol><li>最终会得到 11。</li><li>最终会进入循环。</li><li>值会越来越大，最后接近无穷大。</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 11 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><div class="table-container"><table><thead><tr><th>Digits</th><th style="text-align:center">Largest</th><th style="text-align:right">Next</th></tr></thead><tbody><tr><td>1</td><td style="text-align:center">9</td><td style="text-align:right">81</td></tr><tr><td>2</td><td style="text-align:center">99</td><td style="text-align:right">162</td></tr><tr><td>3</td><td style="text-align:center">999</td><td style="text-align:right">243</td></tr><tr><td>4</td><td style="text-align:center">9999</td><td style="text-align:right">324</td></tr><tr><td>13</td><td style="text-align:center">9999999999999</td><td style="text-align:right">1053</td></tr></tbody></table></div><p>对于 33 位数的数字，它不可能大于 243243。这意味着它要么被困在 243243 以下的循环内，要么跌到 11。44 位或 44 位以上的数字在每一步都会丢失一位，直到降到 33 位为止。所以我们知道，最坏的情况下，算法可能会在 243243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 11。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p><p><strong>算法</strong></p><p>算法分为两部分，我们需要设计和编写代码。</p><ol><li>给一个数字 nn，它的下一个数字是什么？</li><li>按照一系列的数字来判断我们是否进入了一个循环。</li></ol><p>第 1 部分我们按照题目的要求做数位分离，求平方和。</p><p>第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。</p><ul><li>如果它不在哈希集合中，我们应该添加它。</li><li>如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。</li></ul><p>我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1)的时间，而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p><p><strong>复杂度分析</strong></p><p>确定这个问题的时间复杂度对于一个「简单」级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 getNext(n) 函数的时间复杂度。</p><p><code>时间复杂度</code>：.O(243⋅3+logn+loglogn+logloglogn)… = O(logn)。</p><ul><li>查找给定数字的下一个值的成本为 O(logn)，因为我们正在处理数字中的每位数字，而数字中的位数由 logn 给定。</li><li>要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。</li><li>我们在上面确定，一旦一个数字低于 243243，它就不可能回到 243 以上。因此，我们就可以用 243 以下最长循环的长度来代替 243，不过，因为常数无论如何都无关紧要，所以我们不会担心它。</li><li>对于高于 243 的 n，我们需要考虑循环中每个数高于 243 的成本。通过数学运算，我们可以证明在最坏的情况下，这些成本将是 O(logn)+O(loglogn)+O(logloglogn)…。幸运的是，O(logn) 是占主导地位的部分，而其他部分相比之下都很小（总的来说，它们的总和小于logn），所以我们可以忽略它们。</li></ul><p><code>空间复杂度</code>：O(logn)。与时间复杂度密切相关的是衡量我们放入哈希集合中的数字以及它们有多大的指标。对于足够大的 n，大部分空间将由 n 本身占用。我们可以很容易地优化到 O(243⋅3)=O(1)，方法是只保存集合中小于 243 的数字，因为对于较高的数字，无论如何都不可能返回到它们。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T202.快乐数</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 取数值各个位上的单数之和</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">set</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = getSum(n);</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.find(sum) != <span class="built_in">set</span>.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">set</span>.insert(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="哈希映射-用法"><a href="#哈希映射-用法" class="headerlink" title="哈希映射 - 用法"></a>哈希映射 - 用法</h1><p><code>哈希映射</code>是用于存储 <code>(key, value)</code> 键值对的一种实现。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;                // 0. include the library</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. initialize a hash map</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="comment">// 2. insert a new (key, value) pair</span></span><br><span class="line">    hashmap.insert(<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    hashmap.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="comment">// 3. insert a new (key, value) pair or update the value of existed key</span></span><br><span class="line">    hashmap[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    hashmap[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 4. get the value of a specific key</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;The value of key 1 is: &quot;</span> &lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 5. delete a key</span></span><br><span class="line">    hashmap.erase(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 6. check if a key is in the hash map</span></span><br><span class="line">    <span class="keyword">if</span> (hashmap.count(<span class="number">2</span>) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Key 2 is not in the hash map.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. get the size of the hash map</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;the size of hash map is: &quot;</span> &lt;&lt; hashmap.size() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="comment">// 8. iterate the hash map</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = hashmap.begin(); it != hashmap.end(); ++it) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot;) &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;are in the hash map.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 9. clear the hash map</span></span><br><span class="line">    hashmap.clear();</span><br><span class="line">    <span class="comment">// 10. check if the hash map is empty</span></span><br><span class="line">    <span class="keyword">if</span> (hashmap.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hash map is empty now!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="实践-两数之和"><a href="#实践-两数之和" class="headerlink" title="实践 - 两数之和"></a>实践 - 两数之和</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T1.两数之和</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p><p>空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。</p><hr><h1 id="实践-同构字符串"><a href="#实践-同构字符串" class="headerlink" title="实践 - 同构字符串"></a>实践 - 同构字符串</h1><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p><p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T205.同构字符串</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; s2t;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; t2s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> x = s[i], y = t[i];</span><br><span class="line">            <span class="keyword">if</span> ((s2t.count(x) &amp;&amp; s2t[x] != y) || (t2s.count(y) &amp;&amp; t2s[y] != x)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s2t[x] = y;</span><br><span class="line">            t2s[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p>时间复杂度：O(n)，其中 n 为字符串的长度。我们只需同时遍历一遍字符串 s 和 t 即可。<br>空间复杂度：O(∣Σ∣)，其中 Σ 是字符串的字符集。哈希表存储字符的空间取决于字符串的字符集大小，最坏情况下每个字符均不相同，需要 O(∣Σ∣) 的空间。</p><hr><h1 id="实践-两个列表的最小索引总和"><a href="#实践-两个列表的最小索引总和" class="headerlink" title="实践 - 两个列表的最小索引总和"></a>实践 - 两个列表的最小索引总和</h1><p>假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</p><p>你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</p><p>示例 1:</p><p>输入:<br>[“Shogun”, “Tapioca Express”, “Burger King”, “KFC”]<br>[“Piatti”, “The Grill at Torrey Pines”, “Hungry Hunter Steakhouse”, “Shogun”]<br>输出: [“Shogun”]<br>解释: 他们唯一共同喜爱的餐厅是“Shogun”。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T599.两个列表的最小索引总和</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findRestaurant</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; str1ind;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            str1ind[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; sum2strs;</span><br><span class="line">        <span class="keyword">int</span> minSum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1ind.find(list2[i]) != str1ind.end())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> curSum = i + str1ind[list2[i]];</span><br><span class="line">                <span class="keyword">if</span> (curSum &lt;= minSum)</span><br><span class="line">                &#123;</span><br><span class="line">                    minSum = curSum;</span><br><span class="line">                    sum2strs[minSum].push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum2strs[minSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><p><code>时间复杂度</code>：O(l1 ∗l2 ∗x)。list1 中的每个字符串都与 list2 中的字符串进行了比较。l_1  和 l_2  是 list1 和 list2 列表的长度，x 是字符串的平均长度。</p><p><code>空间复杂度</code>：O(l1 ∗l2 ∗x) 。最坏情况下，list1 和 list2 中所有字符串都相同，那么哈希表最大会变成 l1 ∗l2 ∗x，其中 x 是字符串的平均长度。</p><hr><h1 id="哈希表与滑动窗口"><a href="#哈希表与滑动窗口" class="headerlink" title="哈希表与滑动窗口"></a>哈希表与滑动窗口</h1><p><strong>什么是滑动窗口</strong></p><p>顾名思义，滑动窗口就是将数组或字符串中的一个分段，形象地看作一个“窗口”，通过更改“窗口”的左右边界，实现窗口的移动、缩放等操作。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730183724897.png" alt="image-20210730183724897"></p><p>如图所示，窗口的左右边界使用 i, j 实现，当两个指针同时向右移动，则为窗口的“滑动”操作；而当其中一个指针不动，另一个指针向右移动时，窗口会扩大或缩小。</p><p>需要注意的是，一般情况下，在实际题目中指针只会沿 一个方向 移动。</p><p>对于基本情况，滑动窗口使用双指针即可实现，但是有时会出现一些问题，假如如窗口中的元素为 “(aaaaaabc)”，左右边界指针分别为 i 和 j，如果我们想要将窗口变为 “(abc)”，可以选择将左边界指针 i 向右移动 5 步。</p><p>以上情况会造成时间的浪费，假如建立元素 a 为键，下标为值的哈希表 {“a”:5}，那么元素 a 只需 1 步即可“跳跃”到下标 5 的位置。</p><p>优化运行时间，是滑动窗口问题中使用哈希表的一个目的。除此之外，哈希表还被用来统计窗口中的元素个数，以判断当前窗口的状态是否满足条件。以下是滑动窗口类题目的总结：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730183821382.png" alt="image-20210730183821382"></p><h3 id="例题1：存在重复元素-II（T219）"><a href="#例题1：存在重复元素-II（T219）" class="headerlink" title="例题1：存在重复元素 II（T219）"></a>例题1：存在重复元素 II（T219）</h3><h3 id="例题2：替换后的最长重复字符（T424）"><a href="#例题2：替换后的最长重复字符（T424）" class="headerlink" title="例题2：替换后的最长重复字符（T424）"></a>例题2：替换后的最长重复字符（T424）</h3><h3 id="例题3：最大连续-1-的个数-III（T1004）"><a href="#例题3：最大连续-1-的个数-III（T1004）" class="headerlink" title="例题3：最大连续 1 的个数 III（T1004）"></a>例题3：最大连续 1 的个数 III（T1004）</h3><h3 id="例题4：至多包含两个不同字符的最长子串（T159）"><a href="#例题4：至多包含两个不同字符的最长子串（T159）" class="headerlink" title="例题4：至多包含两个不同字符的最长子串（T159）"></a>例题4：至多包含两个不同字符的最长子串（T159）</h3><hr><h1 id="设计键"><a href="#设计键" class="headerlink" title="设计键"></a>设计键</h1><p>在前面的问题中，我们主要考虑了根据值的不同形式构造哈希表，而键的设计相对简单。然而在某些题目中，我们可能已经想到了哈希表的解法，但受限于 无法设计出合适的键，本章将对键的设计做出总结。</p><p>示例<br>我们来看一个例子：</p><p>给定一组字符串，将字母异位词组合在一起。</p><p>字母异位词指字母相同，但排列不同的字符串，比如 “ate” 与 “eat” 是一组字母异位词。如果单纯地把每个字符串作为键，显然没有起到任何作用。</p><p>解决方案<br>经过分析发现，同一组字母异位词中，如果按照字典序排列，得到的字符串相同，且长度相等。这时我们自然想到以 按照字典序排列后的字符串 作为键，这样就能合理区分出字母异位词了。例如对于 “ate” 和 “eat” 构造的哈希表为 {“aet”:[“ate”, “eat”]}。</p><p>设计键的策略可能是非常 棘手的，接下来我们将提供一些习题，并对键的设计技巧做出总结。</p><h3 id="例题1：字母异位词分组（T49）"><a href="#例题1：字母异位词分组（T49）" class="headerlink" title="例题1：字母异位词分组（T49）"></a>例题1：字母异位词分组（T49）</h3><h3 id="例题2：移位字符串分组（T249）"><a href="#例题2：移位字符串分组（T249）" class="headerlink" title="例题2：移位字符串分组（T249）"></a>例题2：移位字符串分组（T249）</h3><h3 id="例题3：有效的数独（T36）"><a href="#例题3：有效的数独（T36）" class="headerlink" title="例题3：有效的数独（T36）"></a>例题3：有效的数独（T36）</h3><h3 id="例题4：寻找重复的子树（T652）"><a href="#例题4：寻找重复的子树（T652）" class="headerlink" title="例题4：寻找重复的子树（T652）"></a>例题4：寻找重复的子树（T652）</h3><h3 id="例题5：稀疏矩阵的乘法（T311）"><a href="#例题5：稀疏矩阵的乘法（T311）" class="headerlink" title="例题5：稀疏矩阵的乘法（T311）"></a>例题5：稀疏矩阵的乘法（T311）</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以下是一些关于设计键的方法总结，我们鼓励你根据以下思路及做题经验，做出自己的总结。</p><ol><li><p>当字符串 / 数组中每个元素的顺序不重要时，可以使用 排序后的字符串 / 数组 作为键。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730185259148.png" alt="image-20210730185259148"></p></li><li><p>如果只关心每个值的偏移量，通常是第一个值的偏移量，则可以使用偏移量作为键。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730185310947.png" alt="image-20210730185310947"></p></li><li><p>在树的题目中，可以直接使用 TreeNode 作为键。但在大多数情况下，可以将 子树的序列化结果 作为键。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730185331707.png" alt="image-20210730185331707"></p></li><li><p>在矩阵中，你可能会使用 行索引 或 列索引 作为键。</p></li><li><p>如果需要将矩阵分块，可以将行索引和列索引进行组合以标识该元素属于哪个 块。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730185353106.png" alt="image-20210730185353106"></p></li><li><p>有时，在矩阵中，你可能会希望将对角线的元素组合在一起。</p></li></ol><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730185402638.png" alt="image-20210730185402638"></p><hr><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210730185528833.png" alt="image-20210730185528833"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 哈希表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode刷题之路的一些记录</title>
      <link href="2021/07/26/blog24-leetcode/"/>
      <url>2021/07/26/blog24-leetcode/</url>
      
        <content type="html"><![CDATA[<hr><p>lower_bound使用</p><p>在 非递减序列中 找到 第一个大于或者等于 某个元素的位置，如果找得到，返回相应的迭代器，否则，返回范围中的尾迭代器。</p><p>使用示例</p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pos = lower_bound(d.begin(), d.end(), nums[i]) - d.begin();</span><br><span class="line">d[pos] = nums[i];</span><br></pre></td></tr></table></figure><hr><p>自定义优先队列</p><hr><p><a href="https://leetcode.cn/submissions/detail/326788137/">https://leetcode.cn/submissions/detail/326788137/</a></p><p>自定义sort方法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(envelopes.begin(), envelopes.end(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e1, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e2) &#123;</span><br><span class="line">    <span class="keyword">return</span> e1[<span class="number">0</span>] &lt; e2[<span class="number">0</span>] || (e1[<span class="number">0</span>] == e2[<span class="number">0</span>] &amp;&amp; e1[<span class="number">1</span>] &gt; e2[<span class="number">1</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-第-1-号问题：两数之和（暴力解、哈希表）"><a href="#LeetCode-第-1-号问题：两数之和（暴力解、哈希表）" class="headerlink" title="LeetCode 第 1 号问题：两数之和（暴力解、哈希表）"></a>LeetCode 第 1 号问题：两数之和（暴力解、哈希表）</h1><h2 id="c-vector"><a href="#c-vector" class="headerlink" title="c++ vector"></a>c++ vector</h2><ul><li><p>vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector 是C++ STL的一个重要成员，使用它时需要包含头文件：</p><p><code>#include&lt;vector&gt;;</code></p></li><li><p>vector 的初始化：可以有五种方式,举例说明如下：</p><p>（1） vector<int> a(10); //定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。<br>（2）vector<int> a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1<br>（3）vector<int> a(b); //用b向量来创建a向量，整体复制性赋值<br>（4）vector<int> a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素<br>（5）int b[7]={1,2,3,4,5,9,8};<br>vector<int> a(b,b+7); //从数组中获得初值<br>（6）vector<int> vec1{ 1, 2, 3, 4, 5, 6 };             //vec1内容1,2,3,4,5,6</p></li></ul><h2 id="c-for循环"><a href="#c-for循环" class="headerlink" title="c++ for循环"></a>c++ for循环</h2><ul><li>可以在初始化部分中声明变量。如for (int i = 0; ;)</li></ul><h2 id="返回vector类型"><a href="#返回vector类型" class="headerlink" title="返回vector类型"></a>返回vector类型</h2><ul><li><p>可直接return {i,j}; 或 return {,};</p></li><li><p>capacity,如果不重新分配内存,当前已经分配的可以容纳的元素的个数.<br>max_size最大的可能的元素个数.<br>size是当前元素个数<br>sizeof是vector本身的大小（sizeof(vector<int>)）<br>int len=sizeof(arr)/size(arr[0])</p></li></ul><h2 id="引用作函数参数"><a href="#引用作函数参数" class="headerlink" title="引用作函数参数"></a>引用作函数参数</h2><ul><li>vector<int>&amp; nums 引用</li></ul><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的</p><p>最初的 C++ 标准库中没有类似 hash_map 的实现，但不同实现者自己提供了非标准的 hash_map。 因为这些实现不是遵循标准编写的，所以它们在功能和性能保证方面都有细微差别。从 C++ 11 开始，hash_map 实现已被添加到标准库中。但为了防止与已开发的代码存在冲突，决定使用替代名称 unordered_map。这个名字其实更具描述性，因为它暗示了该类元素的无序性。</p><p>C++ 11标准中加入了unordered系列的容器。unordered_map记录元素的hash值，根据hash值判断元素是否相同。map相当于java中的TreeMap，unordered_map相当于HashMap。无论从查找、插入上来说，unordered_map的效率都优于hash_map，更优于map；而空间复杂度方面，hash_map最低，unordered_map次之，map最大。</p><p><strong>unordered_map与map的对比：</strong></p><p>　　存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些。</p><p>　　总结：结构体用map重载&lt;运算符，结构体用unordered_map重载==运算符。</p><p><strong>unordered_map与hash_map对比：</strong></p><p>　　unordered_map原来属于boost分支和std::tr1中，而hash_map属于非标准容器。<br>　　unordered_map感觉速度和hash_map差不多，但是支持string做key，也可以使用复杂的对象作为key。<br>　　unordered_map编译时gxx需要添加编译选项：—std=c++11</p><p><strong>unordered_map模板：</strong> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 template &lt; class Key,                                    &#x2F;&#x2F; unordered_map::key_type</span><br><span class="line">2            class T,                                      &#x2F;&#x2F; unordered_map::mapped_type</span><br><span class="line">3            class Hash &#x3D; hash&lt;Key&gt;,                       &#x2F;&#x2F; unordered_map::hasher</span><br><span class="line">4            class Pred &#x3D; equal_to&lt;Key&gt;,                   &#x2F;&#x2F; unordered_map::key_equal</span><br><span class="line">5            class Alloc &#x3D; allocator&lt; pair&lt;const Key,T&gt; &gt;  &#x2F;&#x2F; unordered_map::allocator_type</span><br><span class="line">6            &gt; class unordered_map;</span><br></pre></td></tr></table></figure><p> <strong>迭代器：</strong></p><p>unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 unordered_map&lt;Key,T&gt;::iterator it;</span><br><span class="line">2 (*it).first;             &#x2F;&#x2F; the key value (of type Key)</span><br><span class="line">3 (*it).second;            &#x2F;&#x2F; the mapped value (of type T)</span><br><span class="line">4 (*it);                   &#x2F;&#x2F; the &quot;element value&quot; (of type pair&lt;const Key,T&gt;) </span><br></pre></td></tr></table></figure><p>它的键值分别是迭代器的first和second属性。 </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 it-&gt;first;               &#x2F;&#x2F; same as (*it).first   (the key value)</span><br><span class="line">2 it-&gt;second;              &#x2F;&#x2F; same as (*it).second  (the mapped value) </span><br></pre></td></tr></table></figure><p><strong>成员函数：</strong></p><p>=================迭代器=========================<br>begin 　　返回指向容器起始位置的迭代器（iterator）<br>end 　　  返回指向容器末尾位置的迭代器<br>cbegin　  返回指向容器起始位置的常迭代器（const_iterator）<br>cend 　　 返回指向容器末尾位置的常迭代器<br>=================Capacity================<br>size  　 返回有效元素个数<br>max_size 返回 unordered_map 支持的最大元素个数<br>empty     判断是否为空<br>=================元素访问=================<br>operator[]  　  访问元素<br>at  　 　　　访问元素<br>=================元素修改=================<br>insert 　　插入元素<br>erase　　 删除元素<br>swap 　　 交换内容<br>clear　　  清空内容<br>emplace 　构造及插入一个元素<br>emplace_hint 按提示构造及插入一个元素<br>================操作=========================<br>find 　　　　　　通过给定主键查找元素,没找到：返回unordered_map::end<br>count 　　　　　返回匹配给定主键的元素的个数<br>equal_range 　　返回值匹配给定搜索值的元素组成的范围<br>================Buckets======================<br>bucket_count 　　　返回槽（Bucket）数<br>max_bucket_count  返回最大槽数<br>bucket_size 　　　  返回槽大小<br>bucket 　　　　　　返回元素所在槽的序号<br>load_factor　　　　 返回载入因子，即一个元素槽（Bucket）的最大元素数<br>max_load_factor 　 返回或设置最大载入因子<br>rehash　　　　　　 设置槽数<br>reserve 　　　　　 请求改变容器容量</p><p><a href="https://www.cnblogs.com/langyao/p/8823092.html">https://www.cnblogs.com/langyao/p/8823092.html</a></p><hr><p>LeetCode 第 15 号问题：三数之和（排序+双指针）</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第22篇博客】李航《统计学习方法·第一章》笔记、代码、习题</title>
      <link href="2021/06/14/blog22-ML-Lihang-ch1/"/>
      <url>2021/06/14/blog22-ML-Lihang-ch1/</url>
      
        <content type="html"><![CDATA[<h1 id="CH01-统计学习及监督学习概论"><a href="#CH01-统计学习及监督学习概论" class="headerlink" title="CH01 统计学习及监督学习概论"></a>CH01 统计学习及监督学习概论</h1><p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="章节目录"><a href="#章节目录" class="headerlink" title="章节目录"></a>章节目录</h3><ol><li>统计学习</li><li>统计学习的分类<ol><li>基本分类</li><li>按模型分类</li><li>按算法分类</li><li>按技巧分类</li></ol></li><li>统计学习三要素<ol><li>模型</li><li>策略</li><li>算法</li></ol></li><li>模型评估与模型选择<ol><li>训练误差与测试误差</li><li>过拟合与模型选择</li></ol></li><li>正则化与交叉验证<ol><li>正则化</li><li>交叉验证</li></ol></li><li>泛化能力<ol><li>泛化误差</li><li>泛化误差上界</li></ol></li><li>生成模型与判别模型</li><li>监督学习应用<ol><li>分类问题</li><li>标注问题</li><li>回归问题</li></ol></li></ol><h2 id="1-1-统计学习"><a href="#1-1-统计学习" class="headerlink" title="1.1 统计学习"></a>1.1 统计学习</h2><h4 id="实现统计学习方法的步骤"><a href="#实现统计学习方法的步骤" class="headerlink" title="实现统计学习方法的步骤"></a>实现统计学习方法的步骤</h4><p>统计学习方法三要素：模型，策略，算法</p><blockquote><ol><li>得到一个有限的训练数据集合</li><li>确定包含所有可能的模型的<strong>假设空间</strong>，即学习模型的集合</li><li>确定模型选择的准则，即学习的<strong>策略</strong></li><li>实现求解最优模型的算法，即学习的<strong>算法</strong></li><li>通过学习方法选择最优的模型</li><li>利用学习的最优模型对新数据进行预测或分析</li></ol></blockquote><h2 id="1-2-统计学习分类"><a href="#1-2-统计学习分类" class="headerlink" title="1.2 统计学习分类"></a>1.2 统计学习分类</h2><h3 id="基本分类"><a href="#基本分类" class="headerlink" title="基本分类"></a>基本分类</h3><p>这部分内容新增了无监督学习和强化学习。值得注意的一个点，之前因为只写了监督学习，样本表示(x, y)对，在无监督学习里面，样本就是x。</p><h4 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h4><ul><li><p>监督学习指从标注数据中学习预测模型的机器学习问题，其本质是学习输入到输出的映射的统计规律。</p></li><li><p>输入变量<strong>X</strong>和输出变量<strong>Y</strong>有不同的类型，可以是连续或是离散的。根据输入输出变量的不同类型，对预测任务给予不同的名称：输入与输出均为连续变量的预测问题称为<strong>回归问题</strong>；输出变量为有限个离散变量的预测问题称为<strong>分类问题</strong>；输入与输出变量均为变量序列的预测问题称为<strong>标注问题</strong>。</p></li><li><p>条件概率分布 $\hat{P}(Y|X)$ 或决策函数 $Y=\hat{f}(X)$ 描述输入与输出随机变量之间的映射关系。</p><script type="math/tex; mode=display">\hat{f}</script></li></ul><h4 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h4><ul><li>无监督学习模型，即函数 $z=\hat{g}(x)$, 条件概率分布 $\hat{P}(z|x)$ 或者条件概率分布 $\hat{P}(x|z)$ 可以实现对数据的聚类、降维或概率估计。在预测过程中，预测系统对于给定的输入 $x<em>{N+1}$ ，由模型 $z</em>{N+1}=\hat{g}(x<em>{N+1})$ 或 $z</em>{N+1}=\arg\max\limits<em>{z}\hat{P}(z|x</em>{N+1})$ 给出相应的输出 $z<em>{N+1}$ 进行聚类或降维，或者由模型 $\hat{P}(x|z)$ 给出输出的概率 $\hat{P}(x</em>{N+1}|z_{N+1})$ 进行概率估计。</li></ul><h4 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h4><h3 id="按模型分类"><a href="#按模型分类" class="headerlink" title="按模型分类"></a>按模型分类</h3><ol><li><h4 id="概率模型与非概率模型（确定性模型）"><a href="#概率模型与非概率模型（确定性模型）" class="headerlink" title="概率模型与非概率模型（确定性模型）"></a>概率模型与非概率模型（确定性模型）</h4><ul><li>在监督学习中，概率模型 ${P}(y|x)$ 是生成模型，非概率模型 $y=f(x)$ 是判别模型。本书介绍的决策树、朴素贝叶斯、隐马尔科夫模型、条件随机场、概率潜在语义分析、潜在狄利克雷分配、高斯混合模型是概率模型。</li><li>在无监督学习中，概率模型取条件概率分布形式 ${P}(x|z)$ 或${P}(z|x)$ ，非概率模型取函数形式 $z=g(x)$ 。本书介绍的感知机、支持向量机、k近邻、AdaBoost、k均值、潜在语义分析、神经网络是非概率模型。Logistic回归两者都可算是。</li><li>条件概率分布和函数可以相互转化：条件概率分布最大化后得到函数，函数归一化得到条件概率分布。</li></ul></li><li><p>线性模型和非线性模型</p></li><li><p>参数化模型与非参数化模型</p></li></ol><h3 id="按算法分类"><a href="#按算法分类" class="headerlink" title="按算法分类"></a>按算法分类</h3><p>在线学习和批量学习，在线学习通常比批量学习更难。</p><h3 id="按技巧分类"><a href="#按技巧分类" class="headerlink" title="按技巧分类"></a>按技巧分类</h3><ul><li><p>贝叶斯学习</p></li><li><p>核方法（SVM、PCA、K-means）</p></li></ul><h2 id="1-3-统计学习方法三要素"><a href="#1-3-统计学习方法三要素" class="headerlink" title="1.3  统计学习方法三要素"></a>1.3  统计学习方法三要素</h2><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a><u>模型</u></h3><h4 id="模型是什么"><a href="#模型是什么" class="headerlink" title="模型是什么?"></a>模型是什么?</h4><p>在监督学习过程中，模型就是所要学习的<strong>条件概率分布</strong>或者<strong>决策函数</strong>，模型的假设空间包含所有可能的条件概率分布或者决策函数。</p><p>注意书中的这部分描述，整理了一下到表格里：</p><div class="table-container"><table><thead><tr><th></th><th>假设空间$\cal F$</th><th>输入空间$\cal X$</th><th>输出空间$\cal Y$</th><th>参数空间</th></tr></thead><tbody><tr><td>决策函数</td><td>$\cal F\it ={f_{\theta}</td><td>Y=f_{\theta}(x), \theta \in \bf R \it ^n}$</td><td>变量</td><td>变量</td><td>$\bf R\it ^n$</td></tr><tr><td>条件概率分布</td><td>$\cal F\it ={P</td><td>P_{\theta}(Y</td><td>X),\theta\in \bf R \it ^n}$</td><td>随机变量</td><td>随机变量</td><td>$\bf R\it ^n$</td></tr></tbody></table></div><p>书中描述的时候，有提到<strong>条件概率分布族</strong>，这个留一下，后面<a href="../CH06/README.md">CH06</a>有提到确认逻辑斯谛分布属于指数分布族。</p><h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a><u>策略</u></h3><h4 id="损失函数与风险函数"><a href="#损失函数与风险函数" class="headerlink" title="损失函数与风险函数"></a>损失函数与风险函数</h4><blockquote><p><strong>损失函数</strong>度量模型<strong>一次预测</strong>的好坏，<strong>风险函数</strong>度量<strong>平均意义</strong>下模型预测的好坏。</p></blockquote><ol><li><p>损失函数(loss function)或代价函数(cost function)<br>损失函数定义为给定输入$X$的<strong>预测值$f(X)$</strong>和<strong>真实值$Y$</strong>之间的<strong>非负实值</strong>函数，记作<strong>$L(Y,f(X))$</strong></p></li><li><p>风险函数(risk function)或期望损失(expected loss)<br>这个和模型的泛化误差的形式是一样的<br>$R<em>{exp}(f)=E_p[L(Y, f(X))]=\int</em>{\mathcal X\times\mathcal Y}L(y,f(x))P(x,y)\, {\rm d}x{\rm d}y$<br>模型$f(X)$关于联合分布$P(X,Y)$的<strong>平均意义下的</strong>损失(<strong>期望</strong>损失)，但是因为$P(X,Y)$是未知的，所以前面的用词是<strong>期望</strong>，以及<strong>平均意义下的</strong>。</p><p>这个表示其实就是损失的均值，反映了对整个数据的预测效果的好坏，P(x,y)$转换成$\frac {\nu(X=x, Y=y)}{N}$更容易直观理解, 可以参考<a href="../CH09/README.md">CH09</a>，6.2.2节的部分描述来理解，但是真实的数据N是无穷的。</p></li><li><p><strong>经验风险</strong>(empirical risk)或<strong>经验损失</strong>(empirical loss)<br>$R<em>{emp}(f)=\frac{1}{N}\sum^{N}</em>{i=1}L(y_i,f(x_i))$<br>模型$f$关于<strong>训练样本集</strong>的平均损失<br>根据大数定律，当样本容量N趋于无穷大时，经验风险趋于期望风险</p></li><li><p><strong>结构风险</strong>(structural risk)<br>$R<em>{srm}(f)=\frac{1}{N}\sum</em>{i=1}^{N}L(y_i,f(x_i))+\lambda J(f)$<br>$J(f)$为模型复杂度, $\lambda \geqslant 0$是系数，用以权衡经验风险和模型复杂度。</p></li></ol><h4 id="常用损失函数"><a href="#常用损失函数" class="headerlink" title="常用损失函数"></a>常用损失函数</h4><p>损失函数数值越小，模型就越好</p><ol><li>0-1损失<br>$L(Y,f(X))=\begin{cases}1, Y \neq f(X) \0, Y=f(X) \end{cases}$</li><li>平方损失<br>$L(Y,f(X))=(Y-f(X))^2$</li><li><p>绝对损失<br>$L(Y,f(X))=|Y-f(X)|$</p></li><li><p>对数损失<br>这里$P(Y|X)\leqslant 1$，对应的对数是负值，所以对数损失中包含一个负号，为什么不是绝对值？因为肯定是负的。<br>$L(Y,P(Y|X))=-\log P(Y|X)$</p></li></ol><h4 id="ERM与SRM"><a href="#ERM与SRM" class="headerlink" title="ERM与SRM"></a>ERM与SRM</h4><p>经验风险最小化(ERM)与结构风险最小化(SRM)</p><ol><li><strong>极大似然估计</strong>是<strong>经验风险最小化</strong>的一个例子<br>当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化等价于极大似然估计</li><li><strong>贝叶斯估计</strong>中的<strong>最大后验概率估计</strong>是<strong>结构风险最小化</strong>的一个例子<br>当模型是条件概率分布，损失函数是对数损失函数，<strong>模型复杂度由模型的先验概率表示</strong>时，结构风险最小化等价于最大后验概率估计</li></ol><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a><u>算法</u></h3><p>这章里面简单提了一下，具体可以参考<a href="../CH12/README.md">CH12</a>表格中关于学习算法的描述。</p><h2 id="1-4-模型评估与模型选择"><a href="#1-4-模型评估与模型选择" class="headerlink" title="1.4 模型评估与模型选择"></a>1.4 模型评估与模型选择</h2><p><strong>训练误差和测试误差</strong>是模型关于数据集的平均损失。</p><p>提到一句， <code>统计学习方法具体采用的损失函数未必是评估时使用的损失函数</code>，这句理解下。参考下在数据科学比赛中给出的评分标准，与实际学习采用的损失函数之间的关系。</p><h3 id="过拟合与模型选择"><a href="#过拟合与模型选择" class="headerlink" title="过拟合与模型选择"></a>过拟合与模型选择</h3><p>这部分讲到了最小二乘法，给了PRML中的一个例子。</p><p>这个问题中<strong>训练数据</strong>为$T={(x_1, y_1),(x_2,y_2),\cdots,(x_N,y_N)}$</p><p><strong>模型</strong>为</p><p>$f<em>M(x,w)=w_0+w_1x+w_2x^2+\cdots+w_Mx^M=\sum\limits</em>{j=0}^Mw_jx^j$</p><p>经验风险最小化策略下</p><p>$L(w)=\frac{1}{2}\sum\limits_{i=1}^N(f(x_i,w)-y_i)^2$</p><p>将模型和训练数据带入到上式得到</p><p>$L(w)=\frac{1}{2}\sum\limits<em>{i=1}^N\left(\sum\limits</em>{j=0}^Mw<em>jx_i^j-y_i\right)^2=\frac{1}{2}\sum\limits</em>{i=1}^N(w\cdot x_i-y_i)^2$</p><p>这个问题要求$w=(w_0^<em>,w_1^</em>,\cdots,w_M^*)$</p><p>对$w$求偏导令其为零，得到一系列方程，求解可以用梯度下降或者矩阵分解。</p><p>求解线性方程组$Ax=b$，可以表示为$x=A/b$，问题展开之后可以涉及到<strong>矩阵分解</strong>。</p><h3 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h3><h4 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h4><p>模型选择的典型方法是正则化。从贝叶斯估计的角度来看，正则化项对应于模型的先验概率。可以假设复杂的模型有较小的先验概率，简单的模型有较大的先验概率。</p><h4 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h4><p>另一种常用的模型选择方法是交叉验证</p><ul><li>简单</li><li>S折(K折, K-Fold)</li><li>留一法</li></ul><p>关于交叉验证，这里补充一点。</p><p>数据集的划分这个问题，书中有提到数据充足的情况下，将数据划分为三个部分，训练集，验证集和测试集。看到这里，不知道大家会不会有一样的问题：<strong>验证集和测试集有什么区别？</strong></p><p>注意这里，在算法学习的过程中，测试集可能是固定的，但是验证集和训练集可能是变化的。比如K折交叉验证的情况下，分成K折之后，其中的K-1折作为训练集，1折作为验证集，这样针对每一个模型操作K次，计算平均测试误差，最后选择平均测试误差最小的模型。这个过程中用来验证模型效果的那一折数据就是<strong>验证集</strong>。交叉<strong>验证</strong>，就是这样一个使用<strong>验证</strong>集测试模型好坏的过程。他允许我们在模型选择的过程中，使用一部分数据（验证集）“偷窥”一下模型的效果。</p><h2 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h2><ul><li><p>现实中采用最多的方法是通过测试误差来评价学习方法的泛化能力</p></li><li><p>统计学习理论试图从理论上对学习方法的泛化能力进行分析</p></li><li><p>学习方法的泛化能力往往是通过研究泛化误差的<strong>概率上界</strong>进行的, 简称为泛化误差上界(generalization error bound)</p><p>这本书里面讨论的不多，在<a href="../CH08/README.md">CH08</a>里面有讨论提升方法的误差分析, 提到$AdaBoost$不需要知道下界$\gamma$。在<a href="../CH02/README.md">CH02</a>中讨论算法的收敛性的时候有提到误分类次数的上界.</p></li></ul><p>注意泛化误差的定义，书中有说<strong>事实上，泛化误差就是所学习到的模型的期望风险</strong></p><h2 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h2><p><strong>监督学习方法</strong>可分为<strong>生成方法</strong>(generative approach)与<strong>判别方法</strong>(discriminative approach)</p><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>generative approach</p><ul><li>可以还原出<strong>联合概率分布</strong>$P(X,Y)$</li><li>收敛速度快, 当样本容量增加时, 学到的模型可以更快收敛到真实模型</li><li>当存在隐变量时仍可以用</li></ul><h3 id="判别方法"><a href="#判别方法" class="headerlink" title="判别方法"></a>判别方法</h3><p>discriminative approach</p><ul><li>直接学习<strong>条件概率</strong>$P(Y|X)$或者<strong>决策函数</strong>$f(X)$</li><li>直接面对预测, 往往学习准确率更高</li><li>可以对数据进行各种程度的抽象,  定义特征并使用特征, 可以简化学习问题</li></ul><h1 id="习题解答"><a href="#习题解答" class="headerlink" title="习题解答"></a>习题解答</h1><ul><li><p><strong>1.1</strong>   说明伯努利模型的极大似然估计以及贝叶斯估计中的统计学方法三要素</p><ul><li><p>伯努利模型是定义在取值为0与1的随机变量上的概率分布。统计学分为两派：<strong>经典统计学派</strong>和<strong>贝叶斯统计学派</strong>。两者的不同主要是，<u>经典统计学派认为模型已定，参数未知，参数是固定的，只是还不知道</u>；<u>贝叶斯统计学派是通过观察到的现象对概率分布中的主观认定不断进行修正</u>。</p><ul><li><p><strong>极大似然估计</strong>用的是<u>经典统计学派的策略</u>，<strong>贝叶斯估计</strong>用的是<u>贝叶斯统计学派的策略</u>；为了得到使经验风险最小的参数值，使用的算法都是对经验风险求导，使导数为0。</p></li><li><p>定义随机变量$A$为一次伯努利试验的结果，$A$的取值为${0,1}$，概率分布为$P(A)$：</p><pre><code>                $P(A=1)=θ，P(A=0)=1-θ$</code></pre></li><li><p>极大似然估计<br>$L(θ)=\prod_{i=1}^nP(A_i)=θ^k(1-θ)^{n-k}$</p><script type="math/tex; mode=display">θ=\arg\max_{θ}L(θ)=\frac{k}{n}</script><p>上述估计通过取对数求导得到，$A_i$为第$i$次随机试验</p></li><li><p>贝叶斯估计<br>$P(θ|A_1,A_2,…，A_n)=\frac{P(A_1,A_2,…，A_n|θ)P(θ)}{P(A_1,A_2,…，A_n)}$</p></li></ul></li></ul></li></ul><pre><code>   根据观察到的结果修正$θ$，也就是假设$θ$是随机变量，$θ$服从β分布，有很多个可能的取值，我们要取的值是在已知观察结果的条件下使$θ$出现概率最大的值。上式分母是不变的，求分子最大就可以。   $\begin&#123;aligned&#125;  \theta   &amp;=arg\max \limits_\theta &#123;P(A_1,A_2,...,A_n|\theta)P(\theta)&#125; \\   &amp;= arg\max \limits_\theta &#123;\prod_&#123;i=1&#125;^&#123;n&#125;P(A_i|\theta)P(\theta)&#125;  \\  &amp;=arg \max \limits_\theta &#123;\theta^k(1-\theta)^&#123;n-k&#125;\theta^&#123;a-1&#125;(1-\theta)^&#123;b-1&#125;&#125; \\  &amp;=\frac&#123;k+(a-1)&#125;&#123;n+(a-1)+(b-1)&#125;  \end&#123;aligned&#125;$  β分布是一个作为伯努利分布和二项式分布的共轭先验分布的密度函数，是指一组定义在$(0,1)$区间的连续概率分布，有两个参数α，β&gt;0。选定参数后就可以确定$\theta$。* 统计学习方法的三要素为模型，策略，算法。</code></pre><p><img src="https://img-blog.csdnimg.cn/20190524102938764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x5YzQ0ODEzNDE4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li><strong>1.2</strong> 通过经验风险最小化推导极大似然估计。证明模型是条件概率分布，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。<ul><li>模型是条件概率分布：$P<em>θ(Y|X)$，<br>损失函数是对数损失函数：$L(Y,P</em>θ(Y|X))=−logP<em>θ(Y|X)$<br>经验风险为：$$ \begin{aligned}<br>R</em>{emp}(f)&amp;=\frac{1}{N}\sum<em>{i=1}^{N}L(y_i,f(x_i)) \<br>&amp;=\frac{1}{N}\sum</em>{i=1}^{N}-logP(y<em>i|x_i) \<br>&amp;=-\frac{1}{N}\sum</em>{i=1}^{N}logP(y_i|x_i)<br>\end{aligned}$$</li></ul></li></ul><ul><li><p>极大似然估计的似然函数为： </p><script type="math/tex; mode=display">L(\theta)=\prod_DP_{\theta}(Y|X)</script><ul><li>取对数<script type="math/tex; mode=display">log(L(\theta))=\sum_DlogP_{\theta}(Y|X)</script><script type="math/tex; mode=display">arg\max_\theta\sum_DlogP_{\theta}(Y|X)=arg\min_{\theta}\sum_D-logP_{\theta}(Y|X)</script></li></ul><ul><li>因此，当损失函数是对数损失函数时，经验风险最小化等价于极大似然估计。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> 统计学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第21篇博客】树莓派-服务器端-nodejs 和 主机-客户端-flutter 进行socket.io通信</title>
      <link href="2021/06/02/blog21-RaspberryPi-SocketIo/"/>
      <url>2021/06/02/blog21-RaspberryPi-SocketIo/</url>
      
        <content type="html"><![CDATA[<h2 id="如何创建一个nodejs项目"><a href="#如何创建一个nodejs项目" class="headerlink" title="如何创建一个nodejs项目"></a>如何创建一个nodejs项目</h2><p><a href="https://www.pianshen.com/article/27061493784/">https://www.pianshen.com/article/27061493784/</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行命令&#96;</span><br><span class="line">&#96;npm install -g express</span><br></pre></td></tr></table></figure><h2 id="树莓派上使用nodejs进行socket-io收发信息"><a href="#树莓派上使用nodejs进行socket-io收发信息" class="headerlink" title="树莓派上使用nodejs进行socket.io收发信息"></a>树莓派上使用nodejs进行socket.io收发信息</h2><p>服务器端socketServerTest.js文件:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&quot;socket.io&quot;</span>)(<span class="number">3003</span>);</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="params">socket</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Connected&#x27;</span>)</span><br><span class="line">    <span class="comment">// either with send()</span></span><br><span class="line">    socket.send(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or with emit() and custom event names</span></span><br><span class="line">    socket.emit(<span class="string">&quot;greetings&quot;</span>, <span class="string">&quot;Hey!&quot;</span>, &#123; <span class="string">&quot;ms&quot;</span>: <span class="string">&quot;jane&quot;</span> &#125;, Buffer.from([<span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle the event sent with socket.send()</span></span><br><span class="line">    socket.on(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// handle the event sent with socket.emit()</span></span><br><span class="line">    socket.on(<span class="string">&quot;salutations&quot;</span>, <span class="function">(<span class="params">elem1, elem2, elem3</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(elem1, elem2, elem3);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端socketClientTest.js文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">&quot;socket.io-client&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> io(<span class="string">&quot;http://10.0.1.83:3003&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">socket.on(<span class="string">&quot;connect&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// either with send()</span></span><br><span class="line">    socket.send(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// or with emit() and custom event names</span></span><br><span class="line">    socket.emit(<span class="string">&quot;salutations&quot;</span>, <span class="string">&quot;Hello!&quot;</span>, &#123; <span class="string">&quot;mr&quot;</span>: <span class="string">&quot;john&quot;</span> &#125;, <span class="built_in">Uint8Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hhhhh&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the event sent with socket.send()</span></span><br><span class="line">socket.on(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle the event sent with socket.emit()</span></span><br><span class="line">socket.on(<span class="string">&quot;greetings&quot;</span>, <span class="function">(<span class="params">elem1, elem2, elem3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(elem1, elem2, elem3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在可以使用flutter做客户端连接</p><h2 id="flutter做客户端使用socket-io"><a href="#flutter做客户端使用socket-io" class="headerlink" title="flutter做客户端使用socket.io"></a>flutter做客户端使用socket.io</h2><p><a href="https://pub.dev/packages/socket_io_client">https://pub.dev/packages/socket_io_client</a></p><p>该网页有几个简单的示例程序，如dart和flutter下的server端和client端。</p><h4 id="这里遇到了几个坑点："><a href="#这里遇到了几个坑点：" class="headerlink" title="这里遇到了几个坑点："></a>这里遇到了几个坑点：</h4><p>坑是说自己坑…，其实文档上都写了…，刚开始自己没注意。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210602212038706.png" alt="image-20210602212038706"></p><p><strong><code>意思是对应于flutter下的版本v1的socket.io-client对应的Socket.io Sever的版本为v2，而npm package下的socket.io的版本已经到了v4了，一味追求最新版会导致客户端不能正常连上。</code></strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210602212349943.png" alt="image-20210602212349943"></p><p>因此在树莓派下的nodejs服务器端，得使用较低版本的v2.4.1的socket.io package.</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210602212536110.png" alt="image-20210602212536110"></p><p>以上是第一个坑点，版本问题。</p><p>第二个问题是flutter客户端的程序。</p><p>以前用chrome的web程序运行没有问题，</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Socket socket = io(<span class="string">&#x27;http://10.0.1.83:3002&#x27;</span>);</span><br></pre></td></tr></table></figure><p>但在windows下的desktop程序运行连不上，文档中如此说道：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210602213002606.png" alt="image-20210602213002606"></p><p>需要改成</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Socket socket = io(</span><br><span class="line">     <span class="string">&#x27;http://10.0.1.83:3002&#x27;</span>,</span><br><span class="line">     OptionBuilder().setTransports([<span class="string">&#x27;websocket&#x27;</span>]) <span class="comment">// for Flutter or Dart VM</span></span><br><span class="line">         .build());</span><br></pre></td></tr></table></figure><p>就可以连接服务器端了</p><p>flutter客户端代码为：</p><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherCard</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _WeatherCardState createState() =&gt; _WeatherCardState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_WeatherCardState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">WeatherCard</span>&gt; </span>&#123;</span><br><span class="line">  Socket socket = io(</span><br><span class="line">      <span class="string">&#x27;http://10.0.1.83:3002&#x27;</span>,</span><br><span class="line">      OptionBuilder().setTransports([<span class="string">&#x27;websocket&#x27;</span>]) <span class="comment">// for Flutter or Dart VM</span></span><br><span class="line">          .build());</span><br><span class="line">  <span class="keyword">void</span> closeDialogHandler(_, Socket socket, openDialogHandler) &#123;</span><br><span class="line">    Navigator.of(context).pop();</span><br><span class="line">    socket.off(<span class="string">&#x27;closeDialog&#x27;</span>);</span><br><span class="line">    socket.<span class="keyword">on</span>(</span><br><span class="line">        <span class="string">&#x27;openDialog&#x27;</span>, (_) =&gt; openDialogHandler(_, socket, closeDialogHandler));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> openDialogHandler(_, Socket socket, closeDialogHandler) &#123;</span><br><span class="line">    _showMyMaterialDialog();</span><br><span class="line">    socket.off(<span class="string">&#x27;openDialog&#x27;</span>);</span><br><span class="line">    socket.<span class="keyword">on</span>(</span><br><span class="line">        <span class="string">&#x27;closeDialog&#x27;</span>, (_) =&gt; closeDialogHandler(_, socket, openDialogHandler));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    loadJson();</span><br><span class="line"></span><br><span class="line">    socket.onConnect((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;socket.io connect&#x27;</span>);</span><br><span class="line">      <span class="comment">// socket.emit(&#x27;msg&#x27;, &#x27;test&#x27;); //客户端发</span></span><br><span class="line">    &#125;);</span><br><span class="line">    socket.onConnectError((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onConnectError&#x27;</span> + _);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.onConnectTimeout((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onConnectTimeout&#x27;</span> + _);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.onError((_) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;onError&#x27;</span> + _);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.<span class="keyword">on</span>(</span><br><span class="line">        <span class="string">&#x27;openDialog&#x27;</span>, (_) =&gt; openDialogHandler(_, socket, closeDialogHandler));</span><br><span class="line">    socket.onDisconnect((_) =&gt; <span class="built_in">print</span>(<span class="string">&#x27;disconnect&#x27;</span>));</span><br><span class="line">    socket.<span class="keyword">on</span>(<span class="string">&#x27;fromServer&#x27;</span>, (_) =&gt; <span class="built_in">print</span>(_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> raspberrypi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberrypi </tag>
            
            <tag> NodeJs </tag>
            
            <tag> flutter </tag>
            
            <tag> socket.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第20篇博客】使用NodeJs进行树莓派串口使用</title>
      <link href="2021/06/01/blog20-RaspberryPi-SerialPort/"/>
      <url>2021/06/01/blog20-RaspberryPi-SerialPort/</url>
      
        <content type="html"><![CDATA[<p>目前搜到的大多数描述树莓派 4 串口的文章，大多数开头都是禁用下蓝牙，这个做法针对树莓派0-3 是必须的，因为本身串口不够用，但对树莓派 4 来说并不需要，因为有额外 4 个串口可以利用，默认配置好的两串口一个用于蓝牙（UART0）另一个是 miniUART 可以保留设置。此方面的文章大多都是一个流程，原因是参考的最初版本是树莓派 3 的设置；树莓派 4 的额外串口设置在树莓派论坛中可以看到相关的介绍，外面的文章不太多。除此之外，还有USB的4个口可以使用，也就是说，<strong>树莓派4将有10个串口可以使用。</strong></p><h2 id="树莓派正确识别CH340"><a href="#树莓派正确识别CH340" class="headerlink" title="树莓派正确识别CH340"></a>树莓派正确识别CH340</h2><p><a href="https://lightningleader.github.io/posts/4.html">https://lightningleader.github.io/posts/4.html</a></p><p>首先正常开启树莓派，不要插入CH340，然后进入树莓派桌面，打开命令行，输入命令lsusb，可以查看本机的USB设备列表，以及USB设备的详细信息。</p><p>然后插入CH340，再次运行lsusb命令，这个时候再看界面。可以明显看出多了一个设备，后面的设备详情也明确表示这个是CH340，这就表明树莓派正确识别到了插入的CH340。</p><p>接着在命令行输入命令 ls -l /dev/tty*</p><p>不出意外的话最后一个就是你插入的ch340，然后就记住这个黄色字体即/dev/ttyUSB0。这里的USB0也可能是USB1，这个是不确定的。</p><p>到了这里就代表你的树莓派可以正常识别CH34，下面就是写代码来验证效果了。</p><h2 id="树莓派4B如何使用串口与外部进行通信"><a href="#树莓派4B如何使用串口与外部进行通信" class="headerlink" title="树莓派4B如何使用串口与外部进行通信"></a>树莓派4B如何使用串口与外部进行通信</h2><p><a href="https://blog.csdn.net/weixin_42108484/article/details/104039992">https://blog.csdn.net/weixin_42108484/article/details/104039992</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">硬件串口 （PL011）</th><th style="text-align:center">mini串口</th></tr></thead><tbody><tr><td style="text-align:center">/dev/ttyAMA0</td><td style="text-align:center">/dev/ttyS0</td></tr><tr><td style="text-align:center">硬件串口有单独的波特率时钟源，性能好，稳定性强</td><td style="text-align:center">mini串口功能简单，稳定性较差，波特率由CPU内核时钟提供，受内核时钟影响</td></tr><tr><td style="text-align:center">分配给蓝牙模块使用的</td><td style="text-align:center">性能较差的mini串口是分配给GPIO串口 TXD0（GPIO14）、RXD0（GPIO15）</td></tr></tbody></table></div><p>相比树莓派零、1、2 以及 3 的双串口 UART0（PL011）和 UART1（mini UART），树莓派 4 中新增了 4 个 PL011 串口共计有 6 个 UART，整理此笔记用作记录和配置参考。</p><h2 id="树莓派-4-UART-多串口配置通信"><a href="#树莓派-4-UART-多串口配置通信" class="headerlink" title="树莓派 4 UART 多串口配置通信"></a>树莓派 4 UART 多串口配置通信</h2><p><a href="https://blog.csdn.net/weixin_40796925/article/details/107907991">https://blog.csdn.net/weixin_40796925/article/details/107907991</a></p><p>展示所有串口命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dtoverlay -a | grep uart</span><br><span class="line">pi@raspberrypi:~ $ dtoverlay -a | grep uart</span><br><span class="line">  midi-uart0</span><br><span class="line">  midi-uart1</span><br><span class="line">  miniuart-bt</span><br><span class="line">  uart0</span><br><span class="line">  uart1</span><br><span class="line">  uart2</span><br><span class="line">  uart3</span><br><span class="line">  uart4</span><br><span class="line">  uart5</span><br></pre></td></tr></table></figure><p>GPIO14 = TXD0 -&gt; ttyAMA0<br>GPIO0  = TXD2 -&gt; ttyAMA1<br>GPIO4  = TXD3 -&gt; ttyAMA2<br>GPIO8  = TXD4 -&gt; ttyAMA3<br>GPIO12 = TXD5 -&gt; ttyAMA4</p><p>GPIO15 = RXD0 -&gt; ttyAMA0<br>GPIO1  = RXD2 -&gt; ttyAMA1<br>GPIO5  = RXD3 -&gt; ttyAMA2<br>GPIO9  = RXD4 -&gt; ttyAMA3<br>GPIO13 = RXD5 -&gt; ttyAMA4</p><h2 id="NodeJs示例程序"><a href="#NodeJs示例程序" class="headerlink" title="NodeJs示例程序"></a>NodeJs示例程序</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SerialPort = <span class="built_in">require</span>(<span class="string">&#x27;serialport&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> port = <span class="keyword">new</span> SerialPort(<span class="string">&#x27;/dev/ttyUSB0&#x27;</span>, &#123;</span><br><span class="line">    baudRate: <span class="number">9600</span>, <span class="comment">//波特率</span></span><br><span class="line">    dataBits: <span class="number">8</span>, <span class="comment">//数据位</span></span><br><span class="line">    parity: <span class="string">&#x27;none&#x27;</span>, <span class="comment">//奇偶校验</span></span><br><span class="line">    stopBits: <span class="number">1</span>, <span class="comment">//停止位</span></span><br><span class="line">    flowControl: <span class="literal">false</span></span><br><span class="line">&#125;, <span class="literal">false</span>); <span class="comment">// this is the openImmediately flag [default is true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指令监听</span></span><br><span class="line">port.on(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    port.write(<span class="string">&#x27;main screen turn on &#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&#x27;Error on write: &#x27;</span>, err.message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;send success&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    port.on(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data received: &#x27;</span> + data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开错误将会发出一个错误事件</span></span><br><span class="line">port.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Error: &#x27;</span>, err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的<code>/dev/ttyUSB0</code>还可以替换成<code>/dev/ttyAMA1</code>。</p>]]></content>
      
      
      <categories>
          
          <category> raspberrypi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberrypi </tag>
            
            <tag> NodeJs </tag>
            
            <tag> 串口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog17-GithubActions</title>
      <link href="2021/03/15/blog17-GithubActions/"/>
      <url>2021/03/15/blog17-GithubActions/</url>
      
        <content type="html"><![CDATA[<p>DevOps</p><p>CI/CD（持续集成、持续部署）</p><p>GitHub Actions 部署爬虫并定时发送邮件</p><p><a href="https://blog.csdn.net/a12355556/article/details/112099143">https://blog.csdn.net/a12355556/article/details/112099143</a></p><p>newsexpress—利用github_actions建立自动运行爬取学校官网通知并自动发送邮件的小玩意</p><p><a href="https://www.cnblogs.com/roccoshi/p/13144078.html">https://www.cnblogs.com/roccoshi/p/13144078.html</a></p><p>github:epc ustc</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>【第19篇博客】探索树莓派64位系统</title>
      <link href="2021/03/14/blog19_RaspberryPi64bit/"/>
      <url>2021/03/14/blog19_RaspberryPi64bit/</url>
      
        <content type="html"><![CDATA[<p>由于树莓派官方推荐的版本仍是32位，本博客探索64位版本。</p><p><a href="https://www.codenong.com/37790029/">https://www.codenong.com/37790029/</a></p><p>Raspberry Pi Type 3具有64位CPU，但其体系结构不是arm64，而是armhf。armhf代表” arm hard float”，是为具有硬件浮点支持的arm处理器(armv7 +)的debian端口指定的名称。<br>arm64和armhf有什么区别？</p><p>armhf代表” arm hard float”，是为具有硬件浮点支持的arm处理器(armv7 +)的debian端口指定的名称。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:~$ dpkg --print-architecture</span><br><span class="line">armhf</span><br></pre></td></tr></table></figure><p>在树莓派官方推荐的32位系统中将返回armhf，在官方推荐的32位系统升级64位后的系统也返回armhf，只有按下文下载的系统才会返回arm64。</p><h3 id="如何安装64位树莓派系统"><a href="#如何安装64位树莓派系统" class="headerlink" title="如何安装64位树莓派系统"></a>如何安装64位树莓派系统</h3><p><a href="https://raspberrytips.com/raspberry-pi-os-64-bits-vs-32-bits/">https://raspberrytips.com/raspberry-pi-os-64-bits-vs-32-bits/</a></p><p><strong>Raspberry Pi OS is available only in a 32-bit version. There is a 64-bit version in development, but it’s not stable yet.<br>When the CPU is compatible, a 64-bit operating system improves the program performances.</strong></p><p><strong>You can expect an overall boost of about 25% in performance with a 64-bit operating system on a compatible device. And some apps will benefit even more from it.</strong></p><p><strong>On the official website and in the Raspberry Pi Imager, you’ll only find the 32-bit version. You need to go directly <a href="https://downloads.raspberrypi.org/raspios_arm64/images/">to this link</a> to find the latest versions available.</strong></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210530152132577.png" alt="image-20210530152132577"></p><p>可能出现某个版本系统无法安装的情况，换一个即可。</p><p>但是存在一些问题。<strong>Another thing you will notice is that a few apps are missing in the “Recommended Software” tool.</strong>For example, there is no Minecraft Pi or Mathematica that you can install directly from there.<br>These software packages don’t have a build available for the 64-bit operating system.</p><p>上一篇博客可看到系统的架构是v7l，为32位系统。</p><p>下面显示安装的树莓派64位系统的信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@pi:~ $ pi@pi:~ $ uname -a</span><br><span class="line">Linux pi 5.4.51-v8+ #1333 SMP PREEMPT Mon Aug 10 16:58:35 BST 2020 aarch64 GNU&#x2F;Linux</span><br><span class="line">pi@pi:~ $ cat &#x2F;proc&#x2F;cpuinfo</span><br><span class="line">processor       : 0</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : fp asimd evtstrm crc32 cpuid</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : fp asimd evtstrm crc32 cpuid</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">-bash: pi@pi:~：未找到命令</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : fp asimd evtstrm crc32 cpuid</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : fp asimd evtstrm crc32 cpuid</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 8</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">Hardware        : BCM2835</span><br><span class="line">Revision        : c03112</span><br><span class="line">Serial          : 1000000060357d6d</span><br><span class="line">Model           : Raspberry Pi 4 Model B Rev 1.2</span><br></pre></td></tr></table></figure><h3 id="芯片版本BCM2711-or-BCM2835"><a href="#芯片版本BCM2711-or-BCM2835" class="headerlink" title="芯片版本BCM2711 or BCM2835"></a>芯片版本BCM2711 or BCM2835</h3><p>查看当前芯片版本，显示为4核心，但是芯片名字却是BCM2835，这是一个很老的芯片。在树莓派zero和1上使用的，新的树莓派4B是BCM2711，拿起板子我能明显看到 芯片上的丝印字，为什么cpuinfo命令查出来的是错误的呢？因为内核只许设置1个值，如果设置不同的值就要改代码，这会导致上游集成更加麻烦。建议查版本用cat /proc/device-tree/model来看。</p><p>版本参考这里就是准确的 <a href="https://shumeipai.nxez.com/raspberry-pi-revision-codes">https://shumeipai.nxez.com/raspberry-pi-revision-codes</a> 或 <a href="https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md">https://www.raspberrypi.org/documentation/hardware/raspberrypi/revision-codes/README.md</a> 。从 4.9 版的内核开始，所有的树莓派都显示为 BCM2835，即便实际上是 BCM2836 和 BCM2837 或2837和2711 处理器。因此仅用这串字符来作为判断依据是不够的。</p><p>cat /proc/cpuinfo 打印的信息里面，包含 Hardware: BCM2835 硬件架构码，但这并不是 CPU 型号，而是 Linux 内核内置的，代表树莓派系列的硬件架构码。</p><p>这个官方也解释过了：<br>Why does cpuinfo report I have a BCM2835? The upstream Linux kernel developers had decided that all models of Raspberry Pi return bcm2835 as the SoC name. At Raspberry Pi we like to use as much upstream kernel code as possible, as it makes software maintenance much easier, so we use this code. Unfortunately it means that cat /proc/cpuinfo is inaccurate for the Raspberry Pi 2, Raspberry Pi 3 and Raspberry Pi 4, which use the bcm2836/bcm2837, bcm2837 and bcm2711 respectively. You can use cat /proc/device-tree/model to get an accurate description of the SoC on your Raspberry Pi model.</p><h3 id="操作系统版本—指令集版本ARMv7-or-ARMv8"><a href="#操作系统版本—指令集版本ARMv7-or-ARMv8" class="headerlink" title="操作系统版本—指令集版本ARMv7 or ARMv8"></a>操作系统版本—指令集版本ARMv7 or ARMv8</h3><p>ARMv7 是32位。</p><p>ARMv8架构引入了对ARM架构的64位支持，重点在于节能的实现，同时保持与现有32位软件的兼容性。通过采用干净的方法，ARMv8-A处理器扩展了可用的性能范围，同时保持了ARM处理器的低功耗特性，这将为未来最具创新性和效率的设备提供动力。ARM有3种不同的产品级别支持ARMv8-A架构：高性能，高效率和超高效率。</p><p>ARMv8-A为ARM体系结构引入了64位体系结构支持，其中包括：</p><p>64位通用寄存器，SP（堆栈指针）和PC（程序计数器）</p><p>64位数据处理和扩展虚拟寻址<br>两个主要执行状态：</p><p>AArch64 - 64位执行状态，包括异常模式，内存模式，程序员模型和指令集支持</p><p>AArch32 - 32位执行状态，包括异常模型，存储器模型，程序员模型和支持该状态的指令集</p><p>低于ARMv8（如ARMv7）是32位。</p><p><a href="https://www.cnblogs.com/pingwen/p/13455876.html">https://www.cnblogs.com/pingwen/p/13455876.html</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 5.10.17-v8+ #1414 SMP PREEMPT Fri Apr 30 13:23:25 BST 2021 aarch64 GNU&#x2F;Linux</span><br><span class="line">pi@raspberrypi:~ $ uname -m</span><br><span class="line">aarch64</span><br><span class="line">pi@pi:~ $ getconf LONG_BIT</span><br><span class="line">64</span><br></pre></td></tr></table></figure><p>ARMv8指令集分为Aarch64和Aarch32指令集，而ARMv7使用的是A32和T16指令集（分别为32位和16位）。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/0" alt=""></p><p>再补充一个小知识，armv7不是arm7，做嵌入式的可能比较清楚的，但做纯PC的程序员就比较迷糊了。arm7，8, 9是芯片版本，而v7，v8是指令集版本。</p><p>查看当前操作系统版本，有的是v7l，l是小端的cpu。</p><h3 id="架构aarch64-or-armhf"><a href="#架构aarch64-or-armhf" class="headerlink" title="架构aarch64 or armhf"></a>架构aarch64 or armhf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uname -m 显示主机类型</span><br><span class="line">dpkg --print-architecture 显示架构</span><br><span class="line">armhf</span><br></pre></td></tr></table></figure><h3 id="linux版本buster"><a href="#linux版本buster" class="headerlink" title="linux版本buster"></a>linux版本buster</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@pi:~ $ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Debian</span><br><span class="line">Description:  Debian GNU&#x2F;Linux 10 (buster)</span><br><span class="line">Release:    10</span><br><span class="line">Codename:    buster</span><br></pre></td></tr></table></figure><p><a href="https://www.debian.org/releases/index.zh-cn.html">https://www.debian.org/releases/index.zh-cn.html</a></p><p>当前 Debian 的稳定版版本号是 10，开发代号为 <em>buster</em>。Buster，来自皮克斯《玩具总动员》电影中狗的名字。<br>这个版本基于最新的 Debian 开发，甚至比 Debian 的官方版本更早发布。</p><h5 id="发行版目录"><a href="#发行版目录" class="headerlink" title="发行版目录"></a>发行版目录</h5><ul><li>下一代 Debian 正式发行版的代号为 bullseye — 测试中，发布时间尚未确定 </li><li><a href="https://www.debian.org/releases/buster/">Debian 10（buster）</a> — 当前的稳定（stable）版</li><li><a href="https://www.debian.org/releases/stretch/">Debian 9（stretch）</a> — 旧的稳定（oldstable）版，现有<a href="https://wiki.debian.org/LTS">长期支持</a></li><li><a href="https://www.debian.org/releases/jessie/">Debian 8（jessie）</a> — 更旧的稳定（oldoldstable）版，现有<a href="https://wiki.debian.org/LTS/Extended">扩展长期支持</a></li><li><a href="https://www.debian.org/releases/wheezy/">Debian 7（wheezy）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/squeeze/">Debian 6.0（squeeze）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/lenny/">Debian GNU/Linux 5.0（lenny）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/etch/">Debian GNU/Linux 4.0（etch）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/sarge/">Debian GNU/Linux 3.1（sarge）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/woody/">Debian GNU/Linux 3.0（woody）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/potato/">Debian GNU/Linux 2.2（potato）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/slink/">Debian GNU/Linux 2.1（slink）</a> — 被淘汰的稳定版</li><li><a href="https://www.debian.org/releases/hamm/">Debian GNU/Linux 2.0（hamm）</a> — 被淘汰的稳定版</li></ul><h3 id="树莓派4B使用Raspbian官方64位系统内核"><a href="#树莓派4B使用Raspbian官方64位系统内核" class="headerlink" title="树莓派4B使用Raspbian官方64位系统内核"></a>树莓派4B使用Raspbian官方64位系统内核</h3><p><a href="https://www.mmuaa.com/post/0c9188ffde4e2cff.html">https://www.mmuaa.com/post/0c9188ffde4e2cff.html</a></p><h3 id="树莓派版本信息"><a href="#树莓派版本信息" class="headerlink" title="树莓派版本信息"></a>树莓派版本信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getconf&#96; &#96;LONG_BIT    &#96;&#96;# 查看系统位数&#96;&#96;</span><br><span class="line">uname&#96; &#96;-a      &#96;&#96;# kernel 版本&#96;&#96;</span><br><span class="line">&#x2F;opt&#x2F;vc&#x2F;bin&#x2F;vcgencmd&#96; &#96;version  &#96;&#96;# firmware版本&#96;&#96;</span><br><span class="line">strings&#96; &#96;&#x2F;boot&#x2F;start&#96;&#96;.elf | &#96;&#96;grep&#96; &#96;VC_BUILD_ID  &#96;&#96;# firmware版本&#96;&#96;</span><br><span class="line">cat&#96; &#96;&#x2F;proc&#x2F;version&#96;    &#96;# kernel&#96;&#96;</span><br><span class="line">cat&#96; &#96;&#x2F;etc&#x2F;os-release&#96;   &#96;# OS版本资讯&#96;&#96;</span><br><span class="line">cat&#96; &#96;&#x2F;etc&#x2F;issue&#96;     &#96;# Linux distro 版本&#96;&#96;</span><br><span class="line">cat&#96; &#96;&#x2F;etc&#x2F;debian_version&#96;   &#96;# Debian版本编号</span><br></pre></td></tr></table></figure><h2 id="树莓派64位系统换源"><a href="#树莓派64位系统换源" class="headerlink" title="树莓派64位系统换源"></a>树莓派64位系统换源</h2><p><a href="https://blog.csdn.net/qq_51951392/article/details/113703729">https://blog.csdn.net/qq_51951392/article/details/113703729</a></p><p><a href="https://www.codenong.com/cs109778546/">https://www.codenong.com/cs109778546/</a></p><p><a href="https://blog.csdn.net/baidu_26678247/article/details/108930421">https://blog.csdn.net/baidu_26678247/article/details/108930421</a></p><h2 id="SNAP安装程序"><a href="#SNAP安装程序" class="headerlink" title="SNAP安装程序"></a>SNAP安装程序</h2><p>按照教程 <a href="https://snapcraft.io/install/flutter/raspbian">https://snapcraft.io/install/flutter/raspbian</a></p><p>由于snap安装core和flutter都不成功，怀疑是64位支持的snap问题，但不成功会返回snap安装包的链接，我通过windows下科学上网下载该snap文件，然后移到树莓派中，进行本地安装。</p><h2 id="树莓派系统linux桌面运行flutter"><a href="#树莓派系统linux桌面运行flutter" class="headerlink" title="树莓派系统linux桌面运行flutter"></a>树莓派系统linux桌面运行flutter</h2><p>最终无法在桌面应用中展示，出现一点问题。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">libGL error: unable to load driver: swrast_dri.so</span><br><span class="line">libGL error: failed to load driver: swrast</span><br><span class="line"></span><br><span class="line">** (dummy_desktop:10814): WARNING **: Failed to start Flutter renderer: Unable to create a GL context</span><br><span class="line"></span><br><span class="line">** (dummy_desktop:10814): WARNING **: Unable to retrieve framework response: No engine to send to</span><br></pre></td></tr></table></figure><p>解决方案 <a href="https://github.com/flutter/flutter/issues/76178#issuecomment-832127601">https://github.com/flutter/flutter/issues/76178#issuecomment-832127601</a></p><h2 id="对于flutter的桌面支持"><a href="#对于flutter的桌面支持" class="headerlink" title="对于flutter的桌面支持"></a>对于flutter的桌面支持</h2><p><a href="https://flutter.dev/desktop">https://flutter.dev/desktop</a></p><p>使得在win、linux、osx环境下，都有桌面应用可以展示应用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter config --enable-&lt;platform&gt;-desktop</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flutter run -d linux</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> raspberrypi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberrypi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第18篇博客】windows下开发树莓派运行flutter项目</title>
      <link href="2021/03/13/blog18_RaspberryPi/"/>
      <url>2021/03/13/blog18_RaspberryPi/</url>
      
        <content type="html"><![CDATA[<p>Linux有非常多的发行版本，从性质上划分，大体分为由商业公司维护的商业版本与由开源社区维护的免费发行版本。开源社区版本以debian为代表。这些版本各有不同的特点，在不同的应用领域发挥着不同的作用，不能一概而论。下面就这些不同的Linux发行版进行简单的分析。</p><p><strong>Ubuntu</strong></p><p>Ubuntu近些年的粉丝越来越多，Ubuntu有着漂亮的用户界面，完善的包管理系统，强大的软件源支持，丰富的技术社区，Ubuntu还对大多数硬件有着良好的兼容性，包括最新的图形显卡等等。这一切让Ubuntu越来越向大众化方向发展。但别忘了：你所需要的只是一个简约、稳定、易用的服务器系统而已！</p><p>Ubuntu的图形界面固然漂亮，但这也决定了它最佳的应用领域是桌面操作系统而非服务器操作系统。如何你希望在学习Linux的过程中有个沉浸式的环境，那么Ubuntu的确不错：仅仅安装在自己的电脑中而非服务器中。从这一点来讲，Ubuntu并没有在VPS安装的操作系统选择之列，相信你也不会为了那数百M的驱动与宝贵的内存买单。</p><p><strong>CentOS</strong></p><p>你会发现非常多的商业公司部署在生产环境上的服务器都是使用的CentOS系统，CentOS是从RHEL源代码编译的社区重新发布版。CentOS简约，命令行下的人性化做得比较好，稳定，有着强大的英文文档与开发社区的支持。与Redhat有着相同的渊源。虽然不单独提供商业支持，但往往可以从Redhat中找到一丝线索。相对debian来说，CentOS略显体积大一点。是一个非常成熟的Linux发行版。</p><p><strong>Debian</strong></p><p>一般来说Debian作为适合于服务器的操作系统，它比Ubuntu要稳定得多。可以说稳定得无与伦比了。debian整个系统，只要应用层面不出现逻辑缺陷，基本上固若金汤，是个常年不需要重启的系统（当然，这是夸张了点，但并没有夸大其稳定性）。debian整个系统基础核心非常小，不仅稳定，而且占用硬盘空间小，占用内存小。128M的VPS即可以流畅运行Debian，而CentOS则会略显吃力。但是由于Debian的发展路线，使它的帮助文档相对于CentOS略少，技术资料也少一些。</p><p><strong>Raspbian is a free operating system based on Debian Linux, and it is optimized Raspberry Pi.</strong></p><h2 id="下载和安装Raspberry-Pi-OS（以前称为Raspbian）"><a href="#下载和安装Raspberry-Pi-OS（以前称为Raspbian）" class="headerlink" title="下载和安装Raspberry Pi OS（以前称为Raspbian）"></a>下载和安装Raspberry Pi OS（以前称为Raspbian）</h2><p>打开raspberrypi官网，www.raspberrypi.org/ ，进入<code>software</code>，可以看到有三种下载方式。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210316090859590.png" alt="image-20210316090859590"></p><p>我选择full版，带有推荐软件的。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318231323830.png" alt="image-20210318231323830"></p><p>下载2021-01-11-raspios-buster-armhf-full.zip，共2.8g</p><p>再下载balenaEtcher软件或者Raspberry Pi Imager，是一种镜像刻录工具。打开来，选择Flash from file，选择刚刚下载的2.8g的zip。第二步select target选择自己的SD卡，记得需要格式化。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318231625865.png" alt="image-20210318231625865"></p><p>刻录完成之后，SD卡插至树莓派上，接上电源，自动安装系统，接着填写必要信息，接上wifi或网线，系统就安装完成了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ uname -a</span><br><span class="line">Linux raspberrypi 5.10.11-v7l+ #1399 SMP Thu Jan 28 12:09:48 GMT 2021 armv7l GNU&#x2F;Linux</span><br><span class="line">pi@raspberrypi:~ $ cat &#x2F;proc&#x2F;cpuinfo</span><br><span class="line">processor       : 0</span><br><span class="line">model name      : ARMv7 Processor rev 3 (v7l)</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">processor       : 1</span><br><span class="line">model name      : ARMv7 Processor rev 3 (v7l)</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">processor       : 2</span><br><span class="line">model name      : ARMv7 Processor rev 3 (v7l)</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">processor       : 3</span><br><span class="line">model name      : ARMv7 Processor rev 3 (v7l)</span><br><span class="line">BogoMIPS        : 108.00</span><br><span class="line">Features        : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32</span><br><span class="line">CPU implementer : 0x41</span><br><span class="line">CPU architecture: 7</span><br><span class="line">CPU variant     : 0x0</span><br><span class="line">CPU part        : 0xd08</span><br><span class="line">CPU revision    : 3</span><br><span class="line"></span><br><span class="line">Hardware        : BCM2711</span><br><span class="line">Revision        : b03111</span><br><span class="line">Serial          : 100000001c6c37b2</span><br><span class="line">Model           : Raspberry Pi 4 Model B Rev 1.1</span><br></pre></td></tr></table></figure><h2 id="安装dart"><a href="#安装dart" class="headerlink" title="安装dart"></a><del>安装dart</del></h2><p><del><a href="https://blog.csdn.net/weixin_44601948/article/details/105620588">https://blog.csdn.net/weixin_44601948/article/details/105620588</a></del></p><p>Dart SDK已经在打包在Flutter SDK里了，没有必要单独安装Dart。</p><h2 id="windows下安装flutter"><a href="#windows下安装flutter" class="headerlink" title="windows下安装flutter"></a>windows下安装flutter</h2><p><a href="https://flutter.cn/docs/get-started/install/windows">https://flutter.cn/docs/get-started/install/windows</a></p><p>下载安装</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210317101157787.png" alt="image-20210317101157787"></p><p>解压 环境变量</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210317101223767.png" alt="image-20210317101223767"></p><h3 id="安装-Android-Studio"><a href="#安装-Android-Studio" class="headerlink" title="安装 Android Studio"></a><del>安装 Android Studio</del></h3><p><del><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210317101415553.png" alt="image-20210317101415553"></del></p><p><del>运行 Android Studio，并进入 ‘Android Studio Setup Wizard’，这会安装最新的 Android SDK， Android SDK Platform-Tools 以及 Android SDK Build-Tools，这些都是在开发 Android Flutter 应用时所需要的。</del></p><p>记得sdk安装的目录！</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210317121537227.png" alt="image-20210317121537227"></p><p>一路y，最终。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210317121600734.png" alt="image-20210317121600734"></p><h2 id="flutter使用"><a href="#flutter使用" class="headerlink" title="flutter使用"></a>flutter使用</h2><p>如果你在国内使用 Flutter，那么你可能需要找一个与官方同步的可信的镜像站点，帮助你的 Flutter 命令行工具到该镜像站点下载其所需的资源。你需要为此设置两个环境变量：<code>PUB_HOSTED_URL</code> 和 <code>FLUTTER_STORAGE_BASE_URL</code>，然后再运行 Flutter 命令行工具。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PUB_HOSTED_URL&#x3D;https:&#x2F;&#x2F;pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL&#x3D;https:&#x2F;&#x2F;storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p>一些常用flutter指令</p><p>flutter creat 创建项目</p><p>进入项目根目录</p><p>flutter run</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210319194525325.png" alt="image-20210319194525325"></p><h2 id="Flutter应用模板"><a href="#Flutter应用模板" class="headerlink" title="Flutter应用模板"></a>Flutter应用模板</h2><ol><li>导入包。</li></ol><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此行代码作用是导入了Material UI组件库。<a href="https://material.io/guidelines/">Material (opens new window)</a>是一种标准的移动端和web端的视觉设计语言， Flutter默认提供了一套丰富的Material风格的UI组件。</p><ol><li>应用入口。</li></ol><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> main() =&gt; runApp(MyApp());</span><br></pre></td></tr></table></figure><ul><li>与C/C++、Java类似，Flutter 应用中<code>main</code>函数为应用程序的入口。<code>main</code>函数中调用了<code>runApp</code> 方法，它的功能是启动Flutter应用。<code>runApp</code>它接受一个<code>Widget</code>参数，在本示例中它是一个<code>MyApp</code>对象，<code>MyApp()</code>是Flutter应用的根组件。</li><li><code>main</code>函数使用了(<code>=&gt;</code>)符号，这是Dart中单行函数或方法的简写。</li></ul><ol><li>应用结构。</li></ol><ul><li><code>MyApp</code>类代表Flutter应用，它继承了 <code>StatelessWidget</code>类，这也就意味着应用本身也是一个widget。</li><li>在Flutter中，大多数东西都是widget（后同“组件”或“部件”），包括对齐(alignment)、填充(padding)和布局(layout)等，它们都是以widget的形式提供。</li><li>Flutter在构建页面时，会调用组件的<code>build</code>方法，widget的主要工作是提供一个build()方法来描述如何构建UI界面（通常是通过组合、拼装其它基础widget）。</li><li><code>MaterialApp</code> 是Material库中提供的Flutter APP框架，通过它可以设置应用的名称、主题、语言、首页及路由列表等。<code>MaterialApp</code>也是一个widget。</li><li><code>home</code> 为Flutter应用的首页，它也是一个widget。</li></ul><ol><li><p>首页 </p><p><code>MyHomePage</code> 是Flutter应用的首页，它继承自<code>StatefulWidget</code>类，表示它是一个有状态的组件（Stateful widget）。关于Stateful widget我们将在第三章“Widget简介”一节仔细介绍，现在我们只需简单认为有状态的组件（Stateful widget） 和无状态的组件（Stateless widget）有两点不同：</p><ol><li><p>Stateful widget可以拥有状态，这些状态在widget生命周期中是可以变的，而Stateless widget是不可变的。</p></li><li><p>Stateful widget至少由两个类组成：</p><ul><li>一个<code>StatefulWidget</code>类。</li><li>一个 <code>State</code>类； <code>StatefulWidget</code>类本身是不变的，但是<code>State</code>类中持有的状态在widget生命周期中可能会发生变化。</li></ul><p><code>_MyHomePageState</code>类是<code>MyHomePage</code>类对应的状态类。</p></li></ol></li></ol><h2 id="树莓派4B板载资源介绍"><a href="#树莓派4B板载资源介绍" class="headerlink" title="树莓派4B板载资源介绍"></a>树莓派4B板载资源介绍</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318112405257.png" alt="image-20210318112405257"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318112640216.png" alt="image-20210318112640216"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/21545108-38395d45b6e243d5.png" alt="img"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/c822fb58546d27deba8091a729ccf7d892b5b3a0.png@1320w_1110h.webp" alt="img"></p><h2 id="windows系统下vscode通过ssh远程树莓派"><a href="#windows系统下vscode通过ssh远程树莓派" class="headerlink" title="windows系统下vscode通过ssh远程树莓派"></a>windows系统下vscode通过ssh远程树莓派</h2><p><a href="https://code.visualstudio.com/docs/remote/ssh">https://code.visualstudio.com/docs/remote/ssh</a></p><ul><li><p>在树莓派系统的<code>applications menu</code>的<code>首选项</code>的<code>raspberry pi configuration</code>中<code>Interfaces</code>中开启<code>SSH</code>，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210528155231462.png" alt="image-20210528155231462"></p></li><li><p>修改树莓派的用户名，在<code>System</code>选项卡中查看<code>password</code>和<code>Hostname</code>，打开一个终端会话，您应该看到如下提示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi: ~ $</span><br></pre></td></tr></table></figure><p>在每个命令后都会看到的提示（pi @ raspberrypi：〜$）提醒您用户名User（pi）和计算机名HostName（raspberrypi）。 〜字符是您的主目录（/ home / pi）的简写。</p></li></ul><p>接着在客户端windows的vscode上，输入<code>F1</code>打开命令面板，输入<code>remote ssh connect to host</code>，选择<code>Configure SSH Hosts</code>. 再选择自己用户目录下.ssh文件夹下的config文件，进行配置，Host填ip地址。树莓派 Raspbian 系统默认的主机名HostName为 raspberrypi，这里我修改的为pi</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/]APMJ58}4YM%{JR9@E5PA0U.png" alt="img"></p><p>接着再进行Connect to host选择刚刚的10.0.1.83就可以连接到树莓派了。</p><p>如果还不成功，请删除known_hosts文件，<a href="https://www.huaweicloud.com/articles/85f8a5b26c2827208e44708b8c559e92.html">https://www.huaweicloud.com/articles/85f8a5b26c2827208e44708b8c559e92.html</a> 。</p><p>成功。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210528154606211.png" alt="image-20210528154606211"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210528161322051.png" alt="image-20210528161322051"></p><h2 id="使用PuTTY连接树莓派"><a href="#使用PuTTY连接树莓派" class="headerlink" title="使用PuTTY连接树莓派"></a>使用PuTTY连接树莓派</h2><p><a href="https://www.w3schools.com/nodejs/nodejs_raspberrypi.asp">https://www.w3schools.com/nodejs/nodejs_raspberrypi.asp</a></p><p>下载putty，查看树莓派右上角的ip。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210530120945956.png" alt="image-20210530120945956"></p><p>Hostname： pi</p><p>password : pi</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318160026149.png" alt=""></p><p><strong>You are now able to run your Raspberry Pi in “Headless-mode”, meaning you do not need a monitor or keyboard. And if you have a WiFi connection, you do not need a ethernet cable either, just the power cable!</strong></p><p>如果需要安装nodejs，可以继续参考上面的链接。</p><h2 id="用windows远程桌面连接树莓派，通过xrdp"><a href="#用windows远程桌面连接树莓派，通过xrdp" class="headerlink" title="用windows远程桌面连接树莓派，通过xrdp"></a>用<code>windows远程桌面</code>连接树莓派，通过xrdp</h2><p><a href="https://gitee.com/null_695_7527/raspberry_school_learning/tree/master/01.%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E5%87%86%E5%A4%87">https://gitee.com/null_695_7527/raspberry_school_learning/tree/master/01.%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E5%87%86%E5%A4%87</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318161025649.png" alt="image-20210318161025649"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210318161050426.png" alt="image-20210318161050426"></p><h2 id="使用flutter-pi运行flutter程序"><a href="#使用flutter-pi运行flutter程序" class="headerlink" title="使用flutter-pi运行flutter程序"></a>使用flutter-pi运行flutter程序</h2><p>在上文提到的，先在windows下开发应用，接着通过flutter-pi运行flutter程序。</p><p>首先需要安装flutter引擎二进制文件<a href="https://github.com/ardera/flutter-engine-binaries-for-arm">https://github.com/ardera/flutter-engine-binaries-for-arm</a> 。<strong>其中注意，在windows上开发的flutter SDK版本需要在stable模式下，并且需要和flutter-pi的版本一致。</strong></p><p>按照 <a href="https://github.com/ardera/flutter-pi">https://github.com/ardera/flutter-pi</a> 进行配置即可。</p><p>其中，可能会遇到显示频率的问题，安装触摸屏驱动来解决 <a href="https://github.com/raspberrypi/linux/issues/3777">https://github.com/raspberrypi/linux/issues/3777</a>     <a href="https://github.com/ardera/raspberrypi-fast-ts。">https://github.com/ardera/raspberrypi-fast-ts。</a></p><p>遇到该问题</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210530215143549.png" alt="image-20210530215143549"></p><p><a href="https://github.com/ardera/raspberrypi-fast-ts/issues/4#issue-782695302">https://github.com/ardera/raspberrypi-fast-ts/issues/4#issue-782695302</a> 按照该方法，</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210530215238779.png" alt="image-20210530215238779"></p><p>接着执行，遇到下面的结果，遇到警告，先不管它。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210530215306664.png" alt="image-20210530215306664"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210530215339440.png" alt="image-20210530215339440"></p><p>执行完毕。</p><h2 id="树莓派配置git镜像"><a href="#树莓派配置git镜像" class="headerlink" title="树莓派配置git镜像"></a>树莓派配置git镜像</h2><p>以下两个步骤建议都进行，此时在树莓派的环境下便可进行git操作。</p><ol><li><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/">https://mirrors.tuna.tsinghua.edu.cn/help/git-repo/</a></p></li><li><p>当需要树莓派连接到git仓库时，树莓派上配置git：设置用户标识、配置git服务器 <a href="https://blog.csdn.net/baiguoxiong/article/details/84874860">https://blog.csdn.net/baiguoxiong/article/details/84874860</a></p></li></ol><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;git-repo -o repo</span><br><span class="line">chmod +x repo</span><br></pre></td></tr></table></figure><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>repo的运行过程中会尝试访问官方的git源更新自己，如果想使用tuna的镜像源进行更新，可以将如下内容复制到你的<code>~/.bashrc</code>里</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export REPO_URL&#x3D;&#39;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;git&#x2F;git-repo&#39;</span><br></pre></td></tr></table></figure><p>并重启终端模拟器。</p><p>将代码输入Terminal中即可git clone下载。</p><p><strong>记得可以尝试通过ssh方式clone！</strong></p><p><strong>而在windows下</strong> </p><p><code>git config --list</code>查看已经配置好的信息</p><p>配置git socks5代理</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1081&#39; </span><br><span class="line">git config --global https.proxy &#39;socks5:&#x2F;&#x2F;127.0.0.1:1081&#39; </span><br></pre></td></tr></table></figure><h2 id="树莓派设置软件源镜像"><a href="#树莓派设置软件源镜像" class="headerlink" title="树莓派设置软件源镜像"></a>树莓派设置软件源镜像</h2><p>为什么叫<code>镜像</code>，是因为镜像站每隔一段时间（几分钟）便会使自己和国外源保持同步，维持和国外源一模一样的软件资源列表，就像照镜子一样。</p><p>软件源是指 debian 系操作系统的应用程序安装包仓库，很多的软件都会这收录到这个仓库里面。而树莓派的 raspberrypi 操作系统也是基于 debian 的，所以树莓派也有自己的软件源，用来收录各种树莓派应用程序。</p><p>默认情况下，树莓派软件源地址是 <a href="https://link.zhihu.com/?target=http%3A//archive.raspbian.org/">http://archive.raspbian.org/</a>，位于欧洲，在国内访问是非常慢的，经常只有几 k 每秒的下载速率。所以我们在玩转树莓派之前，强烈推荐替换成国内的软件源。</p><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/raspbian/">https://mirror.tuna.tsinghua.edu.cn/help/raspbian/</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 编辑 &#96;&#x2F;etc&#x2F;apt&#x2F;sources.list&#96; 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib rpi</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspbian&#x2F;raspbian&#x2F; buster main non-free contrib rpi</span><br><span class="line"></span><br><span class="line"># 编辑 &#96;&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;raspi.list&#96; 文件，删除原文件所有内容，用以下内容取代：</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;raspberrypi&#x2F; buster main ui</span><br></pre></td></tr></table></figure><h2 id="树莓派学习笔记——文件管理及常用命令"><a href="#树莓派学习笔记——文件管理及常用命令" class="headerlink" title="树莓派学习笔记——文件管理及常用命令"></a>树莓派学习笔记——文件管理及常用命令</h2><p><a href="https://blog.csdn.net/youngandyang/article/details/100042966?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/youngandyang/article/details/100042966?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo shutdown -h now</span><br></pre></td></tr></table></figure><p>ctrl+d 关闭终端。</p><p><a href="https://blog.csdn.net/weixin_43336281/article/details/97373288">https://blog.csdn.net/weixin_43336281/article/details/97373288</a></p><p><a href="https://www.jianshu.com/p/67b9e6ebf8a0">https://www.jianshu.com/p/67b9e6ebf8a0</a></p><p>检查包版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-cache policy libstdc++6</span><br></pre></td></tr></table></figure><p><strong>Sudo</strong> 的全称为：<strong>super user do</strong>。 顾名思义：干超级用户才能干的事！所以Sudo最常用的功能就是提升一个命名的执行权限。</p><p>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</p><p>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>apt 命令执行需要超级管理员权限(root)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt [options] [command] [package ...]</span><br></pre></td></tr></table></figure><ul><li><strong>options：</strong>可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li><li><strong>command：</strong>要进行的操作。</li><li><strong>package</strong>：安装的包名。</li></ul><p>apt 常用命令</p><ul><li><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p></li><li><p>升级软件包：<strong>sudo apt upgrade</strong></p><p>列出可更新的软件包及版本信息：<strong>apt list —upgradeable</strong></p><p>升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p></li><li><p>安装指定的软件命令：<strong>sudo apt install <package_name></strong></p><p>安装多个软件包：<strong>sudo apt install <package_1> <package_2> <package_3></strong></p></li><li><p>更新指定的软件命令：<strong>sudo apt update <package_name></strong></p></li><li><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show <package_name></strong></p></li><li><p>删除软件包命令：<strong>sudo apt remove <package_name></strong></p></li><li><p>清理不再使用的依赖和库文件: <strong>sudo apt autoremove</strong></p></li><li><p>移除软件包及配置文件: <strong>sudo apt purge <package_name></strong></p></li><li><p>查找软件包命令： <strong>sudo apt search <keyword></strong></p></li><li><p>列出所有已安装的包：<em>*apt list —install</em>ed*</p></li><li><p>列出所有已安装的包的版本信息：<strong>apt list —all-versions</strong></p></li></ul><h2 id="安装node和npm"><a href="#安装node和npm" class="headerlink" title="安装node和npm"></a>安装node和npm</h2><p><a href="https://zhuanlan.zhihu.com/p/127757097">https://zhuanlan.zhihu.com/p/127757097</a></p><p>npm更换国内源。</p><p>npm install :每一个node项目都有一个package.json文件，里面有很多组件信息</p><p>使用npm install将按照package.json安装所需要的组件放在生成的node_modules文件夹中</p><p>rn项目下的每一个文件中都可以通过import引入node_modules的组件来加以使用</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>利用gitee来clone <a href="https://blog.csdn.net/u011386173/article/details/109099134?spm=1001.2014.3001.5501">https://blog.csdn.net/u011386173/article/details/109099134?spm=1001.2014.3001.5501</a></p><p>Flutter开发 - 卡在 Running “flutter pub get” in xxx <a href="https://www.jianshu.com/p/fe1354db42b2">https://www.jianshu.com/p/fe1354db42b2</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210322093157733.png" alt="image-20210322093157733"></p><p>windows下设置git代理 <a href="https://blog.csdn.net/qq_29545715/article/details/103576549">https://blog.csdn.net/qq_29545715/article/details/103576549</a></p>]]></content>
      
      
      <categories>
          
          <category> flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raspberrypi </tag>
            
            <tag> flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第16篇博客】DNS解析及浏览器渲染流程</title>
      <link href="2021/03/12/blog16-DNS/"/>
      <url>2021/03/12/blog16-DNS/</url>
      
        <content type="html"><![CDATA[<h2 id="DNS解析（域名解析）"><a href="#DNS解析（域名解析）" class="headerlink" title="DNS解析（域名解析）"></a>DNS解析（域名解析）</h2><p>今天是遇到我换github博客域名的时候的一个问题，总是自动跳转访问旧的那个网址。带着这个问题，今天就来记录一下。</p><p>当一个用户在地址栏输入www.taobao.com 时，<strong>DNS（Domain Names Service）</strong>解析有大致十个过程，如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20171211190812796" alt="img"></p><ol><li>浏览器先检查<code>自身缓存</code>中有没有这个域名被解析过对应的ip地址，如果有，解析结束。同时域名被缓存的时间也可通过TTL属性来设置。缓存就是把你之前访问的web资源，比如一些js，css，图片什么的保存在你本机的内存或者磁盘当中。（在图中访问用户的计算机中）。</li><li>如果浏览器缓存中没有（专业点叫还没命中），浏览器会检查操作<code>系统缓存</code>中有没有对应的已解析过的结果。而操作系统也有一个域名解析的过程。在windows中可通过c盘里一个叫hosts的文件来设置，如果你在这里指定了一个域名对应的ip地址（我的第3篇博客中有提到），那浏览器会首先使用这个ip地址。（在图中访问用户的计算机中）</li><li>如果至此还没有命中域名，才会真正请求<code>本地域名服务器（LDNS）</code>来解析这个域名，这台服务器一般在你的城市的某个角落，距离你不会很远，并且这台服务器的性能都很好，一般都会缓存域名解析结果，大约80%的域名解析到这里就完成了。</li><li>如果LDNS仍然没有命中，就直接跳到Root Server <code>根域名服务器</code>请求解析。</li><li><code>根域名服务器</code>返回给LDNS一个所查询域的<code>主域名服务器</code>（gTLD Server，国际顶尖域名服务器，如.com .cn .org等）地址。</li><li>此时LDNS再发送请求给上一步返回的gTLD。</li><li>接受请求的gTLD查找并返回这个域名对应的<code>Name Server</code>的地址，这个Name Server就是网站注册的<code>域名服务器</code>。</li><li>Name Server根据映射关系表找到目标ip，返回给LDNS。</li><li>LDNS缓存这个域名和对应的ip。</li><li>LDNS把解析的结果返回给用户，用户根据TTL值缓存到本地系统缓存中，域名解析过程至此结束。</li></ol><p><strong>总结：</strong></p><p><strong>DNS解析:域名到IP地址的转换过程。</strong></p><p><strong>域名的解析工作由DNS服务器完成。</strong></p><p><strong>解析后可以获取域名相应的IP地址，发送http请求。</strong></p><h2 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h2><p>在域名解析之后，浏览器向服务器发起了http请求，<strong>tcp连接，三次握手</strong>建立tcp连接。TCP协议是面向连接的，所以在传输数据前必须建立连接。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20190819151449989.png" alt="img"></p><ol><li>客户端向服务器发送连接请求报文； </li><li>服务器端接受客户端发送的连接请求后后回复ACK报文，并为这次连接分配资源。</li><li>客户端接收到ACK报文后也向服务器端发生ACK报文，并分配资源。</li></ol><p>这样TCP连接就建立了。</p><p>在此之后，浏览器开始向服务器发送http请求，请求数据包。请求信息包含一个头部和一个请求体。</p><h2 id="服务器收到请求"><a href="#服务器收到请求" class="headerlink" title="服务器收到请求"></a>服务器收到请求</h2><p>服务器收到浏览器发送的请求信息，返回一个响应头和一个响应体。</p><h2 id="浏览器页面渲染流程（Renderer-Process）"><a href="#浏览器页面渲染流程（Renderer-Process）" class="headerlink" title="浏览器页面渲染流程（Renderer Process）"></a>浏览器页面渲染流程（Renderer Process）</h2><p>浏览器从HTTP服务器获取html文档，核心任务就是把html、css、js、image等资源渲染成用户可以交互的web页面。渲染器进程的主线程将html进行解析，构造DOM数据结构，DOM也就是文档对象模型，是浏览器对页面在其内部的表示形式，是web开发者可以通过JS与之交互的数据结构和API。</p><p>html首先经过Tokeniser标记化，通过词法分析将输入的html内容解析成多个<code>标记</code>，根据识别后的标记进行<code>DOM树</code>构造。</p><p>html代码中往往会引入一些额外的<code>资源</code>，比如图片、css、js脚本等，前两个需要通过网络下载或者从缓存中直接加载，这些资源不会阻塞html的解析，因为他们不会阻塞dom的生成。但当html解析过程中遇到script标签，将停止html解析流程，转而去解析并且执行JS。</p><p>在确定了DOM树之后，接下来需要主线程<code>解析CSS</code>，确定每个DOM节点的计算样式（<code>style</code>）。</p><p>接下来需要确定每个节点需要放在页面的哪个位置，也就是节点的坐标和区域，该阶段被称为layout<code>布局</code>，主线程生成layout tree，与最后显示在屏幕上的节点对应。</p><p>为了保证在屏幕上显示正确的层级，主线程遍历layout tree创建一个绘制记录表（<code>Paint</code> Record），该表记录了绘制的顺序，该阶段被称为<code>绘制</code>。   </p><p>终于到了该把这些信息转化为像素点，显示在屏幕上，该过程称为<code>栅格化</code>（Rastering），由合成器线程负责。</p><p>参考：</p><p><a href="https://blog.csdn.net/m0_37812513/article/details/78775629?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/m0_37812513/article/details/78775629?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p><p><a href="https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.-1">https://www.bilibili.com/video/BV1x54y1B7RE/?spm_id_from=333.788.recommend_more_video.-1</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第15篇博客】使用新的免费短域名</title>
      <link href="2021/03/11/blog15-NewDomain/"/>
      <url>2021/03/11/blog15-NewDomain/</url>
      
        <content type="html"><![CDATA[<h2 id="注册freenom免费域名"><a href="#注册freenom免费域名" class="headerlink" title="注册freenom免费域名"></a>注册freenom免费域名</h2><p><a href="https://www.freenom.com/en/index.html">https://www.freenom.com/en/index.html</a></p><p>我们熟知的免费域名，有.tk，.ml，.cf。.tk域名是南太平洋岛国托克劳的顶级域名，.ml则是马里的顶级域名，.cf则是中非共和国的域名，不过搜索引擎基本上已经不收录了，虽然这些域名和.cn其实没什么区别。以前这些免费域名都是分开注册的，后来都被托管到了freenom，更加方便大家的注册。不过先在freenom也办法直接注册了，当你注册的时候会显示如下:</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210311231105623.png" alt="image-20210311231105623"></p><p>建议先用google登录！然后寻找自己想要的域名。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210311231131960.png" alt="image-20210311231131960"></p><p>接着去结账</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20210311232743765.png" alt="image-20210311232743765"></p><p>接下来可以看到自己已经申请成功。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210311232920762.png" alt="image-20210311232920762"></p><p>接下来选择我们要设置的域名，比如说.tk，点击manage domain。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313211509151.png" alt="image-20210313211509151"></p><p>后续需要先进行Cloudflare方面的设置。</p><h2 id="Cloudflare"><a href="#Cloudflare" class="headerlink" title="Cloudflare"></a>Cloudflare</h2><p><a href="https://dash.cloudflare.com/">https://dash.cloudflare.com/</a></p><p>登录后添加站点</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313212659363.png" alt="image-20210313212659363"></p><p>选择0美元的继续</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/img/image-20220313223551976.png" alt="image-20220313223551976"></p><p>接下来进行添加DNS记录</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313212840605.png" alt="image-20210313212840605"></p><p>添加2条类型为CNAME的记录，名称分别为@和www，分别进行保存，如下</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313213144831.png" alt="image-20210313213144831"></p><p>接下来显示我们还需要做的事情，就是到我们的注册机构，也就是freenom中更改名称服务器。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313213309448.png" alt="image-20210313213309448"></p><p>回到freenom设置我们的<strong><code>名称服务器</code></strong>。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313213521211.png" alt="image-20210313213521211"></p><p>再回到cloudflare中，进行检查。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313213631282.png" alt="image-20210313213631282"></p><p>是的，接下来就收到了邮件。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313222840472.png" alt="image-20210313222840472"></p><p>回到cloudflare</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313222942285.png" alt="image-20210313222942285"></p><h2 id="Github仓库Settings"><a href="#Github仓库Settings" class="headerlink" title="Github仓库Settings"></a>Github仓库Settings</h2><p>找到GitHub Pages项。</p><p>输入刚才申请的域名如<code>tsuiwade.tk</code>，点击保存。下面那个HTTPS证书会在你保存域名后自动帮你申请，不过可能最长需要24小时才能申请成功。</p><p>如果上面的步骤都完成后，等待一会，在浏览器的地址栏输入新增域名，应该就可以跳转到你的博客页面了。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210311233633554.png" alt="image-20210311233633554"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313223613784.png" alt="image-20210313223613784"></p><h2 id="本地CNAME文件"><a href="#本地CNAME文件" class="headerlink" title="本地CNAME文件"></a>本地CNAME文件</h2><p>这是困扰了我很多天的问题，在于每当我重新提交代码的时候，我的博客仓库中的站点域名又被清空为原先的.github.io域名，而非自己在<code>Custom domain</code>中填写的其他域名。</p><p>如果需要将域名指向另一个域名，再由另一个域名提供 IP 地址，就需要添加 CNAME 记录。</p><p>A记录是解析域名到IP，CNAME是解析域名到另外一个域名。</p><p><strong>A记录</strong></p><p>A记录，即Address记录，它并不是一个IP或者一个域名，我们可以把它理解为一种指向关系：域名 <a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 111.111.111.111 主机名 DD → 222.222.222.222</p><p>也就是当你访问这些域名或者主机名的时候，DNS服务器上会通过A记录会帮你解析出相应的IP地址，以达到后续访问目的。所以A记录是IP解析，直接将域名或主机名指向某个IP。</p><p><strong>CNAME</strong></p><p>CNAME记录，也叫别名记录，相当于给A记录中的域名起个小名儿，比如<a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a>的小名儿就叫<a href="https://link.zhihu.com/?target=http%3A//www.yy.com">http://www.yy.com</a>好了，然后CNAME记录也和A记录一样，是一种指向关系，把小名儿<a href="https://link.zhihu.com/?target=http%3A//www.yy.com">http://www.yy.com</a>指向了<a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a>，然后通过A记录，<a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a>又指向了对应的IP：</p><p><a href="https://link.zhihu.com/?target=http%3A//www.yy.com">http://www.yy.com</a> → <a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 111.111.111.111</p><p>这样一来就能通过它的小名儿直接访问111.111.111.111了。</p><p>这时候有人问：这不多了一步嘛，不嫌麻烦？</p><p>假如这个时候我又想给原域名取几个小名儿，分别叫<a href="https://link.zhihu.com/?target=http%3A//www.cc.com">http://www.cc.com</a>和<a href="https://link.zhihu.com/?target=http%3A//www.kk.com">http://www.kk.com</a>那么存在下列指向关系：</p><p><a href="https://link.zhihu.com/?target=http%3A//www.yy.com">http://www.yy.com</a> → <a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 111.111.111.111</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cc.com">http://www.cc.com</a> → <a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 111.111.111.111</p><p><a href="https://link.zhihu.com/?target=http%3A//www.kk.com">http://www.kk.com</a> → <a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 111.111.111.111</p><p>突然服务器的IP地址因为一些不可描述的原因要换了，不再是111.111.111.111了，换成了333.333.333.333，这时候你发现，只要把<a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a>的指向修改一下即可：</p><p>域名 <a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 333.333.333.333</p><p>这时候你又发现了，原来他的小名儿不需要做更改，直接就能访问服务器，因为他们都只指向了<a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a>，服务器IP改没改它们不管</p><p>那么假如不用CNAME，直接做A记录会怎样？</p><p><a href="https://link.zhihu.com/?target=http%3A//www.yy.com">http://www.yy.com</a> → 111.111.111.111</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cc.com">http://www.cc.com</a> → 111.111.111.111</p><p><a href="https://link.zhihu.com/?target=http%3A//www.xx.com">http://www.xx.com</a> → 111.111.111.111</p><p><a href="https://link.zhihu.com/?target=http%3A//www.kk.com">http://www.kk.com</a> → 111.111.111.111</p><p>那么当111.111.111.111更改的时候，全部相关A记录指向关系都要做更改，这才叫麻烦…</p><p>因此我们这边，实际上指向的关系是，tsuiwade.ml域名指向tsuiwade.github.io，当访问ml时，DNS商回把这个这个请求解析发到github去，github内部进行处理，那么github要如何知道它应该响应哪个仓库的内容回去呢？是根据你在仓库Gitpages设置的自定义域名，来给你响应对应仓库的静态内容。</p><p><strong>CNAME的应用</strong></p><p>比较多的是用在CDN加速上</p><p>举个CDN的栗子 ：假如你是DD公司老板，你公司中的一台IP为1.1.1.1的服务器，注册了域名为<a href="https://link.zhihu.com/?target=http%3A//www.dd.com">http://www.dd.com</a>，要对外提供客户访问。随着公司越做越大，访问量也越来越多，服务器顶不住了，你去找CDN提供商购买CDN加速服务，这个时候他们要求你的域名做个CNAME指向他们给你的一个域名叫<a href="https://link.zhihu.com/?target=http%3A//www.xdd.com">http://www.xdd.com</a>，当用户访问<a href="https://link.zhihu.com/?target=http%3A//www.dd.com">http://www.dd.com</a>的时候，本地DNS会获得CDN提供的CNAME域名：<a href="https://link.zhihu.com/?target=http%3A//www.xdd.com">http://www.xdd.com</a>，然后再次向DNS调度系统发出请求，通过DNS调度系统的智能分析，把这个<a href="https://link.zhihu.com/?target=http%3A//www.xdd.com">http://www.xdd.com</a>指向一个（离用户地理位置最近的）CDN提供商的服务器IP，让用户就近取到想要的资源（如访问网站），大大降低了延迟。</p><hr><p>解决方法就是在博客文件的source目录下，新增一个CNAME文件，注意全大写，并且没有文件后缀。CNAME中写：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsuiwade.tk</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313223738438.png" alt="image-20210313223738438"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313163741297.png" alt="image-20210313163741297"></p><p>最后可以在公开的博客仓库的master分支下，看到新增了CNAME文件，并且setting中的站点域名是我所设置的。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313154745903.png" alt="image-20210313154745903"></p><p> source 文件夹，实质上才是你发布时候使用的根目录，你项目的根目录，只是开发的时候的根目录而已。hexo build 的时候，会将 source 目下下的内容进行一次拷贝，如果放在项目根目录下的话，文件并不会存在于构建输出的目录里。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313160408176.png" alt="image-20210313160408176"></p><p>参考：<a href="https://blog.csdn.net/xs20691718/article/details/81873921">https://blog.csdn.net/xs20691718/article/details/81873921</a></p><h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p>我前面使用的是.ml后缀的域名，后来再输入github.io的时候，会自动跳转到ml，导致问题。后来打开浏览器设置选项，清空用户的缓存文件和cookies即可。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210313112617249.png" alt="image-20210313112617249"></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> cloudflare </tag>
            
            <tag> freenom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第14篇博客】带上gitee，双线部署</title>
      <link href="2021/03/09/blog14-gitee/"/>
      <url>2021/03/09/blog14-gitee/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍如何单一使用gitee博客，后面会考虑介绍多线部署多个博客。</p><h2 id="新建gitee仓库"><a href="#新建gitee仓库" class="headerlink" title="新建gitee仓库"></a>新建gitee仓库</h2><p>尽量仓库名称与用户名保持一致。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310095306299.png" alt="image-20210310095306299"></p><p><code>请复制生成token</code>、因为只会生成一次，请及时粘贴保存。如果忘记了、记得重新生成。</p><h2 id="hexo配置文件修改"><a href="#hexo配置文件修改" class="headerlink" title="hexo配置文件修改"></a>hexo配置文件修改</h2><p>复制URL，到hexo的配置文件<code>_config.yml</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">https://tsuiwade.gitee.io/</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://gitee.com/tsuiwade/tsuiwade</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h2 id="gitee部署"><a href="#gitee部署" class="headerlink" title="gitee部署"></a>gitee部署</h2><p>接下来在根目录输入<code>hexo d</code>进行部署，然后如图，输入自己的信息。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310100652160.png" alt="image-20210310100652160"></p><h2 id="gitee设置"><a href="#gitee设置" class="headerlink" title="gitee设置"></a>gitee设置</h2><p>部署完可以回到gitee仓库上看看：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310100849780.png" alt="image-20210310100849780"></p><p>此时gitee仓库上已经有了内容，再点击服务——pages：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310100930745.png" alt="image-20210310100930745"></p><p>在master分支下，点击更新，等待部署完即可访问自己的网址。<a href="https://tsuiwade.gitee.io/">https://tsuiwade.gitee.io</a></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310101015487.png" alt="image-20210310101015487"></p><h2 id="如何更新部署"><a href="#如何更新部署" class="headerlink" title="如何更新部署"></a>如何更新部署</h2><p>gitee并不像github可以自动化部署，因为 Gitee 的自动部署属于 Gitee Pages Pro 的服务，不可通过git add . &amp;&amp; git commit .. &amp;&amp; git push三连提交代码。。</p><p>而是必须hexo cl &amp;&amp; hexo g &amp;&amp; hexo d来提交代码。</p><p>请注意，必须先hexo cl 。</p><p>此时网站已经搭建好了，访问速度也快许多。</p><hr><p>当然，我们不会满足于此。</p><p>是否有一种方法，只需我同样适用git三连进行提交代码，而可以同时部署到github.io和gitee.io上。</p><h2 id="创建github私有仓库"><a href="#创建github私有仓库" class="headerlink" title="创建github私有仓库"></a>创建github私有仓库</h2><p>我们需要一个<code>私有仓库</code>用来存放 Hexo 的源文件、用来执行 Action</p><p>比如我这里创建的仓库名为<code>aacitons</code>，并且设置为私有。</p><h2 id="生成-Github-Token"><a href="#生成-Github-Token" class="headerlink" title="生成 Github Token"></a>生成 Github Token</h2><p>为确保 <code>hexo d</code> 有足够的访问权限、我们需要创建 token</p><p>因为我需要同时部署到 Github 和 Gitee 上、就需要生成三个 token (<code>你可以选择你需要的来创建</code>)</p><p>进入 <a href="https://github.com/">Github</a> 、点击<code>头像 -&gt; Settings</code>。找到 <code>Developer settings</code>。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310203522099.png" alt="image-20210310203522099"></p><p>点击 <code>Personal access tokens</code>，点击 <code>Generate new token</code></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310203818764.png" alt="image-20210310203818764"></p><p>名字随便取、一定要勾选 <code>repo</code></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310203917310.png" alt="image-20210310203917310"></p><p><code>请复制生成token</code>、因为只会生成一次，请及时粘贴保存。如果忘记了、记得重新生成。</p><h2 id="生成-Gitee-Token"><a href="#生成-Gitee-Token" class="headerlink" title="生成 Gitee Token"></a>生成 Gitee Token</h2><p>进入 <a href="https://gitee.com/">Gitee</a> 、 点击<code>头像 -&gt; 设置</code></p><p>点击<code>安全设置 -&gt; 私人令牌</code></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310204213.png" alt=""></p><h2 id="编辑-config-yml"><a href="#编辑-config-yml" class="headerlink" title="编辑 _config.yml"></a>编辑 _config.yml</h2><p>编辑根目录下的 <code>_config.yml</code> </p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">gitee:</span> <span class="string">https://tsuiwade:稍短的那个token@gitee.com/tsuiwade/tsuiwade.git</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">https://tsuiwade:稍长的那个token@github.com/tsuiwade/tsuiwade.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h2 id="配置-Github-Action"><a href="#配置-Github-Action" class="headerlink" title="配置 Github Action"></a>配置 Github Action</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310204610996.png" alt="image-20210310204610996"></p><p>里面写 Github Actions 的配置内容：</p><p>当然下面的部分内容需要根据自己配置如：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">自动部署</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">检查分支</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">main</span>  <span class="comment"># 需要注意，改为自己所在的本地分支，同样也需要和远程分支对应。本地仓库为main，远程仓库也为main。</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Node</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&quot;12.x&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装</span> <span class="string">Hexo</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">缓存依赖</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v1</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">cache</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">node_modules</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">安装依赖</span></span><br><span class="line">        <span class="attr">if:</span> <span class="string">steps.cache.outputs.cache-hit</span> <span class="type">!=</span> <span class="string">&#x27;true&#x27;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">--save</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">生成静态文件</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">generate</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">部署</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;tsuiwade&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;478451541@qq.com&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">clone</span> <span class="string">https://github.com/tsuiwade/tsuiwade.github.io.git</span> <span class="string">.deploy_git</span> </span><br><span class="line">          <span class="string">hexo</span> <span class="string">deploy</span></span><br><span class="line">       <span class="comment"># 注意上面git clone后的仓库为前文新建的私有仓库。</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">同步到</span> <span class="string">Gitee</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">wearerequired/git-mirror-action@master</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY</span></span><br><span class="line">          <span class="attr">SSH_PRIVATE_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_RSA_PRIVATE_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 GitHub 源仓库地址</span></span><br><span class="line">          <span class="attr">source-repo:</span> <span class="string">&quot;git@github.com:tsuiwade/tsuiwade.github.io.git&quot;</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 目标仓库地址</span></span><br><span class="line">          <span class="attr">destination-repo:</span> <span class="string">&quot;git@gitee.com:tsuiwade/tsuiwade.git&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">构建</span> <span class="string">Gitee</span> <span class="string">Pages</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">yanglbme/gitee-pages-action@master</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 用户名</span></span><br><span class="line">          <span class="attr">gitee-username:</span> <span class="string">tsuiwade</span></span><br><span class="line">          <span class="comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD</span></span><br><span class="line">          <span class="attr">gitee-password:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITEE_PASSWORD</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="comment"># 注意替换为你的 Gitee 仓库</span></span><br><span class="line">          <span class="attr">gitee-repo:</span> <span class="string">tsuiwade/tsuiwade</span></span><br></pre></td></tr></table></figure><h2 id="私有仓库的秘钥设置"><a href="#私有仓库的秘钥设置" class="headerlink" title="私有仓库的秘钥设置"></a>私有仓库的秘钥设置</h2><p>在私有仓库内配置</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310205206849.png" alt="image-20210310205206849"></p><p>需要新建仓库的2个秘钥，键分别是<code>GITEE_PASSWORD</code>和<code>GITEE_RSA_PRIVATE_KEY</code>，而值分别是<code>gitee账号的密码</code>和<code>.ssh/id_rsa</code>文件内的内容（文件格式如图）。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310205255600.png" alt="image-20210310205255600"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310205547221.png" alt="image-20210310205547221"></p><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><p>在博客根目录 [Blogroot] 下启动终端，使用 git 指令重设仓库地址。这样在新建仓库，我们仍旧可以保留珍贵的 commit history，便于版本回滚。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote rm origin <span class="comment"># 删除原有仓库链接</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:[GithubUsername]/[SourceRepo].git <span class="comment">#[SourceRepo]为新的存放源码的github私有仓库</span></span><br><span class="line"><span class="comment"># 如 git remote add origin  git@github.com:tsuiwade/aactions.git</span></span><br><span class="line"></span><br><span class="line">git checkout -b master <span class="comment"># 切换到master分支，</span></span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br><span class="line"><span class="comment"># 如果不是，后面的所有设置的分支记得保持一致</span></span><br><span class="line"><span class="comment"># 2020年10月以后，新建仓库的默认分支换成main</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action update&quot;</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="comment">#2020年10月后github新建仓库默认分支改为main，注意更改</span></span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310205907653.png" alt="image-20210310205907653"></p><p>倘若在此出了错，提交的分支名和仓库名。</p><p>最终可以在github新建私有仓库内看到actions成功。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210310210306406.png" alt="image-20210310210306406"></p><p>主要参考：<a href="https://blog.zykjofficial.top/posts/ea8e8e59/">https://blog.zykjofficial.top/posts/ea8e8e59/</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第13篇博客】github贡献日历上画画及博客首页显示gitcalendar</title>
      <link href="2021/03/07/blog13-githubpaint/"/>
      <url>2021/03/07/blog13-githubpaint/</url>
      
        <content type="html"><![CDATA[<h2 id="gitcalendar魔改效果"><a href="#gitcalendar魔改效果" class="headerlink" title="gitcalendar魔改效果"></a>gitcalendar魔改效果</h2><p>由于我是新人，号是新号，github贡献日历基本都挤在右边，看上去确实囊中羞涩、乏善可陈，于是想为加上一些图案，正好看到前人有过类似魔改记录，于是重新走了一遍，首先先来看一下效果。</p><p>github首页效果：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308010618267.png" alt="image-20210308010618267"></p><p>博客首页效果：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308010559971.png" alt="image-20210308010559971"></p><h2 id="github图案绘制"><a href="#github图案绘制" class="headerlink" title="github图案绘制"></a>github图案绘制</h2><ol><li><p>首先感谢<a href="https://github.com/qinshuang1998">qinshuang1998</a>大神的开源项目<a href="https://github.com/qinshuang1998/GithubPainter">GithubPainter</a> ，在本地新建一个空文件夹，例如我在桌面上打开<code>git bash here</code>。下载该项目，得到如下图文件。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;qinshuang1998&#x2F;GithubPainter.git  </span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308002030166.png" alt="image-20210308002030166"></p></li><li><p>打开文件<code>./designer/index.html</code>，这一个用html写的designer设计器，打开后会生成一个和Github一模一样的贡献板，你可以通过在上面点击鼠标来控制格子的颜色，进行绘制图案，如我选择的图案。</p><p>注意，应先选择结束日期，在自己的github首页上看看最后一天对应哪天，再选择开始日期，也需要在github贡献日历上看看左上角是哪天，对应起来。</p><p>接着进行绘制图案，如我选择的图案，点击一下是最浅色，多点击则变深，请各位耐心绘制自己喜欢的图案。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308010536931.png" alt="image-20210308010536931"></p></li><li><p>图案绘制完毕，导出为map.qs文件，替换上图路径下的同名文件。</p></li></ol><h2 id="github仓库创建"><a href="#github仓库创建" class="headerlink" title="github仓库创建"></a>github仓库创建</h2><p>在github上创建新仓库，我命名为<code>githubpaint</code>。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308005534216.png" alt="image-20210308005534216"></p><p>然后在刚刚<code>C:\Users\tsui\Desktop\GithubPainter-master\GithubPainter-master</code>路径下打开<code>git bash</code>，将自己的<code>githubpaint</code>项目clone下来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:tsuiwade&#x2F;githubpaint.git</span><br></pre></td></tr></table></figure><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308005921760.png" alt="image-20210308005921760"></p><p>因此在<code>C:\Users\tsui\Desktop\GithubPainter-master\GithubPainter-master</code>路径下生成了<code>githubpaint</code>文件夹。</p><h2 id="commit脚本"><a href="#commit脚本" class="headerlink" title="commit脚本"></a>commit脚本</h2><p>接着执行python文件，用commit.py的python脚本读取它，并对本地的Git仓库进行commit操作就好了（脚本中的文件路径等参数需要自己改动，包括本地仓库文件githubpaint和图案文件）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">repo = Repo(<span class="string">&#x27;./githubpaint&#x27;</span>)</span><br></pre></td></tr></table></figure><p>注意，这里的<code>git</code>模块是<code>GitPython</code>模块，通过<code>pip install gitpython</code>或<code>conda install gitpython</code>进行安装。GitPython块python用来封装git操作的模块，主要用来替代gitbash的操作。</p><p>不报错运行完即是成功运行。</p><h2 id="git-push提交"><a href="#git-push提交" class="headerlink" title="git push提交"></a>git push提交</h2><p>运行完成后将你的本地仓库push即可，在本地仓库githubpaint路径下git push，就可大功告成了。此时查看你的github首页，就不那么囊中羞涩、乏善可陈，反而有趣新奇，甚好甚好。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308004353339.png" alt="image-20210308004353339"></p><h2 id="hexo-github-calendar使用"><a href="#hexo-github-calendar使用" class="headerlink" title="hexo-github-calendar使用"></a>hexo-github-calendar使用</h2><p>hexo api 文档可参考<a href="https://zfe.space/post/hexo-githubcalendar.html">https://zfe.space/post/hexo-githubcalendar.html</a> 。</p><p>一键部署：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-githubcalendar --save</span><br></pre></td></tr></table></figure><p>网站根目录_config配置项(不是主题的)： 例如butterfly配置为</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ice Kano Plus_in</span></span><br><span class="line"><span class="comment"># Hexo Github Canlendar</span></span><br><span class="line"><span class="comment"># Author: Ice Kano</span></span><br><span class="line"><span class="comment"># Modify: Lete乐特</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># butterfly</span></span><br><span class="line"><span class="attr">githubcalendar:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable_page:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">zfour</span></span><br><span class="line">  <span class="attr">layout:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">id</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">recent-posts</span></span><br><span class="line">    <span class="attr">index:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">githubcalendar_html:</span> <span class="string">&#x27;&lt;div class=&quot;recent-post-item&quot; style=&quot;width:100%;height:auto;padding:10px;&quot;&gt;&lt;div id=&quot;github_loading&quot; style=&quot;width:10%;height:100%;margin:0 auto;display: block&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;  viewBox=&quot;0 0 50 50&quot; style=&quot;enable-background:new 0 0 50 50&quot; xml:space=&quot;preserve&quot;&gt;&lt;path fill=&quot;#d0d0d0&quot; d=&quot;M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z&quot; transform=&quot;rotate(275.098 25 25)&quot;&gt;&lt;animateTransform attributeType=&quot;xml&quot; attributeName=&quot;transform&quot; type=&quot;rotate&quot; from=&quot;0 25 25&quot; to=&quot;360 25 25&quot; dur=&quot;0.6s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animateTransform&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/div&gt;&lt;div id=&quot;github_container&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">  <span class="attr">pc_minheight:</span> <span class="string">280px</span></span><br><span class="line">  <span class="attr">mobile_minheight:</span> <span class="string">0px</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;[&#x27;#ebedf0&#x27;, &#x27;#fdcdec&#x27;, &#x27;#fc9bd9&#x27;, &#x27;#fa6ac5&#x27;, &#x27;#f838b2&#x27;, &#x27;#f5089f&#x27;, &#x27;#c4067e&#x27;, &#x27;#92055e&#x27;, &#x27;#540336&#x27;, &#x27;#48022f&#x27;, &#x27;#30021f&#x27;]&quot;</span></span><br><span class="line">  <span class="attr">api:</span> <span class="string">https://python-github-calendar-api.vercel.app/api</span></span><br><span class="line">  <span class="comment"># api: https://python-gitee-calendar-api.vercel.app/api</span></span><br><span class="line">  <span class="attr">calendar_js:</span> <span class="string">https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js</span></span><br><span class="line">  <span class="attr">plus_style:</span> <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>接下来来简单说明一下配置项的含义：</p><ol><li><p><strong>enable</strong></p><p><strong>参数：</strong>true/false<br><strong>含义：</strong>是否开启插件</p></li><li><p><strong>enable_page</strong></p><p><strong>参数：</strong>/<br><strong>含义：</strong>路由地址，如 / 代表主页。/me/代表自我介绍页等等</p></li><li><p><strong>user</strong></p><p><strong>参数：</strong>zfour<br><strong>含义：</strong>你的 github 或者 gitee 用户名</p></li></ol><ol><li><p><strong>layout</strong></p><p><strong>参数：</strong>type; （class&amp;id）<br><strong>参数：</strong>name;<br><strong>参数：</strong>index；（数字）<br><strong>含义：</strong>如果说 gihubcalendar 是一幅画，那么这个 layout 就是指定了哪面墙来挂画<br>而在 HTML 的是世界里有两种墙分别 type 为 id 和 class。<br>其中在定义 class 的时候会出现多个 class 的情况，这时就需要使用 index，确定是哪一个。<br>最后墙的名字即是 name;</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">&quot;我是墙&quot;</span> <span class="attr">id</span>=<span class="string">&quot;recent-posts&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- id=&gt;type  recent-posts=&gt;name    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">&quot;我是画框&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">&quot;我是纸&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--这里通过js挂载githubcalendar，也就是画画--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><h3 id="githubcalendar-html"><a href="#githubcalendar-html" class="headerlink" title="githubcalendar_html"></a><strong>githubcalendar_html</strong></h3><p><strong>参数：</strong>html 模板字段<br><strong>含义：</strong>包含 loading，和挂载容器</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;recent-post-item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;height:auto;padding:10px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--这个是画框，顾名思义就是借用文章样式给加个框--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--这个是loading的样式，可自行调整--&gt;</span></span><br><span class="line">  &lt;div</span><br><span class="line">    id=&quot;github_loading&quot;</span><br><span class="line">    style=&quot;width:10%;height:100%;margin:0 auto;display: block&quot;</span><br><span class="line">  &gt;</span><br><span class="line">    &lt;svg</span><br><span class="line">      xmlns=&quot;http://www.w3.org/2000/svg&quot;</span><br><span class="line">      xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;</span><br><span class="line">      viewBox=&quot;0 0 50 50&quot;</span><br><span class="line">      style=&quot;enable-background:new 0 0 50 50&quot;</span><br><span class="line">      xml:space=&quot;preserve&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;path</span><br><span class="line">        fill=&quot;#d0d0d0&quot;</span><br><span class="line">        d=&quot;M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z&quot;</span><br><span class="line">        transform=&quot;rotate(275.098 25 25)&quot;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;animateTransform</span><br><span class="line">          attributeType=&quot;xml&quot;</span><br><span class="line">          attributeName=&quot;transform&quot;</span><br><span class="line">          type=&quot;rotate&quot;</span><br><span class="line">          from=&quot;0 25 25&quot;</span><br><span class="line">          to=&quot;360 25 25&quot;</span><br><span class="line">          dur=&quot;0.6s&quot;</span><br><span class="line">          repeatCount=&quot;indefinite&quot;</span><br><span class="line">        &gt;<span class="tag">&lt;/<span class="name">animateTransform</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--这个是github_containner容器，也就是纸--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;github_container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>最后执行：</p><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">hexo clean &amp; hexo g &amp; hexo s</span><br></pre></td></tr></table></figure><p>就可以看到效果了！</p><h2 id="统计页的效果"><a href="#统计页的效果" class="headerlink" title="统计页的效果"></a>统计页的效果</h2><p>效果如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210316205610992.png" alt="image-20210316205610992"></p><p>统计页的github贡献图只需要在统计页加上该标签，id已由上面方法描述好了。</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span>github贡献图<span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;github_container&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>而gitee贡献图，再重复一遍上述操作，不过使用传统的主题修改模板的div+js挂载方法。用到<a href="https://github.com/Zfour/hexo-github-calendar中的[githubcalendar.js](https://github.com/Zfour/hexo-github-calendar/blob/master/githubcalendar.js)文件。">https://github.com/Zfour/hexo-github-calendar中的[githubcalendar.js](https://github.com/Zfour/hexo-github-calendar/blob/master/githubcalendar.js)文件。</a><br>下载后，修改用户名，将其引入到主题中。该文件改名为giteecalendar.js，全文替换github为gitee。也需要在inject中引用该js文件。</p><p>最后代码同样：</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span>gitee贡献图<span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;gitee_container&quot;</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>参考： <a href="https://segmentfault.com/a/1190000022736595">https://segmentfault.com/a/1190000022736595</a></p><p>其实Github统计的commit时间取决于Git仓库中记录的commit时间，而往Git仓库中提交的时间是可以修改的。</p><p>由于对Git命令不是太熟，一开始想到了通过修改系统时间来改变commit的时间，发现是可行的。</p><p>后来查到了commit命令有个—date参数，可以实现提交时间的自定义，格式为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --date&#x3D;&quot;月 日 时间 年 +0800&quot; -m &quot;提交&quot;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --date&#x3D;&quot;May 7 9:05:20 2016 +0800&quot; -m &quot;提交&quot;</span><br></pre></td></tr></table></figure><p>这样就可以实现用过去的时间进行提交。不过关于Github统计时间需要注意下根据官方说法是根据UTC时间统计的，不过我实测发现貌似和Github服务器的所在地点的时区有关，我访问的服务器猜测在旧金山，与北京时间差了16小时，也就是说如果想要Github统计的时间是0点，那么你北京时间就要设置成16点才行。</p><p>自定义提交时间我们实现了，接下来的事情就好办啦，我们如果要实现在Github贡献板任意涂鸦，其实只需要知道哪一天我们需要commit多少次就好了，自定义提交时间用来决定我们想让哪些格子有颜色，而commit次数的多少决定了颜色的深浅，这样通过这两者的结合，我们就可以轻松地创造出属于自己的像素风格的涂鸦啦。</p><h2 id="可能出现的bug"><a href="#可能出现的bug" class="headerlink" title="可能出现的bug"></a>可能出现的bug</h2><p>之前可能在自己的电脑上登陆过别人的号，所以本地的git账号不是自己的，因此commit上并不能计算成自己的贡献。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308004047420.png" alt="image-20210308004047420"></p><p>于是查看了本地git账号，果然不是自己的，修改成自己的账号即可。具体可看<a href="https://www.cnblogs.com/bbldhf/p/13269577.html">如何在vscode修改git 的账号和邮箱</a> 。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308004246316.png" alt="image-20210308004246316"></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> gitcalendar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第12篇博客】PicGo图床工具配合Typora的便捷贴图配置</title>
      <link href="2021/03/06/blog12-PicGo/"/>
      <url>2021/03/06/blog12-PicGo/</url>
      
        <content type="html"><![CDATA[<p>PicGo官网地址 <a href="https://link.zhihu.com/?target=https%3A//molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></p><p>在GitHub项目地址 <a href="https://link.zhihu.com/?target=https%3A//github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>PicGo文档地址 <a href="https://link.zhihu.com/?target=https%3A//picgo.github.io/PicGo-Doc/zh/guide/%23%E5%BA%94%E7%94%A8%E6%A6%82%E8%BF%B0">https://picgo.github.io/PicGo-Doc/zh/guide/#应用概述</a></p><hr><p>在前文介绍了Tpora写markdown博客的操作，然而在贴图方面还是不够便捷，这里介绍一种PicGo配合的方法来便捷贴图。</p><blockquote><p>所谓图床工具，就是专门用来存放图片，同时允许你把图片对外连接的网上空间，不少图床都是免费的。设置图床后，在博客中插入的图片链接就可以随时随地在线预览。网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 <code>Electron-vue</code> 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用。</p></blockquote><h2 id="下载Picgo"><a href="#下载Picgo" class="headerlink" title="下载Picgo"></a>下载Picgo</h2><p>首先进入github下载，<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p>注意：<em>mac</em> 系统选择 <em>dmg</em> 下载，<em>windwos</em> 选择 <em>.exe</em>系统，如果不是下载安装包，想看源码的话，可以选择 <code>git clone https://github.com/Molunerfinn/PicGo.git</code> 克隆到本地</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307130020168.png" alt="image-20210307130020168"></p><p>安装成功界面：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307130215796.png" alt="image-20210307130215796"></p><h2 id="安装gitee插件"><a href="#安装gitee插件" class="headerlink" title="安装gitee插件"></a>安装gitee插件</h2><p>找到底下插件设置，使用码云需要另外安装插件，搜索gitee安装插件，下载第一个：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307130739301.png" alt="image-20210307130739301"></p><p>注意：安装<code>gitee-uploader 1.1.2</code>插件，必须要先安装<code>node.js</code>才能安装插件。</p><p>也可以采用手动安装：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307161112397.png" alt="image-20210307161112397"></p><h2 id="创建gitee仓库"><a href="#创建gitee仓库" class="headerlink" title="创建gitee仓库"></a>创建gitee仓库</h2><p>新建gitee账号这里就不赘述了。</p><p>建立gitee码云图床库，就是在码云新建一个仓库，步骤：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307131125647.png" alt="image-20210307131125647"></p><h2 id="Gitee生成私人令牌token"><a href="#Gitee生成私人令牌token" class="headerlink" title="Gitee生成私人令牌token"></a>Gitee生成私人令牌token</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307160818893.png" alt="image-20210307160818893"></p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307161009440.png" alt="image-20210307161009440"></p><h2 id="PicGo的gitee图床设置"><a href="#PicGo的gitee图床设置" class="headerlink" title="PicGo的gitee图床设置"></a>PicGo的gitee图床设置</h2><p>点击左侧图床设置——gitee图床，设置如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307162023734.png" alt="image-20210307162023734"></p><p>注意，这里的owner和repo名字，如果设置不对，后期出现问题记得查这里的问题。下图即是我第一次设置错的配置，请看我的仓库地址，此时的owner应该是xxxxxxxxxxw，repo名应该是blog-img。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307162148857.png" alt="image-20210307162148857"></p><p>而且还需要注意名称对应的问题，如下图，即使我在repo位置填写的是BlogImg，但被解析成blog-img，此处需要注意。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307162543953.png" alt="image-20210307162543953"></p><h2 id="PicGo设置"><a href="#PicGo设置" class="headerlink" title="PicGo设置"></a>PicGo设置</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307163418777.png" alt="image-20210307163418777"></p><p>请注意此处的Server监听地址和监听端口。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307163526827.png" alt="image-20210307163526827"></p><h2 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20200323201738802.png" alt="img"></p><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>可在码云仓库内查看上传的图片。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210307175745968.png" alt="image-20210307175745968"></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li>直接复制图片，粘贴至Typora，便会自动生成链接，非常方便。</li><li>将图片文件拖进PicGo上传区，也会自动生成markdown链接。</li><li>PicGo上传区剪贴板图片，直接复制图片，点击<code>剪贴板图片</code>，即可获取markdown链接。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> PicGo </tag>
            
            <tag> Gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第11篇博客】博客操作优化2——使用bat优化操作及bat语法学习记录</title>
      <link href="2021/03/06/blog11-BatLearning/"/>
      <url>2021/03/06/blog11-BatLearning/</url>
      
        <content type="html"><![CDATA[<h2 id="博客准备脚本"><a href="#博客准备脚本" class="headerlink" title="博客准备脚本"></a>博客准备脚本</h2><p>首先总结一下痛点，由于我们不再使用vscode编写markdown文章，开始使用Typora编写文章，于是当我们一开机，或者准备写博客的时候，首先打开文档文件夹，<code>C:\Users\tsui\blog\source\_posts</code>，然后再打开Typora软件和PicGo软件。于是，可以将打开文件夹、打开软件，继承为一个bat脚本。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308203047265.png" alt="image-20210308203047265"></p><p>因此在<code>C:\Users\tsui\blog\source\_posts</code>文件夹下新建文档文件，写下面代码：</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;C:\Users\tsui\blog\source\_posts&quot;</span><br><span class="line">tasklist | <span class="built_in">find</span> /i &quot;Typora.exe&quot; &amp;&amp; <span class="built_in">echo</span> &quot;Typora is running&quot; || <span class="built_in">start</span> &quot;&quot; &quot;D:\Typora\Typora.exe&quot;</span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;D:\PicGo\PicGo.exe&quot;</span><br></pre></td></tr></table></figure><p>第一行为打开博客文件夹。</p><p>第二行为当运行了Typora时，则不执行；未执行Typora时，则运行Typora程序。（由于Typora可以多开，若不作此判断，则会多开；而PicGo软件则不会多开，因此无需判断。）</p><p>在批处理程序中检查指定进程是否在运行，然后根据其运行状态分别执行不同的命令。<br>语法：tasklist | find /i “程序” &amp;&amp; 程序在运行执行命令1 || 不在运行执行命令2。<br>例子：tasklist | find /i “calc.exe” &amp;&amp; taskkill /im calc.exe || echo 没有运行</p><p>第三行为运行PicGo程序。（至于为何与第二行不一样，倘若一样的情况下，PicGo若已经打开，则会报错。也欢迎大家帮我解答该问题。）</p><p>最后将该文件修改为<code>.bat</code>文件。</p><h2 id="启动文件桌面魔改"><a href="#启动文件桌面魔改" class="headerlink" title="启动文件桌面魔改"></a>启动文件桌面魔改</h2><ol><li><p>首先将刚刚的文件发送至桌面。</p></li><li><p>在桌面上可以修改该文件名，甚至把后缀去掉。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308203240590.png" alt="image-20210308203240590"></p></li><li><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210308203342929.png" alt="image-20210308203342929"></p></li></ol><p>修改结束，当点击该文件时，即可打开博客文件夹、打开Typora和PicGo随时等待你修改文章。</p><h2 id="运行hexo脚本"><a href="#运行hexo脚本" class="headerlink" title="运行hexo脚本"></a>运行hexo脚本</h2><p>同样在刚刚快接打开的博客文件夹中新建bat文件，命名为HexoRun。</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">start</span>  http://localhost:<span class="number">4000</span>/</span><br><span class="line"><span class="built_in">start</span> &quot;&quot; &quot;D:\PicGo\PicGo.exe&quot;</span><br><span class="line">tasklist | <span class="built_in">find</span> /i &quot;Typora.exe&quot; &amp;&amp; <span class="built_in">echo</span> &quot;Typora is running&quot; || <span class="built_in">start</span> &quot;&quot; &quot;D:\Typora\Typora.exe&quot;</span><br><span class="line"><span class="built_in">cmd</span> /k &quot;<span class="built_in">cd</span> /d C:\Users\tsui\blog&amp;&amp;hexo s&quot;</span><br></pre></td></tr></table></figure><p>第一行表示运行本地文件<code>localhost:4000</code>。无需先打开浏览器，这里我默认的浏览器为Chrome。</p><p>第二行、第三行表示启动Typora和PicGo程序。</p><p>第四行表示打开cmd指向hexo根目录，并执行命令，加&amp;&amp;。通过使用CD命令，并加入参数 /d ，可以通过一个步骤，直接进入指定盘符下的任意文件夹。</p><p>该脚本文件帮我们省了不少事哈。</p><h2 id="博客提交脚本"><a href="#博客提交脚本" class="headerlink" title="博客提交脚本"></a>博客提交脚本</h2><p>主要是帮助我们git三连提交。</p><figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">cd</span> /d C:\Users\tsui\blog</span><br><span class="line">git add . </span><br><span class="line">git commit -m &quot;bat push&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客优化 </tag>
            
            <tag> bat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第10篇博客】博客操作优化1——使用Typora编写markdown博客</title>
      <link href="2021/03/06/blog10-Typora/"/>
      <url>2021/03/06/blog10-Typora/</url>
      
        <content type="html"><![CDATA[<h2 id="一个markdown文本编辑器"><a href="#一个markdown文本编辑器" class="headerlink" title="一个markdown文本编辑器"></a>一个markdown文本编辑器</h2><p>「它的<strong>功能之强大、设计之冷静、体验之美妙、理念之先进</strong>，我认为值得所有笔记应用厂商学习。」</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/beta.gif" alt="beta"></p><p><a href="https://www.typora.io/">Typora</a> 是一款<strong>支持实时预览的 Markdown 文本编辑器</strong>。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是<strong>完全免费</strong>的。</p><p>由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。其中比较受到认可的是 <a href="https://github.github.com/gfm/">GFM 标准</a>，它是由著名代码托管网站 <a href="https://github.com/">GitHub</a> 所制定的。Typora 主要使用的也是 GFM 标准。同时，你还可以在 <code>文件 - 偏好设置 - Markdown 语法偏好 - 严格模式</code> 中将标准设置为「更严格地遵循 GFM 标准」。具体内容你可以在官方的 <a href="http://support.typora.io/Strict-Mode/">这篇文档</a> 中查看。</p><h2 id="适用于自己的Typora配置"><a href="#适用于自己的Typora配置" class="headerlink" title="适用于自己的Typora配置"></a>适用于自己的Typora配置</h2><ol><li><p><strong>快捷键</strong></p><p>打开自己电脑根目录下的<code>C:\Users\tsui\AppData\Roaming\Typora\conf</code>文件夹（读者自行修改该目录），如下图所示：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306195316546.png" alt="image-20210306195316546"></p><p>打开<code>conf.user.json</code>文件，主要修改画框处的代码即可，如下图所示：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306195441753.png" alt="image-20210306195441753"></p><p>至于代码中的<code>Always on Top</code>和我代码中的<code>Delete Line/Sentence</code>这些参数，该如何找呢？打开偏好设置，语言设置为英文，再从工具栏中找到对应的操作，例如我要设置删除改行（vscode中的Ctrl+D，很是方便），如下图所示：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/8EFBAA12EABA3092AE1EB1CE061298DD.png" alt="img"></p><p>找到对应的参数名<code>Delete Line/Sentence</code>，然后再设置具体的快捷键即可。</p><p>还可以参考官网的快捷键帮助<a href="https://support.typora.io/Shortcut-Keys/">https://support.typora.io/Shortcut-Keys/</a> 。</p></li><li><p><strong>侧边栏</strong></p><p><code>侧边栏</code>保持显示侧边栏，主要显示文件数和大纲，可以帮助开发。快捷键为Ctrl+Shift+L。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306194555367.png" alt=""></p></li><li><p><strong>启动选项</strong></p><p><code>启动选项</code>选择重新打开选择重新打开上次使用的文件和目录，这样直接打开Typora软件即可找到上次编写的位置，同vscode一样，无需一步步打开文件，很是方便。</p><p>在偏好设置里设置：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306194138225.png" alt="image-20210306194138225"></p></li></ol><h2 id="图片插入"><a href="#图片插入" class="headerlink" title="图片插入"></a>图片插入</h2><p>Typora 的图片插入功能是广受好评的。要知道，Markdown 原生不太注重图片插入的功能，但你可以在 Typora 中：</p><ul><li>直接使用 <code>右键 - 复制 Ctrl + V</code> 将网络图片、剪贴板图片复制到文档中</li><li>拖动本地图片到文档中</li></ul><p>Typora 会自动帮你插入符合 Markdown 语法的图片语句，并给它加上标题。如：</p><p><code>![](http://rto3hzle5.hd-bkt.clouddn.com/20210310123322.png)</code></p><p>现在已经支持粘贴图片自动上传至图床了，使用PicGo，具体参见我的另一篇博客。</p><h2 id="打字机模式和专注模式"><a href="#打字机模式和专注模式" class="headerlink" title="打字机模式和专注模式"></a>打字机模式和专注模式</h2><p><strong>「打字机模式」</strong>使得你所编辑的那一行永远处于屏幕正中。</p><p><strong>「专注模式」</strong>使你正在编辑的那一行保留颜色，而其他行的字体呈灰色。</p><p>你可以在 <code>视图 - 专注模式 / 打字机模式</code> 中勾选使用这两个模式。</p><h2 id="实时预览"><a href="#实时预览" class="headerlink" title="实时预览"></a>实时预览</h2><p>我想很果断地下这个结论：到现在还不支持编辑界面实时预览的 Markdown 编辑器基本可以退出市场了。Typora 在这一方面显然已经领先了一大步——他们连 Markdown 语法的标记都在实时预览中消去了。当你离开正在编辑的有格式的文本段后，Typora 会自动隐藏 Markdown 标记，只留下<strong>「所见即所得」</strong>的美妙。他们把这称为 <em>Hybrid View。</em></p><p>为了防止一些程序 bug 的发生（虽然在我使用下来感到是很少的）导致格式问题无法修改，Typora 保留了一个<strong>「源代码模式」</strong>。你可以通过 <code>视图 - 源代码模式</code> 或左下角的 <code>&lt;/&gt;</code> 按钮进入。</p><h2 id="大纲-文件侧边栏配置"><a href="#大纲-文件侧边栏配置" class="headerlink" title="大纲 / 文件侧边栏配置"></a>大纲 / 文件侧边栏配置</h2><p>Typora 会根据你 Markdown 标记的 H1、H2、H3…… 各级标题为你呈现一个大纲。</p><p>你也可以选择查看文件夹中的文件，但由于目前 Typora 只支持查看 md 文件。     </p><h2 id="空格与换行"><a href="#空格与换行" class="headerlink" title="空格与换行"></a>空格与换行</h2><p>Typora 在空格与换行部分主要是使用 <a href="http://www.commonmark.cn/w/">CommonMark</a> 作为标注规范。与前文提到的 GFM 一样，CommonMark 也是比较流行的 Markdown 语言规范（解析器）之一。 </p><ul><li><strong>空格：</strong>在输入连续的空格后，Typora 会在编辑器视图里为你保留这些空格，但当你打印或导出时，这些空格会被省略成一个。<br>你可以在源代码模式下，为每个空格前加一个 <code>\</code> 转义符，或者直接使用 HTML 风格的 <code>&amp;nbps;</code> 来保持连续的空格。</li><li><strong>软换行：</strong>需要说明的是，在 Markdown 语法中，换行（line break）与换段是不同的。且换行分为软换行和硬换行。在 Typora 中，你可以通过 <code>Shift + Enter</code> 完成一次软换行。软换行只在编辑界面可见，当文档被导出时换行会被省略。</li><li><strong>硬换行：</strong>你可以通过 <code>空格 + 空格 + Shift + Enter</code> 完成一次硬换行，而这也是许多 Markdown 编辑器所原生支持的。硬换行在文档被导出时将被保留，且没有换段的段后距。</li><li><strong>换段：</strong>你可以通过 <code>Enter</code> 完成一次换段。Typora 会自动帮你完成两次 <code>Shift + Enter</code> 的软换行，从而完成一次换段。这也意味着在 Markdown 语法下，换段是通过在段与段之间加入空行来实现的。 </li></ul><h2 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h2><p>在 Typora 中，你可以用 <code>:emoji:</code> 的形式来打出 emoji，软件会自动给出图形的提示，还是比较好用的。:sunny:、:cow:、:grey_question:。</p><p>emoji编码合集可参考<a href="https://blog.csdn.net/weixin_42395140/article/details/111642339">https://blog.csdn.net/weixin_42395140/article/details/111642339</a> 。</p><h2 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h2><p>Typora还提供了如同<strong>word</strong>快捷键的操作包括加粗、斜体等。</p><p>在vscode中写markdown的表格一直是一件比较头疼的事情。好在 Typora 为我们提供了图形界面的插入表格的功能，你只需要在行内 <code>鼠标右键 - 插入 - 表格</code> ，并输入行数和列数，Typora 就会自动生成一张样式不错的空表格。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306211350709.png" alt="image-20210306211350709"></p><h2 id="hexo-new-post-更换模板"><a href="#hexo-new-post-更换模板" class="headerlink" title="hexo new post 更换模板"></a>hexo new post 更换模板</h2><p>除了上述介绍来的Typora使用之外，本文还将介绍如何优化 每次新建博客之后填写博客文章摘要信息的操作。</p><p>每当我们hexo n blog的时候，在未设置模板的情况下，如何才能出现以下完整的信息呢？</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: 【第10篇博客】博客操作优化1——使用Typora编写markdown博客</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> Typora</span><br><span class="line"><span class="bullet">  -</span> markdown</span><br><span class="line"><span class="bullet">  -</span> 博客优化</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> 博客搭建记录</span><br><span class="line">date: 2021-03-06 12:06:31</span><br><span class="line">updated: 2021-03-06 12:06:31</span><br><span class="line">description: 时至今日，可以优化一下博客的操作，本文将介绍使用Typora来写markdown语言，最为方便的在于图片的粘贴。以及自己的优化操作中的Typora偏好设置。</span><br><span class="line">cover: &quot;http://rto3hzle5.hd-bkt.clouddn.com/20210310123446.png&quot;</span><br></pre></td></tr></table></figure><p>通过查看文档，找到模板文件的路径：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306214807156.png" alt="image-20210306214807156"></p><p>打开post填写以下信息，保存即可。</p><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; date &#125;&#125;</span><br><span class="line">description:  </span><br><span class="line">cover: </span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">  -</span> </span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">  -</span> </span><br></pre></td></tr></table></figure><p>将来hexo n blog的时候，将会自动存在这些基础信息。</p><hr><p>本文参考：<a href="https://sspai.com/post/54912">https://sspai.com/post/54912</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> markdown </tag>
            
            <tag> 博客优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第9篇博客】标签外挂的配置学习记录</title>
      <link href="2021/02/07/blog9-TagPlugins/"/>
      <url>2021/02/07/blog9-TagPlugins/</url>
      
        <content type="html"><![CDATA[<p>标签外挂主要使用了<a href="https://github.com/volantis-x/hexo-theme-volantis">Volantis</a>的标签样式。引入[tag].js，并针对butterfly主题修改了相应的[tag].styl。</p><p>标签外挂是Hexo独有的功能，并不是标准的Markdown格式。以下的写法，只适用于butterfly主题，用在其他主题不会有效果。</p><h2 id="配置教程"><a href="#配置教程" class="headerlink" title="配置教程"></a>配置教程</h2><p>主要参考 <a href="https://akilar.top/posts/615e2dec/">https://akilar.top/posts/615e2dec/</a><br>点击下方github链接，并下载。</p><p><a style="margin-inline:5px"target="_blank" href="https://github.com/Akilarlxh/Tag_Plugins"><img src="https://github-readme-stats.vercel.app/api/pin/?username=Akilarlxh&amp;repo=Tag_Plugins&amp;theme=vue&amp;show_owner=true" ></p><ol><li>将下载的Tag_Plugins.zip解压得到butterfly文件夹。</li><li>将butterfly文件夹复制到[Blogroot]\themes\目录下，覆盖当前的butterfly主题文件夹，提示重复则选择替换。(如果担心覆盖自己的其他魔改内容，可以根据静态文件内容自主比对修改)</li><li>修改[Blogroot]_config.butterfly.yml的inject配置项，添加CDN依赖项。由于issues写入timeline和site-card标签要用到jquery，请务必根据注释指示的版本决定是否添加。</li></ol><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css&quot;</span>  <span class="string">media=&quot;defer&quot;</span> <span class="string">onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span>  <span class="comment">#动画标签anima的依赖</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment"># 自butterfly_v3.4.0+开始，主题基本实现去jquery化，需要自己添加引用，请读者根据版本自行决定是否添加这行引用。</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">defer</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="comment">#数据集合标签issues的依赖</span></span><br></pre></td></tr></table></figure><p>如果遇到问题，请hexo <span class='p red'>clean、</span> <span class='p green'>g、</span> <span class='p blue'>s。</span></p><p>接下来将介绍外挂标签使用语法。</p><h2 id="行内文本样式"><a href="#行内文本样式" class="headerlink" title="行内文本样式"></a>行内文本样式</h2><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#1-1">标签语法</button></li><li class="tab active"><button type="button" data-href="#1-2">样式预览</button></li><li class="tab"><button type="button" data-href="#1-3">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="1-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="1-2"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="行内文本-span"><a href="#行内文本-span" class="headerlink" title="行内文本 span"></a>行内文本 span</h2><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#1-1">标签语法</button></li><li class="tab active"><button type="button" data-href="#1-2">样式预览</button></li><li class="tab"><button type="button" data-href="#1-3">示例源码</button></li><li class="tab"><button type="button" data-href="#1-4">配置参数</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="1-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="1-2"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-4"><ol><li>字体: logo, code</li><li>颜色: <span class='p red'>red</span>,<span class='p yellow'>yellow</span>,<span class='p green'>green</span>,<span class='p blue'>blue</span>,<span class='p cyan'>cyan</span>,<span class='p gray'>gray</span></li><li>大小: small, h4, h3, h2, h1, large, huge, ultra</li><li>对齐方向: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="段落文本-p"><a href="#段落文本-p" class="headerlink" title="段落文本 p"></a>段落文本 p</h2><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#1-1">标签语法</button></li><li class="tab active"><button type="button" data-href="#1-2">样式预览</button></li><li class="tab"><button type="button" data-href="#1-3">示例源码</button></li><li class="tab"><button type="button" data-href="#1-4">配置参数</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="1-1"><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="1-2"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-4"><ol><li>字体: logo, code</li><li>颜色: <span class='p red'>red</span>,<span class='p yellow'>yellow</span>,<span class='p green'>green</span>,<span class='p blue'>blue</span>,<span class='p cyan'>cyan</span>,<span class='p gray'>gray</span></li><li>大小: small, h4, h3, h2, h1, large, huge, ultra</li><li>对齐方向: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="引用-note"><a href="#引用-note" class="headerlink" title="引用 note"></a>引用 note</h2><p>最新版butterfly标签支持引用fontawesome V5图标，效果上已经优于volantis的note标签。故不再额外引入volantis的note样式。</p><div class="tabs" id="1"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#1-1">通用配置</button></li><li class="tab"><button type="button" data-href="#1-2">语法格式</button></li><li class="tab"><button type="button" data-href="#1-3">配置参数</button></li><li class="tab active"><button type="button" data-href="#1-4">样式预览</button></li><li class="tab"><button type="button" data-href="#1-5">示例源码</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="1-1"><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">note:</span></span><br><span class="line">  <span class="comment"># Note tag style values:</span></span><br><span class="line">  <span class="comment">#  - simple    bs-callout old alert style. Default.</span></span><br><span class="line">  <span class="comment">#  - modern    bs-callout new (v2-v3) alert style.</span></span><br><span class="line">  <span class="comment">#  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span></span><br><span class="line">  <span class="comment">#  - disabled  disable all CSS styles import of note tag.</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">simple</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">border_radius:</span> <span class="number">3</span></span><br><span class="line">  <span class="comment"># Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line">  <span class="comment"># Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line">  <span class="attr">light_bg_offset:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-2"><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>或者<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-3"><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">用法</th></tr></thead><tbody><tr><td style="text-align:left">class</td><td style="text-align:left">【可选】标识，不同的标识有不同的配色 &lt;/br&gt;（ default / primary / success / info / warning / danger ）</td></tr><tr><td style="text-align:left">no-icon</td><td style="text-align:left">【可选】不显示 icon</td></tr><tr><td style="text-align:left">style</td><td style="text-align:left">【可选】可以覆盖配置中的 style &lt;/br&gt;（simple/modern/flat/disabled）</td></tr></tbody></table></div><p>或者<br>参数| 用法<br>:-|:-<br>class | 【可选】标识，不同的标识有不同的配色 &lt;/br&gt;（ default / primary / success / info / warning / danger ）<br>no-icon | 【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )<br>style | 【可选】可以覆盖配置中的 style &lt;/br&gt;（simple/modern/flat/disabled）</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="1-4"><ol><li><p><code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div></li><li><p><code>modern</code>样式</p><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="1-5"><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>本文参考：<br><a href="https://akilar.top/posts/615e2dec/">https://akilar.top/posts/615e2dec/</a><br><a href="https://github.com/Akilarlxh/Tag_Plugins">https://github.com/Akilarlxh/Tag_Plugins</a></p><p><img src="https://cdn.sspai.com/2019/05/24/1de13eae43785e27bbbcd631931fd161.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 标签外挂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第8篇博客】GitHub Badge徽标的配置学习记录</title>
      <link href="2021/02/04/blog8-ShieldIoBadge/"/>
      <url>2021/02/04/blog8-ShieldIoBadge/</url>
      
        <content type="html"><![CDATA[<p>效果如下：<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310123146.png" alt=""><br>大家平时在逛GitHub，Gitee，各大论坛博客的时候，都有类似很好看很漂亮的徽章，主要通过 <a href="https://shields.io/">shields.io</a> 在线生成。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310123227.png" alt=""></p><p>其中，找到Your BADGE 专属定制徽章</p><ul><li>label：标签，徽标左侧内容</li><li>message：信息，徽标右侧内容</li><li>color：色值，支持支持十六进制、rgb、rgba、hsl、hsla 和 css 命名颜色。十六进制记得删除前面的 # 号</li></ul><p>输入相关信息后，点击 make badge 即可得到徽标的 URL。可以用 img 标签引用</p><p>在主题配置文件中的<code>footer</code>:  <code>copyright:</code>设置为false、<code>footer</code>:  <code>custom_text:</code>中填写<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo&quot;</span> <span class="attr">title</span>=<span class="string">&quot;博客框架为 Hexo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;HEXO&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://butterfly.js.org/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender&quot;</span> <span class="attr">title</span>=<span class="string">&quot;主题采用 Butterfly&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Butterfly&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.jsdelivr.com/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站使用 Jsdelivr 为静态资源提供CDN加速&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Jsdelivr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站项目由 GitHub 托管&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;GitHub&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">&quot;margin-inline:5px&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span><span class="attr">href</span>=<span class="string">&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;img&quot;</span> <span class="attr">title</span>=<span class="string">&quot;本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br>可以发现，简单定制小牌子非常方便，最最基础的语法规则就是：<br><code>https://img.shields.io/badge/&#123;左半部分标签&#125;-&#123;右半部分标签&#125;-&#123;右半部分颜色&#125;</code><br>还可以贴在markdown文档中。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shield.io </tag>
            
            <tag> GitHub Badge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第7篇博客】配置jsDelivr提供静态资源CDN加速学习记录</title>
      <link href="2021/02/01/blog7-JdDelivrUse/"/>
      <url>2021/02/01/blog7-JdDelivrUse/</url>
      
        <content type="html"><![CDATA[<p>在之前第二篇主题样式修改的学习记录里，就出现过很多引用jsdelivr的链接，一直不知道这是做什么用的，今天就来<code>学习</code>、<code>记录</code>、<code>配置</code>一下jsdelivr。</p><blockquote><p><code>CDN</code>的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><p><code>jsDelivr</code> <a href="https://www.jsdelivr.com/">https://www.jsdelivr.com/</a> 是一个CDN服务提供商，优点在于全球通用。专门提供js相关的CDN，对npm,github做了加速镜像。针对npm, github提供了CDN镜像。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310122850.png" alt=""></p><p>接下来，将介绍如何将自己的字体文件上传jsDelivr。</p><h2 id="新建github仓库"><a href="#新建github仓库" class="headerlink" title="新建github仓库"></a>新建github仓库</h2><p>在此，仓库名设置为CDN。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310122920.png" alt=""></p><h2 id="克隆github仓库到本地"><a href="#克隆github仓库到本地" class="headerlink" title="克隆github仓库到本地"></a>克隆github仓库到本地</h2><pre><code>git clone git@github.com:tsuiwade/CDN.git</code></pre><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310123017.png" alt=""><br>在vscode的cmd中输入代码，倘若出现如下的报错，是因为客户端与服务端未生成 ssh key，为解决以上问题，我们需要重新生成一次ssh key ，并重新配置一下GitHub账户即可。具体参考 <a href="https://blog.csdn.net/weixin_40922744/article/details/107576748">https://blog.csdn.net/weixin_40922744/article/details/107576748</a><br>（其中，解决方法里面的cmd窗口是Git bash。）<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310123042.png" alt=""><br>如果出现ssh无效问题 参考 <a href="https://blog.csdn.net/weixin_45604257/article/details/106649576">https://blog.csdn.net/weixin_45604257/article/details/106649576</a></p><h2 id="上传资源"><a href="#上传资源" class="headerlink" title="上传资源"></a>上传资源</h2><p>将需要上传的资源放进本地CDN仓库中。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310123058.png" alt=""><br>（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status                    &#x2F;&#x2F;查看状态</span><br><span class="line">git add .                     &#x2F;&#x2F;添加所有文件到暂存区</span><br><span class="line">git commit -m &#39;第一次提交&#39;      &#x2F;&#x2F;把文件提交到仓库</span><br><span class="line">git push                      &#x2F;&#x2F;推送至远程仓库</span><br></pre></td></tr></table></figure></p><h2 id="发布仓库"><a href="#发布仓库" class="headerlink" title="发布仓库"></a>发布仓库</h2><p>回到github上，点击release发布，填写必要信息如下图所示。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/20210310123121.png" alt=""></p><p>这就设置完成了，接下来可以引用资源了。</p><h2 id="通过jsDelivr引用资源"><a href="#通过jsDelivr引用资源" class="headerlink" title="通过jsDelivr引用资源"></a>通过jsDelivr引用资源</h2><p><code>使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</code><br>例如：<br><a href="https://cdn.jsdelivr.net/gh/tsuiwade/CDN@4.0/font/yenianti.otf">https://cdn.jsdelivr.net/gh/tsuiwade/CDN@4.0/font/yenianti.otf</a></p><p>这里就大功告成了，这里引用的字体，可以参考第二篇博客的首页字体修改。</p><p>本文主要参考 <a href="https://blog.csdn.net/qq_36759224/article/details/86936453">https://blog.csdn.net/qq_36759224/article/details/86936453</a></p><p><a href="https://github.com/badges/shields">https://github.com/badges/shields</a><br><a href="https://github.com/spencerwooo/Substats">https://github.com/spencerwooo/Substats</a><br><a href="https://sspai.com/post/59593">https://sspai.com/post/59593</a><br><a href="https://www.cnblogs.com/sddai/p/13779316.html">https://www.cnblogs.com/sddai/p/13779316.html</a><br><a href="https://shields.io/">https://shields.io/</a><br><a href="https://www.baidu.com/s?wd=https%3A%2F%2Fshields.io%2F&amp;pn=10&amp;oq=https%3A%2F%2Fshields.io%2F&amp;ie=utf-8&amp;rsv_pq=bf92913f0003488b&amp;rsv_t=d46aUVHAFQ77ZmEGMpHpwQ5ncdiMRCwA4exwuw8jxTdXvT1%2BpwCVWcKKgec&amp;rsv_jmp=slow">https://www.baidu.com/s?wd=https%3A%2F%2Fshields.io%2F&amp;pn=10&amp;oq=https%3A%2F%2Fshields.io%2F&amp;ie=utf-8&amp;rsv_pq=bf92913f0003488b&amp;rsv_t=d46aUVHAFQ77ZmEGMpHpwQ5ncdiMRCwA4exwuw8jxTdXvT1%2BpwCVWcKKgec&amp;rsv_jmp=slow</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jeDelivr </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第6篇博客】写博客的git概念和指令学习记录</title>
      <link href="2021/01/09/blog6-BaseGit/"/>
      <url>2021/01/09/blog6-BaseGit/</url>
      
        <content type="html"><![CDATA[<p>在写完博客之后，一般都是通过<code>git add .</code>、<code>git commit -m &quot;message&quot;</code>、<code>git push</code>进行提交，至于这些代码的含义及相关概念是什么？本文就带着这些问题进行学习并记录。</p><h2 id="四个工作区域"><a href="#四个工作区域" class="headerlink" title="四个工作区域"></a>四个工作区域</h2><p>git本地有四个工作区域，文件在这四个区域之间的转换关系如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306232549737.png" alt="image-20210306232549737"></p><ul><li><code>workspace</code>：工作区，就是你平时存放项目代码的地方。</li><li><code>staging area</code>：又叫<code>Index / Stage</code>，暂存区/缓冲区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li><code>local repository</code>：本地仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本。</li><li><code>remote repository</code>：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换。</li></ul><p>因此，git的工作流程一般是这样的：通过<code>git add .</code>将在工作区中修改、添加后的文件从工作区移至暂存区；再通过<code>git commit</code>移至本地仓库；最后通过<code>git push</code>推到远程仓库中。</p><p>因此，git管理的文件有三种状态：已修改（modified），已暂存（staged），已提交(committed)。</p><h2 id="文件的版本控制"><a href="#文件的版本控制" class="headerlink" title="文件的版本控制"></a>文件的版本控制</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><p>git不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用SHA-1算法计算文件的校验和。</p><p>版本控制的文件状态有四种，如下图所示。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306232649281.png" alt="image-20210306232649281"></p><p><code>Untracked</code>： 未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。 通过git add可将状态变为Staged。</p><p><code>Unmodify</code>： 文件已经入库，但未修改，即版本库中的文件快照内容与文件夹中完全一致。 这种类型的文件有两种去处，如果它被修改，而变为Modified。如果使用git rm移出版本库，则成为Untracked文件。</p><p><code>Modified</code>： 文件已修改，仅仅是修改，并没有进行其他的操作。 这个文件也有两个去处，通过git add可进入暂存staged状态，使用git checkout 则丢弃修改过，返回到unmodify状态，这个git checkout即从库中取出文件，覆盖当前修改。</p><p><code>Staged</code>： 暂存状态。 执行git commit则将修改同步到库中，这时库中的文件和本地文件又变为一致，文件为Unmodify状态。 执行git reset HEAD filename取消暂存，文件状态为Modified。</p><h2 id="git-status命令"><a href="#git-status命令" class="headerlink" title="git status命令"></a>git status命令</h2><p>在命令行中输入git status命令可以得到文件在工作区、暂存区的状态，下面展示这不同的三种状态：</p><pre><code>PS C：\Users\tsui\blog&gt; git statusOn branch myblogYour branch is up to date with &#39;origin/myblog&#39;.Changes to be committed：(use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)        modified：   source/_posts/blog3_DnsBlogGithubIo.md        modified：   source/_posts/blog6_hexo_commands.md        modified：   source/_posts/blog7-MarkdownLearning.md        new file：   source/_posts/blog8-BaseGit.md        new file：   source/_posts/blog8-BaseGit/0.gifChanges not staged for commit：(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)        modified：   source/_posts/blog8-BaseGit.mdUntracked files：(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)        source/_posts/te.md</code></pre><ol><li><code>Changes to be committed</code>：表示已经从工作区add到暂存区的file（文件或文件夹），可以通过 <code>git restore --staged filename</code> 命令将该file从暂存区移出，只有工作区有该文件，该文件就为Untracked files。通过 <code>git commit -m [message]</code>将暂存区内容添加到本地仓库中，此时我的vscode左侧工具栏源代码管理被挂起的文件，即一个小数字，将会消失。而在vscode底部状态栏的源代码管理处上拉数加一。</li><li><code>Changes not staged for commit</code>：表示文件还在工作区修改，没有add到暂存区。可以通过 <code>git add file</code> 命令将变更文件添加到暂存区，如此便可取消Changes not staged for commit状态。还可以通过 <code>git restore  file</code> 的命令取消在file在工作区的变更，那么暂存区的file内容还是以前的，也取消Changes not staged for commi的状态。</li><li><code>Untracked files：</code>表示只在工作区有的file（文件或文件夹），也就是在暂时区没有该file。</li></ol><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>git 每次提交代码，都要写 Commit message (提交说明)，应该清晰明了，说明本次提交的目的。git commit 命令将暂存区内容添加到本地仓库中。</p><pre><code>git commit -m [message]</code></pre><p>[message] 可以是一些备注信息。</p><p>还可以提交暂存区的指定文件到仓库区：</p><pre><code>git commit [file1] [file2] ... -m [message]</code></pre><p>目前, 社区有多种 Commit message 的写法规范, 例如<a href="https://www.jianshu.com/p/1b56cd033eea">Angular规范</a>。规范主要针对的问题如下：</p><ol><li>版本回退时无法快速定位到指定版本</li><li>无法知道项目中封版操作是哪一个commit</li><li>无法清晰的知道每次提交的记录</li></ol><h3 id="commit提交规范"><a href="#commit提交规范" class="headerlink" title="commit提交规范"></a>commit提交规范</h3><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。<br>其中，Header 是必需的，Body 和 Footer 可以省略。</p><h3 id="Commit-message-的作用"><a href="#Commit-message-的作用" class="headerlink" title="Commit message 的作用"></a>Commit message 的作用</h3><p>格式化的Commit message，有几个好处</p><ol><li>提供更多的历史信息，方便快速浏览</li><li>可以过滤某些commit（比如文档改动）, 便于快速查找信息</li><li>可以直接从commit生成Change log</li></ol><h3 id="Commit-message-的格式"><a href="#Commit-message-的格式" class="headerlink" title="Commit message 的格式"></a>Commit message 的格式</h3><p>每次提交，Commit message 都包括三个部分：<code>Header</code>，<code>Body</code> 和<code>Footer</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中, Header 是必需的, Body 和 Footer 可以省略不管是哪一个部分, 任何一行都不得超过72个字符（或100个字符）, 这是为了避免自动换行影响美观。</p><p><strong>一、Header</strong><br>Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。</p><ol><li><p>type<br>type用于说明 commit 的类别，只允许使用下面7个标识。其中，如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中. 其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul></li><li><p>scope<br>scope用于说明commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。</p></li><li><p>subject<br>subject 是 commit 目的的简短描述，不超过50个字符以动词开头，使用第一人称现在时，比如change , 而不是 changed 或 changes 第一个字母小写, 结尾不加句号（.）</p></li></ol><p><strong>二、Body</strong><br>Body 部分是对本次 commit 的详细描述, 可以分成多行。下面是一个范例：</p><pre><code>More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines.- Bullet points are okay, too- Use a hanging indent</code></pre><p>有两个注意点:</p><ol><li>使用第一人称现在时, 比如使用change, 而不是changed或changes</li><li>应该说明代码变动的动机. 以及与以前行为的对比</li></ol><p><strong>三、Footer</strong><br>Footer 部分只用于两种情况。</p><ol><li><p>不兼容变动<br>如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE<br>开头，后面是对变动的描述、以及变动理由和迁移方法。</p><pre><code> BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: &#123; myAttr: &#39;attribute&#39;, &#125; After: scope: &#123; myAttr: &#39;@&#39;, &#125; The removed inject wasn&#39;t generaly useful for directives so there should be no code using it.</code></pre></li><li><p>关闭Issure<br>如果当前 commit 针对某个issue, 那么可以在 Footer 部分关闭这个 issue。</p><pre><code> Closes #234</code></pre></li></ol><hr><h2 id="其他的一些git指令"><a href="#其他的一些git指令" class="headerlink" title="其他的一些git指令"></a>其他的一些git指令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add</code> 命令可将该文件添加到暂存区。<br>添加一个或多个文件到暂存区：</p><pre><code>git add [file1] [file2] ...</code></pre><p>添加指定目录到暂存区，包括子目录：</p><pre><code>git add [dir]</code></pre><p>添加当前目录下的所有文件到暂存区：</p><pre><code>git add .</code></pre><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><code>git clone</code> 拷贝一个 git 仓库到本地，让自己能够查看该项目，或者进行修改。<br>拷贝项目命令格式如下：</p><pre><code>git clone [url]</code></pre><p>[url] 是你要拷贝的项目。<br>默认情况下，git 会按照你提供的 URL 所指向的项目的名称创建你的本地项目目录。 通常就是该 URL 最后一个 / 之后的项目名称。如果你想要一个不一样的名字，你可以在该命令后加上你想要的名称。</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。 当你想要将 <code>master</code> 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;：&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><p>如果本地分支名与远程分支名相同，则可以省略冒号和远程分支名<br><code>git push origin master</code>将本地的 master 分支推送到 origin 主机的 master 分支。</p><p>(许久之后，确实遇到了这个问题，回来看看！)</p><ol><li><p><strong>git remote</strong> 不带参数，列出已经存在的远程分支</p></li><li><p><strong>git remote -v</strong> | —verbose 列出详细信息，在每一个名字后面列出其远程url，此时， -v 选项(译注:此为 –verbose 的简写,取首字母),显示对应的克隆地址。</p></li><li><p><strong>git remote add url</strong>  添加一个远程仓库。</p></li></ol><hr><p>Git 里面的 origin 到底代表啥意思? <a href="https://blog.csdn.net/yexudengzhidao/article/details/102882774">参考</a>。</p><p>你的代码库(repository)可以存放在你的电脑里，同时你也可以把代码库托管到Github的服务器上。</p><p>在默认情况下，origin指向的就是你本地的代码库托管在Github上的版本。我们假设你首先在github上创建了一个Repository，叫做repository，假设你的Github ID是user1,这个时候指向你的代码库的链接是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository</span><br></pre></td></tr></table></figure><p>如果你在terminal里输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository</span><br></pre></td></tr></table></figure><p>那么git就会在本地拷贝一份托管在github上的代码库这个时候你cd到repository然后输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>你会看到控制台输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository.git (fetch)</span><br><span class="line">origin https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository.git (push)</span><br></pre></td></tr></table></figure><p>也就是说git为你默认创建了一个指向远端代码库的origin（因为你是从这个地址clone下来的）。在这里我们要联系我们经常用到的命令<code>git remote add origin 你的GitHub上的地址</code>，其实，这是手动的为你的远程仓库的地址在本地起一个别名。</p><p>再假设现在有一个用户user2 fork了你这个repository，那么他的代码库链接就是这个样子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;user2&#x2F;repository</span><br></pre></td></tr></table></figure><p>如果他也照着这个clone一把，然后在他的控制台里输入git remote -v<br>他会看的的就是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin https:&#x2F;&#x2F;github.com&#x2F;user2&#x2F;repository.git (fetch)</span><br><span class="line">origin https:&#x2F;&#x2F;github.com&#x2F;user2&#x2F;repository.git (push)</span><br></pre></td></tr></table></figure><p>可以看到<code>origin</code>指向的位置是user2的远程代码库这个地址，如果user2想加一个远程指向你的代码库，他可以在控制台输入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add upstream https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository.git</span><br></pre></td></tr></table></figure><p>然后再输入一遍 git remote -v输出结果就会变为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">origin https:&#x2F;&#x2F;github.com&#x2F;user2&#x2F;repository.git (fetch)</span><br><span class="line">origin https:&#x2F;&#x2F;github.com&#x2F;user2&#x2F;repository.git (push)</span><br><span class="line">upstream https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository.git (fetch)</span><br><span class="line">upstream https:&#x2F;&#x2F;github.com&#x2F;user1&#x2F;repository.git (push)</span><br></pre></td></tr></table></figure><p>增加了指向user1代码库的upstream，也就是之前对指向位置的命名。</p><p>总结来讲，顾名思义，origin就是一个名字，它是在你clone一个托管在Github上代码库时，git为你默认创建的指向这个远程代码库的标签， origin指向的是repository，master只是这个repository中默认创建的第一个branch<code>。(</code>git push origin master<code>)</code>当你git push的时候因为origin和master都是默认创建的，所以可以这样省略，但是这个是bad practice，因为当你换一个branch再git push的时候，有时候就纠结了。</p><hr><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code> 命令用于从远程获取代码并合并本地的版本。</p><pre><code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;：&lt;本地分支名&gt;</code></pre><p>更新操作：</p><pre><code>git pullgit pull origin</code></pre><p>将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。</p><pre><code>git pull origin master：brantest</code></pre><p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p><pre><code>git pull origin master</code></pre><p>上面命令表示，取回 origin/master 分支，再与本地的 brantest 分支合并。</p><p>参考：<br><a href="https://www.cnblogs.com/qdhxhz/p/9757390.html">https://www.cnblogs.com/qdhxhz/p/9757390.html</a><br><a href="https://www.jianshu.com/p/1b56cd033eea">https://www.jianshu.com/p/1b56cd033eea</a></p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第5篇博客】hexo下的markdown的语法(GFM)学习记录</title>
      <link href="2021/01/02/blog5-MarkdownLearning/"/>
      <url>2021/01/02/blog5-MarkdownLearning/</url>
      
        <content type="html"><![CDATA[<p>Hexo下使用的MarkDown为Github的GFM，<a href="https://github.github.com/gfm/">GFM（Github Flavored Markdown）</a> 是 Github 拓展的基于 Markdown 的一种纯文本的书写格式。风格很漂亮，简洁美观大方。但是GFM的MarkDown语法和标准的MarkDown稍有不同，使用过程中需要注意一些。</p><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>Markdown 中，使用 # 或 = 来定义大纲标题，有多少个#或=，就表示是几级的大纲，相当于<h几>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果 </th></tr></thead><tbody><tr><td style="text-align:center"># 一级标题</td><td style="text-align:center"><h1>一级标题</h1></td></tr><tr><td style="text-align:center">## 二级标题</td><td style="text-align:center"><h2>二级标题</h2></td></tr><tr><td style="text-align:center">### 三级标题</td><td style="text-align:center"><h3>三级标题</h3></td></tr><tr><td style="text-align:center">#### 四级标题</td><td style="text-align:center"><h4>四级标题</h4></td></tr><tr><td style="text-align:center">正常文字</td><td style="text-align:center">正常文字</td></tr><tr><td style="text-align:center">##### 五级标题</td><td style="text-align:center"><h5>五级标题</h5></td></tr><tr><td style="text-align:center">###### 六级标题</td><td style="text-align:center"><h6>六级标题</h6></td></tr></tbody></table></div><h1 id="基本字体样式"><a href="#基本字体样式" class="headerlink" title="基本字体样式"></a>基本字体样式</h1><p>Markdown 使用一个星号表示斜体，两个星号表示加粗，三个星号表示加粗斜体。</p><div class="table-container"><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">效果 </th></tr></thead><tbody><tr><td style="text-align:center">*斜体*</td><td style="text-align:center"><em>斜体</em></td></tr><tr><td style="text-align:center">**粗体** 或 __粗体__</td><td style="text-align:center"><strong>粗体</strong> </td></tr><tr><td style="text-align:center">***加粗斜体<em>*</em></td><td style="text-align:center"><strong><em>加粗斜体</em></strong></td></tr><tr><td style="text-align:center">~~删除线~~</td><td style="text-align:center"><del>删除线</del></td></tr></tbody></table></div><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>使用星号或者中横线来表示无序列表，注意后面需要加个空格。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 无序列表1</span><br><span class="line">* 无序列表2</span><br><span class="line">- 无序列表3</span><br><span class="line">- 无序列表4</span><br><span class="line">1. 有序列表1</span><br><span class="line">2. 有序列表2</span><br></pre></td></tr></table></figure></p><ul><li>无序列表1</li><li>无序列表2</li></ul><ul><li>无序列表3</li><li>无序列表4</li></ul><ol><li>有序列表1</li><li>有序列表2</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用部分的内容只需要在行首加上 &gt; 就可以了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 沃兹基硕德说过：不要以自己的放纵来对抗平庸</span><br><span class="line"></span><br><span class="line">&gt; 动物</span><br><span class="line">&gt;&gt; 水生动物</span><br><span class="line">&gt;&gt; 陆生动物</span><br><span class="line">&gt;&gt;&gt; 猴子</span><br><span class="line">&gt;&gt;&gt; 人</span><br><span class="line">&gt;&gt;&gt;&gt; 程序猿</span><br><span class="line">&gt;&gt;&gt;&gt; 攻城狮</span><br><span class="line">&gt;&gt;产品狗 &#x2F;&#x2F;这里需要注意，没有空行间隔，忽略降级引用标记</span><br><span class="line">射鸡虱   &#x2F;&#x2F;这里需要注意，没有空行间隔，忽略降级引用标记</span><br></pre></td></tr></table></figure></p><blockquote><p>沃兹基硕德说过：不要以自己的放纵来对抗平庸</p><p>动物</p><blockquote><p>水生动物<br>陆生动物</p><blockquote><p>猴子<br>人</p><blockquote><p>程序猿<br>攻城狮<br>产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记<br>射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记</p></blockquote></blockquote></blockquote></blockquote><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>Markdown 使用<code>[]()</code>来表示超链接，中括号表示链接文字，小括号表示链接地址。</p><pre><code>[tsuiwade&#39;s blog](tsuiwade.github.io)</code></pre><p><a href="tsuiwade.github.io">tsuiwade’s blog</a></p><h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>图片的样式与超链接非常相似，只需在前面加个感叹号就可以了，即用<code>![]()</code>表示图片。其中中括号表示图片未加载时的提示文字，小括号表示图片地址。<br>例如使用hexo n blog7_MarkdownLearning时创建了<code>blog7-MarkdownLearning.md</code>和<code>blog7-MarkdownLearning</code>文件夹，此时在文件夹中放入图片。再由小括号中填写文件名就可以在博客中贴图。<br>还可以使用HTML的<code>&lt;img&gt;</code>标签，还有许多例如高度、对齐、宽度标签。具体可见 <a href="https://www.w3school.com.cn/tags/tag_img.asp。">https://www.w3school.com.cn/tags/tag_img.asp。</a><br>下面展示四张图，分别是原始图1、网页链接图2、改大小图3。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![1png](1.png)</span><br><span class="line">![baidu](https:&#x2F;&#x2F;www.baidu.com&#x2F;img&#x2F;PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png)</span><br><span class="line">&lt;img src&#x3D;1.png width&#x3D;&quot;100&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br></pre></td></tr></table></figure><br><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306232840871.png" alt="image-20210306232840871"></p><div align="center">图1</div><p><img src="https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png" alt="baidu"></p><div align="center">图2</div><p><img src=http://rto3hzle5.hd-bkt.clouddn.com/image-20210306232840871.png width="100"/></p><div align="center">图3</div><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;单行文字&#96;</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line">多行文字1</span><br><span class="line">多行文字2</span><br><span class="line">多行文字3</span><br><span class="line">&#96;&#96;&#96;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>单行文字</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">多行文字1</span><br><span class="line">多行文字2</span><br><span class="line">多行文字3</span><br></pre></td></tr></table></figure><br>还可以采用下面的代码块：在连续几行的文本开头加入1个Tab或者4个空格，代码块没有前面的序号。（代码块前需要换行）</p><pre><code>多行文字1多行文字2多行文字3</code></pre><p>也适合做一篇文章的tag。</p><pre><code>`linux` `网络编程` `socket` `epoll`</code></pre><p><code>linux</code> <code>网络编程</code> <code>socket</code> <code>epoll</code></p><h1 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h1><p>使用—-进行水平分割<br>水平分割线上方</p><hr><p>水平分割线下方</p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>表格 - 和 | 分割行和列 ， : 控制对其方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">居左   | 居右 | 居中</span><br><span class="line">:- | -: | :-:</span><br><span class="line">第1行 | 12  | 13  </span><br><span class="line">第2行 | 22  | 23  </span><br><span class="line">第3行 | 32  | 33  </span><br></pre></td></tr></table></figure><br>居左   | 居右 | 居中<br>:- | -: | :-:<br>第1行 | 12  | 13<br>第2行 | 22  | 23<br>第3行 | 32  | 33  </p><p>表格中的样式可以利用html语言进行修改，还需要配合转义字符<code>\</code><br>如第1部分标题的代码如下</p><pre><code>语法   | 效果 :-: | :-: \# 一级标题 | &lt;h1&gt;一级标题&lt;/h1&gt;\#\# 二级标题 | &lt;h2&gt;二级标题&lt;/h2&gt;\#\#\# 三级标题 | &lt;h3&gt;三级标题&lt;/h3&gt;\#\#\#\# 四级标题 | &lt;h4&gt;四级标题&lt;/h4&gt;正常文字 | 正常文字\#\#\#\#\# 五级标题 | &lt;h5&gt;五级标题&lt;/h5&gt;\#\#\#\#\#\# 六级标题 | &lt;h6&gt;六级标题&lt;/h6&gt;</code></pre><h1 id="提示块标签"><a href="#提示块标签" class="headerlink" title="提示块标签"></a>提示块标签</h1><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>可使用语法 no-icon去掉小图标</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><h1 id="diff语法"><a href="#diff语法" class="headerlink" title="diff语法"></a>diff语法</h1><p>版本控制的系统中都少不了diff的功能，即展示一个文件内容的增加与删除。<br>GFM中可以显示的展示diff效果。使用蓝色表示新增，红色表示删除。<br>其语法与代码高亮类似，只是在三个反引号后面写diff，<br>并且其内容中，以 +开头表示新增，-开头表示删除。</p><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ 鸟宿池边树，僧敲月下门</span></span><br><span class="line"><span class="deletion">- 鸟宿池边树，僧推月下门</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;diff</span><br><span class="line">+ 鸟宿池边树，僧敲月下门</span><br><span class="line">- 鸟宿池边树，僧推月下门</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><p>其中，字母要统统小写，空格统统要替换成 ‘-‘</p><pre><code>[回到1、标题](#1、标题)[回到2、基本字体样式](#2、基本字体样式)</code></pre><p><a href="#1、标题">回到1、标题</a><br><a href="#2、基本字体样式">回到2、基本字体样式</a></p><h1 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h1><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。<br>比如<code>:blush:</code>，可以显示:blush:。<code>:smile:</code>，可以显示:smile:。<code>:grinning:</code>，可以显示:grinning:。<code>:elephant:</code>，可以显示:elephant:。<code>:v:</code>，可以显示:v:。<code>:balloon:</code>，可以显示:balloon:。<code>:triangular_flag_on_post:</code>，可以显示:triangular_flag_on_post:。<code>:fast_forward:</code>，可以显示:fast_forward:。<code>:100:</code>，可以显示:100:。<br>通过以下代码进行命令行安装配置，还需要配置hexo站点配置文件_config.yml<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure><br>其他有关表情的符号码和问题可查 <a href="https://hasaik.com/posts/9b280ea3.html">https://hasaik.com/posts/9b280ea3.html</a></p><p>后续跟踪：安装了markdown-it-emoji可能会造成markdown渲染问题，如果出错请注意是这里的问题。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> GFM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第4篇博客】hexo的常见指令及简写汇总</title>
      <link href="2021/01/01/blog4_hexo_commands/"/>
      <url>2021/01/01/blog4_hexo_commands/</url>
      
        <content type="html"><![CDATA[<p>本文借鉴自<a href="https://hexo.io/zh-cn/docs/commands.html">https://hexo.io/zh-cn/docs/commands.html</a></p><p>为了方便查阅,这里汇总一些常用的hexo指令。</p><h2 id="简写指令："><a href="#简写指令：" class="headerlink" title="简写指令："></a>简写指令：</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>hexo init [folder]</code><br>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。<br>该命令是一个缩写，完成如下步骤：<br>1、Git clone hexo-starter including hexo-theme-landscape into the current directory or a target folder if specified.<br>2、Install dependencies using a package manager: Yarn 1, pnpm or npm, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with Node.js by default.</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>hexo new [layout] &lt;title&gt;</code><br>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。<br><code>hexo n &quot;我的第一篇文章&quot;</code> 等价于 <code>hexo new &quot;我的第一篇文章&quot;</code> 还等价于 <code>hexo new post &quot;我的第一篇文章&quot;</code></p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p><code>hexo generate</code><br>生成静态文件。(执行 $ hexo g后会在站点根目录下生成public文件夹, hexo会将”/blog/source/“ 下面的.md后缀的文件编译为.html后缀的文件,存放在”/blog/public/ “ 路径下)<br>该命令可以简写为<br><code>hexo g</code></p><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p><code>hexo publish [layout] &lt;filename&gt;</code><br>发表草稿。<br>该命令可以简写为：<br><code>hexo p</code></p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p><code>hexo server</code><br>启动服务器。Hexo 会监视文件变动并自动更新，除修改站点配置文件外，无须重启服务器，直接刷新网页即可生效。<br>默认情况下，访问网址为： <a href="http://localhost:4000/。">http://localhost:4000/。</a><br>该命令可以简写为：<br><code>hexo s</code></p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p><code>hexo deploy</code><br>部署网站。<br>该命令可以简写为：<br><code>hexo d</code></p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p><code>hexo clean</code><br>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第3篇博客】如何在无外网情况下访问自己的github.io博客</title>
      <link href="2020/10/10/blog3_DnsBlogGithubIo/"/>
      <url>2020/10/10/blog3_DnsBlogGithubIo/</url>
      
        <content type="html"><![CDATA[<p>在没有科学上网的环境下，访问不了github.io个人博客，导致自己欣赏不了自己的博客。<br>于是，记录了配置dns来解决该问题的步骤。</p><p>本文借鉴自<a href="https://blog.csdn.net/qq_32627137/article/details/108046461">https://blog.csdn.net/qq_32627137/article/details/108046461</a></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在网络上访问网站，要首先通过DNS服务器把网络域名<code>www.XXXX.com</code> 解析成XXX.XXX.XXX.XXX的IP地址后，我们的计算机才能访问。要是对于每个域名请求我们都要等待域名服务器解析后返回IP信息，这样访问网络的效率就会降低，而Hosts文件就能提高解析效率。根据Windows系统规定，在进行DNS请求以前，Windows系统会先检查自己的Hosts文件中是否有这个地址映射关系，如果有则调用这个IP地址映射，如果没有再向已知的DNS服务器提出域名解析。也就是说Hosts的请求级别比DNS高。 </p><p>github的CDN被某墙屏了，由于网络代理商的原因，所以访问下载很慢。ping github.com 时，速度只有300多ms。<br>于是解决方案就是绕过dns解析，在本地直接绑定host，该方法也可加速其他因为CDN被屏蔽导致访问慢的网站。</p><h2 id="根据环境情况选择跳转ip"><a href="#根据环境情况选择跳转ip" class="headerlink" title="根据环境情况选择跳转ip"></a>根据环境情况选择跳转ip</h2><p>由该网站进行查询<a href="https://tools.ipip.net/dns.php">https://tools.ipip.net/dns.php</a><br>如下图查看访问github.com域名时，延迟最低的ip，复制该ip</p><h4 id="该步骤的作用是选择可以访问到github-io的ip"><a href="#该步骤的作用是选择可以访问到github-io的ip" class="headerlink" title="该步骤的作用是选择可以访问到github.io的ip"></a>该步骤的作用是选择可以访问到github.io的ip</h4><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210729095507009.png" alt="image-20210729095507009"><br>然后管理员权限打开记事本</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210729095532967.png" alt="image-20210729095532967"></p><p>在记事本中打开C:\Windows\System32\drivers\etc路径下的hosts文件<br>该文件是域名解析文件。可以直接用记事本打开。将IP地址重定向。<br>格式为：ip地址-空格-域名<br>可以将一个域名重新定向到一个IP<br>通过它可以达到以下目的：1、加快域名解析；2、方便局域网用户；3、屏蔽网站 </p><p><img src="C:\Users\tsui\AppData\Roaming\Typora\typora-user-images\image-20210306235123450.png" alt="image-20210306235123450"></p><p>在记事本的最后补上<br><code>219.141.136.10 github.com</code><br>这时候可以打开cmd，输入<code>ping github.com</code>，可以看出ping通该网址了。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210729095646977.png" alt="image-20210729095646977"></p><p>上一段是来自选中的跳转ip，下一段是来自己自己家原来的ip，可以看出用了跳转ip，速度会更快。</p><p>接下来同理，设置自己博客的tsuiwade.github.io的ip,接着补在记事本的最后。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210729095601780.png" alt="image-20210729095601780"></p><p>最后就可以访问了。</p>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第2篇博客】butterfly样式修改学习记录</title>
      <link href="2020/10/09/blog2-BlogTheme/"/>
      <url>2020/10/09/blog2-BlogTheme/</url>
      
        <content type="html"><![CDATA[<h2 id="博客首页图"><a href="#博客首页图" class="headerlink" title="博客首页图"></a>博客首页图</h2><pre><code>default_top_img: /img/me.png # 进入博客首页显示的图</code></pre><p>图片资源放进\themes\butterfly\source\img</p><h2 id="博客头部模板"><a href="#博客头部模板" class="headerlink" title="博客头部模板"></a>博客头部模板</h2><p>在此记录一下博客的头部模板。包括名称、创建日期、更新日期、首页缩略图描述、封面（首页和博客顶部）、标签（多选）、分类的模板。<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 【第2篇博客】butterfly样式修改学习记录</span><br><span class="line">date: 2021-02-09 10:31:23</span><br><span class="line">updated: 2021-02-26 10:31:23</span><br><span class="line">description: butterfly主题样式修改学习记录</span><br><span class="line">cover: &quot;https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/butterfly-diy-cover.png&quot;</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">  -</span> hexo</span><br><span class="line"><span class="bullet">  -</span> butterfly</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">  -</span> 博客搭建记录</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h2 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h2><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306222532700.png" alt="image-20210306222532700"></p><p>在_config.yml修改，还有子菜单的设计。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">首页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="string">文章</span> <span class="string">||</span> <span class="attr">fas fa-book:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">归档</span> <span class="string">||</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">标签</span> <span class="string">||</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">分类</span> <span class="string">||</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">便签</span> <span class="string">||</span> <span class="attr">fas fa-sticky-note:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">留言</span> <span class="string">||</span> <span class="string">/messages/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-comments</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">友链</span> <span class="string">||</span> <span class="string">/blogroll/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-user-friends</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">圈子</span> <span class="string">||</span> <span class="string">/moments/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-blog</span></span><br><span class="line">  <span class="string">列表</span> <span class="string">||</span> <span class="attr">fas fa-list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">图库</span> <span class="string">||</span> <span class="string">/gallery/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-images</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">音乐</span> <span class="string">||</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">说说</span> <span class="string">||</span> <span class="string">/say/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-comment</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">叨叨</span> <span class="string">||</span> <span class="string">/talk/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-comment-dots</span></span><br><span class="line">  <span class="string">关于</span> <span class="string">||</span> <span class="attr">fas fa-desktop:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">本站</span> <span class="string">||</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-stream</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">统计</span> <span class="string">||</span> <span class="string">/charts/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-chart-bar</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">订阅</span> <span class="string">||</span> <span class="string">/sub/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-rss</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">背景</span> <span class="string">||</span> <span class="string">/background/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-adjust</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自己</span> <span class="string">||</span> <span class="string">/me/</span> <span class="string">||</span> <span class="string">far</span> <span class="string">fa-user</span></span><br></pre></td></tr></table></figure><p>必须是 /xxx/，后面||分开，然后写图标名。导航的文字可以自行修改。</p><p>首先介绍文章内的归档archive、标签tag、分类category的修改顶部图方法。</p><p>1、 在主题样式配置文件内修改各属性的img图。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># archive_img修改了归档页archives的顶部图</span></span><br><span class="line"><span class="attr">archive_img:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/archive.jpg&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#category_img修改了分类categories下的每个分类category的顶部图</span></span><br><span class="line"><span class="attr">category_img:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/categories.jpg&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#tag_img修改了标签tags下的每个标签tag的顶部图</span></span><br><span class="line"><span class="attr">tag_img:</span> <span class="string">&quot;https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/tags.jpg&quot;</span></span><br></pre></td></tr></table></figure><br>2、 分类页categories和便签页tags的顶部图需要新建index页设置属性，具体参考 <a href="https://butterfly.js.org/posts/dc584b87/">https://butterfly.js.org/posts/dc584b87/</a></p><p>例如设置分类页，需要先hexo new page link，接着找到source/link/index.md修改文件：<br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2021-02-26 21:33:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">top<span class="emphasis">_img: &quot;https://cdn.jsdelivr.net/gh/jerryc127/butterfly_</span>cdn@2.1.0/top<span class="emphasis">_img/archive.jpg&quot;</span></span><br><span class="line"><span class="emphasis">---</span></span><br></pre></td></tr></table></figure></p><h2 id="社交图标"><a href="#社交图标" class="headerlink" title="社交图标"></a>社交图标</h2><p>效果如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/4.png" alt=""></p><p>butterfly支持<code>font-awesome v5</code>图标。<br>书写格式 <code>图标名: url || 描述性文字</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">fab fa-github:</span> <span class="string">https://github.com/tsuiwade</span> <span class="string">||</span> <span class="string">Github</span></span><br><span class="line">  <span class="attr">fas fa-envelope:</span> <span class="string">mailto:478451541@gmail.com</span> <span class="string">||</span> <span class="string">Email</span></span><br><span class="line">  <span class="attr">iconfont  icon-bilibili:</span> <span class="string">https://space.bilibili.com/381957255</span> <span class="string">||</span> <span class="string">bilibili</span></span><br><span class="line">  <span class="attr">iconfont  icon-zhifubao:</span> <span class="string">https://www.bilibili.com</span> <span class="string">||</span> <span class="string">alipay</span></span><br><span class="line">  <span class="attr">iconfont  icon-wechat:</span> <span class="string">https://www.bilibili.com</span> <span class="string">||</span> <span class="string">wechat</span></span><br><span class="line">  <span class="attr">iconfont  icon-qq:</span> <span class="string">tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=478451541</span> <span class="string">||</span> <span class="string">qq</span></span><br><span class="line">  <span class="attr">iconfont  icon-csdn:</span> <span class="string">https://www.bilibili.com</span> <span class="string">||</span> <span class="string">CSDN</span></span><br><span class="line">  <span class="attr">iconfont  icon-shejiao-yinle:</span> <span class="string">https://www.bilibili.com</span> <span class="string">||</span> <span class="string">music</span></span><br><span class="line">  <span class="attr">iconfont  icon-shejiaotubiao-55:</span> <span class="string">https://www.bilibili.com</span> <span class="string">||</span> <span class="string">facebook</span></span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u012208219/article/details/106883012">https://blog.csdn.net/u012208219/article/details/106883012</a><br>该教程描述了如何引入外部样式。</p><p>添加qq超链接 tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=478451541<br>qq在线联系超链接<a href="http://wpa.qq.com/msgrd?v=3&amp;uin=2445408174&amp;site=qq&amp;menu=yes">http://wpa.qq.com/msgrd?v=3&amp;uin=2445408174&amp;site=qq&amp;menu=yes</a></p><h2 id="主页文章节选"><a href="#主页文章节选" class="headerlink" title="主页文章节选"></a>主页文章节选</h2><p>主页文章的节选有自动节选和文章页description两种，<br>在主题配置文件中定位到<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Display the article introduction on homepage</span></span><br><span class="line"><span class="comment"># 1: description</span></span><br><span class="line"><span class="comment"># 2: both (if the description exists, it will show description, or show the auto_excerpt)</span></span><br><span class="line"><span class="comment"># 3: auto_excerpt (default)</span></span><br><span class="line"><span class="comment"># false: do not show the article introduction</span></span><br><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><br>在这我们选择2，优先选择description，如果没有配置description，则自动节选内容。</p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p><code>disable_top_img: true</code> ：不展示顶部图<br><code>index_img</code>：主页的顶部图<br><code>default_top_img</code>：默认的顶部图，当没有配置页面的顶部图的时候，将展示这个<br><code>archive_img</code>：归档页的顶部图<br><code>tag_img</code>：tag子页面的顶部图</p><p>还可尝试</p><pre><code>top_img: orangetop_img: &#39;linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)&#39;</code></pre><h2 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h2><p>文章打赏设置二维码。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306222725296.png" alt="image-20210306222725296"></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/wechat.jpg</span></span><br><span class="line">      <span class="comment">#   link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">微信打赏</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">/img/alipay.jpg</span></span><br><span class="line">      <span class="comment">#   link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">支付宝打赏</span></span><br></pre></td></tr></table></figure><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block center larger %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,block right outline larger %&#125;</span><br></pre></td></tr></table></figure><a class="btn-beautify button--animated block" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right fa-fw"></i><span>Butterfly</span></a><a class="btn-beautify button--animated block center larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right fa-fw"></i><span>Butterfly</span></a><a class="btn-beautify button--animated block right outline larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right fa-fw"></i><span>Butterfly</span></a><h2 id="tabs"><a href="#tabs" class="headerlink" title="tabs"></a>tabs</h2><p>具体参考 <a href="https://butterfly.js.org/posts/4aa8abbe/#Tabs">https://butterfly.js.org/posts/4aa8abbe/#Tabs</a><br><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h2 id="tag-hide"><a href="#tag-hide" class="headerlink" title="tag-hide"></a>tag-hide</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">哪個英文字母最酷？ &#123;% hideInline 因為西裝褲(C裝酷),查看答案,#FF7242,#fff %&#125;</span><br><span class="line"></span><br><span class="line">門裏站着一個人? &#123;% hideInline 閃 %&#125;</span><br></pre></td></tr></table></figure><p>哪個英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">因為西裝褲(C裝酷)</span></span></p><p>門裏站着一個人? <span class="hide-inline"><button type="button" class="hide-button button--animated" style="">Click  </button><span class="hide-content">閃</span></span></p><h2 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h2><p>在主题配置文件中设置<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Valine</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">true</span> <span class="comment"># Display comment count in top_img</span></span><br><span class="line">  <span class="attr">card_post_count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in Home Page</span></span><br></pre></td></tr></table></figure><br>其中，还需要配置Valine，需要用到leancloud。</p><p>它是领先的 BaaS 提供商,提供数据存储、文件存储、云引擎、容器、即时通讯、消息推送、短信、游戏云等多项服务,为移动开发提供强有力的后端支持。<br>valine: 参考 <a href="https://xuqwblog.blog.csdn.net/article/details/107248047">https://xuqwblog.blog.csdn.net/article/details/107248047</a></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">appId:</span>  <span class="comment"># leancloud application app id</span></span><br><span class="line"><span class="attr">appKey:</span>  <span class="comment"># leancloud application app key</span></span><br><span class="line"><span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># comment list page size</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">monsterid</span> <span class="comment"># gravatar style https://valine.js.org/#/avatar</span></span><br><span class="line"><span class="attr">lang:</span> <span class="string">en</span> <span class="comment"># i18n: zh-CN/zh-TW/en/ja</span></span><br><span class="line"><span class="attr">placeholder:</span> <span class="string">記得留下你的暱稱和郵箱....可以快速收到回復</span> <span class="comment"># valine comment input placeholder(like: Please leave your footprints )</span></span><br><span class="line"><span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment">#valine comment header info (nick/mail/link)</span></span><br><span class="line"><span class="attr">recordIP:</span> <span class="literal">false</span> <span class="comment"># Record reviewer IP</span></span><br><span class="line"><span class="attr">serverURLs:</span> <span class="comment"># This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)</span></span><br><span class="line"><span class="attr">bg:</span> <span class="string">/img/comment_bg.png</span> <span class="comment"># valine background</span></span><br><span class="line"><span class="attr">emojiCDN:</span> <span class="comment"># emoji CDN</span></span><br><span class="line"><span class="attr">enableQQ:</span> <span class="literal">false</span> <span class="comment"># enable the Nickname box to automatically get QQ Nickname and QQ Avatar</span></span><br><span class="line"><span class="attr">requiredFields:</span> <span class="string">nick,mail</span> <span class="comment"># required fields (nick/mail)</span></span><br><span class="line"><span class="attr">option:</span></span><br></pre></td></tr></table></figure><p>由于我们是静态博客，页面和存储是分离开的，动态博客才可以直接删除评论，因此需要用到LeanCloud，按下图进行删评。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306221852309.png" alt="image-20210306221852309"></p><h2 id="打字效果"><a href="#打字效果" class="headerlink" title="打字效果"></a>打字效果</h2><p>评论区打字震动效果如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1.gif" alt=""></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">activate_power_mode:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span> <span class="comment"># open particle animation (冒光特效)</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">true</span> <span class="comment">#  open shake (抖动特效)</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="背景特效"><a href="#背景特效" class="headerlink" title="背景特效"></a>背景特效</h2><p>本文设置的特效名称为canvas_nest，样式见本博客背景空白处的鼠标跟随连接网，很漂亮。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&#x27;0,0,255&#x27;</span> <span class="comment">#color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(<span class="doctag">note:</span> use &#x27;,&#x27; to separate.)</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.7</span> <span class="comment"># the opacity of line (0~1), default: 0.5.</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background, default: -1.</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># the number of lines, default: 99.</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span> <span class="comment"># false 手機端不顯示 true 手機端顯示</span></span><br></pre></td></tr></table></figure></p><h2 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h2><p>效果可见本博客的鼠标样式。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mouse click effects: Heart symbol (鼠標點擊效果: 愛心)</span></span><br><span class="line"><span class="attr">click_heart:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h2 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h2><p>效果见首页背景图上的打字效果，sub中替换要展示的文字。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># the subtitle on homepage (主頁subtitle)</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循環打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source調用第三方服務</span></span><br><span class="line">  <span class="comment"># source: false 關閉調用</span></span><br><span class="line">  <span class="comment"># source: 1  調用搏天api的隨機語錄（簡體）</span></span><br><span class="line">  <span class="comment"># source: 2  調用一言網的一句話（簡體）</span></span><br><span class="line">  <span class="comment"># source: 3  調用一句網（簡體）</span></span><br><span class="line">  <span class="comment"># source: 4  調用今日詩詞（簡體）</span></span><br><span class="line">  <span class="comment"># subtitle 會先顯示 source , 再顯示 sub 的內容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果有英文逗號&#x27; , &#x27;,請使用轉義字元 &amp;#44;</span></span><br><span class="line">  <span class="comment"># 如果有英文雙引號&#x27; &quot; &#x27;,請使用轉義字元 &amp;quot;</span></span><br><span class="line">  <span class="comment"># 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住</span></span><br><span class="line">  <span class="comment"># 如果關閉打字效果，subtitle只會顯示sub的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">不要以自己的放纵来对抗平庸</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Never</span> <span class="string">put</span> <span class="string">off</span> <span class="string">till</span> <span class="string">tomorrow</span> <span class="string">what</span> <span class="string">you</span> <span class="string">can</span> <span class="string">do</span> <span class="string">today</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">你要悄悄的努力，然后惊艳所有人</span></span><br></pre></td></tr></table></figure></p><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>效果见博客上方的介绍。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306222901875.png" alt="image-20210306222901875"></p><p>先<code>yarn add hexo-wordcount</code></p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wordcount (字數統計)</span></span><br><span class="line"><span class="attr">wordcount:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 主页侧边栏的文字统计</span></span><br><span class="line">  <span class="attr">post_wordcount:</span> <span class="literal">true</span> <span class="comment"># 博客上方的文字统计</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_wordcount:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h2><p>国内最出名的莫过于iconfont,功能很强大且图标內容很丰富的矢量图标库。很多Font Awesome不支持的图标都可以在这里找到。同时，iconfont支持选择需要的图标生成css链接，減少不必要的CSS加载。</p><p>具体参考 <a href="https://butterfly.js.org/posts/4073eda/#iconfont">https://butterfly.js.org/posts/4073eda/#iconfont</a></p><h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><p>这里设置的滚动条样式如本文的滚动条一样。</p><p>这里需要介绍一下JS/CSS 如何引用</p><ol><li>定位搜索 inject</li><li>其中 head 是用来引入 css 的。bottom 是用来引入 js 的。<br>具体参考 <a href="https://www.antmoe.com/posts/a811d614/#%E5%89%8D%E7%BD%AE%E8%AF%B4%E6%98%8E">https://www.antmoe.com/posts/a811d614/#%E5%89%8D%E7%BD%AE%E8%AF%B4%E6%98%8E</a></li></ol><p>滚动条参考 <a href="https://www.antmoe.com/posts/a811d614/#%E6%BB%9A%E5%8A%A8%E6%9D%A1">https://www.antmoe.com/posts/a811d614/#%E6%BB%9A%E5%8A%A8%E6%9D%A1</a></p><h2 id="引入css-js文件"><a href="#引入css-js文件" class="headerlink" title="引入css/js文件"></a>引入css/js文件</h2><p>这里介绍常用的主题样式魔改方法，大多需要修改或新建css和js文件。<br>具体参考 <a href="https://butterfly.lete114.top/article/Butterfly-config.html">https://butterfly.lete114.top/article/Butterfly-config.html</a><br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/iconfont.min.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/20210205.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/self/Kimbiedark.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/background.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macblack.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">src=&quot;https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/js/hideMobileSidebar.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">src=&quot;/js/myjs.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="卖萌标题"><a href="#卖萌标题" class="headerlink" title="卖萌标题"></a>卖萌标题</h2><p>当离开至其他页面标签后，再回到本博客页面，和过一小会时间后，标题显示的文字不同，效果如下：</p><p><img src="C:\Users\tsui\blog\source\_posts\blog2-BlogTheme\3.png" alt="3"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可爱的Title</span></span><br><span class="line"><span class="keyword">var</span> OriginTitle = <span class="built_in">document</span>.title;</span><br><span class="line"><span class="keyword">var</span> titleTime;</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">        $(<span class="string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).attr(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;/img/favicon.ico&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">&#x27;(つェ⊂) 我藏好了哦~~&#x27;</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(titleTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $(<span class="string">&#x27;[rel=&quot;icon&quot;]&#x27;</span>).attr(<span class="string">&#x27;href&#x27;</span>, <span class="string">&quot;/img/favicon.ico&quot;</span>);</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">&#x27;(*´∇｀*) 被你发现啦~~&#x27;</span> + OriginTitle;</span><br><span class="line">        titleTime = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">document</span>.title = OriginTitle;</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="博主昵称颜色"><a href="#博主昵称颜色" class="headerlink" title="博主昵称颜色"></a>博主昵称颜色</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.author-info__name</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ff7242</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果见主页的侧边栏博主信息卡片。</p><h2 id="鼠标魔改"><a href="#鼠标魔改" class="headerlink" title="鼠标魔改"></a>鼠标魔改</h2><p>效果可见本博客的鼠标样式。<br>具体参考 <a href="https://blog.csdn.net/u012208219/article/details/106883001/">https://blog.csdn.net/u012208219/article/details/106883001/</a></p><h2 id="页脚翻页时钟计时"><a href="#页脚翻页时钟计时" class="headerlink" title="页脚翻页时钟计时"></a>页脚翻页时钟计时</h2><p>样式在页脚可见，效果如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/2.png" alt=""></p><p>可设置开始计时的时间。<br>具体参考 <a href="https://akilar.top/posts/b941af/">https://akilar.top/posts/b941af/</a></p><h2 id="打赏按钮投币彩蛋效果"><a href="#打赏按钮投币彩蛋效果" class="headerlink" title="打赏按钮投币彩蛋效果"></a>打赏按钮投币彩蛋效果</h2><p>效果可见我的博客下方的打赏，点击后有硬币弹出的效果，并且点击后文本改变。<br>具体参考 <a href="https://akilar.top/posts/23fdf850/">https://akilar.top/posts/23fdf850/</a></p><h2 id="侧边栏的时钟卡片"><a href="#侧边栏的时钟卡片" class="headerlink" title="侧边栏的时钟卡片"></a>侧边栏的时钟卡片</h2><p>效果如下：</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/image-20210306222217407.png" alt="image-20210306222217407"></p><ol><li>需要访问 <a href="https://openweathermap.org/">OpenWeather</a>, 按照网站指示完成注册。</li><li>注册完成后，访问 <a href="https://home.openweathermap.org/api_keys">API Keys</a> 获取相应的 API 密钥。留待之后备用。</li><li>还需完成邮箱验证，最后通过邮箱发放API，如果还未生效，需要hexo clean。</li></ol><p>具体参考 <a href="https://akilar.top/posts/4e39cf4a/">https://akilar.top/posts/4e39cf4a/</a></p><h2 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h2><p>建议使用本地搜寻方法，需要安装<a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> ，按提示安装即可。</p><p>最后还需配置主题文件<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h2 id="首页字体修改"><a href="#首页字体修改" class="headerlink" title="首页字体修改"></a>首页字体修改</h2><p>效果见本人主页的字体，不同位置的字体不同，例如h1和a使用的某Italic字体，span使用的新叶恋体<br>。这里推荐一个免费字体网站——<a href="https://www.100font.com/">100font</a> 。<br>在inject引入的css文件（或自己新建）中加入下面几行代码。<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">@font-face</span> &#123;</span><br><span class="line">  <span class="string">font-family:&#x27;zhongwen&#x27;;</span></span><br><span class="line">  <span class="string">src:url(&#x27;https://cdn.jsdelivr.net/gh/tsuiwade/CDN@4.0/font/yenianti.otf&#x27;);</span></span><br><span class="line">  <span class="string">font-display:swap</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">@font-face</span> &#123;</span><br><span class="line">  <span class="string">font-family:&#x27;yingwen&#x27;;</span></span><br><span class="line">  <span class="string">src:url(&#x27;https://cdn.jsdelivr.net/gh/tsuiwade/CDN@4.0/font/1Italic.ttf&#x27;);</span></span><br><span class="line">  <span class="string">font-display:swap</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">h1#site-title</span> &#123;</span><br><span class="line">  <span class="string">font-family:yingwen!important</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">span#subtitle</span> &#123;</span><br><span class="line">  <span class="string">font-family:zhongwen!important</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">a#site-name</span> &#123;</span><br><span class="line">  <span class="string">font-family:yingwen!important</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>挑选您心爱的字体，并把它下载下来，可以存在本地，也可以利用 jsdelivr 的方式加速，最后替换 css 文件中的 url 即可，zhongwen/yingwen 只是别名，可以任意修改，不过引用的时候，要确保名字相同。</p><p>有关jsdelivr加速的概念和使用，可见我的第七篇博客。</p><p>也可以换其他字体，具体参考 <a href="https://blog.imzjw.cn/posts/b74f504f/">https://blog.imzjw.cn/posts/b74f504f/</a><br>这里面语法—— <code>CSS3 @font-face规则</code> 可参考 <a href="https://www.runoob.com/cssref/css3-pr-font-face-rule.html">https://www.runoob.com/cssref/css3-pr-font-face-rule.html</a></p><h2 id="WOW-js-–-让页面滚动更有趣"><a href="#WOW-js-–-让页面滚动更有趣" class="headerlink" title="WOW.js – 让页面滚动更有趣"></a>WOW.js – 让页面滚动更有趣</h2><p>本博客在向下滚动的时候，有些元素会产生细小的动画效果。产生一种模块懒加载的特效感，这里主要用到的是wowjs。如果你希望你的页面也更加有趣，那么你可以试试 WOW.js。</p><p>主要参考<br><a href="https://www.delac.io/wow/">https://www.delac.io/wow/</a><br><a href="https://akilar.top/posts/abab51cf/">https://akilar.top/posts/abab51cf/</a> 。<br>还可修改相关配置。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【第1篇博客】hexo搭建github.io博客学习记录</title>
      <link href="2020/07/05/blog1-MyBlog/"/>
      <url>2020/07/05/blog1-MyBlog/</url>
      
        <content type="html"><![CDATA[<p>github Pages可以被认为是用户编写的、托管在github上的静态网页。</p><p>本文将记录如下步骤：</p><ol><li>环境准备</li><li>hexo博客搭建</li><li>github静态网站部署</li><li>通过github的Action自动部署项目</li></ol><hr><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="github账号申请及repository仓库新建"><a href="#github账号申请及repository仓库新建" class="headerlink" title="github账号申请及repository仓库新建"></a>github账号申请及repository仓库新建</h2><p>首先需要进入官网 <a href="https://github.com">https://github.com</a> 申请一个github账号。</p><p>然后在右上角New一个repository，注意Repository name 必须为自己的<code>用户名.github.io</code>，例如 tsuiwade.github.io。（因为这样最后生成的博客网址才会足够的短，直接为<code>username.github.io</code>，否则生成的网址还有前面的用户名，网址过长而不美观。） </p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/1.jpg" alt=""></p><p>其他默认，最后<code>creat repository</code></p><h1 id="hexo博客搭建"><a href="#hexo博客搭建" class="headerlink" title="hexo博客搭建"></a>hexo博客搭建</h1><h2 id="搭建静态博客的框架-hexo"><a href="#搭建静态博客的框架-hexo" class="headerlink" title="搭建静态博客的框架-hexo"></a>搭建静态博客的框架-hexo</h2><p>hexo是一个快速、简洁且高效的博客框架，具有超快速度、支持markdown、一键部署、插件和可扩展性的特性。官网为 <a href="https://hexo.io/">https://hexo.io/</a> 。</p><p>hexo框架的主题样式比较丰富，可用插件也较多，虽然功能不够强大，但仍然能满足现阶段我们写博客的需求，比较适合新手。</p><p>在搭建博客之前，最好有HTML/JS/CSS、Node/Npm、git/github的技能，不过没有也没关系，跟着我的这篇博客走，能完成自己博客的搭建，我的其他文章可以帮助你补全知识框架。</p><h2 id="开始搭建hexo博客"><a href="#开始搭建hexo博客" class="headerlink" title="开始搭建hexo博客"></a>开始搭建hexo博客</h2><p>初始化hexo将使用以下命令。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g # 全局安装hexo提供的脚手架工具hexo-cli</span><br><span class="line">hexo init blog # 使用脚手架工具提供的hexo init来初始化一个hexo项目，后面填写项目名称</span><br><span class="line">cd blog # 项目初始化之后，进入项目文件夹，并且用vscode打开该文件夹</span><br><span class="line">npm install</span><br><span class="line">hexo server # 可简写为hexo s来运行项目，便可以在本地服务4000端口来访问</span><br></pre></td></tr></table></figure><br>在浏览器中访问 <a href="http://localhost:4000">http://localhost:4000</a> ，便可看到博客页面如下图所示，当前博客使用了hexo所提供的一个默认主题<code>landscape</code>，后续可以更换一个更好看的主题。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/2.jpg" alt=""></p><p>我们回到项目文件夹中，主要文件的含义如下图所示。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/3.png" alt=""></p><p>其中，根目录下的<code>_config.yml</code>文件是我们经常会修改的，可修改博客的一些默认配置。yml是一种用来表达数据序列化的格式，类似于json。</p><p>打开该文件，修改如下博客配置属性。</p><div class="table-container"><table><thead><tr><th style="text-align:left">修改前</th><th style="text-align:left">修改后 </th></tr></thead><tbody><tr><td style="text-align:left">title: Hexo&lt;/br&gt;description: ‘’&lt;/br&gt;author: John Doe&lt;/br&gt;language: en&lt;/br&gt;url: <a href="http://example.com">http://example.com</a> &lt;/br&gt;</td><td style="text-align:left">title: TsuiWade’s blog&lt;/br&gt;description: “记录技术生活的点点滴滴”&lt;/br&gt;author: tsuiwade&lt;/br&gt;language: zh-CN&lt;/br&gt;url:<a href="https://tsuiwade.github.io/">https://tsuiwade.github.io/</a></td></tr></tbody></table></div><p>修改后可以看到浏览器上的博客页面也做了相应的变化。</p><p>此时，一个基本的博客已经搭建完成。</p><h2 id="修改主题样式"><a href="#修改主题样式" class="headerlink" title="修改主题样式"></a>修改主题样式</h2><p>hexo官网 <a href="https://hexo.io/">https://hexo.io/</a> 里提供了300多种主题样式，可以在跟随我使用同样的主题，学会设置主题样式后可自行选择任意一款你喜欢的样式来使用。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/5.png" alt=""></p><p>这里我们选择<code>Butterfly</code>样式，同我的博客样式一样。</p><p>官网 <a href="https://butterfly.js.org/">https://butterfly.js.org/</a> 。 官网也做成了该主题的博客样式，使用的butterfly样式，其中有许多hexo博客优化教程，后续我也会学习整理。</p><p>还有github项目地址 <a href="https://github.com/jerryc127/hexo-theme-butterfly">https://github.com/jerryc127/hexo-theme-butterfly</a> 。其中有配置主题的教程，我们先打开来走一遍该流程。</p><p>1、回到vscode，将该主题克隆到themes目录下。</p><p>输入</p><pre><code>git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></pre><p>可以看到在themes文件夹下多了一个butterfly文件夹，即为主题样式文件。</p><p>2、在根目录的<code>_config.yml</code>中修改主题属性：</p><div class="table-container"><table><thead><tr><th style="text-align:left">修改前</th><th style="text-align:left">修改后 </th></tr></thead><tbody><tr><td style="text-align:left">theme: landscape</td><td style="text-align:left">theme: butterfly</td></tr></tbody></table></div><p>3、在文件夹中显示butterfly，删除<code>.git</code>文件夹，删除该主题的默认的git配置文件，是为了把该主题和我们的博客项目合并为一个项目，统一由一个git来管理。</p><p>4、更换主题后，如果输入hexo s，则会看到Hexo启动服务器页面显示报错extends includes/layout.pug block content include includes/recent-posts.pug include</p><p>此时我们在cmd中输入</p><pre><code>npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</code></pre><p>此时<code>hexo s</code>即可看到主题样式应用成功。</p><p>倘若还不能解决，则进行清除缓存<br><code>hexo clean</code><br>生成静态文件，查看效果<br><code>hexo g</code><br><code>hexo s</code><br>可看到主题样式配置生效。</p><p><img src="http://rto3hzle5.hd-bkt.clouddn.com/3.jpg" alt=""></p><h1 id="github静态网站部署"><a href="#github静态网站部署" class="headerlink" title="github静态网站部署"></a>github静态网站部署</h1><p>此时，我们的博客只能在本地访问。接下来我们需要把博客部署到github上的一个仓库上，然后使用github pages功能，获取到一个站点来访问我们的博客。</p><p>由前面的github账号创建的仓库。打开该github页面，正如页面提示的一样。<br><img src="http://rto3hzle5.hd-bkt.clouddn.com/4.jpg" alt=""></p><p>首先进行·git初始化：</p><pre><code>git init</code></pre><p>然后给当前仓库添加一个远程的git地址：</p><pre><code>git remote add origin https://github.com/miemietou/miemietou.github.io.git</code></pre><p>在使用hexo部署博客之前，我们需要先安装一个叫<code>hexo-deployer-git</code>的依赖，这个库会帮助我们将生成好的代码部署到一个具体的分支。</p><pre><code>yarn add hexo-deployer-git</code></pre><p>安装完之后，我们打开<code>_config.yml</code>文件，拉到最下面，修改deploy属性。部署类型为git，仓库地址填项目地址，分支填写master，注意我们的打包产物需要提交到master分支。<br>将</p><pre><code>deploy:  type: &#39;&#39;</code></pre><p>修改为</p><pre><code>deploy:  type: git  repo: https://github.com/miemietou/miemietou.github.io  branch: master</code></pre><p>接着输入</p><pre><code>hexo deploy</code></pre><p>来部署我们的代码，代码提交完成之后，我们打开github项目的首页，就能看到我们打包上传的产物已经提交到了master分支上。master分支里面的代码其实就是生成的public目录下的文件。然后点击仓库页面的setting，找到github pages一栏，顺利的话将显示我们的站点已成功部署，可以打开该网址检查是否被部署成功。</p><p>此时我们已经完成一个博客的基本部署功能。接下来将做一个非常有趣的自动化部署功能。</p><p>在自动化部署之前，我们需要把我们的源代码提交到github上，因为master分支已经被占用，所以我们只能把源代码提交到另一个分支上，首先我们需要commit一下本地代码。</p><pre><code>git add .git commit -m &quot;none&quot;</code></pre><p>然后我们重建一个分支myblog，然后将该分支push到github上。</p><pre><code>git push --set-upstream origin myblog</code></pre><p>接着，myblog分支已经被push到了github上。</p><h1 id="github-actions实现自动化部署"><a href="#github-actions实现自动化部署" class="headerlink" title="github actions实现自动化部署"></a>github actions实现自动化部署</h1><p>不需要自己在本地进行代码的构建打包，使仓库的action功能，点击该按钮，可以看到github actions提供的功能：帮助构建、测试、部署你的代码，还能使用github actions来做code review、分支管理和issue的追踪。我们这里将会使用它来实现项目的自动打包和代码的部署。</p><p>首先，我们需要在项目根目录下创建.github文件夹和.github目录下的workflows文件夹，然后在里面新建deploy.yml文件，复制粘贴如下代码，该代码的作用就是配置代码部署过程中的一些步骤，例如第一步需要checkout，然后需要安装和打包构建，最后触发一个代码的部署。</p><pre><code>name: Build and Deployon: [push]jobs:build-and-deploy:    runs-on: ubuntu-latest    steps:    - name: Checkout 🛎️        uses: actions/checkout@v2 # If you&#39;re using actions/checkout@v2 you must set persist-credentials to false in most cases for the deployment to work correctly.        with:        persist-credentials: false    - name: Install and Build 🔧 # This example project is built using npm and outputs the result to the &#39;build&#39; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.        run: |        npm install        npm run build        env:        CI: false    - name: Deploy 🚀        uses: JamesIves/github-pages-deploy-action@releases/v3        with:        GITHUB_TOKEN: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;        BRANCH: master # The branch the action should deploy to.        FOLDER: public # The folder the action should deploy.</code></pre><p>接下来，就输入提交代码老三行：<br>    git add .<br>    git commit -m “message”<br>    git push</p><p>提交之后，我们回到仓库首页，点击actions标签，可以看到所有的工作流，如果显示绿色打钩则代码部署成功，站点内容就会成功更新。</p><p>参考： <a href="https://www.bilibili.com/video/BV1dt4y1Q7UE?t=354">https://www.bilibili.com/video/BV1dt4y1Q7UE?t=354</a></p><p><a href="https://www.antmoe.com/posts/4b1b8c9f/">https://www.antmoe.com/posts/4b1b8c9f/</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
